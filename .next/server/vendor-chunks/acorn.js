/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/acorn";
exports.ids = ["vendor-chunks/acorn"];
exports.modules = {

/***/ "(rsc)/./node_modules/acorn/dist/acorn.js":
/*!******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    // This file was generated. Do not modify manually!\n    var astralIdentifierCodes = [\n        509,\n        0,\n        227,\n        0,\n        150,\n        4,\n        294,\n        9,\n        1368,\n        2,\n        2,\n        1,\n        6,\n        3,\n        41,\n        2,\n        5,\n        0,\n        166,\n        1,\n        574,\n        3,\n        9,\n        9,\n        370,\n        1,\n        81,\n        2,\n        71,\n        10,\n        50,\n        3,\n        123,\n        2,\n        54,\n        14,\n        32,\n        10,\n        3,\n        1,\n        11,\n        3,\n        46,\n        10,\n        8,\n        0,\n        46,\n        9,\n        7,\n        2,\n        37,\n        13,\n        2,\n        9,\n        6,\n        1,\n        45,\n        0,\n        13,\n        2,\n        49,\n        13,\n        9,\n        3,\n        2,\n        11,\n        83,\n        11,\n        7,\n        0,\n        3,\n        0,\n        158,\n        11,\n        6,\n        9,\n        7,\n        3,\n        56,\n        1,\n        2,\n        6,\n        3,\n        1,\n        3,\n        2,\n        10,\n        0,\n        11,\n        1,\n        3,\n        6,\n        4,\n        4,\n        193,\n        17,\n        10,\n        9,\n        5,\n        0,\n        82,\n        19,\n        13,\n        9,\n        214,\n        6,\n        3,\n        8,\n        28,\n        1,\n        83,\n        16,\n        16,\n        9,\n        82,\n        12,\n        9,\n        9,\n        84,\n        14,\n        5,\n        9,\n        243,\n        14,\n        166,\n        9,\n        71,\n        5,\n        2,\n        1,\n        3,\n        3,\n        2,\n        0,\n        2,\n        1,\n        13,\n        9,\n        120,\n        6,\n        3,\n        6,\n        4,\n        0,\n        29,\n        9,\n        41,\n        6,\n        2,\n        3,\n        9,\n        0,\n        10,\n        10,\n        47,\n        15,\n        406,\n        7,\n        2,\n        7,\n        17,\n        9,\n        57,\n        21,\n        2,\n        13,\n        123,\n        5,\n        4,\n        0,\n        2,\n        1,\n        2,\n        6,\n        2,\n        0,\n        9,\n        9,\n        49,\n        4,\n        2,\n        1,\n        2,\n        4,\n        9,\n        9,\n        330,\n        3,\n        10,\n        1,\n        2,\n        0,\n        49,\n        6,\n        4,\n        4,\n        14,\n        9,\n        5351,\n        0,\n        7,\n        14,\n        13835,\n        9,\n        87,\n        9,\n        39,\n        4,\n        60,\n        6,\n        26,\n        9,\n        1014,\n        0,\n        2,\n        54,\n        8,\n        3,\n        82,\n        0,\n        12,\n        1,\n        19628,\n        1,\n        4706,\n        45,\n        3,\n        22,\n        543,\n        4,\n        4,\n        5,\n        9,\n        7,\n        3,\n        6,\n        31,\n        3,\n        149,\n        2,\n        1418,\n        49,\n        513,\n        54,\n        5,\n        49,\n        9,\n        0,\n        15,\n        0,\n        23,\n        4,\n        2,\n        14,\n        1361,\n        6,\n        2,\n        16,\n        3,\n        6,\n        2,\n        1,\n        2,\n        4,\n        101,\n        0,\n        161,\n        6,\n        10,\n        9,\n        357,\n        0,\n        62,\n        13,\n        499,\n        13,\n        983,\n        6,\n        110,\n        6,\n        6,\n        9,\n        4759,\n        9,\n        787719,\n        239\n    ];\n    // This file was generated. Do not modify manually!\n    var astralIdentifierStartCodes = [\n        0,\n        11,\n        2,\n        25,\n        2,\n        18,\n        2,\n        1,\n        2,\n        14,\n        3,\n        13,\n        35,\n        122,\n        70,\n        52,\n        268,\n        28,\n        4,\n        48,\n        48,\n        31,\n        14,\n        29,\n        6,\n        37,\n        11,\n        29,\n        3,\n        35,\n        5,\n        7,\n        2,\n        4,\n        43,\n        157,\n        19,\n        35,\n        5,\n        35,\n        5,\n        39,\n        9,\n        51,\n        13,\n        10,\n        2,\n        14,\n        2,\n        6,\n        2,\n        1,\n        2,\n        10,\n        2,\n        14,\n        2,\n        6,\n        2,\n        1,\n        68,\n        310,\n        10,\n        21,\n        11,\n        7,\n        25,\n        5,\n        2,\n        41,\n        2,\n        8,\n        70,\n        5,\n        3,\n        0,\n        2,\n        43,\n        2,\n        1,\n        4,\n        0,\n        3,\n        22,\n        11,\n        22,\n        10,\n        30,\n        66,\n        18,\n        2,\n        1,\n        11,\n        21,\n        11,\n        25,\n        71,\n        55,\n        7,\n        1,\n        65,\n        0,\n        16,\n        3,\n        2,\n        2,\n        2,\n        28,\n        43,\n        28,\n        4,\n        28,\n        36,\n        7,\n        2,\n        27,\n        28,\n        53,\n        11,\n        21,\n        11,\n        18,\n        14,\n        17,\n        111,\n        72,\n        56,\n        50,\n        14,\n        50,\n        14,\n        35,\n        349,\n        41,\n        7,\n        1,\n        79,\n        28,\n        11,\n        0,\n        9,\n        21,\n        43,\n        17,\n        47,\n        20,\n        28,\n        22,\n        13,\n        52,\n        58,\n        1,\n        3,\n        0,\n        14,\n        44,\n        33,\n        24,\n        27,\n        35,\n        30,\n        0,\n        3,\n        0,\n        9,\n        34,\n        4,\n        0,\n        13,\n        47,\n        15,\n        3,\n        22,\n        0,\n        2,\n        0,\n        36,\n        17,\n        2,\n        24,\n        20,\n        1,\n        64,\n        6,\n        2,\n        0,\n        2,\n        3,\n        2,\n        14,\n        2,\n        9,\n        8,\n        46,\n        39,\n        7,\n        3,\n        1,\n        3,\n        21,\n        2,\n        6,\n        2,\n        1,\n        2,\n        4,\n        4,\n        0,\n        19,\n        0,\n        13,\n        4,\n        159,\n        52,\n        19,\n        3,\n        21,\n        2,\n        31,\n        47,\n        21,\n        1,\n        2,\n        0,\n        185,\n        46,\n        42,\n        3,\n        37,\n        47,\n        21,\n        0,\n        60,\n        42,\n        14,\n        0,\n        72,\n        26,\n        38,\n        6,\n        186,\n        43,\n        117,\n        63,\n        32,\n        7,\n        3,\n        0,\n        3,\n        7,\n        2,\n        1,\n        2,\n        23,\n        16,\n        0,\n        2,\n        0,\n        95,\n        7,\n        3,\n        38,\n        17,\n        0,\n        2,\n        0,\n        29,\n        0,\n        11,\n        39,\n        8,\n        0,\n        22,\n        0,\n        12,\n        45,\n        20,\n        0,\n        19,\n        72,\n        264,\n        8,\n        2,\n        36,\n        18,\n        0,\n        50,\n        29,\n        113,\n        6,\n        2,\n        1,\n        2,\n        37,\n        22,\n        0,\n        26,\n        5,\n        2,\n        1,\n        2,\n        31,\n        15,\n        0,\n        328,\n        18,\n        16,\n        0,\n        2,\n        12,\n        2,\n        33,\n        125,\n        0,\n        80,\n        921,\n        103,\n        110,\n        18,\n        195,\n        2637,\n        96,\n        16,\n        1071,\n        18,\n        5,\n        4026,\n        582,\n        8634,\n        568,\n        8,\n        30,\n        18,\n        78,\n        18,\n        29,\n        19,\n        47,\n        17,\n        3,\n        32,\n        20,\n        6,\n        18,\n        689,\n        63,\n        129,\n        74,\n        6,\n        0,\n        67,\n        12,\n        65,\n        1,\n        2,\n        0,\n        29,\n        6135,\n        9,\n        1237,\n        43,\n        8,\n        8936,\n        3,\n        2,\n        6,\n        2,\n        1,\n        2,\n        290,\n        16,\n        0,\n        30,\n        2,\n        3,\n        0,\n        15,\n        3,\n        9,\n        395,\n        2309,\n        106,\n        6,\n        12,\n        4,\n        8,\n        8,\n        9,\n        5991,\n        84,\n        2,\n        70,\n        2,\n        1,\n        3,\n        0,\n        3,\n        1,\n        3,\n        3,\n        2,\n        11,\n        2,\n        0,\n        2,\n        6,\n        2,\n        64,\n        2,\n        3,\n        3,\n        7,\n        2,\n        6,\n        2,\n        27,\n        2,\n        3,\n        2,\n        4,\n        2,\n        0,\n        4,\n        6,\n        2,\n        339,\n        3,\n        24,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        30,\n        2,\n        24,\n        2,\n        7,\n        1845,\n        30,\n        7,\n        5,\n        262,\n        61,\n        147,\n        44,\n        11,\n        6,\n        17,\n        0,\n        322,\n        29,\n        19,\n        43,\n        485,\n        27,\n        757,\n        6,\n        2,\n        3,\n        2,\n        1,\n        2,\n        14,\n        2,\n        196,\n        60,\n        67,\n        8,\n        0,\n        1205,\n        3,\n        2,\n        26,\n        2,\n        1,\n        2,\n        0,\n        3,\n        0,\n        2,\n        9,\n        2,\n        3,\n        2,\n        0,\n        2,\n        0,\n        7,\n        0,\n        5,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        2,\n        2,\n        1,\n        2,\n        0,\n        3,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        0,\n        2,\n        1,\n        2,\n        0,\n        3,\n        3,\n        2,\n        6,\n        2,\n        3,\n        2,\n        3,\n        2,\n        0,\n        2,\n        9,\n        2,\n        16,\n        6,\n        2,\n        2,\n        4,\n        2,\n        16,\n        4421,\n        42719,\n        33,\n        4153,\n        7,\n        221,\n        3,\n        5761,\n        15,\n        7472,\n        3104,\n        541,\n        1507,\n        4938,\n        6,\n        4191\n    ];\n    // This file was generated. Do not modify manually!\n    var nonASCIIidentifierChars = \"‌‍\\xb7̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿\";\n    // This file was generated. Do not modify manually!\n    var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ\";\n    // These are a run-length and offset encoded representation of the\n    // >0xffff code points that are a valid part of identifiers. The\n    // offset starts at 0x10000, and each pair of numbers represents an\n    // offset to the next range, and then a size of the range.\n    // Reserved word lists for various dialects of the language\n    var reservedWords = {\n        3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n        5: \"class enum extends super const export import\",\n        6: \"enum\",\n        strict: \"implements interface let package private protected public static yield\",\n        strictBind: \"eval arguments\"\n    };\n    // And the keywords\n    var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n    var keywords$1 = {\n        5: ecma5AndLessKeywords,\n        \"5module\": ecma5AndLessKeywords + \" export import\",\n        6: ecma5AndLessKeywords + \" const class extends export import super\"\n    };\n    var keywordRelationalOperator = /^in(stanceof)?$/;\n    // ## Character categories\n    var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n    var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n    // This has a complexity linear to the value of the code. The\n    // assumption is that looking up astral identifier characters is\n    // rare.\n    function isInAstralSet(code, set) {\n        var pos = 0x10000;\n        for(var i = 0; i < set.length; i += 2){\n            pos += set[i];\n            if (pos > code) {\n                return false;\n            }\n            pos += set[i + 1];\n            if (pos >= code) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // Test whether a given character code starts an identifier.\n    function isIdentifierStart(code, astral) {\n        if (code < 65) {\n            return code === 36;\n        }\n        if (code < 91) {\n            return true;\n        }\n        if (code < 97) {\n            return code === 95;\n        }\n        if (code < 123) {\n            return true;\n        }\n        if (code <= 0xffff) {\n            return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n        }\n        if (astral === false) {\n            return false;\n        }\n        return isInAstralSet(code, astralIdentifierStartCodes);\n    }\n    // Test whether a given character is part of an identifier.\n    function isIdentifierChar(code, astral) {\n        if (code < 48) {\n            return code === 36;\n        }\n        if (code < 58) {\n            return true;\n        }\n        if (code < 65) {\n            return false;\n        }\n        if (code < 91) {\n            return true;\n        }\n        if (code < 97) {\n            return code === 95;\n        }\n        if (code < 123) {\n            return true;\n        }\n        if (code <= 0xffff) {\n            return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n        }\n        if (astral === false) {\n            return false;\n        }\n        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n    }\n    // ## Token types\n    // The assignment of fine-grained, information-carrying type objects\n    // allows the tokenizer to store the information it has about a\n    // token in a way that is very cheap for the parser to look up.\n    // All token type variables start with an underscore, to make them\n    // easy to recognize.\n    // The `beforeExpr` property is used to disambiguate between regular\n    // expressions and divisions. It is set on all token types that can\n    // be followed by an expression (thus, a slash after them would be a\n    // regular expression).\n    //\n    // The `startsExpr` property is used to check if the token ends a\n    // `yield` expression. It is set on all token types that either can\n    // directly start an expression (like a quotation mark) or can\n    // continue an expression (like the body of a string).\n    //\n    // `isLoop` marks a keyword as starting a loop, which is important\n    // to know when parsing a label, in order to allow or disallow\n    // continue jumps to that label.\n    var TokenType = function TokenType(label, conf) {\n        if (conf === void 0) conf = {};\n        this.label = label;\n        this.keyword = conf.keyword;\n        this.beforeExpr = !!conf.beforeExpr;\n        this.startsExpr = !!conf.startsExpr;\n        this.isLoop = !!conf.isLoop;\n        this.isAssign = !!conf.isAssign;\n        this.prefix = !!conf.prefix;\n        this.postfix = !!conf.postfix;\n        this.binop = conf.binop || null;\n        this.updateContext = null;\n    };\n    function binop(name, prec) {\n        return new TokenType(name, {\n            beforeExpr: true,\n            binop: prec\n        });\n    }\n    var beforeExpr = {\n        beforeExpr: true\n    }, startsExpr = {\n        startsExpr: true\n    };\n    // Map keyword names to token types.\n    var keywords = {};\n    // Succinct definitions of keyword token types\n    function kw(name, options) {\n        if (options === void 0) options = {};\n        options.keyword = name;\n        return keywords[name] = new TokenType(name, options);\n    }\n    var types$1 = {\n        num: new TokenType(\"num\", startsExpr),\n        regexp: new TokenType(\"regexp\", startsExpr),\n        string: new TokenType(\"string\", startsExpr),\n        name: new TokenType(\"name\", startsExpr),\n        privateId: new TokenType(\"privateId\", startsExpr),\n        eof: new TokenType(\"eof\"),\n        // Punctuation token types.\n        bracketL: new TokenType(\"[\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        bracketR: new TokenType(\"]\"),\n        braceL: new TokenType(\"{\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        braceR: new TokenType(\"}\"),\n        parenL: new TokenType(\"(\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        parenR: new TokenType(\")\"),\n        comma: new TokenType(\",\", beforeExpr),\n        semi: new TokenType(\";\", beforeExpr),\n        colon: new TokenType(\":\", beforeExpr),\n        dot: new TokenType(\".\"),\n        question: new TokenType(\"?\", beforeExpr),\n        questionDot: new TokenType(\"?.\"),\n        arrow: new TokenType(\"=>\", beforeExpr),\n        template: new TokenType(\"template\"),\n        invalidTemplate: new TokenType(\"invalidTemplate\"),\n        ellipsis: new TokenType(\"...\", beforeExpr),\n        backQuote: new TokenType(\"`\", startsExpr),\n        dollarBraceL: new TokenType(\"${\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        // Operators. These carry several kinds of properties to help the\n        // parser use them properly (the presence of these properties is\n        // what categorizes them as operators).\n        //\n        // `binop`, when present, specifies that this operator is a binary\n        // operator, and will refer to its precedence.\n        //\n        // `prefix` and `postfix` mark the operator as a prefix or postfix\n        // unary operator.\n        //\n        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n        // binary operators with a very low precedence, that should result\n        // in AssignmentExpression nodes.\n        eq: new TokenType(\"=\", {\n            beforeExpr: true,\n            isAssign: true\n        }),\n        assign: new TokenType(\"_=\", {\n            beforeExpr: true,\n            isAssign: true\n        }),\n        incDec: new TokenType(\"++/--\", {\n            prefix: true,\n            postfix: true,\n            startsExpr: true\n        }),\n        prefix: new TokenType(\"!/~\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        logicalOR: binop(\"||\", 1),\n        logicalAND: binop(\"&&\", 2),\n        bitwiseOR: binop(\"|\", 3),\n        bitwiseXOR: binop(\"^\", 4),\n        bitwiseAND: binop(\"&\", 5),\n        equality: binop(\"==/!=/===/!==\", 6),\n        relational: binop(\"</>/<=/>=\", 7),\n        bitShift: binop(\"<</>>/>>>\", 8),\n        plusMin: new TokenType(\"+/-\", {\n            beforeExpr: true,\n            binop: 9,\n            prefix: true,\n            startsExpr: true\n        }),\n        modulo: binop(\"%\", 10),\n        star: binop(\"*\", 10),\n        slash: binop(\"/\", 10),\n        starstar: new TokenType(\"**\", {\n            beforeExpr: true\n        }),\n        coalesce: binop(\"??\", 1),\n        // Keyword token types.\n        _break: kw(\"break\"),\n        _case: kw(\"case\", beforeExpr),\n        _catch: kw(\"catch\"),\n        _continue: kw(\"continue\"),\n        _debugger: kw(\"debugger\"),\n        _default: kw(\"default\", beforeExpr),\n        _do: kw(\"do\", {\n            isLoop: true,\n            beforeExpr: true\n        }),\n        _else: kw(\"else\", beforeExpr),\n        _finally: kw(\"finally\"),\n        _for: kw(\"for\", {\n            isLoop: true\n        }),\n        _function: kw(\"function\", startsExpr),\n        _if: kw(\"if\"),\n        _return: kw(\"return\", beforeExpr),\n        _switch: kw(\"switch\"),\n        _throw: kw(\"throw\", beforeExpr),\n        _try: kw(\"try\"),\n        _var: kw(\"var\"),\n        _const: kw(\"const\"),\n        _while: kw(\"while\", {\n            isLoop: true\n        }),\n        _with: kw(\"with\"),\n        _new: kw(\"new\", {\n            beforeExpr: true,\n            startsExpr: true\n        }),\n        _this: kw(\"this\", startsExpr),\n        _super: kw(\"super\", startsExpr),\n        _class: kw(\"class\", startsExpr),\n        _extends: kw(\"extends\", beforeExpr),\n        _export: kw(\"export\"),\n        _import: kw(\"import\", startsExpr),\n        _null: kw(\"null\", startsExpr),\n        _true: kw(\"true\", startsExpr),\n        _false: kw(\"false\", startsExpr),\n        _in: kw(\"in\", {\n            beforeExpr: true,\n            binop: 7\n        }),\n        _instanceof: kw(\"instanceof\", {\n            beforeExpr: true,\n            binop: 7\n        }),\n        _typeof: kw(\"typeof\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        _void: kw(\"void\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        }),\n        _delete: kw(\"delete\", {\n            beforeExpr: true,\n            prefix: true,\n            startsExpr: true\n        })\n    };\n    // Matches a whole line break (where CRLF is considered a single\n    // line break). Used to count lines.\n    var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n    var lineBreakG = new RegExp(lineBreak.source, \"g\");\n    function isNewLine(code) {\n        return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n    }\n    function nextLineBreak(code, from, end) {\n        if (end === void 0) end = code.length;\n        for(var i = from; i < end; i++){\n            var next = code.charCodeAt(i);\n            if (isNewLine(next)) {\n                return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;\n            }\n        }\n        return -1;\n    }\n    var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n    var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n    var ref = Object.prototype;\n    var hasOwnProperty = ref.hasOwnProperty;\n    var toString = ref.toString;\n    var hasOwn = Object.hasOwn || function(obj, propName) {\n        return hasOwnProperty.call(obj, propName);\n    };\n    var isArray = Array.isArray || function(obj) {\n        return toString.call(obj) === \"[object Array]\";\n    };\n    function wordsRegexp(words) {\n        return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\");\n    }\n    function codePointToString(code) {\n        // UTF-16 Decoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        code -= 0x10000;\n        return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n    }\n    var loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n    // These are used when `options.locations` is on, for the\n    // `startLoc` and `endLoc` properties.\n    var Position = function Position(line, col) {\n        this.line = line;\n        this.column = col;\n    };\n    Position.prototype.offset = function offset(n) {\n        return new Position(this.line, this.column + n);\n    };\n    var SourceLocation = function SourceLocation(p, start, end) {\n        this.start = start;\n        this.end = end;\n        if (p.sourceFile !== null) {\n            this.source = p.sourceFile;\n        }\n    };\n    // The `getLineInfo` function is mostly useful when the\n    // `locations` option is off (for performance reasons) and you\n    // want to find the line/column position for a given character\n    // offset. `input` should be the code string that the offset refers\n    // into.\n    function getLineInfo(input, offset) {\n        for(var line = 1, cur = 0;;){\n            var nextBreak = nextLineBreak(input, cur, offset);\n            if (nextBreak < 0) {\n                return new Position(line, offset - cur);\n            }\n            ++line;\n            cur = nextBreak;\n        }\n    }\n    // A second argument must be given to configure the parser process.\n    // These options are recognized (only `ecmaVersion` is required):\n    var defaultOptions = {\n        // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n        // (the latest version the library supports). This influences\n        // support for strict mode, the set of reserved words, and support\n        // for new syntax features.\n        ecmaVersion: null,\n        // `sourceType` indicates the mode the code should be parsed in.\n        // Can be either `\"script\"` or `\"module\"`. This influences global\n        // strict mode and parsing of `import` and `export` declarations.\n        sourceType: \"script\",\n        // `onInsertedSemicolon` can be a callback that will be called\n        // when a semicolon is automatically inserted. It will be passed\n        // the position of the comma as an offset, and if `locations` is\n        // enabled, it is given the location as a `{line, column}` object\n        // as second argument.\n        onInsertedSemicolon: null,\n        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n        // trailing commas.\n        onTrailingComma: null,\n        // By default, reserved words are only enforced if ecmaVersion >= 5.\n        // Set `allowReserved` to a boolean value to explicitly turn this on\n        // an off. When this option has the value \"never\", reserved words\n        // and keywords can also not be used as property names.\n        allowReserved: null,\n        // When enabled, a return at the top level is not considered an\n        // error.\n        allowReturnOutsideFunction: false,\n        // When enabled, import/export statements are not constrained to\n        // appearing at the top of the program, and an import.meta expression\n        // in a script isn't considered an error.\n        allowImportExportEverywhere: false,\n        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n        // When enabled, await identifiers are allowed to appear at the top-level scope,\n        // but they are still not allowed in non-async functions.\n        allowAwaitOutsideFunction: null,\n        // When enabled, super identifiers are not constrained to\n        // appearing in methods and do not raise an error when they appear elsewhere.\n        allowSuperOutsideMethod: null,\n        // When enabled, hashbang directive in the beginning of file is\n        // allowed and treated as a line comment. Enabled by default when\n        // `ecmaVersion` >= 2023.\n        allowHashBang: false,\n        // By default, the parser will verify that private properties are\n        // only used in places where they are valid and have been declared.\n        // Set this to false to turn such checks off.\n        checkPrivateFields: true,\n        // When `locations` is on, `loc` properties holding objects with\n        // `start` and `end` properties in `{line, column}` form (with\n        // line being 1-based and column 0-based) will be attached to the\n        // nodes.\n        locations: false,\n        // A function can be passed as `onToken` option, which will\n        // cause Acorn to call that function with object in the same\n        // format as tokens returned from `tokenizer().getToken()`. Note\n        // that you are not allowed to call the parser from the\n        // callback—that will corrupt its internal state.\n        onToken: null,\n        // A function can be passed as `onComment` option, which will\n        // cause Acorn to call that function with `(block, text, start,\n        // end)` parameters whenever a comment is skipped. `block` is a\n        // boolean indicating whether this is a block (`/* */`) comment,\n        // `text` is the content of the comment, and `start` and `end` are\n        // character offsets that denote the start and end of the comment.\n        // When the `locations` option is on, two more parameters are\n        // passed, the full `{line, column}` locations of the start and\n        // end of the comments. Note that you are not allowed to call the\n        // parser from the callback—that will corrupt its internal state.\n        onComment: null,\n        // Nodes have their start and end characters offsets recorded in\n        // `start` and `end` properties (directly on the node, rather than\n        // the `loc` object, which holds line/column data. To also add a\n        // [semi-standardized][range] `range` property holding a `[start,\n        // end]` array with the same numbers, set the `ranges` option to\n        // `true`.\n        //\n        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n        ranges: false,\n        // It is possible to parse multiple files into a single AST by\n        // passing the tree produced by parsing the first file as\n        // `program` option in subsequent parses. This will add the\n        // toplevel forms of the parsed file to the `Program` (top) node\n        // of an existing parse tree.\n        program: null,\n        // When `locations` is on, you can pass this to record the source\n        // file in every node's `loc` object.\n        sourceFile: null,\n        // This value, if given, is stored in every node, whether\n        // `locations` is on or off.\n        directSourceFile: null,\n        // When enabled, parenthesized expressions are represented by\n        // (non-standard) ParenthesizedExpression nodes\n        preserveParens: false\n    };\n    // Interpret and default an options object\n    var warnedAboutEcmaVersion = false;\n    function getOptions(opts) {\n        var options = {};\n        for(var opt in defaultOptions){\n            options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];\n        }\n        if (options.ecmaVersion === \"latest\") {\n            options.ecmaVersion = 1e8;\n        } else if (options.ecmaVersion == null) {\n            if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n                warnedAboutEcmaVersion = true;\n                console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n            }\n            options.ecmaVersion = 11;\n        } else if (options.ecmaVersion >= 2015) {\n            options.ecmaVersion -= 2009;\n        }\n        if (options.allowReserved == null) {\n            options.allowReserved = options.ecmaVersion < 5;\n        }\n        if (!opts || opts.allowHashBang == null) {\n            options.allowHashBang = options.ecmaVersion >= 14;\n        }\n        if (isArray(options.onToken)) {\n            var tokens = options.onToken;\n            options.onToken = function(token) {\n                return tokens.push(token);\n            };\n        }\n        if (isArray(options.onComment)) {\n            options.onComment = pushComment(options, options.onComment);\n        }\n        return options;\n    }\n    function pushComment(options, array) {\n        return function(block, text, start, end, startLoc, endLoc) {\n            var comment = {\n                type: block ? \"Block\" : \"Line\",\n                value: text,\n                start: start,\n                end: end\n            };\n            if (options.locations) {\n                comment.loc = new SourceLocation(this, startLoc, endLoc);\n            }\n            if (options.ranges) {\n                comment.range = [\n                    start,\n                    end\n                ];\n            }\n            array.push(comment);\n        };\n    }\n    // Each scope gets a bitset that may contain these flags\n    var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\n    function functionFlags(async, generator) {\n        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);\n    }\n    // Used in checkLVal* and declareName to determine the type of a binding\n    var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n    var Parser = function Parser(options, input, startPos) {\n        this.options = options = getOptions(options);\n        this.sourceFile = options.sourceFile;\n        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n        var reserved = \"\";\n        if (options.allowReserved !== true) {\n            reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n            if (options.sourceType === \"module\") {\n                reserved += \" await\";\n            }\n        }\n        this.reservedWords = wordsRegexp(reserved);\n        var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n        this.reservedWordsStrict = wordsRegexp(reservedStrict);\n        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n        this.input = String(input);\n        // Used to signal to callers of `readWord1` whether the word\n        // contained any escape sequences. This is needed because words with\n        // escape sequences must not be interpreted as keywords.\n        this.containsEsc = false;\n        // Set up token state\n        // The current position of the tokenizer in the input.\n        if (startPos) {\n            this.pos = startPos;\n            this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n        } else {\n            this.pos = this.lineStart = 0;\n            this.curLine = 1;\n        }\n        // Properties of the current token:\n        // Its type\n        this.type = types$1.eof;\n        // For tokens that include more information than their type, the value\n        this.value = null;\n        // Its start and end offset\n        this.start = this.end = this.pos;\n        // And, if locations are used, the {line, column} object\n        // corresponding to those offsets\n        this.startLoc = this.endLoc = this.curPosition();\n        // Position information for the previous token\n        this.lastTokEndLoc = this.lastTokStartLoc = null;\n        this.lastTokStart = this.lastTokEnd = this.pos;\n        // The context stack is used to superficially track syntactic\n        // context to predict whether a regular expression is allowed in a\n        // given position.\n        this.context = this.initialContext();\n        this.exprAllowed = true;\n        // Figure out if it's a module code.\n        this.inModule = options.sourceType === \"module\";\n        this.strict = this.inModule || this.strictDirective(this.pos);\n        // Used to signify the start of a potential arrow function\n        this.potentialArrowAt = -1;\n        this.potentialArrowInForAwait = false;\n        // Positions to delayed-check that yield/await does not exist in default parameters.\n        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n        // Labels in scope.\n        this.labels = [];\n        // Thus-far undefined exports.\n        this.undefinedExports = Object.create(null);\n        // If enabled, skip leading hashbang line.\n        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") {\n            this.skipLineComment(2);\n        }\n        // Scope tracking for duplicate variable names (see scope.js)\n        this.scopeStack = [];\n        this.enterScope(SCOPE_TOP);\n        // For RegExp validation\n        this.regexpState = null;\n        // The stack of private names.\n        // Each element has two properties: 'declared' and 'used'.\n        // When it exited from the outermost class definition, all used private names must be declared.\n        this.privateNameStack = [];\n    };\n    var prototypeAccessors = {\n        inFunction: {\n            configurable: true\n        },\n        inGenerator: {\n            configurable: true\n        },\n        inAsync: {\n            configurable: true\n        },\n        canAwait: {\n            configurable: true\n        },\n        allowSuper: {\n            configurable: true\n        },\n        allowDirectSuper: {\n            configurable: true\n        },\n        treatFunctionsAsVar: {\n            configurable: true\n        },\n        allowNewDotTarget: {\n            configurable: true\n        },\n        inClassStaticBlock: {\n            configurable: true\n        }\n    };\n    Parser.prototype.parse = function parse() {\n        var node = this.options.program || this.startNode();\n        this.nextToken();\n        return this.parseTopLevel(node);\n    };\n    prototypeAccessors.inFunction.get = function() {\n        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n    };\n    prototypeAccessors.inGenerator.get = function() {\n        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;\n    };\n    prototypeAccessors.inAsync.get = function() {\n        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;\n    };\n    prototypeAccessors.canAwait.get = function() {\n        for(var i = this.scopeStack.length - 1; i >= 0; i--){\n            var scope = this.scopeStack[i];\n            if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {\n                return false;\n            }\n            if (scope.flags & SCOPE_FUNCTION) {\n                return (scope.flags & SCOPE_ASYNC) > 0;\n            }\n        }\n        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;\n    };\n    prototypeAccessors.allowSuper.get = function() {\n        var ref = this.currentThisScope();\n        var flags = ref.flags;\n        var inClassFieldInit = ref.inClassFieldInit;\n        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;\n    };\n    prototypeAccessors.allowDirectSuper.get = function() {\n        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n    };\n    prototypeAccessors.treatFunctionsAsVar.get = function() {\n        return this.treatFunctionsAsVarInScope(this.currentScope());\n    };\n    prototypeAccessors.allowNewDotTarget.get = function() {\n        var ref = this.currentThisScope();\n        var flags = ref.flags;\n        var inClassFieldInit = ref.inClassFieldInit;\n        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;\n    };\n    prototypeAccessors.inClassStaticBlock.get = function() {\n        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;\n    };\n    Parser.extend = function extend() {\n        var plugins = [], len = arguments.length;\n        while(len--)plugins[len] = arguments[len];\n        var cls = this;\n        for(var i = 0; i < plugins.length; i++){\n            cls = plugins[i](cls);\n        }\n        return cls;\n    };\n    Parser.parse = function parse(input, options) {\n        return new this(options, input).parse();\n    };\n    Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {\n        var parser = new this(options, input, pos);\n        parser.nextToken();\n        return parser.parseExpression();\n    };\n    Parser.tokenizer = function tokenizer(input, options) {\n        return new this(options, input);\n    };\n    Object.defineProperties(Parser.prototype, prototypeAccessors);\n    var pp$9 = Parser.prototype;\n    // ## Parser utilities\n    var literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\n    pp$9.strictDirective = function(start) {\n        if (this.options.ecmaVersion < 5) {\n            return false;\n        }\n        for(;;){\n            // Try to find string literal.\n            skipWhiteSpace.lastIndex = start;\n            start += skipWhiteSpace.exec(this.input)[0].length;\n            var match = literal.exec(this.input.slice(start));\n            if (!match) {\n                return false;\n            }\n            if ((match[1] || match[2]) === \"use strict\") {\n                skipWhiteSpace.lastIndex = start + match[0].length;\n                var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n                var next = this.input.charAt(end);\n                return next === \";\" || next === \"}\" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\");\n            }\n            start += match[0].length;\n            // Skip semicolon, if any.\n            skipWhiteSpace.lastIndex = start;\n            start += skipWhiteSpace.exec(this.input)[0].length;\n            if (this.input[start] === \";\") {\n                start++;\n            }\n        }\n    };\n    // Predicate that tests whether the next token is of the given\n    // type, and if yes, consumes it as a side effect.\n    pp$9.eat = function(type) {\n        if (this.type === type) {\n            this.next();\n            return true;\n        } else {\n            return false;\n        }\n    };\n    // Tests whether parsed token is a contextual keyword.\n    pp$9.isContextual = function(name) {\n        return this.type === types$1.name && this.value === name && !this.containsEsc;\n    };\n    // Consumes contextual keyword if possible.\n    pp$9.eatContextual = function(name) {\n        if (!this.isContextual(name)) {\n            return false;\n        }\n        this.next();\n        return true;\n    };\n    // Asserts that following token is given contextual keyword.\n    pp$9.expectContextual = function(name) {\n        if (!this.eatContextual(name)) {\n            this.unexpected();\n        }\n    };\n    // Test whether a semicolon can be inserted at the current position.\n    pp$9.canInsertSemicolon = function() {\n        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    };\n    pp$9.insertSemicolon = function() {\n        if (this.canInsertSemicolon()) {\n            if (this.options.onInsertedSemicolon) {\n                this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n            }\n            return true;\n        }\n    };\n    // Consume a semicolon, or, failing that, see if we are allowed to\n    // pretend that there is a semicolon at this position.\n    pp$9.semicolon = function() {\n        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {\n            this.unexpected();\n        }\n    };\n    pp$9.afterTrailingComma = function(tokType, notNext) {\n        if (this.type === tokType) {\n            if (this.options.onTrailingComma) {\n                this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n            }\n            if (!notNext) {\n                this.next();\n            }\n            return true;\n        }\n    };\n    // Expect a token of a given type. If found, consume it, otherwise,\n    // raise an unexpected token error.\n    pp$9.expect = function(type) {\n        this.eat(type) || this.unexpected();\n    };\n    // Raise an unexpected token error.\n    pp$9.unexpected = function(pos) {\n        this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n    };\n    var DestructuringErrors = function DestructuringErrors() {\n        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n    };\n    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n        if (!refDestructuringErrors) {\n            return;\n        }\n        if (refDestructuringErrors.trailingComma > -1) {\n            this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n        }\n        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n        if (parens > -1) {\n            this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\");\n        }\n    };\n    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n        if (!refDestructuringErrors) {\n            return false;\n        }\n        var shorthandAssign = refDestructuringErrors.shorthandAssign;\n        var doubleProto = refDestructuringErrors.doubleProto;\n        if (!andThrow) {\n            return shorthandAssign >= 0 || doubleProto >= 0;\n        }\n        if (shorthandAssign >= 0) {\n            this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n        }\n        if (doubleProto >= 0) {\n            this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n        }\n    };\n    pp$9.checkYieldAwaitInDefaultParams = function() {\n        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {\n            this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n        }\n        if (this.awaitPos) {\n            this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n        }\n    };\n    pp$9.isSimpleAssignTarget = function(expr) {\n        if (expr.type === \"ParenthesizedExpression\") {\n            return this.isSimpleAssignTarget(expr.expression);\n        }\n        return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n    };\n    var pp$8 = Parser.prototype;\n    // ### Statement parsing\n    // Parse a program. Initializes the parser, reads any number of\n    // statements, and wraps them in a Program node.  Optionally takes a\n    // `program` argument.  If present, the statements will be appended\n    // to its body instead of creating a new node.\n    pp$8.parseTopLevel = function(node) {\n        var exports1 = Object.create(null);\n        if (!node.body) {\n            node.body = [];\n        }\n        while(this.type !== types$1.eof){\n            var stmt = this.parseStatement(null, true, exports1);\n            node.body.push(stmt);\n        }\n        if (this.inModule) {\n            for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){\n                var name = list[i];\n                this.raiseRecoverable(this.undefinedExports[name].start, \"Export '\" + name + \"' is not defined\");\n            }\n        }\n        this.adaptDirectivePrologue(node.body);\n        this.next();\n        node.sourceType = this.options.sourceType;\n        return this.finishNode(node, \"Program\");\n    };\n    var loopLabel = {\n        kind: \"loop\"\n    }, switchLabel = {\n        kind: \"switch\"\n    };\n    pp$8.isLet = function(context) {\n        if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) {\n            return false;\n        }\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        // For ambiguous cases, determine if a LexicalDeclaration (or only a\n        // Statement) is allowed here. If context is not empty then only a Statement\n        // is allowed. However, `let [` is an explicit negative lookahead for\n        // ExpressionStatement, so special-case it first.\n        if (nextCh === 91 || nextCh === 92) {\n            return true;\n        } // '[', '/'\n        if (context) {\n            return false;\n        }\n        if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n            return true;\n        } // '{', astral\n        if (isIdentifierStart(nextCh, true)) {\n            var pos = next + 1;\n            while(isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)){\n                ++pos;\n            }\n            if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n                return true;\n            }\n            var ident = this.input.slice(next, pos);\n            if (!keywordRelationalOperator.test(ident)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // check 'async [no LineTerminator here] function'\n    // - 'async /*foo*/ function' is OK.\n    // - 'async /*\\n*/ function' is invalid.\n    pp$8.isAsyncFunction = function() {\n        if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) {\n            return false;\n        }\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, after;\n        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00));\n    };\n    // Parse a single statement.\n    //\n    // If expecting a statement and finding a slash operator, parse a\n    // regular expression literal. This is to handle cases like\n    // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n    // does not help.\n    pp$8.parseStatement = function(context, topLevel, exports1) {\n        var starttype = this.type, node = this.startNode(), kind;\n        if (this.isLet(context)) {\n            starttype = types$1._var;\n            kind = \"let\";\n        }\n        // Most types of statements are recognized by the keyword they\n        // start with. Many are trivial to parse, some require a bit of\n        // complexity.\n        switch(starttype){\n            case types$1._break:\n            case types$1._continue:\n                return this.parseBreakContinueStatement(node, starttype.keyword);\n            case types$1._debugger:\n                return this.parseDebuggerStatement(node);\n            case types$1._do:\n                return this.parseDoStatement(node);\n            case types$1._for:\n                return this.parseForStatement(node);\n            case types$1._function:\n                // Function as sole body of either an if statement or a labeled statement\n                // works, but not when it is part of a labeled statement that is the sole\n                // body of an if statement.\n                if (context && (this.strict || context !== \"if\" && context !== \"label\") && this.options.ecmaVersion >= 6) {\n                    this.unexpected();\n                }\n                return this.parseFunctionStatement(node, false, !context);\n            case types$1._class:\n                if (context) {\n                    this.unexpected();\n                }\n                return this.parseClass(node, true);\n            case types$1._if:\n                return this.parseIfStatement(node);\n            case types$1._return:\n                return this.parseReturnStatement(node);\n            case types$1._switch:\n                return this.parseSwitchStatement(node);\n            case types$1._throw:\n                return this.parseThrowStatement(node);\n            case types$1._try:\n                return this.parseTryStatement(node);\n            case types$1._const:\n            case types$1._var:\n                kind = kind || this.value;\n                if (context && kind !== \"var\") {\n                    this.unexpected();\n                }\n                return this.parseVarStatement(node, kind);\n            case types$1._while:\n                return this.parseWhileStatement(node);\n            case types$1._with:\n                return this.parseWithStatement(node);\n            case types$1.braceL:\n                return this.parseBlock(true, node);\n            case types$1.semi:\n                return this.parseEmptyStatement(node);\n            case types$1._export:\n            case types$1._import:\n                if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n                    skipWhiteSpace.lastIndex = this.pos;\n                    var skip = skipWhiteSpace.exec(this.input);\n                    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n                    if (nextCh === 40 || nextCh === 46) {\n                        return this.parseExpressionStatement(node, this.parseExpression());\n                    }\n                }\n                if (!this.options.allowImportExportEverywhere) {\n                    if (!topLevel) {\n                        this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n                    }\n                    if (!this.inModule) {\n                        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n                    }\n                }\n                return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports1);\n            // If the statement does not start with a statement keyword or a\n            // brace, it's an ExpressionStatement or LabeledStatement. We\n            // simply start parsing an expression, and afterwards, if the\n            // next token is a colon and the expression was a simple\n            // Identifier node, we switch to interpreting it as a label.\n            default:\n                if (this.isAsyncFunction()) {\n                    if (context) {\n                        this.unexpected();\n                    }\n                    this.next();\n                    return this.parseFunctionStatement(node, true, !context);\n                }\n                var maybeName = this.value, expr = this.parseExpression();\n                if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon)) {\n                    return this.parseLabeledStatement(node, maybeName, expr, context);\n                } else {\n                    return this.parseExpressionStatement(node, expr);\n                }\n        }\n    };\n    pp$8.parseBreakContinueStatement = function(node, keyword) {\n        var isBreak = keyword === \"break\";\n        this.next();\n        if (this.eat(types$1.semi) || this.insertSemicolon()) {\n            node.label = null;\n        } else if (this.type !== types$1.name) {\n            this.unexpected();\n        } else {\n            node.label = this.parseIdent();\n            this.semicolon();\n        }\n        // Verify that there is an actual destination to break or\n        // continue to.\n        var i = 0;\n        for(; i < this.labels.length; ++i){\n            var lab = this.labels[i];\n            if (node.label == null || lab.name === node.label.name) {\n                if (lab.kind != null && (isBreak || lab.kind === \"loop\")) {\n                    break;\n                }\n                if (node.label && isBreak) {\n                    break;\n                }\n            }\n        }\n        if (i === this.labels.length) {\n            this.raise(node.start, \"Unsyntactic \" + keyword);\n        }\n        return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n    };\n    pp$8.parseDebuggerStatement = function(node) {\n        this.next();\n        this.semicolon();\n        return this.finishNode(node, \"DebuggerStatement\");\n    };\n    pp$8.parseDoStatement = function(node) {\n        this.next();\n        this.labels.push(loopLabel);\n        node.body = this.parseStatement(\"do\");\n        this.labels.pop();\n        this.expect(types$1._while);\n        node.test = this.parseParenExpression();\n        if (this.options.ecmaVersion >= 6) {\n            this.eat(types$1.semi);\n        } else {\n            this.semicolon();\n        }\n        return this.finishNode(node, \"DoWhileStatement\");\n    };\n    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n    // loop is non-trivial. Basically, we have to parse the init `var`\n    // statement or expression, disallowing the `in` operator (see\n    // the second parameter to `parseExpression`), and then check\n    // whether the next token is `in` or `of`. When there is no init\n    // part (semicolon immediately after the opening parenthesis), it\n    // is a regular `for` loop.\n    pp$8.parseForStatement = function(node) {\n        this.next();\n        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n        this.labels.push(loopLabel);\n        this.enterScope(0);\n        this.expect(types$1.parenL);\n        if (this.type === types$1.semi) {\n            if (awaitAt > -1) {\n                this.unexpected(awaitAt);\n            }\n            return this.parseFor(node, null);\n        }\n        var isLet = this.isLet();\n        if (this.type === types$1._var || this.type === types$1._const || isLet) {\n            var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n            this.next();\n            this.parseVar(init$1, true, kind);\n            this.finishNode(init$1, \"VariableDeclaration\");\n            if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1) {\n                if (this.options.ecmaVersion >= 9) {\n                    if (this.type === types$1._in) {\n                        if (awaitAt > -1) {\n                            this.unexpected(awaitAt);\n                        }\n                    } else {\n                        node.await = awaitAt > -1;\n                    }\n                }\n                return this.parseForIn(node, init$1);\n            }\n            if (awaitAt > -1) {\n                this.unexpected(awaitAt);\n            }\n            return this.parseFor(node, init$1);\n        }\n        var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n        var refDestructuringErrors = new DestructuringErrors;\n        var init = this.parseExpression(awaitAt > -1 ? \"await\" : true, refDestructuringErrors);\n        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n            if (this.options.ecmaVersion >= 9) {\n                if (this.type === types$1._in) {\n                    if (awaitAt > -1) {\n                        this.unexpected(awaitAt);\n                    }\n                } else {\n                    node.await = awaitAt > -1;\n                }\n            }\n            if (startsWithLet && isForOf) {\n                this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\");\n            }\n            this.toAssignable(init, false, refDestructuringErrors);\n            this.checkLValPattern(init);\n            return this.parseForIn(node, init);\n        } else {\n            this.checkExpressionErrors(refDestructuringErrors, true);\n        }\n        if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init);\n    };\n    pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n        this.next();\n        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);\n    };\n    pp$8.parseIfStatement = function(node) {\n        this.next();\n        node.test = this.parseParenExpression();\n        // allow function declarations in branches, but only in non-strict mode\n        node.consequent = this.parseStatement(\"if\");\n        node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n        return this.finishNode(node, \"IfStatement\");\n    };\n    pp$8.parseReturnStatement = function(node) {\n        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {\n            this.raise(this.start, \"'return' outside of function\");\n        }\n        this.next();\n        // In `return` (and `break`/`continue`), the keywords with\n        // optional arguments, we eagerly look for a semicolon or the\n        // possibility to insert one.\n        if (this.eat(types$1.semi) || this.insertSemicolon()) {\n            node.argument = null;\n        } else {\n            node.argument = this.parseExpression();\n            this.semicolon();\n        }\n        return this.finishNode(node, \"ReturnStatement\");\n    };\n    pp$8.parseSwitchStatement = function(node) {\n        this.next();\n        node.discriminant = this.parseParenExpression();\n        node.cases = [];\n        this.expect(types$1.braceL);\n        this.labels.push(switchLabel);\n        this.enterScope(0);\n        // Statements under must be grouped (by label) in SwitchCase\n        // nodes. `cur` is used to keep the node that we are currently\n        // adding statements to.\n        var cur;\n        for(var sawDefault = false; this.type !== types$1.braceR;){\n            if (this.type === types$1._case || this.type === types$1._default) {\n                var isCase = this.type === types$1._case;\n                if (cur) {\n                    this.finishNode(cur, \"SwitchCase\");\n                }\n                node.cases.push(cur = this.startNode());\n                cur.consequent = [];\n                this.next();\n                if (isCase) {\n                    cur.test = this.parseExpression();\n                } else {\n                    if (sawDefault) {\n                        this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\");\n                    }\n                    sawDefault = true;\n                    cur.test = null;\n                }\n                this.expect(types$1.colon);\n            } else {\n                if (!cur) {\n                    this.unexpected();\n                }\n                cur.consequent.push(this.parseStatement(null));\n            }\n        }\n        this.exitScope();\n        if (cur) {\n            this.finishNode(cur, \"SwitchCase\");\n        }\n        this.next(); // Closing brace\n        this.labels.pop();\n        return this.finishNode(node, \"SwitchStatement\");\n    };\n    pp$8.parseThrowStatement = function(node) {\n        this.next();\n        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {\n            this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n        }\n        node.argument = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, \"ThrowStatement\");\n    };\n    // Reused empty array added for node fields that are always empty.\n    var empty$1 = [];\n    pp$8.parseCatchClauseParam = function() {\n        var param = this.parseBindingAtom();\n        var simple = param.type === \"Identifier\";\n        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n        this.expect(types$1.parenR);\n        return param;\n    };\n    pp$8.parseTryStatement = function(node) {\n        this.next();\n        node.block = this.parseBlock();\n        node.handler = null;\n        if (this.type === types$1._catch) {\n            var clause = this.startNode();\n            this.next();\n            if (this.eat(types$1.parenL)) {\n                clause.param = this.parseCatchClauseParam();\n            } else {\n                if (this.options.ecmaVersion < 10) {\n                    this.unexpected();\n                }\n                clause.param = null;\n                this.enterScope(0);\n            }\n            clause.body = this.parseBlock(false);\n            this.exitScope();\n            node.handler = this.finishNode(clause, \"CatchClause\");\n        }\n        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n        if (!node.handler && !node.finalizer) {\n            this.raise(node.start, \"Missing catch or finally clause\");\n        }\n        return this.finishNode(node, \"TryStatement\");\n    };\n    pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n        this.next();\n        this.parseVar(node, false, kind, allowMissingInitializer);\n        this.semicolon();\n        return this.finishNode(node, \"VariableDeclaration\");\n    };\n    pp$8.parseWhileStatement = function(node) {\n        this.next();\n        node.test = this.parseParenExpression();\n        this.labels.push(loopLabel);\n        node.body = this.parseStatement(\"while\");\n        this.labels.pop();\n        return this.finishNode(node, \"WhileStatement\");\n    };\n    pp$8.parseWithStatement = function(node) {\n        if (this.strict) {\n            this.raise(this.start, \"'with' in strict mode\");\n        }\n        this.next();\n        node.object = this.parseParenExpression();\n        node.body = this.parseStatement(\"with\");\n        return this.finishNode(node, \"WithStatement\");\n    };\n    pp$8.parseEmptyStatement = function(node) {\n        this.next();\n        return this.finishNode(node, \"EmptyStatement\");\n    };\n    pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n        for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){\n            var label = list[i$1];\n            if (label.name === maybeName) {\n                this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n            }\n        }\n        var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n        for(var i = this.labels.length - 1; i >= 0; i--){\n            var label$1 = this.labels[i];\n            if (label$1.statementStart === node.start) {\n                // Update information about previous labels on this node\n                label$1.statementStart = this.start;\n                label$1.kind = kind;\n            } else {\n                break;\n            }\n        }\n        this.labels.push({\n            name: maybeName,\n            kind: kind,\n            statementStart: this.start\n        });\n        node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n        this.labels.pop();\n        node.label = expr;\n        return this.finishNode(node, \"LabeledStatement\");\n    };\n    pp$8.parseExpressionStatement = function(node, expr) {\n        node.expression = expr;\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\");\n    };\n    // Parse a semicolon-enclosed block of statements, handling `\"use\n    // strict\"` declarations when `allowStrict` is true (used for\n    // function bodies).\n    pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n        if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n        if (node === void 0) node = this.startNode();\n        node.body = [];\n        this.expect(types$1.braceL);\n        if (createNewLexicalScope) {\n            this.enterScope(0);\n        }\n        while(this.type !== types$1.braceR){\n            var stmt = this.parseStatement(null);\n            node.body.push(stmt);\n        }\n        if (exitStrict) {\n            this.strict = false;\n        }\n        this.next();\n        if (createNewLexicalScope) {\n            this.exitScope();\n        }\n        return this.finishNode(node, \"BlockStatement\");\n    };\n    // Parse a regular `for` loop. The disambiguation code in\n    // `parseStatement` will already have parsed the init statement or\n    // expression.\n    pp$8.parseFor = function(node, init) {\n        node.init = init;\n        this.expect(types$1.semi);\n        node.test = this.type === types$1.semi ? null : this.parseExpression();\n        this.expect(types$1.semi);\n        node.update = this.type === types$1.parenR ? null : this.parseExpression();\n        this.expect(types$1.parenR);\n        node.body = this.parseStatement(\"for\");\n        this.exitScope();\n        this.labels.pop();\n        return this.finishNode(node, \"ForStatement\");\n    };\n    // Parse a `for`/`in` and `for`/`of` loop, which are almost\n    // same from parser's perspective.\n    pp$8.parseForIn = function(node, init) {\n        var isForIn = this.type === types$1._in;\n        this.next();\n        if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n            this.raise(init.start, (isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\");\n        }\n        node.left = init;\n        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n        this.expect(types$1.parenR);\n        node.body = this.parseStatement(\"for\");\n        this.exitScope();\n        this.labels.pop();\n        return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n    };\n    // Parse a list of variable declarations.\n    pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n        node.declarations = [];\n        node.kind = kind;\n        for(;;){\n            var decl = this.startNode();\n            this.parseVarId(decl, kind);\n            if (this.eat(types$1.eq)) {\n                decl.init = this.parseMaybeAssign(isFor);\n            } else if (!allowMissingInitializer && kind === \"const\" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n                this.unexpected();\n            } else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n                this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n            } else {\n                decl.init = null;\n            }\n            node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n            if (!this.eat(types$1.comma)) {\n                break;\n            }\n        }\n        return node;\n    };\n    pp$8.parseVarId = function(decl, kind) {\n        decl.id = this.parseBindingAtom();\n        this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n    };\n    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n    // Parse a function declaration or literal (depending on the\n    // `statement & FUNC_STATEMENT`).\n    // Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n    pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n            if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {\n                this.unexpected();\n            }\n            node.generator = this.eat(types$1.star);\n        }\n        if (this.options.ecmaVersion >= 8) {\n            node.async = !!isAsync;\n        }\n        if (statement & FUNC_STATEMENT) {\n            node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();\n            if (node.id && !(statement & FUNC_HANGING_STATEMENT)) // If it is a regular function declaration in sloppy mode, then it is\n            // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n            // mode depends on properties of the current scope (see\n            // treatFunctionsAsVar).\n            {\n                this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);\n            }\n        }\n        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.enterScope(functionFlags(node.async, node.generator));\n        if (!(statement & FUNC_STATEMENT)) {\n            node.id = this.type === types$1.name ? this.parseIdent() : null;\n        }\n        this.parseFunctionParams(node);\n        this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, statement & FUNC_STATEMENT ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    };\n    pp$8.parseFunctionParams = function(node) {\n        this.expect(types$1.parenL);\n        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n        this.checkYieldAwaitInDefaultParams();\n    };\n    // Parse a class declaration or literal (depending on the\n    // `isStatement` parameter).\n    pp$8.parseClass = function(node, isStatement) {\n        this.next();\n        // ecma-262 14.6 Class Definitions\n        // A class definition is always strict mode code.\n        var oldStrict = this.strict;\n        this.strict = true;\n        this.parseClassId(node, isStatement);\n        this.parseClassSuper(node);\n        var privateNameMap = this.enterClassBody();\n        var classBody = this.startNode();\n        var hadConstructor = false;\n        classBody.body = [];\n        this.expect(types$1.braceL);\n        while(this.type !== types$1.braceR){\n            var element = this.parseClassElement(node.superClass !== null);\n            if (element) {\n                classBody.body.push(element);\n                if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n                    if (hadConstructor) {\n                        this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\");\n                    }\n                    hadConstructor = true;\n                } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n                    this.raiseRecoverable(element.key.start, \"Identifier '#\" + element.key.name + \"' has already been declared\");\n                }\n            }\n        }\n        this.strict = oldStrict;\n        this.next();\n        node.body = this.finishNode(classBody, \"ClassBody\");\n        this.exitClassBody();\n        return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n    };\n    pp$8.parseClassElement = function(constructorAllowsSuper) {\n        if (this.eat(types$1.semi)) {\n            return null;\n        }\n        var ecmaVersion = this.options.ecmaVersion;\n        var node = this.startNode();\n        var keyName = \"\";\n        var isGenerator = false;\n        var isAsync = false;\n        var kind = \"method\";\n        var isStatic = false;\n        if (this.eatContextual(\"static\")) {\n            // Parse static init block\n            if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n                this.parseClassStaticBlock(node);\n                return node;\n            }\n            if (this.isClassElementNameStart() || this.type === types$1.star) {\n                isStatic = true;\n            } else {\n                keyName = \"static\";\n            }\n        }\n        node.static = isStatic;\n        if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n            if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n                isAsync = true;\n            } else {\n                keyName = \"async\";\n            }\n        }\n        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n            isGenerator = true;\n        }\n        if (!keyName && !isAsync && !isGenerator) {\n            var lastValue = this.value;\n            if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n                if (this.isClassElementNameStart()) {\n                    kind = lastValue;\n                } else {\n                    keyName = lastValue;\n                }\n            }\n        }\n        // Parse element name\n        if (keyName) {\n            // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n            // The last token is any of those. Make it the element name.\n            node.computed = false;\n            node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n            node.key.name = keyName;\n            this.finishNode(node.key, \"Identifier\");\n        } else {\n            this.parseClassElementName(node);\n        }\n        // Parse element value\n        if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n            var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n            var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n            // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n            if (isConstructor && kind !== \"method\") {\n                this.raise(node.key.start, \"Constructor can't have get/set modifier\");\n            }\n            node.kind = isConstructor ? \"constructor\" : kind;\n            this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n        } else {\n            this.parseClassField(node);\n        }\n        return node;\n    };\n    pp$8.isClassElementNameStart = function() {\n        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;\n    };\n    pp$8.parseClassElementName = function(element) {\n        if (this.type === types$1.privateId) {\n            if (this.value === \"constructor\") {\n                this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n            }\n            element.computed = false;\n            element.key = this.parsePrivateIdent();\n        } else {\n            this.parsePropertyName(element);\n        }\n    };\n    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n        // Check key and flags\n        var key = method.key;\n        if (method.kind === \"constructor\") {\n            if (isGenerator) {\n                this.raise(key.start, \"Constructor can't be a generator\");\n            }\n            if (isAsync) {\n                this.raise(key.start, \"Constructor can't be an async method\");\n            }\n        } else if (method.static && checkKeyName(method, \"prototype\")) {\n            this.raise(key.start, \"Classes may not have a static property named prototype\");\n        }\n        // Parse value\n        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n        // Check value\n        if (method.kind === \"get\" && value.params.length !== 0) {\n            this.raiseRecoverable(value.start, \"getter should have no params\");\n        }\n        if (method.kind === \"set\" && value.params.length !== 1) {\n            this.raiseRecoverable(value.start, \"setter should have exactly one param\");\n        }\n        if (method.kind === \"set\" && value.params[0].type === \"RestElement\") {\n            this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\");\n        }\n        return this.finishNode(method, \"MethodDefinition\");\n    };\n    pp$8.parseClassField = function(field) {\n        if (checkKeyName(field, \"constructor\")) {\n            this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n        } else if (field.static && checkKeyName(field, \"prototype\")) {\n            this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n        }\n        if (this.eat(types$1.eq)) {\n            // To raise SyntaxError if 'arguments' exists in the initializer.\n            var scope = this.currentThisScope();\n            var inClassFieldInit = scope.inClassFieldInit;\n            scope.inClassFieldInit = true;\n            field.value = this.parseMaybeAssign();\n            scope.inClassFieldInit = inClassFieldInit;\n        } else {\n            field.value = null;\n        }\n        this.semicolon();\n        return this.finishNode(field, \"PropertyDefinition\");\n    };\n    pp$8.parseClassStaticBlock = function(node) {\n        node.body = [];\n        var oldLabels = this.labels;\n        this.labels = [];\n        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n        while(this.type !== types$1.braceR){\n            var stmt = this.parseStatement(null);\n            node.body.push(stmt);\n        }\n        this.next();\n        this.exitScope();\n        this.labels = oldLabels;\n        return this.finishNode(node, \"StaticBlock\");\n    };\n    pp$8.parseClassId = function(node, isStatement) {\n        if (this.type === types$1.name) {\n            node.id = this.parseIdent();\n            if (isStatement) {\n                this.checkLValSimple(node.id, BIND_LEXICAL, false);\n            }\n        } else {\n            if (isStatement === true) {\n                this.unexpected();\n            }\n            node.id = null;\n        }\n    };\n    pp$8.parseClassSuper = function(node) {\n        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;\n    };\n    pp$8.enterClassBody = function() {\n        var element = {\n            declared: Object.create(null),\n            used: []\n        };\n        this.privateNameStack.push(element);\n        return element.declared;\n    };\n    pp$8.exitClassBody = function() {\n        var ref = this.privateNameStack.pop();\n        var declared = ref.declared;\n        var used = ref.used;\n        if (!this.options.checkPrivateFields) {\n            return;\n        }\n        var len = this.privateNameStack.length;\n        var parent = len === 0 ? null : this.privateNameStack[len - 1];\n        for(var i = 0; i < used.length; ++i){\n            var id = used[i];\n            if (!hasOwn(declared, id.name)) {\n                if (parent) {\n                    parent.used.push(id);\n                } else {\n                    this.raiseRecoverable(id.start, \"Private field '#\" + id.name + \"' must be declared in an enclosing class\");\n                }\n            }\n        }\n    };\n    function isPrivateNameConflicted(privateNameMap, element) {\n        var name = element.key.name;\n        var curr = privateNameMap[name];\n        var next = \"true\";\n        if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n            next = (element.static ? \"s\" : \"i\") + element.kind;\n        }\n        // `class { get #a(){}; static set #a(_){} }` is also conflict.\n        if (curr === \"iget\" && next === \"iset\" || curr === \"iset\" && next === \"iget\" || curr === \"sget\" && next === \"sset\" || curr === \"sset\" && next === \"sget\") {\n            privateNameMap[name] = \"true\";\n            return false;\n        } else if (!curr) {\n            privateNameMap[name] = next;\n            return false;\n        } else {\n            return true;\n        }\n    }\n    function checkKeyName(node, name) {\n        var computed = node.computed;\n        var key = node.key;\n        return !computed && (key.type === \"Identifier\" && key.name === name || key.type === \"Literal\" && key.value === name);\n    }\n    // Parses module export declaration.\n    pp$8.parseExportAllDeclaration = function(node, exports1) {\n        if (this.options.ecmaVersion >= 11) {\n            if (this.eatContextual(\"as\")) {\n                node.exported = this.parseModuleExportName();\n                this.checkExport(exports1, node.exported, this.lastTokStart);\n            } else {\n                node.exported = null;\n            }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== types$1.string) {\n            this.unexpected();\n        }\n        node.source = this.parseExprAtom();\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n    };\n    pp$8.parseExport = function(node, exports1) {\n        this.next();\n        // export * from '...'\n        if (this.eat(types$1.star)) {\n            return this.parseExportAllDeclaration(node, exports1);\n        }\n        if (this.eat(types$1._default)) {\n            this.checkExport(exports1, \"default\", this.lastTokStart);\n            node.declaration = this.parseExportDefaultDeclaration();\n            return this.finishNode(node, \"ExportDefaultDeclaration\");\n        }\n        // export var|const|let|function|class ...\n        if (this.shouldParseExportStatement()) {\n            node.declaration = this.parseExportDeclaration(node);\n            if (node.declaration.type === \"VariableDeclaration\") {\n                this.checkVariableExport(exports1, node.declaration.declarations);\n            } else {\n                this.checkExport(exports1, node.declaration.id, node.declaration.id.start);\n            }\n            node.specifiers = [];\n            node.source = null;\n        } else {\n            node.declaration = null;\n            node.specifiers = this.parseExportSpecifiers(exports1);\n            if (this.eatContextual(\"from\")) {\n                if (this.type !== types$1.string) {\n                    this.unexpected();\n                }\n                node.source = this.parseExprAtom();\n            } else {\n                for(var i = 0, list = node.specifiers; i < list.length; i += 1){\n                    // check for keywords used as local names\n                    var spec = list[i];\n                    this.checkUnreserved(spec.local);\n                    // check if export is defined\n                    this.checkLocalExport(spec.local);\n                    if (spec.local.type === \"Literal\") {\n                        this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n                    }\n                }\n                node.source = null;\n            }\n            this.semicolon();\n        }\n        return this.finishNode(node, \"ExportNamedDeclaration\");\n    };\n    pp$8.parseExportDeclaration = function(node) {\n        return this.parseStatement(null);\n    };\n    pp$8.parseExportDefaultDeclaration = function() {\n        var isAsync;\n        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n            var fNode = this.startNode();\n            this.next();\n            if (isAsync) {\n                this.next();\n            }\n            return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === types$1._class) {\n            var cNode = this.startNode();\n            return this.parseClass(cNode, \"nullableID\");\n        } else {\n            var declaration = this.parseMaybeAssign();\n            this.semicolon();\n            return declaration;\n        }\n    };\n    pp$8.checkExport = function(exports1, name, pos) {\n        if (!exports1) {\n            return;\n        }\n        if (typeof name !== \"string\") {\n            name = name.type === \"Identifier\" ? name.name : name.value;\n        }\n        if (hasOwn(exports1, name)) {\n            this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n        }\n        exports1[name] = true;\n    };\n    pp$8.checkPatternExport = function(exports1, pat) {\n        var type = pat.type;\n        if (type === \"Identifier\") {\n            this.checkExport(exports1, pat, pat.start);\n        } else if (type === \"ObjectPattern\") {\n            for(var i = 0, list = pat.properties; i < list.length; i += 1){\n                var prop = list[i];\n                this.checkPatternExport(exports1, prop);\n            }\n        } else if (type === \"ArrayPattern\") {\n            for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){\n                var elt = list$1[i$1];\n                if (elt) {\n                    this.checkPatternExport(exports1, elt);\n                }\n            }\n        } else if (type === \"Property\") {\n            this.checkPatternExport(exports1, pat.value);\n        } else if (type === \"AssignmentPattern\") {\n            this.checkPatternExport(exports1, pat.left);\n        } else if (type === \"RestElement\") {\n            this.checkPatternExport(exports1, pat.argument);\n        } else if (type === \"ParenthesizedExpression\") {\n            this.checkPatternExport(exports1, pat.expression);\n        }\n    };\n    pp$8.checkVariableExport = function(exports1, decls) {\n        if (!exports1) {\n            return;\n        }\n        for(var i = 0, list = decls; i < list.length; i += 1){\n            var decl = list[i];\n            this.checkPatternExport(exports1, decl.id);\n        }\n    };\n    pp$8.shouldParseExportStatement = function() {\n        return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n    };\n    // Parses a comma-separated list of module exports.\n    pp$8.parseExportSpecifier = function(exports1) {\n        var node = this.startNode();\n        node.local = this.parseModuleExportName();\n        node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n        this.checkExport(exports1, node.exported, node.exported.start);\n        return this.finishNode(node, \"ExportSpecifier\");\n    };\n    pp$8.parseExportSpecifiers = function(exports1) {\n        var nodes = [], first = true;\n        // export { x, y as z } [from '...']\n        this.expect(types$1.braceL);\n        while(!this.eat(types$1.braceR)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (this.afterTrailingComma(types$1.braceR)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            nodes.push(this.parseExportSpecifier(exports1));\n        }\n        return nodes;\n    };\n    // Parses import declaration.\n    pp$8.parseImport = function(node) {\n        this.next();\n        // import '...'\n        if (this.type === types$1.string) {\n            node.specifiers = empty$1;\n            node.source = this.parseExprAtom();\n        } else {\n            node.specifiers = this.parseImportSpecifiers();\n            this.expectContextual(\"from\");\n            node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n        }\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n    };\n    // Parses a comma-separated list of module imports.\n    pp$8.parseImportSpecifier = function() {\n        var node = this.startNode();\n        node.imported = this.parseModuleExportName();\n        if (this.eatContextual(\"as\")) {\n            node.local = this.parseIdent();\n        } else {\n            this.checkUnreserved(node.imported);\n            node.local = node.imported;\n        }\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, \"ImportSpecifier\");\n    };\n    pp$8.parseImportDefaultSpecifier = function() {\n        // import defaultObj, { x, y as z } from '...'\n        var node = this.startNode();\n        node.local = this.parseIdent();\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, \"ImportDefaultSpecifier\");\n    };\n    pp$8.parseImportNamespaceSpecifier = function() {\n        var node = this.startNode();\n        this.next();\n        this.expectContextual(\"as\");\n        node.local = this.parseIdent();\n        this.checkLValSimple(node.local, BIND_LEXICAL);\n        return this.finishNode(node, \"ImportNamespaceSpecifier\");\n    };\n    pp$8.parseImportSpecifiers = function() {\n        var nodes = [], first = true;\n        if (this.type === types$1.name) {\n            nodes.push(this.parseImportDefaultSpecifier());\n            if (!this.eat(types$1.comma)) {\n                return nodes;\n            }\n        }\n        if (this.type === types$1.star) {\n            nodes.push(this.parseImportNamespaceSpecifier());\n            return nodes;\n        }\n        this.expect(types$1.braceL);\n        while(!this.eat(types$1.braceR)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (this.afterTrailingComma(types$1.braceR)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            nodes.push(this.parseImportSpecifier());\n        }\n        return nodes;\n    };\n    pp$8.parseModuleExportName = function() {\n        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n            var stringLiteral = this.parseLiteral(this.value);\n            if (loneSurrogate.test(stringLiteral.value)) {\n                this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n            }\n            return stringLiteral;\n        }\n        return this.parseIdent(true);\n    };\n    // Set `ExpressionStatement#directive` property for directive prologues.\n    pp$8.adaptDirectivePrologue = function(statements) {\n        for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i){\n            statements[i].directive = statements[i].expression.raw.slice(1, -1);\n        }\n    };\n    pp$8.isDirectiveCandidate = function(statement) {\n        return this.options.ecmaVersion >= 5 && statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && // Reject parenthesized strings.\n        (this.input[statement.start] === '\"' || this.input[statement.start] === \"'\");\n    };\n    var pp$7 = Parser.prototype;\n    // Convert existing expression atom to assignable pattern\n    // if possible.\n    pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n        if (this.options.ecmaVersion >= 6 && node) {\n            switch(node.type){\n                case \"Identifier\":\n                    if (this.inAsync && node.name === \"await\") {\n                        this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\");\n                    }\n                    break;\n                case \"ObjectPattern\":\n                case \"ArrayPattern\":\n                case \"AssignmentPattern\":\n                case \"RestElement\":\n                    break;\n                case \"ObjectExpression\":\n                    node.type = \"ObjectPattern\";\n                    if (refDestructuringErrors) {\n                        this.checkPatternErrors(refDestructuringErrors, true);\n                    }\n                    for(var i = 0, list = node.properties; i < list.length; i += 1){\n                        var prop = list[i];\n                        this.toAssignable(prop, isBinding);\n                        // Early error:\n                        //   AssignmentRestProperty[Yield, Await] :\n                        //     `...` DestructuringAssignmentTarget[Yield, Await]\n                        //\n                        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n                        if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) {\n                            this.raise(prop.argument.start, \"Unexpected token\");\n                        }\n                    }\n                    break;\n                case \"Property\":\n                    // AssignmentProperty has type === \"Property\"\n                    if (node.kind !== \"init\") {\n                        this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n                    }\n                    this.toAssignable(node.value, isBinding);\n                    break;\n                case \"ArrayExpression\":\n                    node.type = \"ArrayPattern\";\n                    if (refDestructuringErrors) {\n                        this.checkPatternErrors(refDestructuringErrors, true);\n                    }\n                    this.toAssignableList(node.elements, isBinding);\n                    break;\n                case \"SpreadElement\":\n                    node.type = \"RestElement\";\n                    this.toAssignable(node.argument, isBinding);\n                    if (node.argument.type === \"AssignmentPattern\") {\n                        this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n                    }\n                    break;\n                case \"AssignmentExpression\":\n                    if (node.operator !== \"=\") {\n                        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n                    }\n                    node.type = \"AssignmentPattern\";\n                    delete node.operator;\n                    this.toAssignable(node.left, isBinding);\n                    break;\n                case \"ParenthesizedExpression\":\n                    this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n                    break;\n                case \"ChainExpression\":\n                    this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n                    break;\n                case \"MemberExpression\":\n                    if (!isBinding) {\n                        break;\n                    }\n                default:\n                    this.raise(node.start, \"Assigning to rvalue\");\n            }\n        } else if (refDestructuringErrors) {\n            this.checkPatternErrors(refDestructuringErrors, true);\n        }\n        return node;\n    };\n    // Convert list of expression atoms to binding list.\n    pp$7.toAssignableList = function(exprList, isBinding) {\n        var end = exprList.length;\n        for(var i = 0; i < end; i++){\n            var elt = exprList[i];\n            if (elt) {\n                this.toAssignable(elt, isBinding);\n            }\n        }\n        if (end) {\n            var last = exprList[end - 1];\n            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") {\n                this.unexpected(last.argument.start);\n            }\n        }\n        return exprList;\n    };\n    // Parses spread element.\n    pp$7.parseSpread = function(refDestructuringErrors) {\n        var node = this.startNode();\n        this.next();\n        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n        return this.finishNode(node, \"SpreadElement\");\n    };\n    pp$7.parseRestBinding = function() {\n        var node = this.startNode();\n        this.next();\n        // RestElement inside of a function parameter must be an identifier\n        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {\n            this.unexpected();\n        }\n        node.argument = this.parseBindingAtom();\n        return this.finishNode(node, \"RestElement\");\n    };\n    // Parses lvalue (assignable) atom.\n    pp$7.parseBindingAtom = function() {\n        if (this.options.ecmaVersion >= 6) {\n            switch(this.type){\n                case types$1.bracketL:\n                    var node = this.startNode();\n                    this.next();\n                    node.elements = this.parseBindingList(types$1.bracketR, true, true);\n                    return this.finishNode(node, \"ArrayPattern\");\n                case types$1.braceL:\n                    return this.parseObj(true);\n            }\n        }\n        return this.parseIdent();\n    };\n    pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n        var elts = [], first = true;\n        while(!this.eat(close)){\n            if (first) {\n                first = false;\n            } else {\n                this.expect(types$1.comma);\n            }\n            if (allowEmpty && this.type === types$1.comma) {\n                elts.push(null);\n            } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n                break;\n            } else if (this.type === types$1.ellipsis) {\n                var rest = this.parseRestBinding();\n                this.parseBindingListItem(rest);\n                elts.push(rest);\n                if (this.type === types$1.comma) {\n                    this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                }\n                this.expect(close);\n                break;\n            } else {\n                elts.push(this.parseAssignableListItem(allowModifiers));\n            }\n        }\n        return elts;\n    };\n    pp$7.parseAssignableListItem = function(allowModifiers) {\n        var elem = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(elem);\n        return elem;\n    };\n    pp$7.parseBindingListItem = function(param) {\n        return param;\n    };\n    // Parses assignment pattern around given atom if possible.\n    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n        left = left || this.parseBindingAtom();\n        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {\n            return left;\n        }\n        var node = this.startNodeAt(startPos, startLoc);\n        node.left = left;\n        node.right = this.parseMaybeAssign();\n        return this.finishNode(node, \"AssignmentPattern\");\n    };\n    // The following three functions all verify that a node is an lvalue —\n    // something that can be bound, or assigned to. In order to do so, they perform\n    // a variety of checks:\n    //\n    // - Check that none of the bound/assigned-to identifiers are reserved words.\n    // - Record name declarations for bindings in the appropriate scope.\n    // - Check duplicate argument names, if checkClashes is set.\n    //\n    // If a complex binding pattern is encountered (e.g., object and array\n    // destructuring), the entire pattern is recursively checked.\n    //\n    // There are three versions of checkLVal*() appropriate for different\n    // circumstances:\n    //\n    // - checkLValSimple() shall be used if the syntactic construct supports\n    //   nothing other than identifiers and member expressions. Parenthesized\n    //   expressions are also correctly handled. This is generally appropriate for\n    //   constructs for which the spec says\n    //\n    //   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n    //   > simple.\n    //\n    //   It is also appropriate for checking if an identifier is valid and not\n    //   defined elsewhere, like import declarations or function/class identifiers.\n    //\n    //   Examples where this is used include:\n    //     a += …;\n    //     import a from '…';\n    //   where a is the node to be checked.\n    //\n    // - checkLValPattern() shall be used if the syntactic construct supports\n    //   anything checkLValSimple() supports, as well as object and array\n    //   destructuring patterns. This is generally appropriate for constructs for\n    //   which the spec says\n    //\n    //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n    //   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n    //   > simple.\n    //\n    //   Examples where this is used include:\n    //     (a = …);\n    //     const a = …;\n    //     try { … } catch (a) { … }\n    //   where a is the node to be checked.\n    //\n    // - checkLValInnerPattern() shall be used if the syntactic construct supports\n    //   anything checkLValPattern() supports, as well as default assignment\n    //   patterns, rest elements, and other constructs that may appear within an\n    //   object or array destructuring pattern.\n    //\n    //   As a special case, function parameters also use checkLValInnerPattern(),\n    //   as they also support defaults and rest constructs.\n    //\n    // These functions deliberately support both assignment and binding constructs,\n    // as the logic for both is exceedingly similar. If the node is the target of\n    // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n    // should be set to the appropriate BIND_* constant, like BIND_VAR or\n    // BIND_LEXICAL.\n    //\n    // If the function is called with a non-BIND_NONE bindingType, then\n    // additionally a checkClashes object may be specified to allow checking for\n    // duplicate argument names. checkClashes is ignored if the provided construct\n    // is an assignment (i.e., bindingType is BIND_NONE).\n    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n        if (bindingType === void 0) bindingType = BIND_NONE;\n        var isBind = bindingType !== BIND_NONE;\n        switch(expr.type){\n            case \"Identifier\":\n                if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {\n                    this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n                }\n                if (isBind) {\n                    if (bindingType === BIND_LEXICAL && expr.name === \"let\") {\n                        this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\");\n                    }\n                    if (checkClashes) {\n                        if (hasOwn(checkClashes, expr.name)) {\n                            this.raiseRecoverable(expr.start, \"Argument name clash\");\n                        }\n                        checkClashes[expr.name] = true;\n                    }\n                    if (bindingType !== BIND_OUTSIDE) {\n                        this.declareName(expr.name, bindingType, expr.start);\n                    }\n                }\n                break;\n            case \"ChainExpression\":\n                this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n                break;\n            case \"MemberExpression\":\n                if (isBind) {\n                    this.raiseRecoverable(expr.start, \"Binding member expression\");\n                }\n                break;\n            case \"ParenthesizedExpression\":\n                if (isBind) {\n                    this.raiseRecoverable(expr.start, \"Binding parenthesized expression\");\n                }\n                return this.checkLValSimple(expr.expression, bindingType, checkClashes);\n            default:\n                this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n        }\n    };\n    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n        if (bindingType === void 0) bindingType = BIND_NONE;\n        switch(expr.type){\n            case \"ObjectPattern\":\n                for(var i = 0, list = expr.properties; i < list.length; i += 1){\n                    var prop = list[i];\n                    this.checkLValInnerPattern(prop, bindingType, checkClashes);\n                }\n                break;\n            case \"ArrayPattern\":\n                for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){\n                    var elem = list$1[i$1];\n                    if (elem) {\n                        this.checkLValInnerPattern(elem, bindingType, checkClashes);\n                    }\n                }\n                break;\n            default:\n                this.checkLValSimple(expr, bindingType, checkClashes);\n        }\n    };\n    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n        if (bindingType === void 0) bindingType = BIND_NONE;\n        switch(expr.type){\n            case \"Property\":\n                // AssignmentProperty has type === \"Property\"\n                this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n                break;\n            case \"AssignmentPattern\":\n                this.checkLValPattern(expr.left, bindingType, checkClashes);\n                break;\n            case \"RestElement\":\n                this.checkLValPattern(expr.argument, bindingType, checkClashes);\n                break;\n            default:\n                this.checkLValPattern(expr, bindingType, checkClashes);\n        }\n    };\n    // The algorithm used to determine whether a regexp can appear at a\n    // given point in the program is loosely based on sweet.js' approach.\n    // See https://github.com/mozilla/sweet.js/wiki/design\n    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n        this.token = token;\n        this.isExpr = !!isExpr;\n        this.preserveSpace = !!preserveSpace;\n        this.override = override;\n        this.generator = !!generator;\n    };\n    var types = {\n        b_stat: new TokContext(\"{\", false),\n        b_expr: new TokContext(\"{\", true),\n        b_tmpl: new TokContext(\"${\", false),\n        p_stat: new TokContext(\"(\", false),\n        p_expr: new TokContext(\"(\", true),\n        q_tmpl: new TokContext(\"`\", true, true, function(p) {\n            return p.tryReadTemplateToken();\n        }),\n        f_stat: new TokContext(\"function\", false),\n        f_expr: new TokContext(\"function\", true),\n        f_expr_gen: new TokContext(\"function\", true, false, null, true),\n        f_gen: new TokContext(\"function\", false, false, null, true)\n    };\n    var pp$6 = Parser.prototype;\n    pp$6.initialContext = function() {\n        return [\n            types.b_stat\n        ];\n    };\n    pp$6.curContext = function() {\n        return this.context[this.context.length - 1];\n    };\n    pp$6.braceIsBlock = function(prevType) {\n        var parent = this.curContext();\n        if (parent === types.f_expr || parent === types.f_stat) {\n            return true;\n        }\n        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {\n            return !parent.isExpr;\n        }\n        // The check for `tt.name && exprAllowed` detects whether we are\n        // after a `yield` or `of` construct. See the `updateContext` for\n        // `tt.name`.\n        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {\n            return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n        }\n        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {\n            return true;\n        }\n        if (prevType === types$1.braceL) {\n            return parent === types.b_stat;\n        }\n        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {\n            return false;\n        }\n        return !this.exprAllowed;\n    };\n    pp$6.inGeneratorContext = function() {\n        for(var i = this.context.length - 1; i >= 1; i--){\n            var context = this.context[i];\n            if (context.token === \"function\") {\n                return context.generator;\n            }\n        }\n        return false;\n    };\n    pp$6.updateContext = function(prevType) {\n        var update, type = this.type;\n        if (type.keyword && prevType === types$1.dot) {\n            this.exprAllowed = false;\n        } else if (update = type.updateContext) {\n            update.call(this, prevType);\n        } else {\n            this.exprAllowed = type.beforeExpr;\n        }\n    };\n    // Used to handle egde cases when token context could not be inferred correctly during tokenization phase\n    pp$6.overrideContext = function(tokenCtx) {\n        if (this.curContext() !== tokenCtx) {\n            this.context[this.context.length - 1] = tokenCtx;\n        }\n    };\n    // Token-specific context update code\n    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n        if (this.context.length === 1) {\n            this.exprAllowed = true;\n            return;\n        }\n        var out = this.context.pop();\n        if (out === types.b_stat && this.curContext().token === \"function\") {\n            out = this.context.pop();\n        }\n        this.exprAllowed = !out.isExpr;\n    };\n    types$1.braceL.updateContext = function(prevType) {\n        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n        this.exprAllowed = true;\n    };\n    types$1.dollarBraceL.updateContext = function() {\n        this.context.push(types.b_tmpl);\n        this.exprAllowed = true;\n    };\n    types$1.parenL.updateContext = function(prevType) {\n        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n        this.context.push(statementParens ? types.p_stat : types.p_expr);\n        this.exprAllowed = true;\n    };\n    types$1.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n    };\n    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {\n            this.context.push(types.f_expr);\n        } else {\n            this.context.push(types.f_stat);\n        }\n        this.exprAllowed = false;\n    };\n    types$1.backQuote.updateContext = function() {\n        if (this.curContext() === types.q_tmpl) {\n            this.context.pop();\n        } else {\n            this.context.push(types.q_tmpl);\n        }\n        this.exprAllowed = false;\n    };\n    types$1.star.updateContext = function(prevType) {\n        if (prevType === types$1._function) {\n            var index = this.context.length - 1;\n            if (this.context[index] === types.f_expr) {\n                this.context[index] = types.f_expr_gen;\n            } else {\n                this.context[index] = types.f_gen;\n            }\n        }\n        this.exprAllowed = true;\n    };\n    types$1.name.updateContext = function(prevType) {\n        var allowed = false;\n        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n            if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) {\n                allowed = true;\n            }\n        }\n        this.exprAllowed = allowed;\n    };\n    // A recursive descent parser operates by defining functions for all\n    // syntactic elements, and recursively calling those, each function\n    // advancing the input stream and returning an AST node. Precedence\n    // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n    // instead of `(!x)[1]` is handled by the fact that the parser\n    // function that parses unary prefix operators is called first, and\n    // in turn calls the function that parses `[]` subscripts — that\n    // way, it'll receive the node for `x[1]` already parsed, and wraps\n    // *that* in the unary operator node.\n    //\n    // Acorn uses an [operator precedence parser][opp] to handle binary\n    // operator precedence, because it is much more compact than using\n    // the technique outlined above, which uses different, nesting\n    // functions to specify precedence, for all of the ten binary\n    // precedence levels that JavaScript defines.\n    //\n    // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n    var pp$5 = Parser.prototype;\n    // Check if property name clashes with already added.\n    // Object/class getters and setters are not allowed to clash —\n    // either with each other or with an init property — and in\n    // strict mode, init properties are also not allowed to be repeated.\n    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n        if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") {\n            return;\n        }\n        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {\n            return;\n        }\n        var key = prop.key;\n        var name;\n        switch(key.type){\n            case \"Identifier\":\n                name = key.name;\n                break;\n            case \"Literal\":\n                name = String(key.value);\n                break;\n            default:\n                return;\n        }\n        var kind = prop.kind;\n        if (this.options.ecmaVersion >= 6) {\n            if (name === \"__proto__\" && kind === \"init\") {\n                if (propHash.proto) {\n                    if (refDestructuringErrors) {\n                        if (refDestructuringErrors.doubleProto < 0) {\n                            refDestructuringErrors.doubleProto = key.start;\n                        }\n                    } else {\n                        this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n                    }\n                }\n                propHash.proto = true;\n            }\n            return;\n        }\n        name = \"$\" + name;\n        var other = propHash[name];\n        if (other) {\n            var redefinition;\n            if (kind === \"init\") {\n                redefinition = this.strict && other.init || other.get || other.set;\n            } else {\n                redefinition = other.init || other[kind];\n            }\n            if (redefinition) {\n                this.raiseRecoverable(key.start, \"Redefinition of property\");\n            }\n        } else {\n            other = propHash[name] = {\n                init: false,\n                get: false,\n                set: false\n            };\n        }\n        other[kind] = true;\n    };\n    // ### Expression parsing\n    // These nest, from the most general expression type at the top to\n    // 'atomic', nondivisible expression types at the bottom. Most of\n    // the functions will simply let the function(s) below them parse,\n    // and, *if* the syntactic construct they handle is present, wrap\n    // the AST node that the inner parser gave them in another node.\n    // Parse a full expression. The optional arguments are used to\n    // forbid the `in` operator (in for loops initalization expressions)\n    // and provide reference for storing '=' operator inside shorthand\n    // property assignment in contexts where both object expression\n    // and object pattern might appear (so it's possible to raise\n    // delayed syntax error at correct position).\n    pp$5.parseExpression = function(forInit, refDestructuringErrors) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n        if (this.type === types$1.comma) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.expressions = [\n                expr\n            ];\n            while(this.eat(types$1.comma)){\n                node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));\n            }\n            return this.finishNode(node, \"SequenceExpression\");\n        }\n        return expr;\n    };\n    // Parse an assignment expression. This includes applications of\n    // operators like `+=`.\n    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n        if (this.isContextual(\"yield\")) {\n            if (this.inGenerator) {\n                return this.parseYield(forInit);\n            } else {\n                this.exprAllowed = false;\n            }\n        }\n        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n        if (refDestructuringErrors) {\n            oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n            oldTrailingComma = refDestructuringErrors.trailingComma;\n            oldDoubleProto = refDestructuringErrors.doubleProto;\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n        } else {\n            refDestructuringErrors = new DestructuringErrors;\n            ownDestructuringErrors = true;\n        }\n        var startPos = this.start, startLoc = this.startLoc;\n        if (this.type === types$1.parenL || this.type === types$1.name) {\n            this.potentialArrowAt = this.start;\n            this.potentialArrowInForAwait = forInit === \"await\";\n        }\n        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n        if (afterLeftParse) {\n            left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n        if (this.type.isAssign) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.operator = this.value;\n            if (this.type === types$1.eq) {\n                left = this.toAssignable(left, false, refDestructuringErrors);\n            }\n            if (!ownDestructuringErrors) {\n                refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n            }\n            if (refDestructuringErrors.shorthandAssign >= left.start) {\n                refDestructuringErrors.shorthandAssign = -1;\n            } // reset because shorthand default was used correctly\n            if (this.type === types$1.eq) {\n                this.checkLValPattern(left);\n            } else {\n                this.checkLValSimple(left);\n            }\n            node.left = left;\n            this.next();\n            node.right = this.parseMaybeAssign(forInit);\n            if (oldDoubleProto > -1) {\n                refDestructuringErrors.doubleProto = oldDoubleProto;\n            }\n            return this.finishNode(node, \"AssignmentExpression\");\n        } else {\n            if (ownDestructuringErrors) {\n                this.checkExpressionErrors(refDestructuringErrors, true);\n            }\n        }\n        if (oldParenAssign > -1) {\n            refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n        }\n        if (oldTrailingComma > -1) {\n            refDestructuringErrors.trailingComma = oldTrailingComma;\n        }\n        return left;\n    };\n    // Parse a ternary conditional (`?:`) operator.\n    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseExprOps(forInit, refDestructuringErrors);\n        if (this.checkExpressionErrors(refDestructuringErrors)) {\n            return expr;\n        }\n        if (this.eat(types$1.question)) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.test = expr;\n            node.consequent = this.parseMaybeAssign();\n            this.expect(types$1.colon);\n            node.alternate = this.parseMaybeAssign(forInit);\n            return this.finishNode(node, \"ConditionalExpression\");\n        }\n        return expr;\n    };\n    // Start the precedence parser.\n    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n        if (this.checkExpressionErrors(refDestructuringErrors)) {\n            return expr;\n        }\n        return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);\n    };\n    // Parse binary operators with the operator precedence parsing\n    // algorithm. `left` is the left-hand side of the operator.\n    // `minPrec` provides context that allows the function to stop and\n    // defer further parser to one of its callers when it encounters an\n    // operator that has a lower precedence than the set it is parsing.\n    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n        var prec = this.type.binop;\n        if (prec != null && (!forInit || this.type !== types$1._in)) {\n            if (prec > minPrec) {\n                var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n                var coalesce = this.type === types$1.coalesce;\n                if (coalesce) {\n                    // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n                    // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n                    prec = types$1.logicalAND.binop;\n                }\n                var op = this.value;\n                this.next();\n                var startPos = this.start, startLoc = this.startLoc;\n                var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n                var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n                if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {\n                    this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n                }\n                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);\n            }\n        }\n        return left;\n    };\n    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n        if (right.type === \"PrivateIdentifier\") {\n            this.raise(right.start, \"Private identifier can only be left side of binary expression\");\n        }\n        var node = this.startNodeAt(startPos, startLoc);\n        node.left = left;\n        node.operator = op;\n        node.right = right;\n        return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n    };\n    // Parse unary operators, both prefix and postfix.\n    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n        var startPos = this.start, startLoc = this.startLoc, expr;\n        if (this.isContextual(\"await\") && this.canAwait) {\n            expr = this.parseAwait(forInit);\n            sawUnary = true;\n        } else if (this.type.prefix) {\n            var node = this.startNode(), update = this.type === types$1.incDec;\n            node.operator = this.value;\n            node.prefix = true;\n            this.next();\n            node.argument = this.parseMaybeUnary(null, true, update, forInit);\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            if (update) {\n                this.checkLValSimple(node.argument);\n            } else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n                this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n            } else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument)) {\n                this.raiseRecoverable(node.start, \"Private fields can not be deleted\");\n            } else {\n                sawUnary = true;\n            }\n            expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n        } else if (!sawUnary && this.type === types$1.privateId) {\n            if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {\n                this.unexpected();\n            }\n            expr = this.parsePrivateIdent();\n            // only could be private fields in 'in', such as #x in obj\n            if (this.type !== types$1._in) {\n                this.unexpected();\n            }\n        } else {\n            expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n            if (this.checkExpressionErrors(refDestructuringErrors)) {\n                return expr;\n            }\n            while(this.type.postfix && !this.canInsertSemicolon()){\n                var node$1 = this.startNodeAt(startPos, startLoc);\n                node$1.operator = this.value;\n                node$1.prefix = false;\n                node$1.argument = expr;\n                this.checkLValSimple(expr);\n                this.next();\n                expr = this.finishNode(node$1, \"UpdateExpression\");\n            }\n        }\n        if (!incDec && this.eat(types$1.starstar)) {\n            if (sawUnary) {\n                this.unexpected(this.lastTokStart);\n            } else {\n                return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false);\n            }\n        } else {\n            return expr;\n        }\n    };\n    function isPrivateFieldAccess(node) {\n        return node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" || node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression);\n    }\n    // Parse call, dot, and `[]`-subscript expressions.\n    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n        var startPos = this.start, startLoc = this.startLoc;\n        var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n        if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\") {\n            return expr;\n        }\n        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n        if (refDestructuringErrors && result.type === \"MemberExpression\") {\n            if (refDestructuringErrors.parenthesizedAssign >= result.start) {\n                refDestructuringErrors.parenthesizedAssign = -1;\n            }\n            if (refDestructuringErrors.parenthesizedBind >= result.start) {\n                refDestructuringErrors.parenthesizedBind = -1;\n            }\n            if (refDestructuringErrors.trailingComma >= result.start) {\n                refDestructuringErrors.trailingComma = -1;\n            }\n        }\n        return result;\n    };\n    pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;\n        var optionalChained = false;\n        while(true){\n            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n            if (element.optional) {\n                optionalChained = true;\n            }\n            if (element === base || element.type === \"ArrowFunctionExpression\") {\n                if (optionalChained) {\n                    var chainNode = this.startNodeAt(startPos, startLoc);\n                    chainNode.expression = element;\n                    element = this.finishNode(chainNode, \"ChainExpression\");\n                }\n                return element;\n            }\n            base = element;\n        }\n    };\n    pp$5.shouldParseAsyncArrow = function() {\n        return !this.canInsertSemicolon() && this.eat(types$1.arrow);\n    };\n    pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);\n    };\n    pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n        var optionalSupported = this.options.ecmaVersion >= 11;\n        var optional = optionalSupported && this.eat(types$1.questionDot);\n        if (noCalls && optional) {\n            this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\");\n        }\n        var computed = this.eat(types$1.bracketL);\n        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {\n            var node = this.startNodeAt(startPos, startLoc);\n            node.object = base;\n            if (computed) {\n                node.property = this.parseExpression();\n                this.expect(types$1.bracketR);\n            } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n                node.property = this.parsePrivateIdent();\n            } else {\n                node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n            }\n            node.computed = !!computed;\n            if (optionalSupported) {\n                node.optional = optional;\n            }\n            base = this.finishNode(node, \"MemberExpression\");\n        } else if (!noCalls && this.eat(types$1.parenL)) {\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n            this.yieldPos = 0;\n            this.awaitPos = 0;\n            this.awaitIdentPos = 0;\n            var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n            if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n                this.checkPatternErrors(refDestructuringErrors, false);\n                this.checkYieldAwaitInDefaultParams();\n                if (this.awaitIdentPos > 0) {\n                    this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\");\n                }\n                this.yieldPos = oldYieldPos;\n                this.awaitPos = oldAwaitPos;\n                this.awaitIdentPos = oldAwaitIdentPos;\n                return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);\n            }\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            this.yieldPos = oldYieldPos || this.yieldPos;\n            this.awaitPos = oldAwaitPos || this.awaitPos;\n            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n            var node$1 = this.startNodeAt(startPos, startLoc);\n            node$1.callee = base;\n            node$1.arguments = exprList;\n            if (optionalSupported) {\n                node$1.optional = optional;\n            }\n            base = this.finishNode(node$1, \"CallExpression\");\n        } else if (this.type === types$1.backQuote) {\n            if (optional || optionalChained) {\n                this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n            }\n            var node$2 = this.startNodeAt(startPos, startLoc);\n            node$2.tag = base;\n            node$2.quasi = this.parseTemplate({\n                isTagged: true\n            });\n            base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n        }\n        return base;\n    };\n    // Parse an atomic expression — either a single token that is an\n    // expression, an expression started by a keyword like `function` or\n    // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n    // or `{}`.\n    pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n        // If a division operator appears in an expression position, the\n        // tokenizer got confused, and we force it to read a regexp instead.\n        if (this.type === types$1.slash) {\n            this.readRegexp();\n        }\n        var node, canBeArrow = this.potentialArrowAt === this.start;\n        switch(this.type){\n            case types$1._super:\n                if (!this.allowSuper) {\n                    this.raise(this.start, \"'super' keyword outside a method\");\n                }\n                node = this.startNode();\n                this.next();\n                if (this.type === types$1.parenL && !this.allowDirectSuper) {\n                    this.raise(node.start, \"super() call outside constructor of a subclass\");\n                }\n                // The `super` keyword can appear at below:\n                // SuperProperty:\n                //     super [ Expression ]\n                //     super . IdentifierName\n                // SuperCall:\n                //     super ( Arguments )\n                if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {\n                    this.unexpected();\n                }\n                return this.finishNode(node, \"Super\");\n            case types$1._this:\n                node = this.startNode();\n                this.next();\n                return this.finishNode(node, \"ThisExpression\");\n            case types$1.name:\n                var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n                var id = this.parseIdent(false);\n                if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n                    this.overrideContext(types.f_expr);\n                    return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);\n                }\n                if (canBeArrow && !this.canInsertSemicolon()) {\n                    if (this.eat(types$1.arrow)) {\n                        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                            id\n                        ], false, forInit);\n                    }\n                    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n                        id = this.parseIdent(false);\n                        if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {\n                            this.unexpected();\n                        }\n                        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                            id\n                        ], true, forInit);\n                    }\n                }\n                return id;\n            case types$1.regexp:\n                var value = this.value;\n                node = this.parseLiteral(value.value);\n                node.regex = {\n                    pattern: value.pattern,\n                    flags: value.flags\n                };\n                return node;\n            case types$1.num:\n            case types$1.string:\n                return this.parseLiteral(this.value);\n            case types$1._null:\n            case types$1._true:\n            case types$1._false:\n                node = this.startNode();\n                node.value = this.type === types$1._null ? null : this.type === types$1._true;\n                node.raw = this.type.keyword;\n                this.next();\n                return this.finishNode(node, \"Literal\");\n            case types$1.parenL:\n                var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n                if (refDestructuringErrors) {\n                    if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {\n                        refDestructuringErrors.parenthesizedAssign = start;\n                    }\n                    if (refDestructuringErrors.parenthesizedBind < 0) {\n                        refDestructuringErrors.parenthesizedBind = start;\n                    }\n                }\n                return expr;\n            case types$1.bracketL:\n                node = this.startNode();\n                this.next();\n                node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n                return this.finishNode(node, \"ArrayExpression\");\n            case types$1.braceL:\n                this.overrideContext(types.b_expr);\n                return this.parseObj(false, refDestructuringErrors);\n            case types$1._function:\n                node = this.startNode();\n                this.next();\n                return this.parseFunction(node, 0);\n            case types$1._class:\n                return this.parseClass(this.startNode(), false);\n            case types$1._new:\n                return this.parseNew();\n            case types$1.backQuote:\n                return this.parseTemplate();\n            case types$1._import:\n                if (this.options.ecmaVersion >= 11) {\n                    return this.parseExprImport(forNew);\n                } else {\n                    return this.unexpected();\n                }\n            default:\n                return this.parseExprAtomDefault();\n        }\n    };\n    pp$5.parseExprAtomDefault = function() {\n        this.unexpected();\n    };\n    pp$5.parseExprImport = function(forNew) {\n        var node = this.startNode();\n        // Consume `import` as an identifier for `import.meta`.\n        // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n        if (this.containsEsc) {\n            this.raiseRecoverable(this.start, \"Escape sequence in keyword import\");\n        }\n        var meta = this.parseIdent(true);\n        if (this.type === types$1.parenL && !forNew) {\n            return this.parseDynamicImport(node);\n        } else if (this.type === types$1.dot) {\n            node.meta = meta;\n            return this.parseImportMeta(node);\n        } else {\n            this.unexpected();\n        }\n    };\n    pp$5.parseDynamicImport = function(node) {\n        this.next(); // skip `(`\n        // Parse node.source.\n        node.source = this.parseMaybeAssign();\n        // Verify ending.\n        if (!this.eat(types$1.parenR)) {\n            var errorPos = this.start;\n            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n                this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n            } else {\n                this.unexpected(errorPos);\n            }\n        }\n        return this.finishNode(node, \"ImportExpression\");\n    };\n    pp$5.parseImportMeta = function(node) {\n        this.next(); // skip `.`\n        var containsEsc = this.containsEsc;\n        node.property = this.parseIdent(true);\n        if (node.property.name !== \"meta\") {\n            this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\");\n        }\n        if (containsEsc) {\n            this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\");\n        }\n        if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere) {\n            this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\");\n        }\n        return this.finishNode(node, \"MetaProperty\");\n    };\n    pp$5.parseLiteral = function(value) {\n        var node = this.startNode();\n        node.value = value;\n        node.raw = this.input.slice(this.start, this.end);\n        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {\n            node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\");\n        }\n        this.next();\n        return this.finishNode(node, \"Literal\");\n    };\n    pp$5.parseParenExpression = function() {\n        this.expect(types$1.parenL);\n        var val = this.parseExpression();\n        this.expect(types$1.parenR);\n        return val;\n    };\n    pp$5.shouldParseArrow = function(exprList) {\n        return !this.canInsertSemicolon();\n    };\n    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n        if (this.options.ecmaVersion >= 6) {\n            this.next();\n            var innerStartPos = this.start, innerStartLoc = this.startLoc;\n            var exprList = [], first = true, lastIsComma = false;\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n            this.yieldPos = 0;\n            this.awaitPos = 0;\n            // Do not save awaitIdentPos to allow checking awaits nested in parameters\n            while(this.type !== types$1.parenR){\n                first ? first = false : this.expect(types$1.comma);\n                if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n                    lastIsComma = true;\n                    break;\n                } else if (this.type === types$1.ellipsis) {\n                    spreadStart = this.start;\n                    exprList.push(this.parseParenItem(this.parseRestBinding()));\n                    if (this.type === types$1.comma) {\n                        this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                    }\n                    break;\n                } else {\n                    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n                }\n            }\n            var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n            this.expect(types$1.parenR);\n            if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {\n                this.checkPatternErrors(refDestructuringErrors, false);\n                this.checkYieldAwaitInDefaultParams();\n                this.yieldPos = oldYieldPos;\n                this.awaitPos = oldAwaitPos;\n                return this.parseParenArrowList(startPos, startLoc, exprList, forInit);\n            }\n            if (!exprList.length || lastIsComma) {\n                this.unexpected(this.lastTokStart);\n            }\n            if (spreadStart) {\n                this.unexpected(spreadStart);\n            }\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            this.yieldPos = oldYieldPos || this.yieldPos;\n            this.awaitPos = oldAwaitPos || this.awaitPos;\n            if (exprList.length > 1) {\n                val = this.startNodeAt(innerStartPos, innerStartLoc);\n                val.expressions = exprList;\n                this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n            } else {\n                val = exprList[0];\n            }\n        } else {\n            val = this.parseParenExpression();\n        }\n        if (this.options.preserveParens) {\n            var par = this.startNodeAt(startPos, startLoc);\n            par.expression = val;\n            return this.finishNode(par, \"ParenthesizedExpression\");\n        } else {\n            return val;\n        }\n    };\n    pp$5.parseParenItem = function(item) {\n        return item;\n    };\n    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);\n    };\n    // New's precedence is slightly tricky. It must allow its argument to\n    // be a `[]` or dot subscript expression, but not a call — at least,\n    // not without wrapping it in parentheses. Thus, it uses the noCalls\n    // argument to parseSubscripts to prevent it from consuming the\n    // argument list.\n    var empty = [];\n    pp$5.parseNew = function() {\n        if (this.containsEsc) {\n            this.raiseRecoverable(this.start, \"Escape sequence in keyword new\");\n        }\n        var node = this.startNode();\n        var meta = this.parseIdent(true);\n        if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {\n            node.meta = meta;\n            var containsEsc = this.containsEsc;\n            node.property = this.parseIdent(true);\n            if (node.property.name !== \"target\") {\n                this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\");\n            }\n            if (containsEsc) {\n                this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\");\n            }\n            if (!this.allowNewDotTarget) {\n                this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\");\n            }\n            return this.finishNode(node, \"MetaProperty\");\n        }\n        var startPos = this.start, startLoc = this.startLoc;\n        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n        if (this.eat(types$1.parenL)) {\n            node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);\n        } else {\n            node.arguments = empty;\n        }\n        return this.finishNode(node, \"NewExpression\");\n    };\n    // Parse template expression.\n    pp$5.parseTemplateElement = function(ref) {\n        var isTagged = ref.isTagged;\n        var elem = this.startNode();\n        if (this.type === types$1.invalidTemplate) {\n            if (!isTagged) {\n                this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n            }\n            elem.value = {\n                raw: this.value,\n                cooked: null\n            };\n        } else {\n            elem.value = {\n                raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n                cooked: this.value\n            };\n        }\n        this.next();\n        elem.tail = this.type === types$1.backQuote;\n        return this.finishNode(elem, \"TemplateElement\");\n    };\n    pp$5.parseTemplate = function(ref) {\n        if (ref === void 0) ref = {};\n        var isTagged = ref.isTagged;\n        if (isTagged === void 0) isTagged = false;\n        var node = this.startNode();\n        this.next();\n        node.expressions = [];\n        var curElt = this.parseTemplateElement({\n            isTagged: isTagged\n        });\n        node.quasis = [\n            curElt\n        ];\n        while(!curElt.tail){\n            if (this.type === types$1.eof) {\n                this.raise(this.pos, \"Unterminated template literal\");\n            }\n            this.expect(types$1.dollarBraceL);\n            node.expressions.push(this.parseExpression());\n            this.expect(types$1.braceR);\n            node.quasis.push(curElt = this.parseTemplateElement({\n                isTagged: isTagged\n            }));\n        }\n        this.next();\n        return this.finishNode(node, \"TemplateLiteral\");\n    };\n    pp$5.isAsyncProp = function(prop) {\n        return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    };\n    // Parse an object literal or binding pattern.\n    pp$5.parseObj = function(isPattern, refDestructuringErrors) {\n        var node = this.startNode(), first = true, propHash = {};\n        node.properties = [];\n        this.next();\n        while(!this.eat(types$1.braceR)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            var prop = this.parseProperty(isPattern, refDestructuringErrors);\n            if (!isPattern) {\n                this.checkPropClash(prop, propHash, refDestructuringErrors);\n            }\n            node.properties.push(prop);\n        }\n        return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n    };\n    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n            if (isPattern) {\n                prop.argument = this.parseIdent(false);\n                if (this.type === types$1.comma) {\n                    this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                }\n                return this.finishNode(prop, \"RestElement\");\n            }\n            // Parse argument.\n            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n            // To disallow trailing comma via `this.toAssignable()`.\n            if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n                refDestructuringErrors.trailingComma = this.start;\n            }\n            // Finish\n            return this.finishNode(prop, \"SpreadElement\");\n        }\n        if (this.options.ecmaVersion >= 6) {\n            prop.method = false;\n            prop.shorthand = false;\n            if (isPattern || refDestructuringErrors) {\n                startPos = this.start;\n                startLoc = this.startLoc;\n            }\n            if (!isPattern) {\n                isGenerator = this.eat(types$1.star);\n            }\n        }\n        var containsEsc = this.containsEsc;\n        this.parsePropertyName(prop);\n        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n            isAsync = true;\n            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n            this.parsePropertyName(prop);\n        } else {\n            isAsync = false;\n        }\n        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n        return this.finishNode(prop, \"Property\");\n    };\n    pp$5.parseGetterSetter = function(prop) {\n        prop.kind = prop.key.name;\n        this.parsePropertyName(prop);\n        prop.value = this.parseMethod(false);\n        var paramCount = prop.kind === \"get\" ? 0 : 1;\n        if (prop.value.params.length !== paramCount) {\n            var start = prop.value.start;\n            if (prop.kind === \"get\") {\n                this.raiseRecoverable(start, \"getter should have no params\");\n            } else {\n                this.raiseRecoverable(start, \"setter should have exactly one param\");\n            }\n        } else {\n            if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n                this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n            }\n        }\n    };\n    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n        if ((isGenerator || isAsync) && this.type === types$1.colon) {\n            this.unexpected();\n        }\n        if (this.eat(types$1.colon)) {\n            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n            prop.kind = \"init\";\n        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n            if (isPattern) {\n                this.unexpected();\n            }\n            prop.kind = \"init\";\n            prop.method = true;\n            prop.value = this.parseMethod(isGenerator, isAsync);\n        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {\n            if (isGenerator || isAsync) {\n                this.unexpected();\n            }\n            this.parseGetterSetter(prop);\n        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n            if (isGenerator || isAsync) {\n                this.unexpected();\n            }\n            this.checkUnreserved(prop.key);\n            if (prop.key.name === \"await\" && !this.awaitIdentPos) {\n                this.awaitIdentPos = startPos;\n            }\n            prop.kind = \"init\";\n            if (isPattern) {\n                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n            } else if (this.type === types$1.eq && refDestructuringErrors) {\n                if (refDestructuringErrors.shorthandAssign < 0) {\n                    refDestructuringErrors.shorthandAssign = this.start;\n                }\n                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n            } else {\n                prop.value = this.copyNode(prop.key);\n            }\n            prop.shorthand = true;\n        } else {\n            this.unexpected();\n        }\n    };\n    pp$5.parsePropertyName = function(prop) {\n        if (this.options.ecmaVersion >= 6) {\n            if (this.eat(types$1.bracketL)) {\n                prop.computed = true;\n                prop.key = this.parseMaybeAssign();\n                this.expect(types$1.bracketR);\n                return prop.key;\n            } else {\n                prop.computed = false;\n            }\n        }\n        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n    };\n    // Initialize empty function node.\n    pp$5.initFunction = function(node) {\n        node.id = null;\n        if (this.options.ecmaVersion >= 6) {\n            node.generator = node.expression = false;\n        }\n        if (this.options.ecmaVersion >= 8) {\n            node.async = false;\n        }\n    };\n    // Parse object or class method.\n    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 6) {\n            node.generator = isGenerator;\n        }\n        if (this.options.ecmaVersion >= 8) {\n            node.async = !!isAsync;\n        }\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n        this.expect(types$1.parenL);\n        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n        this.checkYieldAwaitInDefaultParams();\n        this.parseFunctionBody(node, false, true, false);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, \"FunctionExpression\");\n    };\n    // Parse arrow function expression with given parameters.\n    pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n        this.initFunction(node);\n        if (this.options.ecmaVersion >= 8) {\n            node.async = !!isAsync;\n        }\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        node.params = this.toAssignableList(params, true);\n        this.parseFunctionBody(node, true, false, forInit);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.finishNode(node, \"ArrowFunctionExpression\");\n    };\n    // Parse function body and check parameters.\n    pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n        var isExpression = isArrowFunction && this.type !== types$1.braceL;\n        var oldStrict = this.strict, useStrict = false;\n        if (isExpression) {\n            node.body = this.parseMaybeAssign(forInit);\n            node.expression = true;\n            this.checkParams(node, false);\n        } else {\n            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n            if (!oldStrict || nonSimple) {\n                useStrict = this.strictDirective(this.end);\n                // If this is a strict mode function, verify that argument names\n                // are not repeated, and it does not try to bind the words `eval`\n                // or `arguments`.\n                if (useStrict && nonSimple) {\n                    this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n                }\n            }\n            // Start a new scope with regard to labels and the `inFunction`\n            // flag (restore them to their old value afterwards).\n            var oldLabels = this.labels;\n            this.labels = [];\n            if (useStrict) {\n                this.strict = true;\n            }\n            // Add the params to varDeclaredNames to ensure that an error is thrown\n            // if a let/const declaration in the function clashes with one of the params.\n            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n            // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n            if (this.strict && node.id) {\n                this.checkLValSimple(node.id, BIND_OUTSIDE);\n            }\n            node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n            node.expression = false;\n            this.adaptDirectivePrologue(node.body.body);\n            this.labels = oldLabels;\n        }\n        this.exitScope();\n    };\n    pp$5.isSimpleParamList = function(params) {\n        for(var i = 0, list = params; i < list.length; i += 1){\n            var param = list[i];\n            if (param.type !== \"Identifier\") {\n                return false;\n            }\n        }\n        return true;\n    };\n    // Checks function params for various disallowed patterns such as using \"eval\"\n    // or \"arguments\" and duplicate parameters.\n    pp$5.checkParams = function(node, allowDuplicates) {\n        var nameHash = Object.create(null);\n        for(var i = 0, list = node.params; i < list.length; i += 1){\n            var param = list[i];\n            this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n        }\n    };\n    // Parses a comma-separated list of expressions, and returns them as\n    // an array. `close` is the token type that ends the list, and\n    // `allowEmpty` can be turned on to allow subsequent commas with\n    // nothing in between them to be parsed as `null` (which is needed\n    // for array literals).\n    pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n        var elts = [], first = true;\n        while(!this.eat(close)){\n            if (!first) {\n                this.expect(types$1.comma);\n                if (allowTrailingComma && this.afterTrailingComma(close)) {\n                    break;\n                }\n            } else {\n                first = false;\n            }\n            var elt = void 0;\n            if (allowEmpty && this.type === types$1.comma) {\n                elt = null;\n            } else if (this.type === types$1.ellipsis) {\n                elt = this.parseSpread(refDestructuringErrors);\n                if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {\n                    refDestructuringErrors.trailingComma = this.start;\n                }\n            } else {\n                elt = this.parseMaybeAssign(false, refDestructuringErrors);\n            }\n            elts.push(elt);\n        }\n        return elts;\n    };\n    pp$5.checkUnreserved = function(ref) {\n        var start = ref.start;\n        var end = ref.end;\n        var name = ref.name;\n        if (this.inGenerator && name === \"yield\") {\n            this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\");\n        }\n        if (this.inAsync && name === \"await\") {\n            this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\");\n        }\n        if (this.currentThisScope().inClassFieldInit && name === \"arguments\") {\n            this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\");\n        }\n        if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\")) {\n            this.raise(start, \"Cannot use \" + name + \" in class static initialization block\");\n        }\n        if (this.keywords.test(name)) {\n            this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n        }\n        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) {\n            return;\n        }\n        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n        if (re.test(name)) {\n            if (!this.inAsync && name === \"await\") {\n                this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\");\n            }\n            this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n        }\n    };\n    // Parse the next token as an identifier. If `liberal` is true (used\n    // when parsing properties), it will also convert keywords into\n    // identifiers.\n    pp$5.parseIdent = function(liberal) {\n        var node = this.parseIdentNode();\n        this.next(!!liberal);\n        this.finishNode(node, \"Identifier\");\n        if (!liberal) {\n            this.checkUnreserved(node);\n            if (node.name === \"await\" && !this.awaitIdentPos) {\n                this.awaitIdentPos = node.start;\n            }\n        }\n        return node;\n    };\n    pp$5.parseIdentNode = function() {\n        var node = this.startNode();\n        if (this.type === types$1.name) {\n            node.name = this.value;\n        } else if (this.type.keyword) {\n            node.name = this.type.keyword;\n            // To fix https://github.com/acornjs/acorn/issues/575\n            // `class` and `function` keywords push new context into this.context.\n            // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n            // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n            if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n                this.context.pop();\n            }\n        } else {\n            this.unexpected();\n        }\n        return node;\n    };\n    pp$5.parsePrivateIdent = function() {\n        var node = this.startNode();\n        if (this.type === types$1.privateId) {\n            node.name = this.value;\n        } else {\n            this.unexpected();\n        }\n        this.next();\n        this.finishNode(node, \"PrivateIdentifier\");\n        // For validating existence\n        if (this.options.checkPrivateFields) {\n            if (this.privateNameStack.length === 0) {\n                this.raise(node.start, \"Private field '#\" + node.name + \"' must be declared in an enclosing class\");\n            } else {\n                this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n            }\n        }\n        return node;\n    };\n    // Parses yield expression inside generator.\n    pp$5.parseYield = function(forInit) {\n        if (!this.yieldPos) {\n            this.yieldPos = this.start;\n        }\n        var node = this.startNode();\n        this.next();\n        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {\n            node.delegate = false;\n            node.argument = null;\n        } else {\n            node.delegate = this.eat(types$1.star);\n            node.argument = this.parseMaybeAssign(forInit);\n        }\n        return this.finishNode(node, \"YieldExpression\");\n    };\n    pp$5.parseAwait = function(forInit) {\n        if (!this.awaitPos) {\n            this.awaitPos = this.start;\n        }\n        var node = this.startNode();\n        this.next();\n        node.argument = this.parseMaybeUnary(null, true, false, forInit);\n        return this.finishNode(node, \"AwaitExpression\");\n    };\n    var pp$4 = Parser.prototype;\n    // This function is used to raise exceptions on parse errors. It\n    // takes an offset integer (into the current `input`) to indicate\n    // the location of the error, attaches the position to the end\n    // of the error message, and then raises a `SyntaxError` with that\n    // message.\n    pp$4.raise = function(pos, message) {\n        var loc = getLineInfo(this.input, pos);\n        message += \" (\" + loc.line + \":\" + loc.column + \")\";\n        var err = new SyntaxError(message);\n        err.pos = pos;\n        err.loc = loc;\n        err.raisedAt = this.pos;\n        throw err;\n    };\n    pp$4.raiseRecoverable = pp$4.raise;\n    pp$4.curPosition = function() {\n        if (this.options.locations) {\n            return new Position(this.curLine, this.pos - this.lineStart);\n        }\n    };\n    var pp$3 = Parser.prototype;\n    var Scope = function Scope(flags) {\n        this.flags = flags;\n        // A list of var-declared names in the current lexical scope\n        this.var = [];\n        // A list of lexically-declared names in the current lexical scope\n        this.lexical = [];\n        // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n        this.functions = [];\n        // A switch to disallow the identifier reference 'arguments'\n        this.inClassFieldInit = false;\n    };\n    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n    pp$3.enterScope = function(flags) {\n        this.scopeStack.push(new Scope(flags));\n    };\n    pp$3.exitScope = function() {\n        this.scopeStack.pop();\n    };\n    // The spec says:\n    // > At the top level of a function, or script, function declarations are\n    // > treated like var declarations rather than like lexical declarations.\n    pp$3.treatFunctionsAsVarInScope = function(scope) {\n        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;\n    };\n    pp$3.declareName = function(name, bindingType, pos) {\n        var redeclared = false;\n        if (bindingType === BIND_LEXICAL) {\n            var scope = this.currentScope();\n            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n            scope.lexical.push(name);\n            if (this.inModule && scope.flags & SCOPE_TOP) {\n                delete this.undefinedExports[name];\n            }\n        } else if (bindingType === BIND_SIMPLE_CATCH) {\n            var scope$1 = this.currentScope();\n            scope$1.lexical.push(name);\n        } else if (bindingType === BIND_FUNCTION) {\n            var scope$2 = this.currentScope();\n            if (this.treatFunctionsAsVar) {\n                redeclared = scope$2.lexical.indexOf(name) > -1;\n            } else {\n                redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;\n            }\n            scope$2.functions.push(name);\n        } else {\n            for(var i = this.scopeStack.length - 1; i >= 0; --i){\n                var scope$3 = this.scopeStack[i];\n                if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n                    redeclared = true;\n                    break;\n                }\n                scope$3.var.push(name);\n                if (this.inModule && scope$3.flags & SCOPE_TOP) {\n                    delete this.undefinedExports[name];\n                }\n                if (scope$3.flags & SCOPE_VAR) {\n                    break;\n                }\n            }\n        }\n        if (redeclared) {\n            this.raiseRecoverable(pos, \"Identifier '\" + name + \"' has already been declared\");\n        }\n    };\n    pp$3.checkLocalExport = function(id) {\n        // scope.functions must be empty as Module code is always strict.\n        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {\n            this.undefinedExports[id.name] = id;\n        }\n    };\n    pp$3.currentScope = function() {\n        return this.scopeStack[this.scopeStack.length - 1];\n    };\n    pp$3.currentVarScope = function() {\n        for(var i = this.scopeStack.length - 1;; i--){\n            var scope = this.scopeStack[i];\n            if (scope.flags & SCOPE_VAR) {\n                return scope;\n            }\n        }\n    };\n    // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n    pp$3.currentThisScope = function() {\n        for(var i = this.scopeStack.length - 1;; i--){\n            var scope = this.scopeStack[i];\n            if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {\n                return scope;\n            }\n        }\n    };\n    var Node = function Node(parser, pos, loc) {\n        this.type = \"\";\n        this.start = pos;\n        this.end = 0;\n        if (parser.options.locations) {\n            this.loc = new SourceLocation(parser, loc);\n        }\n        if (parser.options.directSourceFile) {\n            this.sourceFile = parser.options.directSourceFile;\n        }\n        if (parser.options.ranges) {\n            this.range = [\n                pos,\n                0\n            ];\n        }\n    };\n    // Start an AST node, attaching a start offset.\n    var pp$2 = Parser.prototype;\n    pp$2.startNode = function() {\n        return new Node(this, this.start, this.startLoc);\n    };\n    pp$2.startNodeAt = function(pos, loc) {\n        return new Node(this, pos, loc);\n    };\n    // Finish an AST node, adding `type` and `end` properties.\n    function finishNodeAt(node, type, pos, loc) {\n        node.type = type;\n        node.end = pos;\n        if (this.options.locations) {\n            node.loc.end = loc;\n        }\n        if (this.options.ranges) {\n            node.range[1] = pos;\n        }\n        return node;\n    }\n    pp$2.finishNode = function(node, type) {\n        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n    };\n    // Finish node at given position\n    pp$2.finishNodeAt = function(node, type, pos, loc) {\n        return finishNodeAt.call(this, node, type, pos, loc);\n    };\n    pp$2.copyNode = function(node) {\n        var newNode = new Node(this, node.start, this.startLoc);\n        for(var prop in node){\n            newNode[prop] = node[prop];\n        }\n        return newNode;\n    };\n    // This file contains Unicode properties extracted from the ECMAScript specification.\n    // The lists are extracted like so:\n    // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n    // #table-binary-unicode-properties\n    var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n    var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n    var ecma11BinaryProperties = ecma10BinaryProperties;\n    var ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\n    var ecma13BinaryProperties = ecma12BinaryProperties;\n    var ecma14BinaryProperties = ecma13BinaryProperties;\n    var unicodeBinaryProperties = {\n        9: ecma9BinaryProperties,\n        10: ecma10BinaryProperties,\n        11: ecma11BinaryProperties,\n        12: ecma12BinaryProperties,\n        13: ecma13BinaryProperties,\n        14: ecma14BinaryProperties\n    };\n    // #table-binary-unicode-properties-of-strings\n    var ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\n    var unicodeBinaryPropertiesOfStrings = {\n        9: \"\",\n        10: \"\",\n        11: \"\",\n        12: \"\",\n        13: \"\",\n        14: ecma14BinaryPropertiesOfStrings\n    };\n    // #table-unicode-general-category-values\n    var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n    // #table-unicode-script-values\n    var ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n    var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n    var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n    var ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\n    var ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\n    var ecma14ScriptValues = ecma13ScriptValues + \" Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz\";\n    var unicodeScriptValues = {\n        9: ecma9ScriptValues,\n        10: ecma10ScriptValues,\n        11: ecma11ScriptValues,\n        12: ecma12ScriptValues,\n        13: ecma13ScriptValues,\n        14: ecma14ScriptValues\n    };\n    var data = {};\n    function buildUnicodeData(ecmaVersion) {\n        var d = data[ecmaVersion] = {\n            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n            binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n            nonBinary: {\n                General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n                Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n            }\n        };\n        d.nonBinary.Script_Extensions = d.nonBinary.Script;\n        d.nonBinary.gc = d.nonBinary.General_Category;\n        d.nonBinary.sc = d.nonBinary.Script;\n        d.nonBinary.scx = d.nonBinary.Script_Extensions;\n    }\n    for(var i = 0, list = [\n        9,\n        10,\n        11,\n        12,\n        13,\n        14\n    ]; i < list.length; i += 1){\n        var ecmaVersion = list[i];\n        buildUnicodeData(ecmaVersion);\n    }\n    var pp$1 = Parser.prototype;\n    var RegExpValidationState = function RegExpValidationState(parser) {\n        this.parser = parser;\n        this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n        this.source = \"\";\n        this.flags = \"\";\n        this.start = 0;\n        this.switchU = false;\n        this.switchV = false;\n        this.switchN = false;\n        this.pos = 0;\n        this.lastIntValue = 0;\n        this.lastStringValue = \"\";\n        this.lastAssertionIsQuantifiable = false;\n        this.numCapturingParens = 0;\n        this.maxBackReference = 0;\n        this.groupNames = [];\n        this.backReferenceNames = [];\n    };\n    RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n        var unicodeSets = flags.indexOf(\"v\") !== -1;\n        var unicode = flags.indexOf(\"u\") !== -1;\n        this.start = start | 0;\n        this.source = pattern + \"\";\n        this.flags = flags;\n        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n            this.switchU = true;\n            this.switchV = true;\n            this.switchN = true;\n        } else {\n            this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n            this.switchV = false;\n            this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n        }\n    };\n    RegExpValidationState.prototype.raise = function raise(message) {\n        this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n    };\n    // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n    // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n    RegExpValidationState.prototype.at = function at(i, forceU) {\n        if (forceU === void 0) forceU = false;\n        var s = this.source;\n        var l = s.length;\n        if (i >= l) {\n            return -1;\n        }\n        var c = s.charCodeAt(i);\n        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n            return c;\n        }\n        var next = s.charCodeAt(i + 1);\n        return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n    };\n    RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {\n        if (forceU === void 0) forceU = false;\n        var s = this.source;\n        var l = s.length;\n        if (i >= l) {\n            return l;\n        }\n        var c = s.charCodeAt(i), next;\n        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n            return i + 1;\n        }\n        return i + 2;\n    };\n    RegExpValidationState.prototype.current = function current(forceU) {\n        if (forceU === void 0) forceU = false;\n        return this.at(this.pos, forceU);\n    };\n    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {\n        if (forceU === void 0) forceU = false;\n        return this.at(this.nextIndex(this.pos, forceU), forceU);\n    };\n    RegExpValidationState.prototype.advance = function advance(forceU) {\n        if (forceU === void 0) forceU = false;\n        this.pos = this.nextIndex(this.pos, forceU);\n    };\n    RegExpValidationState.prototype.eat = function eat(ch, forceU) {\n        if (forceU === void 0) forceU = false;\n        if (this.current(forceU) === ch) {\n            this.advance(forceU);\n            return true;\n        }\n        return false;\n    };\n    RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {\n        if (forceU === void 0) forceU = false;\n        var pos = this.pos;\n        for(var i = 0, list = chs; i < list.length; i += 1){\n            var ch = list[i];\n            var current = this.at(pos, forceU);\n            if (current === -1 || current !== ch) {\n                return false;\n            }\n            pos = this.nextIndex(pos, forceU);\n        }\n        this.pos = pos;\n        return true;\n    };\n    /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */ pp$1.validateRegExpFlags = function(state) {\n        var validFlags = state.validFlags;\n        var flags = state.flags;\n        var u = false;\n        var v = false;\n        for(var i = 0; i < flags.length; i++){\n            var flag = flags.charAt(i);\n            if (validFlags.indexOf(flag) === -1) {\n                this.raise(state.start, \"Invalid regular expression flag\");\n            }\n            if (flags.indexOf(flag, i + 1) > -1) {\n                this.raise(state.start, \"Duplicate regular expression flag\");\n            }\n            if (flag === \"u\") {\n                u = true;\n            }\n            if (flag === \"v\") {\n                v = true;\n            }\n        }\n        if (this.options.ecmaVersion >= 15 && u && v) {\n            this.raise(state.start, \"Invalid regular expression flag\");\n        }\n    };\n    /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */ pp$1.validateRegExpPattern = function(state) {\n        this.regexp_pattern(state);\n        // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n        // parsing contains a |GroupName|, reparse with the goal symbol\n        // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n        // exception if _P_ did not conform to the grammar, if any elements of _P_\n        // were not matched by the parse, or if any Early Error conditions exist.\n        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n            state.switchN = true;\n            this.regexp_pattern(state);\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n    pp$1.regexp_pattern = function(state) {\n        state.pos = 0;\n        state.lastIntValue = 0;\n        state.lastStringValue = \"\";\n        state.lastAssertionIsQuantifiable = false;\n        state.numCapturingParens = 0;\n        state.maxBackReference = 0;\n        state.groupNames.length = 0;\n        state.backReferenceNames.length = 0;\n        this.regexp_disjunction(state);\n        if (state.pos !== state.source.length) {\n            // Make the same messages as V8.\n            if (state.eat(0x29 /* ) */ )) {\n                state.raise(\"Unmatched ')'\");\n            }\n            if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) {\n                state.raise(\"Lone quantifier brackets\");\n            }\n        }\n        if (state.maxBackReference > state.numCapturingParens) {\n            state.raise(\"Invalid escape\");\n        }\n        for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){\n            var name = list[i];\n            if (state.groupNames.indexOf(name) === -1) {\n                state.raise(\"Invalid named capture referenced\");\n            }\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n    pp$1.regexp_disjunction = function(state) {\n        this.regexp_alternative(state);\n        while(state.eat(0x7C /* | */ )){\n            this.regexp_alternative(state);\n        }\n        // Make the same message as V8.\n        if (this.regexp_eatQuantifier(state, true)) {\n            state.raise(\"Nothing to repeat\");\n        }\n        if (state.eat(0x7B /* { */ )) {\n            state.raise(\"Lone quantifier brackets\");\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n    pp$1.regexp_alternative = function(state) {\n        while(state.pos < state.source.length && this.regexp_eatTerm(state)){}\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n    pp$1.regexp_eatTerm = function(state) {\n        if (this.regexp_eatAssertion(state)) {\n            // Handle `QuantifiableAssertion Quantifier` alternative.\n            // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n            // is a QuantifiableAssertion.\n            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n                // Make the same message as V8.\n                if (state.switchU) {\n                    state.raise(\"Invalid quantifier\");\n                }\n            }\n            return true;\n        }\n        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n            this.regexp_eatQuantifier(state);\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n    pp$1.regexp_eatAssertion = function(state) {\n        var start = state.pos;\n        state.lastAssertionIsQuantifiable = false;\n        // ^, $\n        if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) {\n            return true;\n        }\n        // \\b \\B\n        if (state.eat(0x5C /* \\ */ )) {\n            if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) {\n                return true;\n            }\n            state.pos = start;\n        }\n        // Lookahead / Lookbehind\n        if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {\n            var lookbehind = false;\n            if (this.options.ecmaVersion >= 9) {\n                lookbehind = state.eat(0x3C /* < */ );\n            }\n            if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {\n                this.regexp_disjunction(state);\n                if (!state.eat(0x29 /* ) */ )) {\n                    state.raise(\"Unterminated group\");\n                }\n                state.lastAssertionIsQuantifiable = !lookbehind;\n                return true;\n            }\n        }\n        state.pos = start;\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n    pp$1.regexp_eatQuantifier = function(state, noError) {\n        if (noError === void 0) noError = false;\n        if (this.regexp_eatQuantifierPrefix(state, noError)) {\n            state.eat(0x3F /* ? */ );\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n        return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);\n    };\n    pp$1.regexp_eatBracedQuantifier = function(state, noError) {\n        var start = state.pos;\n        if (state.eat(0x7B /* { */ )) {\n            var min = 0, max = -1;\n            if (this.regexp_eatDecimalDigits(state)) {\n                min = state.lastIntValue;\n                if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) {\n                    max = state.lastIntValue;\n                }\n                if (state.eat(0x7D /* } */ )) {\n                    // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n                    if (max !== -1 && max < min && !noError) {\n                        state.raise(\"numbers out of order in {} quantifier\");\n                    }\n                    return true;\n                }\n            }\n            if (state.switchU && !noError) {\n                state.raise(\"Incomplete quantifier\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n    pp$1.regexp_eatAtom = function(state) {\n        return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n    };\n    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5C /* \\ */ )) {\n            if (this.regexp_eatAtomEscape(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatUncapturingGroup = function(state) {\n        var start = state.pos;\n        if (state.eat(0x28 /* ( */ )) {\n            if (state.eat(0x3F /* ? */ ) && state.eat(0x3A /* : */ )) {\n                this.regexp_disjunction(state);\n                if (state.eat(0x29 /* ) */ )) {\n                    return true;\n                }\n                state.raise(\"Unterminated group\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatCapturingGroup = function(state) {\n        if (state.eat(0x28 /* ( */ )) {\n            if (this.options.ecmaVersion >= 9) {\n                this.regexp_groupSpecifier(state);\n            } else if (state.current() === 0x3F /* ? */ ) {\n                state.raise(\"Invalid group\");\n            }\n            this.regexp_disjunction(state);\n            if (state.eat(0x29 /* ) */ )) {\n                state.numCapturingParens += 1;\n                return true;\n            }\n            state.raise(\"Unterminated group\");\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n    pp$1.regexp_eatExtendedAtom = function(state) {\n        return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n        if (this.regexp_eatBracedQuantifier(state, true)) {\n            state.raise(\"Nothing to repeat\");\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n    pp$1.regexp_eatSyntaxCharacter = function(state) {\n        var ch = state.current();\n        if (isSyntaxCharacter(ch)) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    function isSyntaxCharacter(ch) {\n        return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n    // But eat eager.\n    pp$1.regexp_eatPatternCharacters = function(state) {\n        var start = state.pos;\n        var ch = 0;\n        while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)){\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n    pp$1.regexp_eatExtendedPatternCharacter = function(state) {\n        var ch = state.current();\n        if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // GroupSpecifier ::\n    //   [empty]\n    //   `?` GroupName\n    pp$1.regexp_groupSpecifier = function(state) {\n        if (state.eat(0x3F /* ? */ )) {\n            if (this.regexp_eatGroupName(state)) {\n                if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n                    state.raise(\"Duplicate capture group name\");\n                }\n                state.groupNames.push(state.lastStringValue);\n                return;\n            }\n            state.raise(\"Invalid group\");\n        }\n    };\n    // GroupName ::\n    //   `<` RegExpIdentifierName `>`\n    // Note: this updates `state.lastStringValue` property with the eaten name.\n    pp$1.regexp_eatGroupName = function(state) {\n        state.lastStringValue = \"\";\n        if (state.eat(0x3C /* < */ )) {\n            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) {\n                return true;\n            }\n            state.raise(\"Invalid capture group name\");\n        }\n        return false;\n    };\n    // RegExpIdentifierName ::\n    //   RegExpIdentifierStart\n    //   RegExpIdentifierName RegExpIdentifierPart\n    // Note: this updates `state.lastStringValue` property with the eaten name.\n    pp$1.regexp_eatRegExpIdentifierName = function(state) {\n        state.lastStringValue = \"\";\n        if (this.regexp_eatRegExpIdentifierStart(state)) {\n            state.lastStringValue += codePointToString(state.lastIntValue);\n            while(this.regexp_eatRegExpIdentifierPart(state)){\n                state.lastStringValue += codePointToString(state.lastIntValue);\n            }\n            return true;\n        }\n        return false;\n    };\n    // RegExpIdentifierStart ::\n    //   UnicodeIDStart\n    //   `$`\n    //   `_`\n    //   `\\` RegExpUnicodeEscapeSequence[+U]\n    pp$1.regexp_eatRegExpIdentifierStart = function(state) {\n        var start = state.pos;\n        var forceU = this.options.ecmaVersion >= 11;\n        var ch = state.current(forceU);\n        state.advance(forceU);\n        if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n            ch = state.lastIntValue;\n        }\n        if (isRegExpIdentifierStart(ch)) {\n            state.lastIntValue = ch;\n            return true;\n        }\n        state.pos = start;\n        return false;\n    };\n    function isRegExpIdentifierStart(ch) {\n        return isIdentifierStart(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;\n    }\n    // RegExpIdentifierPart ::\n    //   UnicodeIDContinue\n    //   `$`\n    //   `_`\n    //   `\\` RegExpUnicodeEscapeSequence[+U]\n    //   <ZWNJ>\n    //   <ZWJ>\n    pp$1.regexp_eatRegExpIdentifierPart = function(state) {\n        var start = state.pos;\n        var forceU = this.options.ecmaVersion >= 11;\n        var ch = state.current(forceU);\n        state.advance(forceU);\n        if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n            ch = state.lastIntValue;\n        }\n        if (isRegExpIdentifierPart(ch)) {\n            state.lastIntValue = ch;\n            return true;\n        }\n        state.pos = start;\n        return false;\n    };\n    function isRegExpIdentifierPart(ch) {\n        return isIdentifierChar(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n    pp$1.regexp_eatAtomEscape = function(state) {\n        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n            return true;\n        }\n        if (state.switchU) {\n            // Make the same message as V8.\n            if (state.current() === 0x63 /* c */ ) {\n                state.raise(\"Invalid unicode escape\");\n            }\n            state.raise(\"Invalid escape\");\n        }\n        return false;\n    };\n    pp$1.regexp_eatBackReference = function(state) {\n        var start = state.pos;\n        if (this.regexp_eatDecimalEscape(state)) {\n            var n = state.lastIntValue;\n            if (state.switchU) {\n                // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n                if (n > state.maxBackReference) {\n                    state.maxBackReference = n;\n                }\n                return true;\n            }\n            if (n <= state.numCapturingParens) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatKGroupName = function(state) {\n        if (state.eat(0x6B /* k */ )) {\n            if (this.regexp_eatGroupName(state)) {\n                state.backReferenceNames.push(state.lastStringValue);\n                return true;\n            }\n            state.raise(\"Invalid named reference\");\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n    pp$1.regexp_eatCharacterEscape = function(state) {\n        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n    };\n    pp$1.regexp_eatCControlLetter = function(state) {\n        var start = state.pos;\n        if (state.eat(0x63 /* c */ )) {\n            if (this.regexp_eatControlLetter(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    pp$1.regexp_eatZero = function(state) {\n        if (state.current() === 0x30 /* 0 */  && !isDecimalDigit(state.lookahead())) {\n            state.lastIntValue = 0;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n    pp$1.regexp_eatControlEscape = function(state) {\n        var ch = state.current();\n        if (ch === 0x74 /* t */ ) {\n            state.lastIntValue = 0x09; /* \\t */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x6E /* n */ ) {\n            state.lastIntValue = 0x0A; /* \\n */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x76 /* v */ ) {\n            state.lastIntValue = 0x0B; /* \\v */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x66 /* f */ ) {\n            state.lastIntValue = 0x0C; /* \\f */ \n            state.advance();\n            return true;\n        }\n        if (ch === 0x72 /* r */ ) {\n            state.lastIntValue = 0x0D; /* \\r */ \n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n    pp$1.regexp_eatControlLetter = function(state) {\n        var ch = state.current();\n        if (isControlLetter(ch)) {\n            state.lastIntValue = ch % 0x20;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    function isControlLetter(ch) {\n        return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n        if (forceU === void 0) forceU = false;\n        var start = state.pos;\n        var switchU = forceU || state.switchU;\n        if (state.eat(0x75 /* u */ )) {\n            if (this.regexp_eatFixedHexDigits(state, 4)) {\n                var lead = state.lastIntValue;\n                if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n                    var leadSurrogateEnd = state.pos;\n                    if (state.eat(0x5C /* \\ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {\n                        var trail = state.lastIntValue;\n                        if (trail >= 0xDC00 && trail <= 0xDFFF) {\n                            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n                            return true;\n                        }\n                    }\n                    state.pos = leadSurrogateEnd;\n                    state.lastIntValue = lead;\n                }\n                return true;\n            }\n            if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && isValidUnicode(state.lastIntValue)) {\n                return true;\n            }\n            if (switchU) {\n                state.raise(\"Invalid unicode escape\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    function isValidUnicode(ch) {\n        return ch >= 0 && ch <= 0x10FFFF;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n    pp$1.regexp_eatIdentityEscape = function(state) {\n        if (state.switchU) {\n            if (this.regexp_eatSyntaxCharacter(state)) {\n                return true;\n            }\n            if (state.eat(0x2F /* / */ )) {\n                state.lastIntValue = 0x2F; /* / */ \n                return true;\n            }\n            return false;\n        }\n        var ch = state.current();\n        if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n    pp$1.regexp_eatDecimalEscape = function(state) {\n        state.lastIntValue = 0;\n        var ch = state.current();\n        if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {\n            do {\n                state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n                state.advance();\n            }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );\n            return true;\n        }\n        return false;\n    };\n    // Return values used by character set parsing methods, needed to\n    // forbid negation of sets that can match strings.\n    var CharSetNone = 0; // Nothing parsed\n    var CharSetOk = 1; // Construct parsed, cannot contain strings\n    var CharSetString = 2; // Construct parsed, can contain strings\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n    pp$1.regexp_eatCharacterClassEscape = function(state) {\n        var ch = state.current();\n        if (isCharacterClassEscape(ch)) {\n            state.lastIntValue = -1;\n            state.advance();\n            return CharSetOk;\n        }\n        var negate = false;\n        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 0x50 /* P */ ) || ch === 0x70 /* p */ )) {\n            state.lastIntValue = -1;\n            state.advance();\n            var result;\n            if (state.eat(0x7B /* { */ ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(0x7D /* } */ )) {\n                if (negate && result === CharSetString) {\n                    state.raise(\"Invalid property name\");\n                }\n                return result;\n            }\n            state.raise(\"Invalid property name\");\n        }\n        return CharSetNone;\n    };\n    function isCharacterClassEscape(ch) {\n        return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;\n    }\n    // UnicodePropertyValueExpression ::\n    //   UnicodePropertyName `=` UnicodePropertyValue\n    //   LoneUnicodePropertyNameOrValue\n    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n        var start = state.pos;\n        // UnicodePropertyName `=` UnicodePropertyValue\n        if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {\n            var name = state.lastStringValue;\n            if (this.regexp_eatUnicodePropertyValue(state)) {\n                var value = state.lastStringValue;\n                this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n                return CharSetOk;\n            }\n        }\n        state.pos = start;\n        // LoneUnicodePropertyNameOrValue\n        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n            var nameOrValue = state.lastStringValue;\n            return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n        }\n        return CharSetNone;\n    };\n    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {\n            state.raise(\"Invalid property name\");\n        }\n        if (!state.unicodeProperties.nonBinary[name].test(value)) {\n            state.raise(\"Invalid property value\");\n        }\n    };\n    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n        if (state.unicodeProperties.binary.test(nameOrValue)) {\n            return CharSetOk;\n        }\n        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {\n            return CharSetString;\n        }\n        state.raise(\"Invalid property name\");\n    };\n    // UnicodePropertyName ::\n    //   UnicodePropertyNameCharacters\n    pp$1.regexp_eatUnicodePropertyName = function(state) {\n        var ch = 0;\n        state.lastStringValue = \"\";\n        while(isUnicodePropertyNameCharacter(ch = state.current())){\n            state.lastStringValue += codePointToString(ch);\n            state.advance();\n        }\n        return state.lastStringValue !== \"\";\n    };\n    function isUnicodePropertyNameCharacter(ch) {\n        return isControlLetter(ch) || ch === 0x5F /* _ */ ;\n    }\n    // UnicodePropertyValue ::\n    //   UnicodePropertyValueCharacters\n    pp$1.regexp_eatUnicodePropertyValue = function(state) {\n        var ch = 0;\n        state.lastStringValue = \"\";\n        while(isUnicodePropertyValueCharacter(ch = state.current())){\n            state.lastStringValue += codePointToString(ch);\n            state.advance();\n        }\n        return state.lastStringValue !== \"\";\n    };\n    function isUnicodePropertyValueCharacter(ch) {\n        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n    }\n    // LoneUnicodePropertyNameOrValue ::\n    //   UnicodePropertyValueCharacters\n    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n        return this.regexp_eatUnicodePropertyValue(state);\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n    pp$1.regexp_eatCharacterClass = function(state) {\n        if (state.eat(0x5B /* [ */ )) {\n            var negate = state.eat(0x5E /* ^ */ );\n            var result = this.regexp_classContents(state);\n            if (!state.eat(0x5D /* ] */ )) {\n                state.raise(\"Unterminated character class\");\n            }\n            if (negate && result === CharSetString) {\n                state.raise(\"Negated character class may contain strings\");\n            }\n            return true;\n        }\n        return false;\n    };\n    // https://tc39.es/ecma262/#prod-ClassContents\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n    pp$1.regexp_classContents = function(state) {\n        if (state.current() === 0x5D /* ] */ ) {\n            return CharSetOk;\n        }\n        if (state.switchV) {\n            return this.regexp_classSetExpression(state);\n        }\n        this.regexp_nonEmptyClassRanges(state);\n        return CharSetOk;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n    pp$1.regexp_nonEmptyClassRanges = function(state) {\n        while(this.regexp_eatClassAtom(state)){\n            var left = state.lastIntValue;\n            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {\n                var right = state.lastIntValue;\n                if (state.switchU && (left === -1 || right === -1)) {\n                    state.raise(\"Invalid character class\");\n                }\n                if (left !== -1 && right !== -1 && left > right) {\n                    state.raise(\"Range out of order in character class\");\n                }\n            }\n        }\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n    pp$1.regexp_eatClassAtom = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5C /* \\ */ )) {\n            if (this.regexp_eatClassEscape(state)) {\n                return true;\n            }\n            if (state.switchU) {\n                // Make the same message as V8.\n                var ch$1 = state.current();\n                if (ch$1 === 0x63 /* c */  || isOctalDigit(ch$1)) {\n                    state.raise(\"Invalid class escape\");\n                }\n                state.raise(\"Invalid escape\");\n            }\n            state.pos = start;\n        }\n        var ch = state.current();\n        if (ch !== 0x5D /* ] */ ) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n    pp$1.regexp_eatClassEscape = function(state) {\n        var start = state.pos;\n        if (state.eat(0x62 /* b */ )) {\n            state.lastIntValue = 0x08; /* <BS> */ \n            return true;\n        }\n        if (state.switchU && state.eat(0x2D /* - */ )) {\n            state.lastIntValue = 0x2D; /* - */ \n            return true;\n        }\n        if (!state.switchU && state.eat(0x63 /* c */ )) {\n            if (this.regexp_eatClassControlLetter(state)) {\n                return true;\n            }\n            state.pos = start;\n        }\n        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetExpression\n    // https://tc39.es/ecma262/#prod-ClassUnion\n    // https://tc39.es/ecma262/#prod-ClassIntersection\n    // https://tc39.es/ecma262/#prod-ClassSubtraction\n    pp$1.regexp_classSetExpression = function(state) {\n        var result = CharSetOk, subResult;\n        if (this.regexp_eatClassSetRange(state)) ;\n        else if (subResult = this.regexp_eatClassSetOperand(state)) {\n            if (subResult === CharSetString) {\n                result = CharSetString;\n            }\n            // https://tc39.es/ecma262/#prod-ClassIntersection\n            var start = state.pos;\n            while(state.eatChars([\n                0x26,\n                0x26\n            ])){\n                if (state.current() !== 0x26 /* & */  && (subResult = this.regexp_eatClassSetOperand(state))) {\n                    if (subResult !== CharSetString) {\n                        result = CharSetOk;\n                    }\n                    continue;\n                }\n                state.raise(\"Invalid character in character class\");\n            }\n            if (start !== state.pos) {\n                return result;\n            }\n            // https://tc39.es/ecma262/#prod-ClassSubtraction\n            while(state.eatChars([\n                0x2D,\n                0x2D\n            ])){\n                if (this.regexp_eatClassSetOperand(state)) {\n                    continue;\n                }\n                state.raise(\"Invalid character in character class\");\n            }\n            if (start !== state.pos) {\n                return result;\n            }\n        } else {\n            state.raise(\"Invalid character in character class\");\n        }\n        // https://tc39.es/ecma262/#prod-ClassUnion\n        for(;;){\n            if (this.regexp_eatClassSetRange(state)) {\n                continue;\n            }\n            subResult = this.regexp_eatClassSetOperand(state);\n            if (!subResult) {\n                return result;\n            }\n            if (subResult === CharSetString) {\n                result = CharSetString;\n            }\n        }\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetRange\n    pp$1.regexp_eatClassSetRange = function(state) {\n        var start = state.pos;\n        if (this.regexp_eatClassSetCharacter(state)) {\n            var left = state.lastIntValue;\n            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassSetCharacter(state)) {\n                var right = state.lastIntValue;\n                if (left !== -1 && right !== -1 && left > right) {\n                    state.raise(\"Range out of order in character class\");\n                }\n                return true;\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetOperand\n    pp$1.regexp_eatClassSetOperand = function(state) {\n        if (this.regexp_eatClassSetCharacter(state)) {\n            return CharSetOk;\n        }\n        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);\n    };\n    // https://tc39.es/ecma262/#prod-NestedClass\n    pp$1.regexp_eatNestedClass = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5B /* [ */ )) {\n            var negate = state.eat(0x5E /* ^ */ );\n            var result = this.regexp_classContents(state);\n            if (state.eat(0x5D /* ] */ )) {\n                if (negate && result === CharSetString) {\n                    state.raise(\"Negated character class may contain strings\");\n                }\n                return result;\n            }\n            state.pos = start;\n        }\n        if (state.eat(0x5C /* \\ */ )) {\n            var result$1 = this.regexp_eatCharacterClassEscape(state);\n            if (result$1) {\n                return result$1;\n            }\n            state.pos = start;\n        }\n        return null;\n    };\n    // https://tc39.es/ecma262/#prod-ClassStringDisjunction\n    pp$1.regexp_eatClassStringDisjunction = function(state) {\n        var start = state.pos;\n        if (state.eatChars([\n            0x5C,\n            0x71\n        ])) {\n            if (state.eat(0x7B /* { */ )) {\n                var result = this.regexp_classStringDisjunctionContents(state);\n                if (state.eat(0x7D /* } */ )) {\n                    return result;\n                }\n            } else {\n                // Make the same message as V8.\n                state.raise(\"Invalid escape\");\n            }\n            state.pos = start;\n        }\n        return null;\n    };\n    // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\n    pp$1.regexp_classStringDisjunctionContents = function(state) {\n        var result = this.regexp_classString(state);\n        while(state.eat(0x7C /* | */ )){\n            if (this.regexp_classString(state) === CharSetString) {\n                result = CharSetString;\n            }\n        }\n        return result;\n    };\n    // https://tc39.es/ecma262/#prod-ClassString\n    // https://tc39.es/ecma262/#prod-NonEmptyClassString\n    pp$1.regexp_classString = function(state) {\n        var count = 0;\n        while(this.regexp_eatClassSetCharacter(state)){\n            count++;\n        }\n        return count === 1 ? CharSetOk : CharSetString;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetCharacter\n    pp$1.regexp_eatClassSetCharacter = function(state) {\n        var start = state.pos;\n        if (state.eat(0x5C /* \\ */ )) {\n            if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {\n                return true;\n            }\n            if (state.eat(0x62 /* b */ )) {\n                state.lastIntValue = 0x08; /* <BS> */ \n                return true;\n            }\n            state.pos = start;\n            return false;\n        }\n        var ch = state.current();\n        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {\n            return false;\n        }\n        if (isClassSetSyntaxCharacter(ch)) {\n            return false;\n        }\n        state.advance();\n        state.lastIntValue = ch;\n        return true;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\n    function isClassSetReservedDoublePunctuatorCharacter(ch) {\n        return ch === 0x21 /* ! */  || ch >= 0x23 /* # */  && ch <= 0x26 /* & */  || ch >= 0x2A /* * */  && ch <= 0x2C /* , */  || ch === 0x2E /* . */  || ch >= 0x3A /* : */  && ch <= 0x40 /* @ */  || ch === 0x5E /* ^ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n    }\n    // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\n    function isClassSetSyntaxCharacter(ch) {\n        return ch === 0x28 /* ( */  || ch === 0x29 /* ) */  || ch === 0x2D /* - */  || ch === 0x2F /* / */  || ch >= 0x5B /* [ */  && ch <= 0x5D /* ] */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n    }\n    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\n    pp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n        var ch = state.current();\n        if (isClassSetReservedPunctuator(ch)) {\n            state.lastIntValue = ch;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\n    function isClassSetReservedPunctuator(ch) {\n        return ch === 0x21 /* ! */  || ch === 0x23 /* # */  || ch === 0x25 /* % */  || ch === 0x26 /* & */  || ch === 0x2C /* , */  || ch === 0x2D /* - */  || ch >= 0x3A /* : */  && ch <= 0x3E /* > */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n    pp$1.regexp_eatClassControlLetter = function(state) {\n        var ch = state.current();\n        if (isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {\n            state.lastIntValue = ch % 0x20;\n            state.advance();\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n    pp$1.regexp_eatHexEscapeSequence = function(state) {\n        var start = state.pos;\n        if (state.eat(0x78 /* x */ )) {\n            if (this.regexp_eatFixedHexDigits(state, 2)) {\n                return true;\n            }\n            if (state.switchU) {\n                state.raise(\"Invalid escape\");\n            }\n            state.pos = start;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n    pp$1.regexp_eatDecimalDigits = function(state) {\n        var start = state.pos;\n        var ch = 0;\n        state.lastIntValue = 0;\n        while(isDecimalDigit(ch = state.current())){\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    function isDecimalDigit(ch) {\n        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n    pp$1.regexp_eatHexDigits = function(state) {\n        var start = state.pos;\n        var ch = 0;\n        state.lastIntValue = 0;\n        while(isHexDigit(ch = state.current())){\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n            state.advance();\n        }\n        return state.pos !== start;\n    };\n    function isHexDigit(ch) {\n        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;\n    }\n    function hexToInt(ch) {\n        if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) {\n            return 10 + (ch - 0x41 /* A */ );\n        }\n        if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) {\n            return 10 + (ch - 0x61 /* a */ );\n        }\n        return ch - 0x30 /* 0 */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n    // Allows only 0-377(octal) i.e. 0-255(decimal).\n    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n        if (this.regexp_eatOctalDigit(state)) {\n            var n1 = state.lastIntValue;\n            if (this.regexp_eatOctalDigit(state)) {\n                var n2 = state.lastIntValue;\n                if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n                    state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n                } else {\n                    state.lastIntValue = n1 * 8 + n2;\n                }\n            } else {\n                state.lastIntValue = n1;\n            }\n            return true;\n        }\n        return false;\n    };\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n    pp$1.regexp_eatOctalDigit = function(state) {\n        var ch = state.current();\n        if (isOctalDigit(ch)) {\n            state.lastIntValue = ch - 0x30; /* 0 */ \n            state.advance();\n            return true;\n        }\n        state.lastIntValue = 0;\n        return false;\n    };\n    function isOctalDigit(ch) {\n        return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;\n    }\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n    // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n    pp$1.regexp_eatFixedHexDigits = function(state, length) {\n        var start = state.pos;\n        state.lastIntValue = 0;\n        for(var i = 0; i < length; ++i){\n            var ch = state.current();\n            if (!isHexDigit(ch)) {\n                state.pos = start;\n                return false;\n            }\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n            state.advance();\n        }\n        return true;\n    };\n    // Object type used to represent tokens. Note that normally, tokens\n    // simply exist as properties on the parser object. This is only\n    // used for the onToken callback and the external tokenizer.\n    var Token = function Token(p) {\n        this.type = p.type;\n        this.value = p.value;\n        this.start = p.start;\n        this.end = p.end;\n        if (p.options.locations) {\n            this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n        }\n        if (p.options.ranges) {\n            this.range = [\n                p.start,\n                p.end\n            ];\n        }\n    };\n    // ## Tokenizer\n    var pp = Parser.prototype;\n    // Move to the next token\n    pp.next = function(ignoreEscapeSequenceInKeyword) {\n        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {\n            this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword);\n        }\n        if (this.options.onToken) {\n            this.options.onToken(new Token(this));\n        }\n        this.lastTokEnd = this.end;\n        this.lastTokStart = this.start;\n        this.lastTokEndLoc = this.endLoc;\n        this.lastTokStartLoc = this.startLoc;\n        this.nextToken();\n    };\n    pp.getToken = function() {\n        this.next();\n        return new Token(this);\n    };\n    // If we're in an ES6 environment, make parsers iterable\n    if (typeof Symbol !== \"undefined\") {\n        pp[Symbol.iterator] = function() {\n            var this$1$1 = this;\n            return {\n                next: function() {\n                    var token = this$1$1.getToken();\n                    return {\n                        done: token.type === types$1.eof,\n                        value: token\n                    };\n                }\n            };\n        };\n    }\n    // Toggle strict mode. Re-reads the next number or string to please\n    // pedantic tests (`\"use strict\"; 010;` should fail).\n    // Read a single token, updating the parser object's token-related\n    // properties.\n    pp.nextToken = function() {\n        var curContext = this.curContext();\n        if (!curContext || !curContext.preserveSpace) {\n            this.skipSpace();\n        }\n        this.start = this.pos;\n        if (this.options.locations) {\n            this.startLoc = this.curPosition();\n        }\n        if (this.pos >= this.input.length) {\n            return this.finishToken(types$1.eof);\n        }\n        if (curContext.override) {\n            return curContext.override(this);\n        } else {\n            this.readToken(this.fullCharCodeAtPos());\n        }\n    };\n    pp.readToken = function(code) {\n        // Identifier or keyword. '\\uXXXX' sequences are allowed in\n        // identifiers, so '\\' also dispatches to that.\n        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */ ) {\n            return this.readWord();\n        }\n        return this.getTokenFromCode(code);\n    };\n    pp.fullCharCodeAtPos = function() {\n        var code = this.input.charCodeAt(this.pos);\n        if (code <= 0xd7ff || code >= 0xdc00) {\n            return code;\n        }\n        var next = this.input.charCodeAt(this.pos + 1);\n        return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00;\n    };\n    pp.skipBlockComment = function() {\n        var startLoc = this.options.onComment && this.curPosition();\n        var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n        if (end === -1) {\n            this.raise(this.pos - 2, \"Unterminated comment\");\n        }\n        this.pos = end + 2;\n        if (this.options.locations) {\n            for(var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;){\n                ++this.curLine;\n                pos = this.lineStart = nextBreak;\n            }\n        }\n        if (this.options.onComment) {\n            this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n        }\n    };\n    pp.skipLineComment = function(startSkip) {\n        var start = this.pos;\n        var startLoc = this.options.onComment && this.curPosition();\n        var ch = this.input.charCodeAt(this.pos += startSkip);\n        while(this.pos < this.input.length && !isNewLine(ch)){\n            ch = this.input.charCodeAt(++this.pos);\n        }\n        if (this.options.onComment) {\n            this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n        }\n    };\n    // Called at the start of the parse and after every token. Skips\n    // whitespace and comments, and.\n    pp.skipSpace = function() {\n        loop: while(this.pos < this.input.length){\n            var ch = this.input.charCodeAt(this.pos);\n            switch(ch){\n                case 32:\n                case 160:\n                    ++this.pos;\n                    break;\n                case 13:\n                    if (this.input.charCodeAt(this.pos + 1) === 10) {\n                        ++this.pos;\n                    }\n                case 10:\n                case 8232:\n                case 8233:\n                    ++this.pos;\n                    if (this.options.locations) {\n                        ++this.curLine;\n                        this.lineStart = this.pos;\n                    }\n                    break;\n                case 47:\n                    switch(this.input.charCodeAt(this.pos + 1)){\n                        case 42:\n                            this.skipBlockComment();\n                            break;\n                        case 47:\n                            this.skipLineComment(2);\n                            break;\n                        default:\n                            break loop;\n                    }\n                    break;\n                default:\n                    if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n                        ++this.pos;\n                    } else {\n                        break loop;\n                    }\n            }\n        }\n    };\n    // Called at the end of every token. Sets `end`, `val`, and\n    // maintains `context` and `exprAllowed`, and skips the space after\n    // the token, so that the next one's `start` will point at the\n    // right position.\n    pp.finishToken = function(type, val) {\n        this.end = this.pos;\n        if (this.options.locations) {\n            this.endLoc = this.curPosition();\n        }\n        var prevType = this.type;\n        this.type = type;\n        this.value = val;\n        this.updateContext(prevType);\n    };\n    // ### Token reading\n    // This is the function that is called to fetch the next token. It\n    // is somewhat obscure, because it works in character codes rather\n    // than characters, and because operator parsing has been inlined\n    // into it.\n    //\n    // All in the name of speed.\n    //\n    pp.readToken_dot = function() {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next >= 48 && next <= 57) {\n            return this.readNumber(true);\n        }\n        var next2 = this.input.charCodeAt(this.pos + 2);\n        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n            this.pos += 3;\n            return this.finishToken(types$1.ellipsis);\n        } else {\n            ++this.pos;\n            return this.finishToken(types$1.dot);\n        }\n    };\n    pp.readToken_slash = function() {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (this.exprAllowed) {\n            ++this.pos;\n            return this.readRegexp();\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(types$1.slash, 1);\n    };\n    pp.readToken_mult_modulo_exp = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        var size = 1;\n        var tokentype = code === 42 ? types$1.star : types$1.modulo;\n        // exponentiation operator ** and **=\n        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n            ++size;\n            tokentype = types$1.starstar;\n            next = this.input.charCodeAt(this.pos + 2);\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, size + 1);\n        }\n        return this.finishOp(tokentype, size);\n    };\n    pp.readToken_pipe_amp = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === code) {\n            if (this.options.ecmaVersion >= 12) {\n                var next2 = this.input.charCodeAt(this.pos + 2);\n                if (next2 === 61) {\n                    return this.finishOp(types$1.assign, 3);\n                }\n            }\n            return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);\n    };\n    pp.readToken_caret = function() {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(types$1.bitwiseXOR, 1);\n    };\n    pp.readToken_plus_min = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === code) {\n            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n                // A `-->` line comment\n                this.skipLineComment(3);\n                this.skipSpace();\n                return this.nextToken();\n            }\n            return this.finishOp(types$1.incDec, 2);\n        }\n        if (next === 61) {\n            return this.finishOp(types$1.assign, 2);\n        }\n        return this.finishOp(types$1.plusMin, 1);\n    };\n    pp.readToken_lt_gt = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        var size = 1;\n        if (next === code) {\n            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n            if (this.input.charCodeAt(this.pos + size) === 61) {\n                return this.finishOp(types$1.assign, size + 1);\n            }\n            return this.finishOp(types$1.bitShift, size);\n        }\n        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n            // `<!--`, an XML-style comment that should be interpreted as a line comment\n            this.skipLineComment(4);\n            this.skipSpace();\n            return this.nextToken();\n        }\n        if (next === 61) {\n            size = 2;\n        }\n        return this.finishOp(types$1.relational, size);\n    };\n    pp.readToken_eq_excl = function(code) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 61) {\n            return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n        }\n        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n            this.pos += 2;\n            return this.finishToken(types$1.arrow);\n        }\n        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);\n    };\n    pp.readToken_question = function() {\n        var ecmaVersion = this.options.ecmaVersion;\n        if (ecmaVersion >= 11) {\n            var next = this.input.charCodeAt(this.pos + 1);\n            if (next === 46) {\n                var next2 = this.input.charCodeAt(this.pos + 2);\n                if (next2 < 48 || next2 > 57) {\n                    return this.finishOp(types$1.questionDot, 2);\n                }\n            }\n            if (next === 63) {\n                if (ecmaVersion >= 12) {\n                    var next2$1 = this.input.charCodeAt(this.pos + 2);\n                    if (next2$1 === 61) {\n                        return this.finishOp(types$1.assign, 3);\n                    }\n                }\n                return this.finishOp(types$1.coalesce, 2);\n            }\n        }\n        return this.finishOp(types$1.question, 1);\n    };\n    pp.readToken_numberSign = function() {\n        var ecmaVersion = this.options.ecmaVersion;\n        var code = 35; // '#'\n        if (ecmaVersion >= 13) {\n            ++this.pos;\n            code = this.fullCharCodeAtPos();\n            if (isIdentifierStart(code, true) || code === 92 /* '\\' */ ) {\n                return this.finishToken(types$1.privateId, this.readWord1());\n            }\n        }\n        this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n    };\n    pp.getTokenFromCode = function(code) {\n        switch(code){\n            // The interpretation of a dot depends on whether it is followed\n            // by a digit or another two dots.\n            case 46:\n                return this.readToken_dot();\n            // Punctuation tokens.\n            case 40:\n                ++this.pos;\n                return this.finishToken(types$1.parenL);\n            case 41:\n                ++this.pos;\n                return this.finishToken(types$1.parenR);\n            case 59:\n                ++this.pos;\n                return this.finishToken(types$1.semi);\n            case 44:\n                ++this.pos;\n                return this.finishToken(types$1.comma);\n            case 91:\n                ++this.pos;\n                return this.finishToken(types$1.bracketL);\n            case 93:\n                ++this.pos;\n                return this.finishToken(types$1.bracketR);\n            case 123:\n                ++this.pos;\n                return this.finishToken(types$1.braceL);\n            case 125:\n                ++this.pos;\n                return this.finishToken(types$1.braceR);\n            case 58:\n                ++this.pos;\n                return this.finishToken(types$1.colon);\n            case 96:\n                if (this.options.ecmaVersion < 6) {\n                    break;\n                }\n                ++this.pos;\n                return this.finishToken(types$1.backQuote);\n            case 48:\n                var next = this.input.charCodeAt(this.pos + 1);\n                if (next === 120 || next === 88) {\n                    return this.readRadixNumber(16);\n                } // '0x', '0X' - hex number\n                if (this.options.ecmaVersion >= 6) {\n                    if (next === 111 || next === 79) {\n                        return this.readRadixNumber(8);\n                    } // '0o', '0O' - octal number\n                    if (next === 98 || next === 66) {\n                        return this.readRadixNumber(2);\n                    } // '0b', '0B' - binary number\n                }\n            // Anything else beginning with a digit is an integer, octal\n            // number, or float.\n            case 49:\n            case 50:\n            case 51:\n            case 52:\n            case 53:\n            case 54:\n            case 55:\n            case 56:\n            case 57:\n                return this.readNumber(false);\n            // Quotes produce strings.\n            case 34:\n            case 39:\n                return this.readString(code);\n            // Operators are parsed inline in tiny state machines. '=' (61) is\n            // often referred to. `finishOp` simply skips the amount of\n            // characters it is given as second argument, and returns a token\n            // of the type given by its first argument.\n            case 47:\n                return this.readToken_slash();\n            case 37:\n            case 42:\n                return this.readToken_mult_modulo_exp(code);\n            case 124:\n            case 38:\n                return this.readToken_pipe_amp(code);\n            case 94:\n                return this.readToken_caret();\n            case 43:\n            case 45:\n                return this.readToken_plus_min(code);\n            case 60:\n            case 62:\n                return this.readToken_lt_gt(code);\n            case 61:\n            case 33:\n                return this.readToken_eq_excl(code);\n            case 63:\n                return this.readToken_question();\n            case 126:\n                return this.finishOp(types$1.prefix, 1);\n            case 35:\n                return this.readToken_numberSign();\n        }\n        this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n    };\n    pp.finishOp = function(type, size) {\n        var str = this.input.slice(this.pos, this.pos + size);\n        this.pos += size;\n        return this.finishToken(type, str);\n    };\n    pp.readRegexp = function() {\n        var escaped, inClass, start = this.pos;\n        for(;;){\n            if (this.pos >= this.input.length) {\n                this.raise(start, \"Unterminated regular expression\");\n            }\n            var ch = this.input.charAt(this.pos);\n            if (lineBreak.test(ch)) {\n                this.raise(start, \"Unterminated regular expression\");\n            }\n            if (!escaped) {\n                if (ch === \"[\") {\n                    inClass = true;\n                } else if (ch === \"]\" && inClass) {\n                    inClass = false;\n                } else if (ch === \"/\" && !inClass) {\n                    break;\n                }\n                escaped = ch === \"\\\\\";\n            } else {\n                escaped = false;\n            }\n            ++this.pos;\n        }\n        var pattern = this.input.slice(start, this.pos);\n        ++this.pos;\n        var flagsStart = this.pos;\n        var flags = this.readWord1();\n        if (this.containsEsc) {\n            this.unexpected(flagsStart);\n        }\n        // Validate pattern\n        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n        state.reset(start, pattern, flags);\n        this.validateRegExpFlags(state);\n        this.validateRegExpPattern(state);\n        // Create Literal#value property value.\n        var value = null;\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n        // ESTree requires null if it failed to instantiate RegExp object.\n        // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n        }\n        return this.finishToken(types$1.regexp, {\n            pattern: pattern,\n            flags: flags,\n            value: value\n        });\n    };\n    // Read an integer in the given radix. Return null if zero digits\n    // were read, the integer value otherwise. When `len` is given, this\n    // will return `null` unless the integer has exactly `len` digits.\n    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n        // `len` is used for character escape sequences. In that case, disallow separators.\n        var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n        // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n        // and isn't fraction part nor exponent part. In that case, if the first digit\n        // is zero then disallow separators.\n        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n        var start = this.pos, total = 0, lastCode = 0;\n        for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){\n            var code = this.input.charCodeAt(this.pos), val = void 0;\n            if (allowSeparators && code === 95) {\n                if (isLegacyOctalNumericLiteral) {\n                    this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\");\n                }\n                if (lastCode === 95) {\n                    this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\");\n                }\n                if (i === 0) {\n                    this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\");\n                }\n                lastCode = code;\n                continue;\n            }\n            if (code >= 97) {\n                val = code - 97 + 10;\n            } else if (code >= 65) {\n                val = code - 65 + 10;\n            } else if (code >= 48 && code <= 57) {\n                val = code - 48;\n            } else {\n                val = Infinity;\n            }\n            if (val >= radix) {\n                break;\n            }\n            lastCode = code;\n            total = total * radix + val;\n        }\n        if (allowSeparators && lastCode === 95) {\n            this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\");\n        }\n        if (this.pos === start || len != null && this.pos - start !== len) {\n            return null;\n        }\n        return total;\n    };\n    function stringToNumber(str, isLegacyOctalNumericLiteral) {\n        if (isLegacyOctalNumericLiteral) {\n            return parseInt(str, 8);\n        }\n        // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n        return parseFloat(str.replace(/_/g, \"\"));\n    }\n    function stringToBigInt(str) {\n        if (typeof BigInt !== \"function\") {\n            return null;\n        }\n        // `BigInt(value)` throws syntax error if the string contains numeric separators.\n        return BigInt(str.replace(/_/g, \"\"));\n    }\n    pp.readRadixNumber = function(radix) {\n        var start = this.pos;\n        this.pos += 2; // 0x\n        var val = this.readInt(radix);\n        if (val == null) {\n            this.raise(this.start + 2, \"Expected number in radix \" + radix);\n        }\n        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n            val = stringToBigInt(this.input.slice(start, this.pos));\n            ++this.pos;\n        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {\n            this.raise(this.pos, \"Identifier directly after number\");\n        }\n        return this.finishToken(types$1.num, val);\n    };\n    // Read an integer, octal integer, or floating-point number.\n    pp.readNumber = function(startsWithDot) {\n        var start = this.pos;\n        if (!startsWithDot && this.readInt(10, undefined, true) === null) {\n            this.raise(start, \"Invalid number\");\n        }\n        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n        if (octal && this.strict) {\n            this.raise(start, \"Invalid number\");\n        }\n        var next = this.input.charCodeAt(this.pos);\n        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n            var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n            ++this.pos;\n            if (isIdentifierStart(this.fullCharCodeAtPos())) {\n                this.raise(this.pos, \"Identifier directly after number\");\n            }\n            return this.finishToken(types$1.num, val$1);\n        }\n        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {\n            octal = false;\n        }\n        if (next === 46 && !octal) {\n            ++this.pos;\n            this.readInt(10);\n            next = this.input.charCodeAt(this.pos);\n        }\n        if ((next === 69 || next === 101) && !octal) {\n            next = this.input.charCodeAt(++this.pos);\n            if (next === 43 || next === 45) {\n                ++this.pos;\n            } // '+-'\n            if (this.readInt(10) === null) {\n                this.raise(start, \"Invalid number\");\n            }\n        }\n        if (isIdentifierStart(this.fullCharCodeAtPos())) {\n            this.raise(this.pos, \"Identifier directly after number\");\n        }\n        var val = stringToNumber(this.input.slice(start, this.pos), octal);\n        return this.finishToken(types$1.num, val);\n    };\n    // Read a string value, interpreting backslash-escapes.\n    pp.readCodePoint = function() {\n        var ch = this.input.charCodeAt(this.pos), code;\n        if (ch === 123) {\n            if (this.options.ecmaVersion < 6) {\n                this.unexpected();\n            }\n            var codePos = ++this.pos;\n            code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n            ++this.pos;\n            if (code > 0x10FFFF) {\n                this.invalidStringToken(codePos, \"Code point out of bounds\");\n            }\n        } else {\n            code = this.readHexChar(4);\n        }\n        return code;\n    };\n    pp.readString = function(quote) {\n        var out = \"\", chunkStart = ++this.pos;\n        for(;;){\n            if (this.pos >= this.input.length) {\n                this.raise(this.start, \"Unterminated string constant\");\n            }\n            var ch = this.input.charCodeAt(this.pos);\n            if (ch === quote) {\n                break;\n            }\n            if (ch === 92) {\n                out += this.input.slice(chunkStart, this.pos);\n                out += this.readEscapedChar(false);\n                chunkStart = this.pos;\n            } else if (ch === 0x2028 || ch === 0x2029) {\n                if (this.options.ecmaVersion < 10) {\n                    this.raise(this.start, \"Unterminated string constant\");\n                }\n                ++this.pos;\n                if (this.options.locations) {\n                    this.curLine++;\n                    this.lineStart = this.pos;\n                }\n            } else {\n                if (isNewLine(ch)) {\n                    this.raise(this.start, \"Unterminated string constant\");\n                }\n                ++this.pos;\n            }\n        }\n        out += this.input.slice(chunkStart, this.pos++);\n        return this.finishToken(types$1.string, out);\n    };\n    // Reads template string tokens.\n    var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n    pp.tryReadTemplateToken = function() {\n        this.inTemplateElement = true;\n        try {\n            this.readTmplToken();\n        } catch (err) {\n            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n                this.readInvalidTemplateToken();\n            } else {\n                throw err;\n            }\n        }\n        this.inTemplateElement = false;\n    };\n    pp.invalidStringToken = function(position, message) {\n        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n            throw INVALID_TEMPLATE_ESCAPE_ERROR;\n        } else {\n            this.raise(position, message);\n        }\n    };\n    pp.readTmplToken = function() {\n        var out = \"\", chunkStart = this.pos;\n        for(;;){\n            if (this.pos >= this.input.length) {\n                this.raise(this.start, \"Unterminated template\");\n            }\n            var ch = this.input.charCodeAt(this.pos);\n            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {\n                if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n                    if (ch === 36) {\n                        this.pos += 2;\n                        return this.finishToken(types$1.dollarBraceL);\n                    } else {\n                        ++this.pos;\n                        return this.finishToken(types$1.backQuote);\n                    }\n                }\n                out += this.input.slice(chunkStart, this.pos);\n                return this.finishToken(types$1.template, out);\n            }\n            if (ch === 92) {\n                out += this.input.slice(chunkStart, this.pos);\n                out += this.readEscapedChar(true);\n                chunkStart = this.pos;\n            } else if (isNewLine(ch)) {\n                out += this.input.slice(chunkStart, this.pos);\n                ++this.pos;\n                switch(ch){\n                    case 13:\n                        if (this.input.charCodeAt(this.pos) === 10) {\n                            ++this.pos;\n                        }\n                    case 10:\n                        out += \"\\n\";\n                        break;\n                    default:\n                        out += String.fromCharCode(ch);\n                        break;\n                }\n                if (this.options.locations) {\n                    ++this.curLine;\n                    this.lineStart = this.pos;\n                }\n                chunkStart = this.pos;\n            } else {\n                ++this.pos;\n            }\n        }\n    };\n    // Reads a template token to search for the end, without validating any escape sequences\n    pp.readInvalidTemplateToken = function() {\n        for(; this.pos < this.input.length; this.pos++){\n            switch(this.input[this.pos]){\n                case \"\\\\\":\n                    ++this.pos;\n                    break;\n                case \"$\":\n                    if (this.input[this.pos + 1] !== \"{\") {\n                        break;\n                    }\n                // falls through\n                case \"`\":\n                    return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));\n            }\n        }\n        this.raise(this.start, \"Unterminated template\");\n    };\n    // Used to read escaped characters\n    pp.readEscapedChar = function(inTemplate) {\n        var ch = this.input.charCodeAt(++this.pos);\n        ++this.pos;\n        switch(ch){\n            case 110:\n                return \"\\n\" // 'n' -> '\\n'\n                ;\n            case 114:\n                return \"\\r\" // 'r' -> '\\r'\n                ;\n            case 120:\n                return String.fromCharCode(this.readHexChar(2)) // 'x'\n                ;\n            case 117:\n                return codePointToString(this.readCodePoint()) // 'u'\n                ;\n            case 116:\n                return \"\t\" // 't' -> '\\t'\n                ;\n            case 98:\n                return \"\\b\" // 'b' -> '\\b'\n                ;\n            case 118:\n                return \"\\v\" // 'v' -> '\\u000b'\n                ;\n            case 102:\n                return \"\\f\" // 'f' -> '\\f'\n                ;\n            case 13:\n                if (this.input.charCodeAt(this.pos) === 10) {\n                    ++this.pos;\n                } // '\\r\\n'\n            case 10:\n                if (this.options.locations) {\n                    this.lineStart = this.pos;\n                    ++this.curLine;\n                }\n                return \"\";\n            case 56:\n            case 57:\n                if (this.strict) {\n                    this.invalidStringToken(this.pos - 1, \"Invalid escape sequence\");\n                }\n                if (inTemplate) {\n                    var codePos = this.pos - 1;\n                    this.invalidStringToken(codePos, \"Invalid escape sequence in template string\");\n                }\n            default:\n                if (ch >= 48 && ch <= 55) {\n                    var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n                    var octal = parseInt(octalStr, 8);\n                    if (octal > 255) {\n                        octalStr = octalStr.slice(0, -1);\n                        octal = parseInt(octalStr, 8);\n                    }\n                    this.pos += octalStr.length - 1;\n                    ch = this.input.charCodeAt(this.pos);\n                    if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n                        this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n                    }\n                    return String.fromCharCode(octal);\n                }\n                if (isNewLine(ch)) {\n                    // Unicode new line characters after \\ get removed from output in both\n                    // template literals and strings\n                    return \"\";\n                }\n                return String.fromCharCode(ch);\n        }\n    };\n    // Used to read character escape sequences ('\\x', '\\u', '\\U').\n    pp.readHexChar = function(len) {\n        var codePos = this.pos;\n        var n = this.readInt(16, len);\n        if (n === null) {\n            this.invalidStringToken(codePos, \"Bad character escape sequence\");\n        }\n        return n;\n    };\n    // Read an identifier, and return it as a string. Sets `this.containsEsc`\n    // to whether the word contained a '\\u' escape.\n    //\n    // Incrementally adds only escaped chars, adding other chunks as-is\n    // as a micro-optimization.\n    pp.readWord1 = function() {\n        this.containsEsc = false;\n        var word = \"\", first = true, chunkStart = this.pos;\n        var astral = this.options.ecmaVersion >= 6;\n        while(this.pos < this.input.length){\n            var ch = this.fullCharCodeAtPos();\n            if (isIdentifierChar(ch, astral)) {\n                this.pos += ch <= 0xffff ? 1 : 2;\n            } else if (ch === 92) {\n                this.containsEsc = true;\n                word += this.input.slice(chunkStart, this.pos);\n                var escStart = this.pos;\n                if (this.input.charCodeAt(++this.pos) !== 117) {\n                    this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n                }\n                ++this.pos;\n                var esc = this.readCodePoint();\n                if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {\n                    this.invalidStringToken(escStart, \"Invalid Unicode escape\");\n                }\n                word += codePointToString(esc);\n                chunkStart = this.pos;\n            } else {\n                break;\n            }\n            first = false;\n        }\n        return word + this.input.slice(chunkStart, this.pos);\n    };\n    // Read an identifier or keyword token. Will check for reserved\n    // words when necessary.\n    pp.readWord = function() {\n        var word = this.readWord1();\n        var type = types$1.name;\n        if (this.keywords.test(word)) {\n            type = keywords[word];\n        }\n        return this.finishToken(type, word);\n    };\n    // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n    //\n    // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n    // various contributors and released under an MIT license.\n    //\n    // Git repositories for Acorn are available at\n    //\n    //     http://marijnhaverbeke.nl/git/acorn\n    //     https://github.com/acornjs/acorn.git\n    //\n    // Please use the [github bug tracker][ghbt] to report issues.\n    //\n    // [ghbt]: https://github.com/acornjs/acorn/issues\n    //\n    // [walk]: util/walk.js\n    var version = \"8.10.0\";\n    Parser.acorn = {\n        Parser: Parser,\n        version: version,\n        defaultOptions: defaultOptions,\n        Position: Position,\n        SourceLocation: SourceLocation,\n        getLineInfo: getLineInfo,\n        Node: Node,\n        TokenType: TokenType,\n        tokTypes: types$1,\n        keywordTypes: keywords,\n        TokContext: TokContext,\n        tokContexts: types,\n        isIdentifierChar: isIdentifierChar,\n        isIdentifierStart: isIdentifierStart,\n        Token: Token,\n        isNewLine: isNewLine,\n        lineBreak: lineBreak,\n        lineBreakG: lineBreakG,\n        nonASCIIwhitespace: nonASCIIwhitespace\n    };\n    // The main exported interface (under `self.acorn` when in the\n    // browser) is a `parse` function that takes a code string and\n    // returns an abstract syntax tree as specified by [Mozilla parser\n    // API][api].\n    //\n    // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n    function parse(input, options) {\n        return Parser.parse(input, options);\n    }\n    // This function tries to parse a single expression at a given\n    // offset in a string. Useful for parsing mixed-language formats\n    // that embed JavaScript expressions.\n    function parseExpressionAt(input, pos, options) {\n        return Parser.parseExpressionAt(input, pos, options);\n    }\n    // Acorn is organized as a tokenizer and a recursive-descent parser.\n    // The `tokenizer` export provides an interface to the tokenizer.\n    function tokenizer(input, options) {\n        return Parser.tokenizer(input, options);\n    }\n    exports1.Node = Node;\n    exports1.Parser = Parser;\n    exports1.Position = Position;\n    exports1.SourceLocation = SourceLocation;\n    exports1.TokContext = TokContext;\n    exports1.Token = Token;\n    exports1.TokenType = TokenType;\n    exports1.defaultOptions = defaultOptions;\n    exports1.getLineInfo = getLineInfo;\n    exports1.isIdentifierChar = isIdentifierChar;\n    exports1.isIdentifierStart = isIdentifierStart;\n    exports1.isNewLine = isNewLine;\n    exports1.keywordTypes = keywords;\n    exports1.lineBreak = lineBreak;\n    exports1.lineBreakG = lineBreakG;\n    exports1.nonASCIIwhitespace = nonASCIIwhitespace;\n    exports1.parse = parse;\n    exports1.parseExpressionAt = parseExpressionAt;\n    exports1.tokContexts = types;\n    exports1.tokTypes = types$1;\n    exports1.tokenizer = tokenizer;\n    exports1.version = version;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFVQSxNQUFNLEVBQUVDLE9BQU87SUFDeEIsS0FBaUQsR0FBY0EsUUFBUUMsV0FDdkUsQ0FDcUc7QUFDdkcsR0FBRyxJQUFJLEVBQUcsU0FBVUEsUUFBTztJQUFJO0lBRTdCLG1EQUFtRDtJQUNuRCxJQUFJTyx3QkFBd0I7UUFBQztRQUFLO1FBQUc7UUFBSztRQUFHO1FBQUs7UUFBRztRQUFLO1FBQUc7UUFBTTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUs7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFNO1FBQUc7UUFBRztRQUFJO1FBQU87UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBTTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFPO1FBQUc7UUFBTTtRQUFJO1FBQUc7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBRztRQUFNO1FBQUk7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBTTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUc7UUFBSztRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUc7UUFBSTtRQUFJO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFNO1FBQUc7UUFBUTtLQUFJO0lBRTVoQyxtREFBbUQ7SUFDbkQsSUFBSUMsNkJBQTZCO1FBQUM7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFJO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSztRQUFHO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQU07UUFBSTtRQUFJO1FBQU07UUFBSTtRQUFHO1FBQU07UUFBSztRQUFNO1FBQUs7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFJO1FBQUs7UUFBSTtRQUFLO1FBQUk7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBTTtRQUFHO1FBQU07UUFBSTtRQUFHO1FBQU07UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFLO1FBQU07UUFBSztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFNO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBRztRQUFNO1FBQUk7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFJO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBTTtRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBTTtRQUFPO1FBQUk7UUFBTTtRQUFHO1FBQUs7UUFBRztRQUFNO1FBQUk7UUFBTTtRQUFNO1FBQUs7UUFBTTtRQUFNO1FBQUc7S0FBSztJQUVoaEUsbURB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QVFtUyxTQUFTLEdBQUdBO0lBQ3BCblMsU0FBUTA1QixPQUFPLEdBQUdBO0FBRXBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3ZlcnJlYWN0ZWQvLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5qcz84NmMwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuYWNvcm4gPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbiAgdmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksIDAsIDIyNywgMCwgMTUwLCA0LCAyOTQsIDksIDEzNjgsIDIsIDIsIDEsIDYsIDMsIDQxLCAyLCA1LCAwLCAxNjYsIDEsIDU3NCwgMywgOSwgOSwgMzcwLCAxLCA4MSwgMiwgNzEsIDEwLCA1MCwgMywgMTIzLCAyLCA1NCwgMTQsIDMyLCAxMCwgMywgMSwgMTEsIDMsIDQ2LCAxMCwgOCwgMCwgNDYsIDksIDcsIDIsIDM3LCAxMywgMiwgOSwgNiwgMSwgNDUsIDAsIDEzLCAyLCA0OSwgMTMsIDksIDMsIDIsIDExLCA4MywgMTEsIDcsIDAsIDMsIDAsIDE1OCwgMTEsIDYsIDksIDcsIDMsIDU2LCAxLCAyLCA2LCAzLCAxLCAzLCAyLCAxMCwgMCwgMTEsIDEsIDMsIDYsIDQsIDQsIDE5MywgMTcsIDEwLCA5LCA1LCAwLCA4MiwgMTksIDEzLCA5LCAyMTQsIDYsIDMsIDgsIDI4LCAxLCA4MywgMTYsIDE2LCA5LCA4MiwgMTIsIDksIDksIDg0LCAxNCwgNSwgOSwgMjQzLCAxNCwgMTY2LCA5LCA3MSwgNSwgMiwgMSwgMywgMywgMiwgMCwgMiwgMSwgMTMsIDksIDEyMCwgNiwgMywgNiwgNCwgMCwgMjksIDksIDQxLCA2LCAyLCAzLCA5LCAwLCAxMCwgMTAsIDQ3LCAxNSwgNDA2LCA3LCAyLCA3LCAxNywgOSwgNTcsIDIxLCAyLCAxMywgMTIzLCA1LCA0LCAwLCAyLCAxLCAyLCA2LCAyLCAwLCA5LCA5LCA0OSwgNCwgMiwgMSwgMiwgNCwgOSwgOSwgMzMwLCAzLCAxMCwgMSwgMiwgMCwgNDksIDYsIDQsIDQsIDE0LCA5LCA1MzUxLCAwLCA3LCAxNCwgMTM4MzUsIDksIDg3LCA5LCAzOSwgNCwgNjAsIDYsIDI2LCA5LCAxMDE0LCAwLCAyLCA1NCwgOCwgMywgODIsIDAsIDEyLCAxLCAxOTYyOCwgMSwgNDcwNiwgNDUsIDMsIDIyLCA1NDMsIDQsIDQsIDUsIDksIDcsIDMsIDYsIDMxLCAzLCAxNDksIDIsIDE0MTgsIDQ5LCA1MTMsIDU0LCA1LCA0OSwgOSwgMCwgMTUsIDAsIDIzLCA0LCAyLCAxNCwgMTM2MSwgNiwgMiwgMTYsIDMsIDYsIDIsIDEsIDIsIDQsIDEwMSwgMCwgMTYxLCA2LCAxMCwgOSwgMzU3LCAwLCA2MiwgMTMsIDQ5OSwgMTMsIDk4MywgNiwgMTEwLCA2LCA2LCA5LCA0NzU5LCA5LCA3ODc3MTksIDIzOV07XG5cbiAgLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLCAxMSwgMiwgMjUsIDIsIDE4LCAyLCAxLCAyLCAxNCwgMywgMTMsIDM1LCAxMjIsIDcwLCA1MiwgMjY4LCAyOCwgNCwgNDgsIDQ4LCAzMSwgMTQsIDI5LCA2LCAzNywgMTEsIDI5LCAzLCAzNSwgNSwgNywgMiwgNCwgNDMsIDE1NywgMTksIDM1LCA1LCAzNSwgNSwgMzksIDksIDUxLCAxMywgMTAsIDIsIDE0LCAyLCA2LCAyLCAxLCAyLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDY4LCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyOCwgNDMsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCAxNCwgMzUsIDM0OSwgNDEsIDcsIDEsIDc5LCAyOCwgMTEsIDAsIDksIDIxLCA0MywgMTcsIDQ3LCAyMCwgMjgsIDIyLCAxMywgNTIsIDU4LCAxLCAzLCAwLCAxNCwgNDQsIDMzLCAyNCwgMjcsIDM1LCAzMCwgMCwgMywgMCwgOSwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCAyMCwgMSwgNjQsIDYsIDIsIDAsIDIsIDMsIDIsIDE0LCAyLCA5LCA4LCA0NiwgMzksIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCA0LCAwLCAxOSwgMCwgMTMsIDQsIDE1OSwgNTIsIDE5LCAzLCAyMSwgMiwgMzEsIDQ3LCAyMSwgMSwgMiwgMCwgMTg1LCA0NiwgNDIsIDMsIDM3LCA0NywgMjEsIDAsIDYwLCA0MiwgMTQsIDAsIDcyLCAyNiwgMzgsIDYsIDE4NiwgNDMsIDExNywgNjMsIDMyLCA3LCAzLCAwLCAzLCA3LCAyLCAxLCAyLCAyMywgMTYsIDAsIDIsIDAsIDk1LCA3LCAzLCAzOCwgMTcsIDAsIDIsIDAsIDI5LCAwLCAxMSwgMzksIDgsIDAsIDIyLCAwLCAxMiwgNDUsIDIwLCAwLCAxOSwgNzIsIDI2NCwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDExMywgNiwgMiwgMSwgMiwgMzcsIDIyLCAwLCAyNiwgNSwgMiwgMSwgMiwgMzEsIDE1LCAwLCAzMjgsIDE4LCAxNiwgMCwgMiwgMTIsIDIsIDMzLCAxMjUsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNjM3LCA5NiwgMTYsIDEwNzEsIDE4LCA1LCA0MDI2LCA1ODIsIDg2MzQsIDU2OCwgOCwgMzAsIDE4LCA3OCwgMTgsIDI5LCAxOSwgNDcsIDE3LCAzLCAzMiwgMjAsIDYsIDE4LCA2ODksIDYzLCAxMjksIDc0LCA2LCAwLCA2NywgMTIsIDY1LCAxLCAyLCAwLCAyOSwgNjEzNSwgOSwgMTIzNywgNDMsIDgsIDg5MzYsIDMsIDIsIDYsIDIsIDEsIDIsIDI5MCwgMTYsIDAsIDMwLCAyLCAzLCAwLCAxNSwgMywgOSwgMzk1LCAyMzA5LCAxMDYsIDYsIDEyLCA0LCA4LCA4LCA5LCA1OTkxLCA4NCwgMiwgNzAsIDIsIDEsIDMsIDAsIDMsIDEsIDMsIDMsIDIsIDExLCAyLCAwLCAyLCA2LCAyLCA2NCwgMiwgMywgMywgNywgMiwgNiwgMiwgMjcsIDIsIDMsIDIsIDQsIDIsIDAsIDQsIDYsIDIsIDMzOSwgMywgMjQsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDcsIDE4NDUsIDMwLCA3LCA1LCAyNjIsIDYxLCAxNDcsIDQ0LCAxMSwgNiwgMTcsIDAsIDMyMiwgMjksIDE5LCA0MywgNDg1LCAyNywgNzU3LCA2LCAyLCAzLCAyLCAxLCAyLCAxNCwgMiwgMTk2LCA2MCwgNjcsIDgsIDAsIDEyMDUsIDMsIDIsIDI2LCAyLCAxLCAyLCAwLCAzLCAwLCAyLCA5LCAyLCAzLCAyLCAwLCAyLCAwLCA3LCAwLCA1LCAwLCAyLCAwLCAyLCAwLCAyLCAyLCAyLCAxLCAyLCAwLCAzLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAxLCAyLCAwLCAzLCAzLCAyLCA2LCAyLCAzLCAyLCAzLCAyLCAwLCAyLCA5LCAyLCAxNiwgNiwgMiwgMiwgNCwgMiwgMTYsIDQ0MjEsIDQyNzE5LCAzMywgNDE1MywgNywgMjIxLCAzLCA1NzYxLCAxNSwgNzQ3MiwgMzEwNCwgNTQxLCAxNTA3LCA0OTM4LCA2LCA0MTkxXTtcblxuICAvLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5OC1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjNcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZVxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhY2VcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuXG4gIC8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkLiBEbyBub3QgbW9kaWZ5IG1hbnVhbGx5IVxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwODcwLVxcdTA4ODdcXHUwODg5LVxcdTA4OGVcXHUwOGEwLVxcdTA4YzlcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM1ZFxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA0LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNTQtXFx1MGQ1NlxcdTBkNWYtXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODYtXFx1MGU4YVxcdTBlOGMtXFx1MGVhM1xcdTBlYTVcXHUwZWE3LVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNVxcdTEzZjgtXFx1MTNmZFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmOFxcdTE3MDAtXFx1MTcxMVxcdTE3MWYtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxZVxcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGNcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjODAtXFx1MWM4OFxcdTFjOTAtXFx1MWNiYVxcdTFjYmQtXFx1MWNiZlxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmM1xcdTFjZjVcXHUxY2Y2XFx1MWNmYVxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWItXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZlxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiZlxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiZlxcdTRlMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjlkXFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhN2NhXFx1YTdkMFxcdWE3ZDFcXHVhN2QzXFx1YTdkNS1cXHVhN2Q5XFx1YTdmMi1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE4ZmRcXHVhOGZlXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWE5ZTAtXFx1YTllNFxcdWE5ZTYtXFx1YTllZlxcdWE5ZmEtXFx1YTlmZVxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTdlLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiMzAtXFx1YWI1YVxcdWFiNWMtXFx1YWI2OVxcdWFiNzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xuXG4gIC8vIFRoZXNlIGFyZSBhIHJ1bi1sZW5ndGggYW5kIG9mZnNldCBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAvLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4gIC8vIG9mZnNldCBzdGFydHMgYXQgMHgxMDAwMCwgYW5kIGVhY2ggcGFpciBvZiBudW1iZXJzIHJlcHJlc2VudHMgYW5cbiAgLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IHJhbmdlLCBhbmQgdGhlbiBhIHNpemUgb2YgdGhlIHJhbmdlLlxuXG4gIC8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbiAgdmFyIHJlc2VydmVkV29yZHMgPSB7XG4gICAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gICAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IFwiZW51bVwiLFxuICAgIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gICAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG4gIH07XG5cbiAgLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG4gIHZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbiAgdmFyIGtleXdvcmRzJDEgPSB7XG4gICAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gICAgXCI1bW9kdWxlXCI6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHN1cGVyXCJcbiAgfTtcblxuICB2YXIga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9eaW4oc3RhbmNlb2YpPyQvO1xuXG4gIC8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG4gIC8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbiAgLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuICAvLyByYXJlLlxuICBmdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICAgIHZhciBwb3MgPSAweDEwMDAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBwb3MgKz0gc2V0W2ldO1xuICAgICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgICAgaWYgKHBvcyA+PSBjb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlLCBhc3RyYWwpIHtcbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKVxuICB9XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUsIGFzdHJhbCkge1xuICAgIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgICBpZiAoY29kZSA8IDU4KSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gICAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpXG4gIH1cblxuICAvLyAjIyBUb2tlbiB0eXBlc1xuXG4gIC8vIFRoZSBhc3NpZ25tZW50IG9mIGZpbmUtZ3JhaW5lZCwgaW5mb3JtYXRpb24tY2FycnlpbmcgdHlwZSBvYmplY3RzXG4gIC8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuICAvLyB0b2tlbiBpbiBhIHdheSB0aGF0IGlzIHZlcnkgY2hlYXAgZm9yIHRoZSBwYXJzZXIgdG8gbG9vayB1cC5cblxuICAvLyBBbGwgdG9rZW4gdHlwZSB2YXJpYWJsZXMgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlLCB0byBtYWtlIHRoZW1cbiAgLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbiAgLy8gVGhlIGBiZWZvcmVFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuIHJlZ3VsYXJcbiAgLy8gZXhwcmVzc2lvbnMgYW5kIGRpdmlzaW9ucy4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGNhblxuICAvLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuICAvLyByZWd1bGFyIGV4cHJlc3Npb24pLlxuICAvL1xuICAvLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuICAvLyBgeWllbGRgIGV4cHJlc3Npb24uIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBlaXRoZXIgY2FuXG4gIC8vIGRpcmVjdGx5IHN0YXJ0IGFuIGV4cHJlc3Npb24gKGxpa2UgYSBxdW90YXRpb24gbWFyaykgb3IgY2FuXG4gIC8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuICAvL1xuICAvLyBgaXNMb29wYCBtYXJrcyBhIGtleXdvcmQgYXMgc3RhcnRpbmcgYSBsb29wLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbiAgLy8gY29udGludWUganVtcHMgdG8gdGhhdCBsYWJlbC5cblxuICB2YXIgVG9rZW5UeXBlID0gZnVuY3Rpb24gVG9rZW5UeXBlKGxhYmVsLCBjb25mKSB7XG4gICAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICAgIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICAgIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICAgIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICAgIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICAgIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICAgIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogcHJlY30pXG4gIH1cbiAgdmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cbiAgLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbiAgdmFyIGtleXdvcmRzID0ge307XG5cbiAgLy8gU3VjY2luY3QgZGVmaW5pdGlvbnMgb2Yga2V5d29yZCB0b2tlbiB0eXBlc1xuICBmdW5jdGlvbiBrdyhuYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuICAgIHJldHVybiBrZXl3b3Jkc1tuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciB0eXBlcyQxID0ge1xuICAgIG51bTogbmV3IFRva2VuVHlwZShcIm51bVwiLCBzdGFydHNFeHByKSxcbiAgICByZWdleHA6IG5ldyBUb2tlblR5cGUoXCJyZWdleHBcIiwgc3RhcnRzRXhwciksXG4gICAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHN0YXJ0c0V4cHIpLFxuICAgIG5hbWU6IG5ldyBUb2tlblR5cGUoXCJuYW1lXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHByaXZhdGVJZDogbmV3IFRva2VuVHlwZShcInByaXZhdGVJZFwiLCBzdGFydHNFeHByKSxcbiAgICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgICAvLyBQdW5jdHVhdGlvbiB0b2tlbiB0eXBlcy5cbiAgICBicmFja2V0TDogbmV3IFRva2VuVHlwZShcIltcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gICAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGJyYWNlUjogbmV3IFRva2VuVHlwZShcIn1cIiksXG4gICAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gICAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIGJlZm9yZUV4cHIpLFxuICAgIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICAgIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICAgIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgICBxdWVzdGlvbkRvdDogbmV3IFRva2VuVHlwZShcIj8uXCIpLFxuICAgIGFycm93OiBuZXcgVG9rZW5UeXBlKFwiPT5cIiwgYmVmb3JlRXhwciksXG4gICAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgICBpbnZhbGlkVGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJpbnZhbGlkVGVtcGxhdGVcIiksXG4gICAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgYmVmb3JlRXhwciksXG4gICAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG4gICAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gICAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gICAgLy9cbiAgICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgICAvLyBvcGVyYXRvciwgYW5kIHdpbGwgcmVmZXIgdG8gaXRzIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgICAvLyB1bmFyeSBvcGVyYXRvci5cbiAgICAvL1xuICAgIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gICAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gICAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwge3ByZWZpeDogdHJ1ZSwgcG9zdGZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHByZWZpeDogbmV3IFRva2VuVHlwZShcIiEvflwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICAgIGxvZ2ljYWxBTkQ6IGJpbm9wKFwiJiZcIiwgMiksXG4gICAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gICAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICAgIGJpdHdpc2VBTkQ6IGJpbm9wKFwiJlwiLCA1KSxcbiAgICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPS89PT0vIT09XCIsIDYpLFxuICAgIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICAgIGJpdFNoaWZ0OiBiaW5vcChcIjw8Lz4+Lz4+PlwiLCA4KSxcbiAgICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICAgIHN0YXI6IGJpbm9wKFwiKlwiLCAxMCksXG4gICAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gICAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuICAgIGNvYWxlc2NlOiBiaW5vcChcIj8/XCIsIDEpLFxuXG4gICAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgICBfYnJlYWs6IGt3KFwiYnJlYWtcIiksXG4gICAgX2Nhc2U6IGt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKSxcbiAgICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gICAgX2NvbnRpbnVlOiBrdyhcImNvbnRpbnVlXCIpLFxuICAgIF9kZWJ1Z2dlcjoga3coXCJkZWJ1Z2dlclwiKSxcbiAgICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICAgIF9kbzoga3coXCJkb1wiLCB7aXNMb29wOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSksXG4gICAgX2Vsc2U6IGt3KFwiZWxzZVwiLCBiZWZvcmVFeHByKSxcbiAgICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICAgIF9mb3I6IGt3KFwiZm9yXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgICBfZnVuY3Rpb246IGt3KFwiZnVuY3Rpb25cIiwgc3RhcnRzRXhwciksXG4gICAgX2lmOiBrdyhcImlmXCIpLFxuICAgIF9yZXR1cm46IGt3KFwicmV0dXJuXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9zd2l0Y2g6IGt3KFwic3dpdGNoXCIpLFxuICAgIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgICBfdHJ5OiBrdyhcInRyeVwiKSxcbiAgICBfdmFyOiBrdyhcInZhclwiKSxcbiAgICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gICAgX3doaWxlOiBrdyhcIndoaWxlXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgICBfd2l0aDoga3coXCJ3aXRoXCIpLFxuICAgIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX3RoaXM6IGt3KFwidGhpc1wiLCBzdGFydHNFeHByKSxcbiAgICBfc3VwZXI6IGt3KFwic3VwZXJcIiwgc3RhcnRzRXhwciksXG4gICAgX2NsYXNzOiBrdyhcImNsYXNzXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9leHRlbmRzOiBrdyhcImV4dGVuZHNcIiwgYmVmb3JlRXhwciksXG4gICAgX2V4cG9ydDoga3coXCJleHBvcnRcIiksXG4gICAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiwgc3RhcnRzRXhwciksXG4gICAgX251bGw6IGt3KFwibnVsbFwiLCBzdGFydHNFeHByKSxcbiAgICBfdHJ1ZToga3coXCJ0cnVlXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgICBfaW46IGt3KFwiaW5cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gICAgX2luc3RhbmNlb2Y6IGt3KFwiaW5zdGFuY2VvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX3ZvaWQ6IGt3KFwidm9pZFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX2RlbGV0ZToga3coXCJkZWxldGVcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pXG4gIH07XG5cbiAgLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuICAvLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuICB2YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG4gIHZhciBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5cbiAgZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT09IDB4MjAyOVxuICB9XG5cbiAgZnVuY3Rpb24gbmV4dExpbmVCcmVhayhjb2RlLCBmcm9tLCBlbmQpIHtcbiAgICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gY29kZS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGNvZGUuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChpc05ld0xpbmUobmV4dCkpXG4gICAgICAgIHsgcmV0dXJuIGkgPCBlbmQgLSAxICYmIG5leHQgPT09IDEzICYmIGNvZGUuY2hhckNvZGVBdChpICsgMSkgPT09IDEwID8gaSArIDIgOiBpICsgMSB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLztcblxuICB2YXIgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcblxuICB2YXIgcmVmID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gcmVmLmhhc093blByb3BlcnR5O1xuICB2YXIgdG9TdHJpbmcgPSByZWYudG9TdHJpbmc7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5oYXNPd24gfHwgKGZ1bmN0aW9uIChvYmosIHByb3BOYW1lKSB7IHJldHVybiAoXG4gICAgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BOYW1lKVxuICApOyB9KTtcblxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChcbiAgICB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIlxuICApOyB9KTtcblxuICBmdW5jdGlvbiB3b3Jkc1JlZ2V4cCh3b3Jkcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMucmVwbGFjZSgvIC9nLCBcInxcIikgKyBcIikkXCIpXG4gIH1cblxuICBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjb2RlKSB7XG4gICAgLy8gVVRGLTE2IERlY29kaW5nXG4gICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhEODAwLCAoY29kZSAmIDEwMjMpICsgMHhEQzAwKVxuICB9XG5cbiAgdmFyIGxvbmVTdXJyb2dhdGUgPSAvKD86W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pLztcblxuICAvLyBUaGVzZSBhcmUgdXNlZCB3aGVuIGBvcHRpb25zLmxvY2F0aW9uc2AgaXMgb24sIGZvciB0aGVcbiAgLy8gYHN0YXJ0TG9jYCBhbmQgYGVuZExvY2AgcHJvcGVydGllcy5cblxuICB2YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sO1xuICB9O1xuXG4gIFBvc2l0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQgKG4pIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxuICB9O1xuXG4gIHZhciBTb3VyY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHAsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgaWYgKHAuc291cmNlRmlsZSAhPT0gbnVsbCkgeyB0aGlzLnNvdXJjZSA9IHAuc291cmNlRmlsZTsgfVxuICB9O1xuXG4gIC8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbiAgLy8gYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9mZiAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpIGFuZCB5b3VcbiAgLy8gd2FudCB0byBmaW5kIHRoZSBsaW5lL2NvbHVtbiBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbiAgLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuICAvLyBpbnRvLlxuXG4gIGZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgICB2YXIgbmV4dEJyZWFrID0gbmV4dExpbmVCcmVhayhpbnB1dCwgY3VyLCBvZmZzZXQpO1xuICAgICAgaWYgKG5leHRCcmVhayA8IDApIHsgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBjdXIpIH1cbiAgICAgICsrbGluZTtcbiAgICAgIGN1ciA9IG5leHRCcmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBBIHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGdpdmVuIHRvIGNvbmZpZ3VyZSB0aGUgcGFyc2VyIHByb2Nlc3MuXG4gIC8vIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQgKG9ubHkgYGVjbWFWZXJzaW9uYCBpcyByZXF1aXJlZCk6XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8vIGBlY21hVmVyc2lvbmAgaW5kaWNhdGVzIHRoZSBFQ01BU2NyaXB0IHZlcnNpb24gdG8gcGFyc2UuIE11c3QgYmVcbiAgICAvLyBlaXRoZXIgMywgNSwgNiAob3IgMjAxNSksIDcgKDIwMTYpLCA4ICgyMDE3KSwgOSAoMjAxOCksIDEwXG4gICAgLy8gKDIwMTkpLCAxMSAoMjAyMCksIDEyICgyMDIxKSwgMTMgKDIwMjIpLCAxNCAoMjAyMyksIG9yIGBcImxhdGVzdFwiYFxuICAgIC8vICh0aGUgbGF0ZXN0IHZlcnNpb24gdGhlIGxpYnJhcnkgc3VwcG9ydHMpLiBUaGlzIGluZmx1ZW5jZXNcbiAgICAvLyBzdXBwb3J0IGZvciBzdHJpY3QgbW9kZSwgdGhlIHNldCBvZiByZXNlcnZlZCB3b3JkcywgYW5kIHN1cHBvcnRcbiAgICAvLyBmb3IgbmV3IHN5bnRheCBmZWF0dXJlcy5cbiAgICBlY21hVmVyc2lvbjogbnVsbCxcbiAgICAvLyBgc291cmNlVHlwZWAgaW5kaWNhdGVzIHRoZSBtb2RlIHRoZSBjb2RlIHNob3VsZCBiZSBwYXJzZWQgaW4uXG4gICAgLy8gQ2FuIGJlIGVpdGhlciBgXCJzY3JpcHRcImAgb3IgYFwibW9kdWxlXCJgLiBUaGlzIGluZmx1ZW5jZXMgZ2xvYmFsXG4gICAgLy8gc3RyaWN0IG1vZGUgYW5kIHBhcnNpbmcgb2YgYGltcG9ydGAgYW5kIGBleHBvcnRgIGRlY2xhcmF0aW9ucy5cbiAgICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAgIC8vIGBvbkluc2VydGVkU2VtaWNvbG9uYCBjYW4gYmUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gICAgLy8gd2hlbiBhIHNlbWljb2xvbiBpcyBhdXRvbWF0aWNhbGx5IGluc2VydGVkLiBJdCB3aWxsIGJlIHBhc3NlZFxuICAgIC8vIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29tbWEgYXMgYW4gb2Zmc2V0LCBhbmQgaWYgYGxvY2F0aW9uc2AgaXNcbiAgICAvLyBlbmFibGVkLCBpdCBpcyBnaXZlbiB0aGUgbG9jYXRpb24gYXMgYSBge2xpbmUsIGNvbHVtbn1gIG9iamVjdFxuICAgIC8vIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgICBvbkluc2VydGVkU2VtaWNvbG9uOiBudWxsLFxuICAgIC8vIGBvblRyYWlsaW5nQ29tbWFgIGlzIHNpbWlsYXIgdG8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gLCBidXQgZm9yXG4gICAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICAgIG9uVHJhaWxpbmdDb21tYTogbnVsbCxcbiAgICAvLyBCeSBkZWZhdWx0LCByZXNlcnZlZCB3b3JkcyBhcmUgb25seSBlbmZvcmNlZCBpZiBlY21hVmVyc2lvbiA+PSA1LlxuICAgIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gICAgLy8gYW4gb2ZmLiBXaGVuIHRoaXMgb3B0aW9uIGhhcyB0aGUgdmFsdWUgXCJuZXZlclwiLCByZXNlcnZlZCB3b3Jkc1xuICAgIC8vIGFuZCBrZXl3b3JkcyBjYW4gYWxzbyBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eSBuYW1lcy5cbiAgICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgYSByZXR1cm4gYXQgdGhlIHRvcCBsZXZlbCBpcyBub3QgY29uc2lkZXJlZCBhblxuICAgIC8vIGVycm9yLlxuICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIGltcG9ydC9leHBvcnQgc3RhdGVtZW50cyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gICAgLy8gYXBwZWFyaW5nIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW0sIGFuZCBhbiBpbXBvcnQubWV0YSBleHByZXNzaW9uXG4gICAgLy8gaW4gYSBzY3JpcHQgaXNuJ3QgY29uc2lkZXJlZCBhbiBlcnJvci5cbiAgICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IGZhbHNlLFxuICAgIC8vIEJ5IGRlZmF1bHQsIGF3YWl0IGlkZW50aWZpZXJzIGFyZSBhbGxvd2VkIHRvIGFwcGVhciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlIG9ubHkgaWYgZWNtYVZlcnNpb24gPj0gMjAyMi5cbiAgICAvLyBXaGVuIGVuYWJsZWQsIGF3YWl0IGlkZW50aWZpZXJzIGFyZSBhbGxvd2VkIHRvIGFwcGVhciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlLFxuICAgIC8vIGJ1dCB0aGV5IGFyZSBzdGlsbCBub3QgYWxsb3dlZCBpbiBub24tYXN5bmMgZnVuY3Rpb25zLlxuICAgIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IG51bGwsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBzdXBlciBpZGVudGlmaWVycyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gICAgLy8gYXBwZWFyaW5nIGluIG1ldGhvZHMgYW5kIGRvIG5vdCByYWlzZSBhbiBlcnJvciB3aGVuIHRoZXkgYXBwZWFyIGVsc2V3aGVyZS5cbiAgICBhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZDogbnVsbCxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIGhhc2hiYW5nIGRpcmVjdGl2ZSBpbiB0aGUgYmVnaW5uaW5nIG9mIGZpbGUgaXNcbiAgICAvLyBhbGxvd2VkIGFuZCB0cmVhdGVkIGFzIGEgbGluZSBjb21tZW50LiBFbmFibGVkIGJ5IGRlZmF1bHQgd2hlblxuICAgIC8vIGBlY21hVmVyc2lvbmAgPj0gMjAyMy5cbiAgICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgICAvLyBCeSBkZWZhdWx0LCB0aGUgcGFyc2VyIHdpbGwgdmVyaWZ5IHRoYXQgcHJpdmF0ZSBwcm9wZXJ0aWVzIGFyZVxuICAgIC8vIG9ubHkgdXNlZCBpbiBwbGFjZXMgd2hlcmUgdGhleSBhcmUgdmFsaWQgYW5kIGhhdmUgYmVlbiBkZWNsYXJlZC5cbiAgICAvLyBTZXQgdGhpcyB0byBmYWxzZSB0byB0dXJuIHN1Y2ggY2hlY2tzIG9mZi5cbiAgICBjaGVja1ByaXZhdGVGaWVsZHM6IHRydWUsXG4gICAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgYGxvY2AgcHJvcGVydGllcyBob2xkaW5nIG9iamVjdHMgd2l0aFxuICAgIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gICAgLy8gbGluZSBiZWluZyAxLWJhc2VkIGFuZCBjb2x1bW4gMC1iYXNlZCkgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGVcbiAgICAvLyBub2Rlcy5cbiAgICBsb2NhdGlvbnM6IGZhbHNlLFxuICAgIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Ub2tlbmAgb3B0aW9uLCB3aGljaCB3aWxsXG4gICAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggb2JqZWN0IGluIHRoZSBzYW1lXG4gICAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAgIC8vIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZSBwYXJzZXIgZnJvbSB0aGVcbiAgICAvLyBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgICBvblRva2VuOiBudWxsLFxuICAgIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Db21tZW50YCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBgKGJsb2NrLCB0ZXh0LCBzdGFydCxcbiAgICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgICAvLyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGlzIGEgYmxvY2sgKGAvKiAqL2ApIGNvbW1lbnQsXG4gICAgLy8gYHRleHRgIGlzIHRoZSBjb250ZW50IG9mIHRoZSBjb21tZW50LCBhbmQgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlXG4gICAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gICAgLy8gV2hlbiB0aGUgYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9uLCB0d28gbW9yZSBwYXJhbWV0ZXJzIGFyZVxuICAgIC8vIHBhc3NlZCwgdGhlIGZ1bGwgYHtsaW5lLCBjb2x1bW59YCBsb2NhdGlvbnMgb2YgdGhlIHN0YXJ0IGFuZFxuICAgIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gICAgLy8gcGFyc2VyIGZyb20gdGhlIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICAgIG9uQ29tbWVudDogbnVsbCxcbiAgICAvLyBOb2RlcyBoYXZlIHRoZWlyIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVycyBvZmZzZXRzIHJlY29yZGVkIGluXG4gICAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyAoZGlyZWN0bHkgb24gdGhlIG5vZGUsIHJhdGhlciB0aGFuXG4gICAgLy8gdGhlIGBsb2NgIG9iamVjdCwgd2hpY2ggaG9sZHMgbGluZS9jb2x1bW4gZGF0YS4gVG8gYWxzbyBhZGQgYVxuICAgIC8vIFtzZW1pLXN0YW5kYXJkaXplZF1bcmFuZ2VdIGByYW5nZWAgcHJvcGVydHkgaG9sZGluZyBhIGBbc3RhcnQsXG4gICAgLy8gZW5kXWAgYXJyYXkgd2l0aCB0aGUgc2FtZSBudW1iZXJzLCBzZXQgdGhlIGByYW5nZXNgIG9wdGlvbiB0b1xuICAgIC8vIGB0cnVlYC5cbiAgICAvL1xuICAgIC8vIFtyYW5nZV06IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc0NTY3OFxuICAgIHJhbmdlczogZmFsc2UsXG4gICAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGFyc2UgbXVsdGlwbGUgZmlsZXMgaW50byBhIHNpbmdsZSBBU1QgYnlcbiAgICAvLyBwYXNzaW5nIHRoZSB0cmVlIHByb2R1Y2VkIGJ5IHBhcnNpbmcgdGhlIGZpcnN0IGZpbGUgYXNcbiAgICAvLyBgcHJvZ3JhbWAgb3B0aW9uIGluIHN1YnNlcXVlbnQgcGFyc2VzLiBUaGlzIHdpbGwgYWRkIHRoZVxuICAgIC8vIHRvcGxldmVsIGZvcm1zIG9mIHRoZSBwYXJzZWQgZmlsZSB0byB0aGUgYFByb2dyYW1gICh0b3ApIG5vZGVcbiAgICAvLyBvZiBhbiBleGlzdGluZyBwYXJzZSB0cmVlLlxuICAgIHByb2dyYW06IG51bGwsXG4gICAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgeW91IGNhbiBwYXNzIHRoaXMgdG8gcmVjb3JkIHRoZSBzb3VyY2VcbiAgICAvLyBmaWxlIGluIGV2ZXJ5IG5vZGUncyBgbG9jYCBvYmplY3QuXG4gICAgc291cmNlRmlsZTogbnVsbCxcbiAgICAvLyBUaGlzIHZhbHVlLCBpZiBnaXZlbiwgaXMgc3RvcmVkIGluIGV2ZXJ5IG5vZGUsIHdoZXRoZXJcbiAgICAvLyBgbG9jYXRpb25zYCBpcyBvbiBvciBvZmYuXG4gICAgZGlyZWN0U291cmNlRmlsZTogbnVsbCxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbnMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gICAgLy8gKG5vbi1zdGFuZGFyZCkgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gbm9kZXNcbiAgICBwcmVzZXJ2ZVBhcmVuczogZmFsc2VcbiAgfTtcblxuICAvLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxuICB2YXIgd2FybmVkQWJvdXRFY21hVmVyc2lvbiA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpXG4gICAgICB7IG9wdGlvbnNbb3B0XSA9IG9wdHMgJiYgaGFzT3duKG9wdHMsIG9wdCkgPyBvcHRzW29wdF0gOiBkZWZhdWx0T3B0aW9uc1tvcHRdOyB9XG5cbiAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gXCJsYXRlc3RcIikge1xuICAgICAgb3B0aW9ucy5lY21hVmVyc2lvbiA9IDFlODtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgaWYgKCF3YXJuZWRBYm91dEVjbWFWZXJzaW9uICYmIHR5cGVvZiBjb25zb2xlID09PSBcIm9iamVjdFwiICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICB3YXJuZWRBYm91dEVjbWFWZXJzaW9uID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS53YXJuKFwiU2luY2UgQWNvcm4gOC4wLjAsIG9wdGlvbnMuZWNtYVZlcnNpb24gaXMgcmVxdWlyZWQuXFxuRGVmYXVsdGluZyB0byAyMDIwLCBidXQgdGhpcyB3aWxsIHN0b3Agd29ya2luZyBpbiB0aGUgZnV0dXJlLlwiKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuZWNtYVZlcnNpb24gPSAxMTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMjAxNSkge1xuICAgICAgb3B0aW9ucy5lY21hVmVyc2lvbiAtPSAyMDA5O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gbnVsbClcbiAgICAgIHsgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID0gb3B0aW9ucy5lY21hVmVyc2lvbiA8IDU7IH1cblxuICAgIGlmICghb3B0cyB8fCBvcHRzLmFsbG93SGFzaEJhbmcgPT0gbnVsbClcbiAgICAgIHsgb3B0aW9ucy5hbGxvd0hhc2hCYW5nID0gb3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNDsgfVxuXG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgICAgdmFyIHRva2VucyA9IG9wdGlvbnMub25Ub2tlbjtcbiAgICAgIG9wdGlvbnMub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW5zLnB1c2godG9rZW4pOyB9O1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShvcHRpb25zLm9uQ29tbWVudCkpXG4gICAgICB7IG9wdGlvbnMub25Db21tZW50ID0gcHVzaENvbW1lbnQob3B0aW9ucywgb3B0aW9ucy5vbkNvbW1lbnQpOyB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaENvbW1lbnQob3B0aW9ucywgYXJyYXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICAgIHZhciBjb21tZW50ID0ge1xuICAgICAgICB0eXBlOiBibG9jayA/IFwiQmxvY2tcIiA6IFwiTGluZVwiLFxuICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucylcbiAgICAgICAgeyBjb21tZW50LmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBzdGFydExvYywgZW5kTG9jKTsgfVxuICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgICB7IGNvbW1lbnQucmFuZ2UgPSBbc3RhcnQsIGVuZF07IH1cbiAgICAgIGFycmF5LnB1c2goY29tbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRWFjaCBzY29wZSBnZXRzIGEgYml0c2V0IHRoYXQgbWF5IGNvbnRhaW4gdGhlc2UgZmxhZ3NcbiAgdmFyXG4gICAgICBTQ09QRV9UT1AgPSAxLFxuICAgICAgU0NPUEVfRlVOQ1RJT04gPSAyLFxuICAgICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgICAgU0NPUEVfR0VORVJBVE9SID0gOCxcbiAgICAgIFNDT1BFX0FSUk9XID0gMTYsXG4gICAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICAgIFNDT1BFX1NVUEVSID0gNjQsXG4gICAgICBTQ09QRV9ESVJFQ1RfU1VQRVIgPSAxMjgsXG4gICAgICBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgPSAyNTYsXG4gICAgICBTQ09QRV9WQVIgPSBTQ09QRV9UT1AgfCBTQ09QRV9GVU5DVElPTiB8IFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSztcblxuICBmdW5jdGlvbiBmdW5jdGlvbkZsYWdzKGFzeW5jLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gU0NPUEVfRlVOQ1RJT04gfCAoYXN5bmMgPyBTQ09QRV9BU1lOQyA6IDApIHwgKGdlbmVyYXRvciA/IFNDT1BFX0dFTkVSQVRPUiA6IDApXG4gIH1cblxuICAvLyBVc2VkIGluIGNoZWNrTFZhbCogYW5kIGRlY2xhcmVOYW1lIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBhIGJpbmRpbmdcbiAgdmFyXG4gICAgICBCSU5EX05PTkUgPSAwLCAvLyBOb3QgYSBiaW5kaW5nXG4gICAgICBCSU5EX1ZBUiA9IDEsIC8vIFZhci1zdHlsZSBiaW5kaW5nXG4gICAgICBCSU5EX0xFWElDQUwgPSAyLCAvLyBMZXQtIG9yIGNvbnN0LXN0eWxlIGJpbmRpbmdcbiAgICAgIEJJTkRfRlVOQ1RJT04gPSAzLCAvLyBGdW5jdGlvbiBkZWNsYXJhdGlvblxuICAgICAgQklORF9TSU1QTEVfQ0FUQ0ggPSA0LCAvLyBTaW1wbGUgKGlkZW50aWZpZXIgcGF0dGVybikgY2F0Y2ggYmluZGluZ1xuICAgICAgQklORF9PVVRTSURFID0gNTsgLy8gU3BlY2lhbCBjYXNlIGZvciBmdW5jdGlvbiBuYW1lcyBhcyBib3VuZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG5cbiAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gICAgdGhpcy5rZXl3b3JkcyA9IHdvcmRzUmVnZXhwKGtleXdvcmRzJDFbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIiA/IFwiNW1vZHVsZVwiIDogNV0pO1xuICAgIHZhciByZXNlcnZlZCA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gdHJ1ZSkge1xuICAgICAgcmVzZXJ2ZWQgPSByZXNlcnZlZFdvcmRzW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLmVjbWFWZXJzaW9uID09PSA1ID8gNSA6IDNdO1xuICAgICAgaWYgKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIikgeyByZXNlcnZlZCArPSBcIiBhd2FpdFwiOyB9XG4gICAgfVxuICAgIHRoaXMucmVzZXJ2ZWRXb3JkcyA9IHdvcmRzUmVnZXhwKHJlc2VydmVkKTtcbiAgICB2YXIgcmVzZXJ2ZWRTdHJpY3QgPSAocmVzZXJ2ZWQgPyByZXNlcnZlZCArIFwiIFwiIDogXCJcIikgKyByZXNlcnZlZFdvcmRzLnN0cmljdDtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCk7XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0ICsgXCIgXCIgKyByZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuICAgIHRoaXMuaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuXG4gICAgLy8gVXNlZCB0byBzaWduYWwgdG8gY2FsbGVycyBvZiBgcmVhZFdvcmQxYCB3aGV0aGVyIHRoZSB3b3JkXG4gICAgLy8gY29udGFpbmVkIGFueSBlc2NhcGUgc2VxdWVuY2VzLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHdvcmRzIHdpdGhcbiAgICAvLyBlc2NhcGUgc2VxdWVuY2VzIG11c3Qgbm90IGJlIGludGVycHJldGVkIGFzIGtleXdvcmRzLlxuICAgIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcblxuICAgIC8vIFNldCB1cCB0b2tlbiBzdGF0ZVxuXG4gICAgLy8gVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHRva2VuaXplciBpbiB0aGUgaW5wdXQuXG4gICAgaWYgKHN0YXJ0UG9zKSB7XG4gICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zO1xuICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHN0YXJ0UG9zIC0gMSkgKyAxO1xuICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pbnB1dC5zbGljZSgwLCB0aGlzLmxpbmVTdGFydCkuc3BsaXQobGluZUJyZWFrKS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9zID0gdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgICAgdGhpcy5jdXJMaW5lID0gMTtcbiAgICB9XG5cbiAgICAvLyBQcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRva2VuOlxuICAgIC8vIEl0cyB0eXBlXG4gICAgdGhpcy50eXBlID0gdHlwZXMkMS5lb2Y7XG4gICAgLy8gRm9yIHRva2VucyB0aGF0IGluY2x1ZGUgbW9yZSBpbmZvcm1hdGlvbiB0aGFuIHRoZWlyIHR5cGUsIHRoZSB2YWx1ZVxuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIC8vIEl0cyBzdGFydCBhbmQgZW5kIG9mZnNldFxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gICAgLy8gY29ycmVzcG9uZGluZyB0byB0aG9zZSBvZmZzZXRzXG4gICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpO1xuXG4gICAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMubGFzdFRva0VuZCA9IHRoaXMucG9zO1xuXG4gICAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAgIC8vIGNvbnRleHQgdG8gcHJlZGljdCB3aGV0aGVyIGEgcmVndWxhciBleHByZXNzaW9uIGlzIGFsbG93ZWQgaW4gYVxuICAgIC8vIGdpdmVuIHBvc2l0aW9uLlxuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcblxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgaXQncyBhIG1vZHVsZSBjb2RlLlxuICAgIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgdGhpcy5zdHJpY3QgPSB0aGlzLmluTW9kdWxlIHx8IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMucG9zKTtcblxuICAgIC8vIFVzZWQgdG8gc2lnbmlmeSB0aGUgc3RhcnQgb2YgYSBwb3RlbnRpYWwgYXJyb3cgZnVuY3Rpb25cbiAgICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcbiAgICB0aGlzLnBvdGVudGlhbEFycm93SW5Gb3JBd2FpdCA9IGZhbHNlO1xuXG4gICAgLy8gUG9zaXRpb25zIHRvIGRlbGF5ZWQtY2hlY2sgdGhhdCB5aWVsZC9hd2FpdCBkb2VzIG5vdCBleGlzdCBpbiBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gICAgdGhpcy55aWVsZFBvcyA9IHRoaXMuYXdhaXRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgIC8vIExhYmVscyBpbiBzY29wZS5cbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIC8vIFRodXMtZmFyIHVuZGVmaW5lZCBleHBvcnRzLlxuICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBJZiBlbmFibGVkLCBza2lwIGxlYWRpbmcgaGFzaGJhbmcgbGluZS5cbiAgICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICAgIHsgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7IH1cblxuICAgIC8vIFNjb3BlIHRyYWNraW5nIGZvciBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMgKHNlZSBzY29wZS5qcylcbiAgICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmVudGVyU2NvcGUoU0NPUEVfVE9QKTtcblxuICAgIC8vIEZvciBSZWdFeHAgdmFsaWRhdGlvblxuICAgIHRoaXMucmVnZXhwU3RhdGUgPSBudWxsO1xuXG4gICAgLy8gVGhlIHN0YWNrIG9mIHByaXZhdGUgbmFtZXMuXG4gICAgLy8gRWFjaCBlbGVtZW50IGhhcyB0d28gcHJvcGVydGllczogJ2RlY2xhcmVkJyBhbmQgJ3VzZWQnLlxuICAgIC8vIFdoZW4gaXQgZXhpdGVkIGZyb20gdGhlIG91dGVybW9zdCBjbGFzcyBkZWZpbml0aW9uLCBhbGwgdXNlZCBwcml2YXRlIG5hbWVzIG11c3QgYmUgZGVjbGFyZWQuXG4gICAgdGhpcy5wcml2YXRlTmFtZVN0YWNrID0gW107XG4gIH07XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgaW5GdW5jdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkdlbmVyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkFzeW5jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGNhbkF3YWl0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dEaXJlY3RTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cmVhdEZ1bmN0aW9uc0FzVmFyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93TmV3RG90VGFyZ2V0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQ2xhc3NTdGF0aWNCbG9jazogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm9wdGlvbnMucHJvZ3JhbSB8fCB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbChub2RlKVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkZ1bmN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkdlbmVyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0dFTkVSQVRPUikgPiAwICYmICF0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmluQ2xhc3NGaWVsZEluaXQgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5Bc3luYy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0FTWU5DKSA+IDAgJiYgIXRoaXMuY3VycmVudFZhclNjb3BlKCkuaW5DbGFzc0ZpZWxkSW5pdCB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5jYW5Bd2FpdC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlLmluQ2xhc3NGaWVsZEluaXQgfHwgc2NvcGUuZmxhZ3MgJiBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSB7IHJldHVybiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9BU1lOQykgPiAwIH1cbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMykgfHwgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb25cbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuY3VycmVudFRoaXNTY29wZSgpO1xuICAgICAgdmFyIGZsYWdzID0gcmVmLmZsYWdzO1xuICAgICAgdmFyIGluQ2xhc3NGaWVsZEluaXQgPSByZWYuaW5DbGFzc0ZpZWxkSW5pdDtcbiAgICByZXR1cm4gKGZsYWdzICYgU0NPUEVfU1VQRVIpID4gMCB8fCBpbkNsYXNzRmllbGRJbml0IHx8IHRoaXMub3B0aW9ucy5hbGxvd1N1cGVyT3V0c2lkZU1ldGhvZFxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd0RpcmVjdFN1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0RJUkVDVF9TVVBFUikgPiAwIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLnRyZWF0RnVuY3Rpb25zQXNWYXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKSB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd05ld0RvdFRhcmdldC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuY3VycmVudFRoaXNTY29wZSgpO1xuICAgICAgdmFyIGZsYWdzID0gcmVmLmZsYWdzO1xuICAgICAgdmFyIGluQ2xhc3NGaWVsZEluaXQgPSByZWYuaW5DbGFzc0ZpZWxkSW5pdDtcbiAgICByZXR1cm4gKGZsYWdzICYgKFNDT1BFX0ZVTkNUSU9OIHwgU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLKSkgPiAwIHx8IGluQ2xhc3NGaWVsZEluaXRcbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5DbGFzc1N0YXRpY0Jsb2NrLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spID4gMFxuICB9O1xuXG4gIFBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKCkge1xuICAgICAgdmFyIHBsdWdpbnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBwbHVnaW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgY2xzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHsgY2xzID0gcGx1Z2luc1tpXShjbHMpOyB9XG4gICAgcmV0dXJuIGNsc1xuICB9O1xuXG4gIFBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCkucGFyc2UoKVxuICB9O1xuXG4gIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdCA9IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0IChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICAgIHBhcnNlci5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbigpXG4gIH07XG5cbiAgUGFyc2VyLnRva2VuaXplciA9IGZ1bmN0aW9uIHRva2VuaXplciAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFBhcnNlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHZhciBwcCQ5ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyAjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbiAgdmFyIGxpdGVyYWwgPSAvXig/OicoKD86XFxcXC58W14nXFxcXF0pKj8pJ3xcIigoPzpcXFxcLnxbXlwiXFxcXF0pKj8pXCIpLztcbiAgcHAkOS5zdHJpY3REaXJlY3RpdmUgPSBmdW5jdGlvbihzdGFydCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA1KSB7IHJldHVybiBmYWxzZSB9XG4gICAgZm9yICg7Oykge1xuICAgICAgLy8gVHJ5IHRvIGZpbmQgc3RyaW5nIGxpdGVyYWwuXG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgICAgdmFyIG1hdGNoID0gbGl0ZXJhbC5leGVjKHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQpKTtcbiAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmICgobWF0Y2hbMV0gfHwgbWF0Y2hbMl0pID09PSBcInVzZSBzdHJpY3RcIikge1xuICAgICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIHNwYWNlQWZ0ZXIgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpLCBlbmQgPSBzcGFjZUFmdGVyLmluZGV4ICsgc3BhY2VBZnRlclswXS5sZW5ndGg7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQXQoZW5kKTtcbiAgICAgICAgcmV0dXJuIG5leHQgPT09IFwiO1wiIHx8IG5leHQgPT09IFwifVwiIHx8XG4gICAgICAgICAgKGxpbmVCcmVhay50ZXN0KHNwYWNlQWZ0ZXJbMF0pICYmXG4gICAgICAgICAgICEoL1soYC5bK1xcLS8qJTw+PSw/XiZdLy50ZXN0KG5leHQpIHx8IG5leHQgPT09IFwiIVwiICYmIHRoaXMuaW5wdXQuY2hhckF0KGVuZCArIDEpID09PSBcIj1cIikpXG4gICAgICB9XG4gICAgICBzdGFydCArPSBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAgIC8vIFNraXAgc2VtaWNvbG9uLCBpZiBhbnkuXG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuaW5wdXRbc3RhcnRdID09PSBcIjtcIilcbiAgICAgICAgeyBzdGFydCsrOyB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFByZWRpY2F0ZSB0aGF0IHRlc3RzIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgb2YgdGhlIGdpdmVuXG4gIC8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbiAgcHAkOS5lYXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbiAgcHAkOS5pc0NvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIHRoaXMudmFsdWUgPT09IG5hbWUgJiYgIXRoaXMuY29udGFpbnNFc2NcbiAgfTtcblxuICAvLyBDb25zdW1lcyBjb250ZXh0dWFsIGtleXdvcmQgaWYgcG9zc2libGUuXG5cbiAgcHAkOS5lYXRDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwobmFtZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIEFzc2VydHMgdGhhdCBmb2xsb3dpbmcgdG9rZW4gaXMgZ2l2ZW4gY29udGV4dHVhbCBrZXl3b3JkLlxuXG4gIHBwJDkuZXhwZWN0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbChuYW1lKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG4gIC8vIFRlc3Qgd2hldGhlciBhIHNlbWljb2xvbiBjYW4gYmUgaW5zZXJ0ZWQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG5cbiAgcHAkOS5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcyQxLmVvZiB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLmJyYWNlUiB8fFxuICAgICAgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxuICB9O1xuXG4gIHBwJDkuaW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbilcbiAgICAgICAgeyB0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbih0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYyk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIC8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuICAvLyBwcmV0ZW5kIHRoYXQgdGhlcmUgaXMgYSBzZW1pY29sb24gYXQgdGhpcyBwb3NpdGlvbi5cblxuICBwcCQ5LnNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5zZW1pKSAmJiAhdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG4gIHBwJDkuYWZ0ZXJUcmFpbGluZ0NvbW1hID0gZnVuY3Rpb24odG9rVHlwZSwgbm90TmV4dCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKVxuICAgICAgICB7IHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTsgfVxuICAgICAgaWYgKCFub3ROZXh0KVxuICAgICAgICB7IHRoaXMubmV4dCgpOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcblxuICAvLyBFeHBlY3QgYSB0b2tlbiBvZiBhIGdpdmVuIHR5cGUuIElmIGZvdW5kLCBjb25zdW1lIGl0LCBvdGhlcndpc2UsXG4gIC8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbiAgcHAkOS5leHBlY3QgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdGhpcy5lYXQodHlwZSkgfHwgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH07XG5cbiAgLy8gUmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxuICBwcCQ5LnVuZXhwZWN0ZWQgPSBmdW5jdGlvbihwb3MpIHtcbiAgICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICB9O1xuXG4gIHZhciBEZXN0cnVjdHVyaW5nRXJyb3JzID0gZnVuY3Rpb24gRGVzdHJ1Y3R1cmluZ0Vycm9ycygpIHtcbiAgICB0aGlzLnNob3J0aGFuZEFzc2lnbiA9XG4gICAgdGhpcy50cmFpbGluZ0NvbW1hID1cbiAgICB0aGlzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPVxuICAgIHRoaXMucGFyZW50aGVzaXplZEJpbmQgPVxuICAgIHRoaXMuZG91YmxlUHJvdG8gPVxuICAgICAgLTE7XG4gIH07XG5cbiAgcHAkOS5jaGVja1BhdHRlcm5FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBpc0Fzc2lnbikge1xuICAgIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPiAtMSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICB2YXIgcGFyZW5zID0gaXNBc3NpZ24gPyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gOiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kO1xuICAgIGlmIChwYXJlbnMgPiAtMSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocGFyZW5zLCBpc0Fzc2lnbiA/IFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiIDogXCJQYXJlbnRoZXNpemVkIHBhdHRlcm5cIik7IH1cbiAgfTtcblxuICBwcCQ5LmNoZWNrRXhwcmVzc2lvbkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFuZFRocm93KSB7XG4gICAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIHNob3J0aGFuZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduO1xuICAgIHZhciBkb3VibGVQcm90byA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG87XG4gICAgaWYgKCFhbmRUaHJvdykgeyByZXR1cm4gc2hvcnRoYW5kQXNzaWduID49IDAgfHwgZG91YmxlUHJvdG8gPj0gMCB9XG4gICAgaWYgKHNob3J0aGFuZEFzc2lnbiA+PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlKHNob3J0aGFuZEFzc2lnbiwgXCJTaG9ydGhhbmQgcHJvcGVydHkgYXNzaWdubWVudHMgYXJlIHZhbGlkIG9ubHkgaW4gZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuc1wiKTsgfVxuICAgIGlmIChkb3VibGVQcm90byA+PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZG91YmxlUHJvdG8sIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxuICB9O1xuXG4gIHBwJDkuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMueWllbGRQb3MgJiYgKCF0aGlzLmF3YWl0UG9zIHx8IHRoaXMueWllbGRQb3MgPCB0aGlzLmF3YWl0UG9zKSlcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnlpZWxkUG9zLCBcIllpZWxkIGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgIGlmICh0aGlzLmF3YWl0UG9zKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRQb3MsIFwiQXdhaXQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gIH07XG5cbiAgcHAkOS5pc1NpbXBsZUFzc2lnblRhcmdldCA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgICB7IHJldHVybiB0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIuZXhwcmVzc2lvbikgfVxuICAgIHJldHVybiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGV4cHIudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCJcbiAgfTtcblxuICB2YXIgcHAkOCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gIyMjIFN0YXRlbWVudCBwYXJzaW5nXG5cbiAgLy8gUGFyc2UgYSBwcm9ncmFtLiBJbml0aWFsaXplcyB0aGUgcGFyc2VyLCByZWFkcyBhbnkgbnVtYmVyIG9mXG4gIC8vIHN0YXRlbWVudHMsIGFuZCB3cmFwcyB0aGVtIGluIGEgUHJvZ3JhbSBub2RlLiAgT3B0aW9uYWxseSB0YWtlcyBhXG4gIC8vIGBwcm9ncmFtYCBhcmd1bWVudC4gIElmIHByZXNlbnQsIHRoZSBzdGF0ZW1lbnRzIHdpbGwgYmUgYXBwZW5kZWRcbiAgLy8gdG8gaXRzIGJvZHkgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBub2RlLlxuXG4gIHBwJDgucGFyc2VUb3BMZXZlbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKCFub2RlLmJvZHkpIHsgbm9kZS5ib2R5ID0gW107IH1cbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcyQxLmVvZikge1xuICAgICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwsIHRydWUsIGV4cG9ydHMpO1xuICAgICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluTW9kdWxlKVxuICAgICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IE9iamVjdC5rZXlzKHRoaXMudW5kZWZpbmVkRXhwb3J0cyk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXS5zdGFydCwgKFwiRXhwb3J0ICdcIiArIG5hbWUgKyBcIicgaXMgbm90IGRlZmluZWRcIikpO1xuICAgICAgICB9IH1cbiAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxuICB9O1xuXG4gIHZhciBsb29wTGFiZWwgPSB7a2luZDogXCJsb29wXCJ9LCBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxuICBwcCQ4LmlzTGV0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICAvLyBGb3IgYW1iaWd1b3VzIGNhc2VzLCBkZXRlcm1pbmUgaWYgYSBMZXhpY2FsRGVjbGFyYXRpb24gKG9yIG9ubHkgYVxuICAgIC8vIFN0YXRlbWVudCkgaXMgYWxsb3dlZCBoZXJlLiBJZiBjb250ZXh0IGlzIG5vdCBlbXB0eSB0aGVuIG9ubHkgYSBTdGF0ZW1lbnRcbiAgICAvLyBpcyBhbGxvd2VkLiBIb3dldmVyLCBgbGV0IFtgIGlzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIGxvb2thaGVhZCBmb3JcbiAgICAvLyBFeHByZXNzaW9uU3RhdGVtZW50LCBzbyBzcGVjaWFsLWNhc2UgaXQgZmlyc3QuXG4gICAgaWYgKG5leHRDaCA9PT0gOTEgfHwgbmV4dENoID09PSA5MikgeyByZXR1cm4gdHJ1ZSB9IC8vICdbJywgJy8nXG4gICAgaWYgKGNvbnRleHQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChuZXh0Q2ggPT09IDEyMyB8fCBuZXh0Q2ggPiAweGQ3ZmYgJiYgbmV4dENoIDwgMHhkYzAwKSB7IHJldHVybiB0cnVlIH0gLy8gJ3snLCBhc3RyYWxcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoLCB0cnVlKSkge1xuICAgICAgdmFyIHBvcyA9IG5leHQgKyAxO1xuICAgICAgd2hpbGUgKGlzSWRlbnRpZmllckNoYXIobmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyksIHRydWUpKSB7ICsrcG9zOyB9XG4gICAgICBpZiAobmV4dENoID09PSA5MiB8fCBuZXh0Q2ggPiAweGQ3ZmYgJiYgbmV4dENoIDwgMHhkYzAwKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICAgIGlmICgha2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci50ZXN0KGlkZW50KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGNoZWNrICdhc3luYyBbbm8gTGluZVRlcm1pbmF0b3IgaGVyZV0gZnVuY3Rpb24nXG4gIC8vIC0gJ2FzeW5jIC8qZm9vKi8gZnVuY3Rpb24nIGlzIE9LLlxuICAvLyAtICdhc3luYyAvKlxcbiovIGZ1bmN0aW9uJyBpcyBpbnZhbGlkLlxuICBwcCQ4LmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgYWZ0ZXI7XG4gICAgcmV0dXJuICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCBuZXh0KSkgJiZcbiAgICAgIHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgbmV4dCArIDgpID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIChuZXh0ICsgOCA9PT0gdGhpcy5pbnB1dC5sZW5ndGggfHxcbiAgICAgICAhKGlzSWRlbnRpZmllckNoYXIoYWZ0ZXIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCArIDgpKSB8fCBhZnRlciA+IDB4ZDdmZiAmJiBhZnRlciA8IDB4ZGMwMCkpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuICAvL1xuICAvLyBJZiBleHBlY3RpbmcgYSBzdGF0ZW1lbnQgYW5kIGZpbmRpbmcgYSBzbGFzaCBvcGVyYXRvciwgcGFyc2UgYVxuICAvLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuICAvLyBgaWYgKGZvbykgL2JsYWgvLmV4ZWMoZm9vKWAsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4gIC8vIGRvZXMgbm90IGhlbHAuXG5cbiAgcHAkOC5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGNvbnRleHQsIHRvcExldmVsLCBleHBvcnRzKSB7XG4gICAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgICAgc3RhcnR0eXBlID0gdHlwZXMkMS5fdmFyO1xuICAgICAga2luZCA9IFwibGV0XCI7XG4gICAgfVxuXG4gICAgLy8gTW9zdCB0eXBlcyBvZiBzdGF0ZW1lbnRzIGFyZSByZWNvZ25pemVkIGJ5IHRoZSBrZXl3b3JkIHRoZXlcbiAgICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgICAvLyBjb21wbGV4aXR5LlxuXG4gICAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICBjYXNlIHR5cGVzJDEuX2JyZWFrOiBjYXNlIHR5cGVzJDEuX2NvbnRpbnVlOiByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpXG4gICAgY2FzZSB0eXBlcyQxLl9kZWJ1Z2dlcjogcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX2ZvcjogcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX2Z1bmN0aW9uOlxuICAgICAgLy8gRnVuY3Rpb24gYXMgc29sZSBib2R5IG9mIGVpdGhlciBhbiBpZiBzdGF0ZW1lbnQgb3IgYSBsYWJlbGVkIHN0YXRlbWVudFxuICAgICAgLy8gd29ya3MsIGJ1dCBub3Qgd2hlbiBpdCBpcyBwYXJ0IG9mIGEgbGFiZWxlZCBzdGF0ZW1lbnQgdGhhdCBpcyB0aGUgc29sZVxuICAgICAgLy8gYm9keSBvZiBhbiBpZiBzdGF0ZW1lbnQuXG4gICAgICBpZiAoKGNvbnRleHQgJiYgKHRoaXMuc3RyaWN0IHx8IGNvbnRleHQgIT09IFwiaWZcIiAmJiBjb250ZXh0ICE9PSBcImxhYmVsXCIpKSAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gICAgY2FzZSB0eXBlcyQxLl9jbGFzczpcbiAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gICAgY2FzZSB0eXBlcyQxLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fcmV0dXJuOiByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX3RyeTogcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX2NvbnN0OiBjYXNlIHR5cGVzJDEuX3ZhcjpcbiAgICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgICBpZiAoY29udGV4dCAmJiBraW5kICE9PSBcInZhclwiKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICAgIGNhc2UgdHlwZXMkMS5fd2hpbGU6IHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuX3dpdGg6IHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgbm9kZSlcbiAgICBjYXNlIHR5cGVzJDEuc2VtaTogcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMkMS5fZXhwb3J0OlxuICAgIGNhc2UgdHlwZXMkMS5faW1wb3J0OlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5faW1wb3J0KSB7XG4gICAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgICAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICBpZiAobmV4dENoID09PSA0MCB8fCBuZXh0Q2ggPT09IDQ2KSAvLyAnKCcgb3IgJy4nXG4gICAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpIHtcbiAgICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZXhwb3J0cylcblxuICAgICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgICAgLy8gYnJhY2UsIGl0J3MgYW4gRXhwcmVzc2lvblN0YXRlbWVudCBvciBMYWJlbGVkU3RhdGVtZW50LiBXZVxuICAgICAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAgICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAgIC8vIElkZW50aWZpZXIgbm9kZSwgd2Ugc3dpdGNoIHRvIGludGVycHJldGluZyBpdCBhcyBhIGxhYmVsLlxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICAgIH1cblxuICAgICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMkMS5jb2xvbikpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkgfVxuICAgICAgZWxzZSB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2V5d29yZCkge1xuICAgIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIGVsc2Uge1xuICAgICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgICAvLyBjb250aW51ZSB0by5cbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxhYiA9IHRoaXMubGFiZWxzW2ldO1xuICAgICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIHsgYnJlYWsgfVxuICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRG9TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJkb1wiKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLl93aGlsZSk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgdGhpcy5lYXQodHlwZXMkMS5zZW1pKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuICAvLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbiAgLy8gc3RhdGVtZW50IG9yIGV4cHJlc3Npb24sIGRpc2FsbG93aW5nIHRoZSBgaW5gIG9wZXJhdG9yIChzZWVcbiAgLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuICAvLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4gIC8vIHBhcnQgKHNlbWljb2xvbiBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyksIGl0XG4gIC8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG4gIHBwJDgucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5jYW5Bd2FpdCAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkgPyB0aGlzLmxhc3RUb2tTdGFydCA6IC0xO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc2VtaSkge1xuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gICAgfVxuICAgIHZhciBpc0xldCA9IHRoaXMuaXNMZXQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl92YXIgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLl9jb25zdCB8fCBpc0xldCkge1xuICAgICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICBpZiAoKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSAmJiBpbml0JDEuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbikge1xuICAgICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0JDEpXG4gICAgICB9XG4gICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCQxKVxuICAgIH1cbiAgICB2YXIgc3RhcnRzV2l0aExldCA9IHRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpLCBpc0Zvck9mID0gZmFsc2U7XG4gICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICB2YXIgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGF3YWl0QXQgPiAtMSA/IFwiYXdhaXRcIiA6IHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8IChpc0Zvck9mID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbikge1xuICAgICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydHNXaXRoTGV0ICYmIGlzRm9yT2YpIHsgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBcIlRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhIGZvci1vZiBsb29wIG1heSBub3Qgc3RhcnQgd2l0aCAnbGV0Jy5cIik7IH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihpbml0KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbiAgfTtcblxuICBwcCQ4LnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBpc0FzeW5jLCBkZWNsYXJhdGlvblBvc2l0aW9uKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBGVU5DX1NUQVRFTUVOVCB8IChkZWNsYXJhdGlvblBvc2l0aW9uID8gMCA6IEZVTkNfSEFOR0lOR19TVEFURU1FTlQpLCBmYWxzZSwgaXNBc3luYylcbiAgfTtcblxuICBwcCQ4LnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIC8vIGFsbG93IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBpbiBicmFuY2hlcywgYnV0IG9ubHkgaW4gbm9uLXN0cmljdCBtb2RlXG4gICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQodHlwZXMkMS5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIikgOiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCF0aGlzLmluRnVuY3Rpb24gJiYgIXRoaXMub3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7IH1cbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIEluIGByZXR1cm5gIChhbmQgYGJyZWFrYC9gY29udGludWVgKSwgdGhlIGtleXdvcmRzIHdpdGhcbiAgICAvLyBvcHRpb25hbCBhcmd1bWVudHMsIHdlIGVhZ2VybHkgbG9vayBmb3IgYSBzZW1pY29sb24gb3IgdGhlXG4gICAgLy8gcG9zc2liaWxpdHkgdG8gaW5zZXJ0IG9uZS5cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmNhc2VzID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICAgIHRoaXMubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcblxuICAgIC8vIFN0YXRlbWVudHMgdW5kZXIgbXVzdCBiZSBncm91cGVkIChieSBsYWJlbCkgaW4gU3dpdGNoQ2FzZVxuICAgIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gICAgLy8gYWRkaW5nIHN0YXRlbWVudHMgdG8uXG5cbiAgICB2YXIgY3VyO1xuICAgIGZvciAodmFyIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlUjspIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2Nhc2UgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLl9kZWZhdWx0KSB7XG4gICAgICAgIHZhciBpc0Nhc2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2Nhc2U7XG4gICAgICAgIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gICAgICAgIG5vZGUuY2FzZXMucHVzaChjdXIgPSB0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChpc0Nhc2UpIHtcbiAgICAgICAgICBjdXIudGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNhd0RlZmF1bHQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgfVxuICAgICAgICAgIHNhd0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbG9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VyKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICB0aGlzLm5leHQoKTsgLy8gQ2xvc2luZyBicmFjZVxuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTsgfVxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbiAgdmFyIGVtcHR5JDEgPSBbXTtcblxuICBwcCQ4LnBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHZhciBzaW1wbGUgPSBwYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIjtcbiAgICB0aGlzLmVudGVyU2NvcGUoc2ltcGxlID8gU0NPUEVfU0lNUExFX0NBVENIIDogMCk7XG4gICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKHBhcmFtLCBzaW1wbGUgPyBCSU5EX1NJTVBMRV9DQVRDSCA6IEJJTkRfTEVYSUNBTCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuXG4gICAgcmV0dXJuIHBhcmFtXG4gIH07XG5cbiAgcHAkOC5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9jYXRjaCkge1xuICAgICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnBhcmVuTCkpIHtcbiAgICAgICAgY2xhdXNlLnBhcmFtID0gdGhpcy5wYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgICB9XG4gICAgICBjbGF1c2UuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgICB9XG4gICAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCh0eXBlcyQxLl9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplcikge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndoaWxlXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndpdGhcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gdGhpcy5sYWJlbHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBsYWJlbCA9IGxpc3RbaSQxXTtcblxuICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gICAgfSB9XG4gICAgdmFyIGtpbmQgPSB0aGlzLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGxhYmVsJDEgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgIC8vIFVwZGF0ZSBpbmZvcm1hdGlvbiBhYm91dCBwcmV2aW91cyBsYWJlbHMgb24gdGhpcyBub2RlXG4gICAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgICAgfSBlbHNlIHsgYnJlYWsgfVxuICAgIH1cbiAgICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChjb250ZXh0ID8gY29udGV4dC5pbmRleE9mKFwibGFiZWxcIikgPT09IC0xID8gY29udGV4dCArIFwibGFiZWxcIiA6IGNvbnRleHQgOiBcImxhYmVsXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBzZW1pY29sb24tZW5jbG9zZWQgYmxvY2sgb2Ygc3RhdGVtZW50cywgaGFuZGxpbmcgYFwidXNlXG4gIC8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4gIC8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbiAgcHAkOC5wYXJzZUJsb2NrID0gZnVuY3Rpb24oY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBub2RlLCBleGl0U3RyaWN0KSB7XG4gICAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG4gICAgaWYgKCBub2RlID09PSB2b2lkIDAgKSBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIG5vZGUuYm9keSA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZW50ZXJTY29wZSgwKTsgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSKSB7XG4gICAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICB9XG4gICAgaWYgKGV4aXRTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSBmYWxzZTsgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHsgdGhpcy5leGl0U2NvcGUoKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGEgcmVndWxhciBgZm9yYCBsb29wLiBUaGUgZGlzYW1iaWd1YXRpb24gY29kZSBpblxuICAvLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3JcbiAgLy8gZXhwcmVzc2lvbi5cblxuICBwcCQ4LnBhcnNlRm9yID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICAgIG5vZGUuaW5pdCA9IGluaXQ7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5zZW1pKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc2VtaSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuc2VtaSk7XG4gICAgbm9kZS51cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5SID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3RcbiAgLy8gc2FtZSBmcm9tIHBhcnNlcidzIHBlcnNwZWN0aXZlLlxuXG4gIHBwJDgucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICB2YXIgaXNGb3JJbiA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW47XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAoXG4gICAgICBpbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmXG4gICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0ICE9IG51bGwgJiZcbiAgICAgIChcbiAgICAgICAgIWlzRm9ySW4gfHxcbiAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fFxuICAgICAgICB0aGlzLnN0cmljdCB8fFxuICAgICAgICBpbml0LmtpbmQgIT09IFwidmFyXCIgfHxcbiAgICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCJcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRoaXMucmFpc2UoXG4gICAgICAgIGluaXQuc3RhcnQsXG4gICAgICAgICgoaXNGb3JJbiA/IFwiZm9yLWluXCIgOiBcImZvci1vZlwiKSArIFwiIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyXCIpXG4gICAgICApO1xuICAgIH1cbiAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbiAgcHAkOC5wYXJzZVZhciA9IGZ1bmN0aW9uKG5vZGUsIGlzRm9yLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplcikge1xuICAgIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgbm9kZS5raW5kID0ga2luZDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZGVjbCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMkMS5lcSkpIHtcbiAgICAgICAgZGVjbC5pbml0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoIWFsbG93TWlzc2luZ0luaXRpYWxpemVyICYmIGtpbmQgPT09IFwiY29uc3RcIiAmJiAhKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWFsbG93TWlzc2luZ0luaXRpYWxpemVyICYmIGRlY2wuaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgIShpc0ZvciAmJiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiQ29tcGxleCBiaW5kaW5nIHBhdHRlcm5zIHJlcXVpcmUgYW4gaW5pdGlhbGl6YXRpb24gdmFsdWVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNsLmluaXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgICAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSkgeyBicmVhayB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkOC5wYXJzZVZhcklkID0gZnVuY3Rpb24oZGVjbCwga2luZCkge1xuICAgIGRlY2wuaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZGVjbC5pZCwga2luZCA9PT0gXCJ2YXJcIiA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMLCBmYWxzZSk7XG4gIH07XG5cbiAgdmFyIEZVTkNfU1RBVEVNRU5UID0gMSwgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCA9IDIsIEZVTkNfTlVMTEFCTEVfSUQgPSA0O1xuXG4gIC8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAvLyBgc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlRgKS5cblxuICAvLyBSZW1vdmUgYGFsbG93RXhwcmVzc2lvbkJvZHlgIGZvciA3LjAuMCwgYXMgaXQgaXMgb25seSBjYWxsZWQgd2l0aCBmYWxzZVxuICBwcCQ4LnBhcnNlRnVuY3Rpb24gPSBmdW5jdGlvbihub2RlLCBzdGF0ZW1lbnQsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzQXN5bmMsIGZvckluaXQpIHtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgfHwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIWlzQXN5bmMpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RhciAmJiAoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMkMS5zdGFyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgICBpZiAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpIHtcbiAgICAgIG5vZGUuaWQgPSAoc3RhdGVtZW50ICYgRlVOQ19OVUxMQUJMRV9JRCkgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLm5hbWUgPyBudWxsIDogdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICBpZiAobm9kZS5pZCAmJiAhKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgICAvLyBJZiBpdCBpcyBhIHJlZ3VsYXIgZnVuY3Rpb24gZGVjbGFyYXRpb24gaW4gc2xvcHB5IG1vZGUsIHRoZW4gaXQgaXNcbiAgICAgICAgLy8gc3ViamVjdCB0byBBbm5leCBCIHNlbWFudGljcyAoQklORF9GVU5DVElPTikuIE90aGVyd2lzZSwgdGhlIGJpbmRpbmdcbiAgICAgICAgLy8gbW9kZSBkZXBlbmRzIG9uIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgc2NvcGUgKHNlZVxuICAgICAgICAvLyB0cmVhdEZ1bmN0aW9uc0FzVmFyKS5cbiAgICAgICAgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmlkLCAodGhpcy5zdHJpY3QgfHwgbm9kZS5nZW5lcmF0b3IgfHwgbm9kZS5hc3luYykgPyB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCA6IEJJTkRfRlVOQ1RJT04pOyB9XG4gICAgfVxuXG4gICAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3Mobm9kZS5hc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcblxuICAgIGlmICghKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSlcbiAgICAgIHsgbm9kZS5pZCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiBudWxsOyB9XG5cbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBmYWxzZSwgZm9ySW5pdCk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VGdW5jdGlvblBhcmFtcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuTCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMkMS5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgfTtcblxuICAvLyBQYXJzZSBhIGNsYXNzIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbiAgLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG4gIHBwJDgucGFyc2VDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICAvLyBlY21hLTI2MiAxNC42IENsYXNzIERlZmluaXRpb25zXG4gICAgLy8gQSBjbGFzcyBkZWZpbml0aW9uIGlzIGFsd2F5cyBzdHJpY3QgbW9kZSBjb2RlLlxuICAgIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdDtcbiAgICB0aGlzLnN0cmljdCA9IHRydWU7XG5cbiAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gICAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgdmFyIHByaXZhdGVOYW1lTWFwID0gdGhpcy5lbnRlckNsYXNzQm9keSgpO1xuICAgIHZhciBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciBoYWRDb25zdHJ1Y3RvciA9IGZhbHNlO1xuICAgIGNsYXNzQm9keS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnQobm9kZS5zdXBlckNsYXNzICE9PSBudWxsKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIGVsZW1lbnQua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShlbGVtZW50LnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzc1wiKTsgfVxuICAgICAgICAgIGhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmtleSAmJiBlbGVtZW50LmtleS50eXBlID09PSBcIlByaXZhdGVJZGVudGlmaWVyXCIgJiYgaXNQcml2YXRlTmFtZUNvbmZsaWN0ZWQocHJpdmF0ZU5hbWVNYXAsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVsZW1lbnQua2V5LnN0YXJ0LCAoXCJJZGVudGlmaWVyICcjXCIgKyAoZWxlbWVudC5rZXkubmFtZSkgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gICAgdGhpcy5leGl0Q2xhc3NCb2R5KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24oY29uc3RydWN0b3JBbGxvd3NTdXBlcikge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnNlbWkpKSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIGtleU5hbWUgPSBcIlwiO1xuICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xuICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XG4gICAgdmFyIGtpbmQgPSBcIm1ldGhvZFwiO1xuICAgIHZhciBpc1N0YXRpYyA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcInN0YXRpY1wiKSkge1xuICAgICAgLy8gUGFyc2Ugc3RhdGljIGluaXQgYmxvY2tcbiAgICAgIGlmIChlY21hVmVyc2lvbiA+PSAxMyAmJiB0aGlzLmVhdCh0eXBlcyQxLmJyYWNlTCkpIHtcbiAgICAgICAgdGhpcy5wYXJzZUNsYXNzU3RhdGljQmxvY2sobm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSB7XG4gICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleU5hbWUgPSBcInN0YXRpY1wiO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIGlmICgha2V5TmFtZSAmJiBlY21hVmVyc2lvbiA+PSA4ICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImFzeW5jXCIpKSB7XG4gICAgICBpZiAoKHRoaXMuaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQoKSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RhcikgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlOYW1lID0gXCJhc3luY1wiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWtleU5hbWUgJiYgKGVjbWFWZXJzaW9uID49IDkgfHwgIWlzQXN5bmMpICYmIHRoaXMuZWF0KHR5cGVzJDEuc3RhcikpIHtcbiAgICAgIGlzR2VuZXJhdG9yID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFrZXlOYW1lICYmICFpc0FzeW5jICYmICFpc0dlbmVyYXRvcikge1xuICAgICAgdmFyIGxhc3RWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZ2V0XCIpIHx8IHRoaXMuZWF0Q29udGV4dHVhbChcInNldFwiKSkge1xuICAgICAgICBpZiAodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpKSB7XG4gICAgICAgICAga2luZCA9IGxhc3RWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlOYW1lID0gbGFzdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgZWxlbWVudCBuYW1lXG4gICAgaWYgKGtleU5hbWUpIHtcbiAgICAgIC8vICdhc3luYycsICdnZXQnLCAnc2V0Jywgb3IgJ3N0YXRpYycgd2VyZSBub3QgYSBrZXl3b3JkIGNvbnRleHR1YWxseS5cbiAgICAgIC8vIFRoZSBsYXN0IHRva2VuIGlzIGFueSBvZiB0aG9zZS4gTWFrZSBpdCB0aGUgZWxlbWVudCBuYW1lLlxuICAgICAgbm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgbm9kZS5rZXkgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICBub2RlLmtleS5uYW1lID0ga2V5TmFtZTtcbiAgICAgIHRoaXMuZmluaXNoTm9kZShub2RlLmtleSwgXCJJZGVudGlmaWVyXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBlbGVtZW50IHZhbHVlXG4gICAgaWYgKGVjbWFWZXJzaW9uIDwgMTMgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCB8fCBraW5kICE9PSBcIm1ldGhvZFwiIHx8IGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHtcbiAgICAgIHZhciBpc0NvbnN0cnVjdG9yID0gIW5vZGUuc3RhdGljICYmIGNoZWNrS2V5TmFtZShub2RlLCBcImNvbnN0cnVjdG9yXCIpO1xuICAgICAgdmFyIGFsbG93c0RpcmVjdFN1cGVyID0gaXNDb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3RvckFsbG93c1N1cGVyO1xuICAgICAgLy8gQ291bGRuJ3QgbW92ZSB0aGlzIGNoZWNrIGludG8gdGhlICdwYXJzZUNsYXNzTWV0aG9kJyBtZXRob2QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICBpZiAoaXNDb25zdHJ1Y3RvciAmJiBraW5kICE9PSBcIm1ldGhvZFwiKSB7IHRoaXMucmFpc2Uobm9kZS5rZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpOyB9XG4gICAgICBub2RlLmtpbmQgPSBpc0NvbnN0cnVjdG9yID8gXCJjb25zdHJ1Y3RvclwiIDoga2luZDtcbiAgICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NGaWVsZChub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIHBwJDguaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgfHxcbiAgICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wcml2YXRlSWQgfHxcbiAgICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5udW0gfHxcbiAgICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgfHxcbiAgICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5icmFja2V0TCB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmRcbiAgICApXG4gIH07XG5cbiAgcHAkOC5wYXJzZUNsYXNzRWxlbWVudE5hbWUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wcml2YXRlSWQpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNsYXNzZXMgY2FuJ3QgaGF2ZSBhbiBlbGVtZW50IG5hbWVkICcjY29uc3RydWN0b3InXCIpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgZWxlbWVudC5rZXkgPSB0aGlzLnBhcnNlUHJpdmF0ZUlkZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUoZWxlbWVudCk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucGFyc2VDbGFzc01ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgLy8gQ2hlY2sga2V5IGFuZCBmbGFnc1xuICAgIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIG1ldGhvZFwiKTsgfVxuICAgIH0gZWxzZSBpZiAobWV0aG9kLnN0YXRpYyAmJiBjaGVja0tleU5hbWUobWV0aG9kLCBcInByb3RvdHlwZVwiKSkge1xuICAgICAgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlXCIpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHZhbHVlXG4gICAgdmFyIHZhbHVlID0gbWV0aG9kLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuXG4gICAgLy8gQ2hlY2sgdmFsdWVcbiAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgJiYgdmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMClcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHZhbHVlLnN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgdmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHZhbHVlLnN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiB2YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUNsYXNzRmllbGQgPSBmdW5jdGlvbihmaWVsZCkge1xuICAgIGlmIChjaGVja0tleU5hbWUoZmllbGQsIFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgIHRoaXMucmFpc2UoZmllbGQua2V5LnN0YXJ0LCBcIkNsYXNzZXMgY2FuJ3QgaGF2ZSBhIGZpZWxkIG5hbWVkICdjb25zdHJ1Y3RvcidcIik7XG4gICAgfSBlbHNlIGlmIChmaWVsZC5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKGZpZWxkLCBcInByb3RvdHlwZVwiKSkge1xuICAgICAgdGhpcy5yYWlzZShmaWVsZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGEgc3RhdGljIGZpZWxkIG5hbWVkICdwcm90b3R5cGUnXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmVxKSkge1xuICAgICAgLy8gVG8gcmFpc2UgU3ludGF4RXJyb3IgaWYgJ2FyZ3VtZW50cycgZXhpc3RzIGluIHRoZSBpbml0aWFsaXplci5cbiAgICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFRoaXNTY29wZSgpO1xuICAgICAgdmFyIGluQ2xhc3NGaWVsZEluaXQgPSBzY29wZS5pbkNsYXNzRmllbGRJbml0O1xuICAgICAgc2NvcGUuaW5DbGFzc0ZpZWxkSW5pdCA9IHRydWU7XG4gICAgICBmaWVsZC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgc2NvcGUuaW5DbGFzc0ZpZWxkSW5pdCA9IGluQ2xhc3NGaWVsZEluaXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZmllbGQsIFwiUHJvcGVydHlEZWZpbml0aW9uXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUNsYXNzU3RhdGljQmxvY2sgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZS5ib2R5ID0gW107XG5cbiAgICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICB0aGlzLmVudGVyU2NvcGUoU0NPUEVfQ0xBU1NfU1RBVElDX0JMT0NLIHwgU0NPUEVfU1VQRVIpO1xuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSKSB7XG4gICAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdGF0aWNCbG9ja1wiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChpc1N0YXRlbWVudClcbiAgICAgICAgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmlkLCBCSU5EX0xFWElDQUwsIGZhbHNlKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBwcCQ4LnBhcnNlQ2xhc3NTdXBlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcyQxLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhudWxsLCBmYWxzZSkgOiBudWxsO1xuICB9O1xuXG4gIHBwJDguZW50ZXJDbGFzc0JvZHkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWxlbWVudCA9IHtkZWNsYXJlZDogT2JqZWN0LmNyZWF0ZShudWxsKSwgdXNlZDogW119O1xuICAgIHRoaXMucHJpdmF0ZU5hbWVTdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgIHJldHVybiBlbGVtZW50LmRlY2xhcmVkXG4gIH07XG5cbiAgcHAkOC5leGl0Q2xhc3NCb2R5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMucHJpdmF0ZU5hbWVTdGFjay5wb3AoKTtcbiAgICB2YXIgZGVjbGFyZWQgPSByZWYuZGVjbGFyZWQ7XG4gICAgdmFyIHVzZWQgPSByZWYudXNlZDtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5jaGVja1ByaXZhdGVGaWVsZHMpIHsgcmV0dXJuIH1cbiAgICB2YXIgbGVuID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aDtcbiAgICB2YXIgcGFyZW50ID0gbGVuID09PSAwID8gbnVsbCA6IHRoaXMucHJpdmF0ZU5hbWVTdGFja1tsZW4gLSAxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVzZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBpZCA9IHVzZWRbaV07XG4gICAgICBpZiAoIWhhc093bihkZWNsYXJlZCwgaWQubmFtZSkpIHtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC51c2VkLnB1c2goaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShpZC5zdGFydCwgKFwiUHJpdmF0ZSBmaWVsZCAnI1wiICsgKGlkLm5hbWUpICsgXCInIG11c3QgYmUgZGVjbGFyZWQgaW4gYW4gZW5jbG9zaW5nIGNsYXNzXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZChwcml2YXRlTmFtZU1hcCwgZWxlbWVudCkge1xuICAgIHZhciBuYW1lID0gZWxlbWVudC5rZXkubmFtZTtcbiAgICB2YXIgY3VyciA9IHByaXZhdGVOYW1lTWFwW25hbWVdO1xuXG4gICAgdmFyIG5leHQgPSBcInRydWVcIjtcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiAoZWxlbWVudC5raW5kID09PSBcImdldFwiIHx8IGVsZW1lbnQua2luZCA9PT0gXCJzZXRcIikpIHtcbiAgICAgIG5leHQgPSAoZWxlbWVudC5zdGF0aWMgPyBcInNcIiA6IFwiaVwiKSArIGVsZW1lbnQua2luZDtcbiAgICB9XG5cbiAgICAvLyBgY2xhc3MgeyBnZXQgI2EoKXt9OyBzdGF0aWMgc2V0ICNhKF8pe30gfWAgaXMgYWxzbyBjb25mbGljdC5cbiAgICBpZiAoXG4gICAgICBjdXJyID09PSBcImlnZXRcIiAmJiBuZXh0ID09PSBcImlzZXRcIiB8fFxuICAgICAgY3VyciA9PT0gXCJpc2V0XCIgJiYgbmV4dCA9PT0gXCJpZ2V0XCIgfHxcbiAgICAgIGN1cnIgPT09IFwic2dldFwiICYmIG5leHQgPT09IFwic3NldFwiIHx8XG4gICAgICBjdXJyID09PSBcInNzZXRcIiAmJiBuZXh0ID09PSBcInNnZXRcIlxuICAgICkge1xuICAgICAgcHJpdmF0ZU5hbWVNYXBbbmFtZV0gPSBcInRydWVcIjtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAoIWN1cnIpIHtcbiAgICAgIHByaXZhdGVOYW1lTWFwW25hbWVdID0gbmV4dDtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrS2V5TmFtZShub2RlLCBuYW1lKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gbm9kZS5jb21wdXRlZDtcbiAgICB2YXIga2V5ID0gbm9kZS5rZXk7XG4gICAgcmV0dXJuICFjb21wdXRlZCAmJiAoXG4gICAgICBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IG5hbWUgfHxcbiAgICAgIGtleS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IG5hbWVcbiAgICApXG4gIH1cblxuICAvLyBQYXJzZXMgbW9kdWxlIGV4cG9ydCBkZWNsYXJhdGlvbi5cblxuICBwcCQ4LnBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSkge1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZXhwb3J0ZWQsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZXhwb3J0ZWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICB9O1xuXG4gIHBwJDgucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJ1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnN0YXIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIGV4cG9ydHMpXG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLl9kZWZhdWx0KSkgeyAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gICAgfVxuICAgIC8vIGV4cG9ydCB2YXJ8Y29uc3R8bGV0fGZ1bmN0aW9ufGNsYXNzIC4uLlxuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLCBub2RlLmRlY2xhcmF0aW9uLmlkLnN0YXJ0KTsgfVxuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgfSBlbHNlIHsgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKGV4cG9ydHMpO1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIC8vIGNoZWNrIGZvciBrZXl3b3JkcyB1c2VkIGFzIGxvY2FsIG5hbWVzXG4gICAgICAgICAgdmFyIHNwZWMgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgZXhwb3J0IGlzIGRlZmluZWRcbiAgICAgICAgICB0aGlzLmNoZWNrTG9jYWxFeHBvcnQoc3BlYy5sb2NhbCk7XG5cbiAgICAgICAgICBpZiAoc3BlYy5sb2NhbC50eXBlID09PSBcIkxpdGVyYWxcIikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShzcGVjLmxvY2FsLnN0YXJ0LCBcIkEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gZXhwb3J0ZWQgYmluZGluZyB3aXRob3V0IGBmcm9tYC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBwcCQ4LnBhcnNlRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbClcbiAgfTtcblxuICBwcCQ4LnBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlzQXN5bmM7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fZnVuY3Rpb24gfHwgKGlzQXN5bmMgPSB0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSkge1xuICAgICAgdmFyIGZOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24oZk5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgRlVOQ19OVUxMQUJMRV9JRCwgZmFsc2UsIGlzQXN5bmMpXG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2NsYXNzKSB7XG4gICAgICB2YXIgY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhjTm9kZSwgXCJudWxsYWJsZUlEXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiBkZWNsYXJhdGlvblxuICAgIH1cbiAgfTtcblxuICBwcCQ4LmNoZWNrRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgcG9zKSB7XG4gICAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKVxuICAgICAgeyBuYW1lID0gbmFtZS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IG5hbWUubmFtZSA6IG5hbWUudmFsdWU7IH1cbiAgICBpZiAoaGFzT3duKGV4cG9ydHMsIG5hbWUpKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCBcIkR1cGxpY2F0ZSBleHBvcnQgJ1wiICsgbmFtZSArIFwiJ1wiKTsgfVxuICAgIGV4cG9ydHNbbmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHBwJDguY2hlY2tQYXR0ZXJuRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgcGF0KSB7XG4gICAgdmFyIHR5cGUgPSBwYXQudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgcGF0LCBwYXQuc3RhcnQpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGF0LnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcCk7XG4gICAgICAgIH0gfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpXG4gICAgICB7IGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHBhdC5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIGVsdCA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgICAgaWYgKGVsdCkgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBlbHQpOyB9XG4gICAgICB9IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlByb3BlcnR5XCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC52YWx1ZSk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5sZWZ0KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmFyZ3VtZW50KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmV4cHJlc3Npb24pOyB9XG4gIH07XG5cbiAgcHAkOC5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGRlY2xzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBkZWNsID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZGVjbC5pZCk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDguc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlLmtleXdvcmQgPT09IFwidmFyXCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNsYXNzXCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgIHRoaXMuaXNMZXQoKSB8fFxuICAgICAgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKVxuICB9O1xuXG4gIC8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBleHBvcnRzLlxuXG4gIHBwJDgucGFyc2VFeHBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuXG4gICAgbm9kZS5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKSA6IG5vZGUubG9jYWw7XG4gICAgdGhpcy5jaGVja0V4cG9ydChcbiAgICAgIGV4cG9ydHMsXG4gICAgICBub2RlLmV4cG9ydGVkLFxuICAgICAgbm9kZS5leHBvcnRlZC5zdGFydFxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUV4cG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcyQxLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXIoZXhwb3J0cykpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICAvLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG4gIHBwJDgucGFyc2VJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICAvLyBpbXBvcnQgJy4uLidcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gZW1wdHkkMTtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgaW1wb3J0cy5cblxuICBwcCQ4LnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuXG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUuaW1wb3J0ZWQpO1xuICAgICAgbm9kZS5sb2NhbCA9IG5vZGUuaW1wb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0U3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBpbXBvcnQgZGVmYXVsdE9iaiwgeyB4LCB5IGFzIHogfSBmcm9tICcuLi4nXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpXG4gIH07XG5cbiAgcHAkOC5wYXJzZUltcG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllcigpKTtcbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMkMS5jb21tYSkpIHsgcmV0dXJuIG5vZGVzIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSB7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICBwcCQ4LnBhcnNlTW9kdWxlRXhwb3J0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgICAgdmFyIHN0cmluZ0xpdGVyYWwgPSB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKTtcbiAgICAgIGlmIChsb25lU3Vycm9nYXRlLnRlc3Qoc3RyaW5nTGl0ZXJhbC52YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdHJpbmdMaXRlcmFsLnN0YXJ0LCBcIkFuIGV4cG9ydCBuYW1lIGNhbm5vdCBpbmNsdWRlIGEgbG9uZSBzdXJyb2dhdGUuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudCh0cnVlKVxuICB9O1xuXG4gIC8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxuICBwcCQ4LmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUgPSBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aCAmJiB0aGlzLmlzRGlyZWN0aXZlQ2FuZGlkYXRlKHN0YXRlbWVudHNbaV0pOyArK2kpIHtcbiAgICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gICAgfVxuICB9O1xuICBwcCQ4LmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmXG4gICAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICAgIHN0YXRlbWVudC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmXG4gICAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgIC8vIFJlamVjdCBwYXJlbnRoZXNpemVkIHN0cmluZ3MuXG4gICAgICAodGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIlxcXCJcIiB8fCB0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiJ1wiKVxuICAgIClcbiAgfTtcblxuICB2YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4gIC8vIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDcudG9Bc3NpZ25hYmxlID0gZnVuY3Rpb24obm9kZSwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAgIC8vIEVhcmx5IGVycm9yOlxuICAgICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgICAvLyAgICAgYC4uLmAgRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRbWWllbGQsIEF3YWl0XVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJlxuICAgICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShwcm9wLmFyZ3VtZW50LnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgICBpZiAobm9kZS5raW5kICE9PSBcImluaXRcIikgeyB0aGlzLnJhaXNlKG5vZGUua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTsgfVxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGlzQmluZGluZyk7XG4gICAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5hcmd1bWVudC5zdGFydCwgXCJSZXN0IGVsZW1lbnRzIGNhbm5vdCBoYXZlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7IHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTsgfVxuICAgICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmxlZnQsIGlzQmluZGluZyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZVwiKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFpc0JpbmRpbmcpIHsgYnJlYWsgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIC8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxuICBwcCQ3LnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gICAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZWx0KSB7IHRoaXMudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2VuZCAtIDFdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3RcbiAgfTtcblxuICAvLyBQYXJzZXMgc3ByZWFkIGVsZW1lbnQuXG5cbiAgcHAkNy5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQ3LnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICAvLyBSZXN0RWxlbWVudCBpbnNpZGUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpZGVudGlmaWVyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbiAgcHAkNy5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcyQxLmJyYWNrZXRMOlxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzJDEuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpXG5cbiAgICAgIGNhc2UgdHlwZXMkMS5icmFjZUw6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxuICB9O1xuXG4gIHBwJDcucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93TW9kaWZpZXJzKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpOyB9XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtKGFsbG93TW9kaWZpZXJzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkNy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbSA9IGZ1bmN0aW9uKGFsbG93TW9kaWZpZXJzKSB7XG4gICAgdmFyIGVsZW0gPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgcmV0dXJuIGVsZW1cbiAgfTtcblxuICBwcCQ3LnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW1cbiAgfTtcblxuICAvLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDcucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMkMS5lcSkpIHsgcmV0dXJuIGxlZnQgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICB9O1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgdGhyZWUgZnVuY3Rpb25zIGFsbCB2ZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbHVlIOKAlFxuICAvLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYm91bmQsIG9yIGFzc2lnbmVkIHRvLiBJbiBvcmRlciB0byBkbyBzbywgdGhleSBwZXJmb3JtXG4gIC8vIGEgdmFyaWV0eSBvZiBjaGVja3M6XG4gIC8vXG4gIC8vIC0gQ2hlY2sgdGhhdCBub25lIG9mIHRoZSBib3VuZC9hc3NpZ25lZC10byBpZGVudGlmaWVycyBhcmUgcmVzZXJ2ZWQgd29yZHMuXG4gIC8vIC0gUmVjb3JkIG5hbWUgZGVjbGFyYXRpb25zIGZvciBiaW5kaW5ncyBpbiB0aGUgYXBwcm9wcmlhdGUgc2NvcGUuXG4gIC8vIC0gQ2hlY2sgZHVwbGljYXRlIGFyZ3VtZW50IG5hbWVzLCBpZiBjaGVja0NsYXNoZXMgaXMgc2V0LlxuICAvL1xuICAvLyBJZiBhIGNvbXBsZXggYmluZGluZyBwYXR0ZXJuIGlzIGVuY291bnRlcmVkIChlLmcuLCBvYmplY3QgYW5kIGFycmF5XG4gIC8vIGRlc3RydWN0dXJpbmcpLCB0aGUgZW50aXJlIHBhdHRlcm4gaXMgcmVjdXJzaXZlbHkgY2hlY2tlZC5cbiAgLy9cbiAgLy8gVGhlcmUgYXJlIHRocmVlIHZlcnNpb25zIG9mIGNoZWNrTFZhbCooKSBhcHByb3ByaWF0ZSBmb3IgZGlmZmVyZW50XG4gIC8vIGNpcmN1bXN0YW5jZXM6XG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsU2ltcGxlKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuICAvLyAgIG5vdGhpbmcgb3RoZXIgdGhhbiBpZGVudGlmaWVycyBhbmQgbWVtYmVyIGV4cHJlc3Npb25zLiBQYXJlbnRoZXNpemVkXG4gIC8vICAgZXhwcmVzc2lvbnMgYXJlIGFsc28gY29ycmVjdGx5IGhhbmRsZWQuIFRoaXMgaXMgZ2VuZXJhbGx5IGFwcHJvcHJpYXRlIGZvclxuICAvLyAgIGNvbnN0cnVjdHMgZm9yIHdoaWNoIHRoZSBzcGVjIHNheXNcbiAgLy9cbiAgLy8gICA+IEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4gIC8vICAgPiBzaW1wbGUuXG4gIC8vXG4gIC8vICAgSXQgaXMgYWxzbyBhcHByb3ByaWF0ZSBmb3IgY2hlY2tpbmcgaWYgYW4gaWRlbnRpZmllciBpcyB2YWxpZCBhbmQgbm90XG4gIC8vICAgZGVmaW5lZCBlbHNld2hlcmUsIGxpa2UgaW1wb3J0IGRlY2xhcmF0aW9ucyBvciBmdW5jdGlvbi9jbGFzcyBpZGVudGlmaWVycy5cbiAgLy9cbiAgLy8gICBFeGFtcGxlcyB3aGVyZSB0aGlzIGlzIHVzZWQgaW5jbHVkZTpcbiAgLy8gICAgIGEgKz0g4oCmO1xuICAvLyAgICAgaW1wb3J0IGEgZnJvbSAn4oCmJztcbiAgLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsUGF0dGVybigpIHNoYWxsIGJlIHVzZWQgaWYgdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3Qgc3VwcG9ydHNcbiAgLy8gICBhbnl0aGluZyBjaGVja0xWYWxTaW1wbGUoKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBvYmplY3QgYW5kIGFycmF5XG4gIC8vICAgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJucy4gVGhpcyBpcyBnZW5lcmFsbHkgYXBwcm9wcmlhdGUgZm9yIGNvbnN0cnVjdHMgZm9yXG4gIC8vICAgd2hpY2ggdGhlIHNwZWMgc2F5c1xuICAvL1xuICAvLyAgID4gSXQgaXMgYSBTeW50YXggRXJyb3IgaWYgW3RoZSBwcm9kdWN0aW9uXSBpcyBuZWl0aGVyIGFuIE9iamVjdExpdGVyYWwgbm9yXG4gIC8vICAgPiBhbiBBcnJheUxpdGVyYWwgYW5kIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4gIC8vICAgPiBzaW1wbGUuXG4gIC8vXG4gIC8vICAgRXhhbXBsZXMgd2hlcmUgdGhpcyBpcyB1c2VkIGluY2x1ZGU6XG4gIC8vICAgICAoYSA9IOKApik7XG4gIC8vICAgICBjb25zdCBhID0g4oCmO1xuICAvLyAgICAgdHJ5IHsg4oCmIH0gY2F0Y2ggKGEpIHsg4oCmIH1cbiAgLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gIC8vXG4gIC8vIC0gY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuICAvLyAgIGFueXRoaW5nIGNoZWNrTFZhbFBhdHRlcm4oKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBkZWZhdWx0IGFzc2lnbm1lbnRcbiAgLy8gICBwYXR0ZXJucywgcmVzdCBlbGVtZW50cywgYW5kIG90aGVyIGNvbnN0cnVjdHMgdGhhdCBtYXkgYXBwZWFyIHdpdGhpbiBhblxuICAvLyAgIG9iamVjdCBvciBhcnJheSBkZXN0cnVjdHVyaW5nIHBhdHRlcm4uXG4gIC8vXG4gIC8vICAgQXMgYSBzcGVjaWFsIGNhc2UsIGZ1bmN0aW9uIHBhcmFtZXRlcnMgYWxzbyB1c2UgY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKCksXG4gIC8vICAgYXMgdGhleSBhbHNvIHN1cHBvcnQgZGVmYXVsdHMgYW5kIHJlc3QgY29uc3RydWN0cy5cbiAgLy9cbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRlbGliZXJhdGVseSBzdXBwb3J0IGJvdGggYXNzaWdubWVudCBhbmQgYmluZGluZyBjb25zdHJ1Y3RzLFxuICAvLyBhcyB0aGUgbG9naWMgZm9yIGJvdGggaXMgZXhjZWVkaW5nbHkgc2ltaWxhci4gSWYgdGhlIG5vZGUgaXMgdGhlIHRhcmdldCBvZlxuICAvLyBhbiBhc3NpZ25tZW50LCB0aGVuIGJpbmRpbmdUeXBlIHNob3VsZCBiZSBzZXQgdG8gQklORF9OT05FLiBPdGhlcndpc2UsIGl0XG4gIC8vIHNob3VsZCBiZSBzZXQgdG8gdGhlIGFwcHJvcHJpYXRlIEJJTkRfKiBjb25zdGFudCwgbGlrZSBCSU5EX1ZBUiBvclxuICAvLyBCSU5EX0xFWElDQUwuXG4gIC8vXG4gIC8vIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhIG5vbi1CSU5EX05PTkUgYmluZGluZ1R5cGUsIHRoZW5cbiAgLy8gYWRkaXRpb25hbGx5IGEgY2hlY2tDbGFzaGVzIG9iamVjdCBtYXkgYmUgc3BlY2lmaWVkIHRvIGFsbG93IGNoZWNraW5nIGZvclxuICAvLyBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMuIGNoZWNrQ2xhc2hlcyBpcyBpZ25vcmVkIGlmIHRoZSBwcm92aWRlZCBjb25zdHJ1Y3RcbiAgLy8gaXMgYW4gYXNzaWdubWVudCAoaS5lLiwgYmluZGluZ1R5cGUgaXMgQklORF9OT05FKS5cblxuICBwcCQ3LmNoZWNrTFZhbFNpbXBsZSA9IGZ1bmN0aW9uKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpIHtcbiAgICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICAgIHZhciBpc0JpbmQgPSBiaW5kaW5nVHlwZSAhPT0gQklORF9OT05FO1xuXG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoaXNCaW5kID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGlmIChpc0JpbmQpIHtcbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwgJiYgZXhwci5uYW1lID09PSBcImxldFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgICAgaWYgKGhhc093bihjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpXG4gICAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX09VVFNJREUpIHsgdGhpcy5kZWNsYXJlTmFtZShleHByLm5hbWUsIGJpbmRpbmdUeXBlLCBleHByLnN0YXJ0KTsgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gbGVmdC1oYW5kIHNpZGVcIik7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChpc0JpbmQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKGlzQmluZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tMVmFsU2ltcGxlKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcylcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChpc0JpbmQgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ3LmNoZWNrTFZhbFBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHIucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBleHByLmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZWxlbSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkNy5jaGVja0xWYWxJbm5lclBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICAgIHRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuICAvLyBnaXZlbiBwb2ludCBpbiB0aGUgcHJvZ3JhbSBpcyBsb29zZWx5IGJhc2VkIG9uIHN3ZWV0LmpzJyBhcHByb2FjaC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG5cblxuICB2YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSAhIWdlbmVyYXRvcjtcbiAgfTtcblxuICB2YXIgdHlwZXMgPSB7XG4gICAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICAgIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICAgIGJfdG1wbDogbmV3IFRva0NvbnRleHQoXCIke1wiLCBmYWxzZSksXG4gICAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICAgIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICAgIHFfdG1wbDogbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuKCk7IH0pLFxuICAgIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gICAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICAgIGZfZXhwcl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSwgZmFsc2UsIG51bGwsIHRydWUpLFxuICAgIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbiAgfTtcblxuICB2YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgcHAkNi5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbdHlwZXMuYl9zdGF0XVxuICB9O1xuXG4gIHBwJDYuY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG4gIH07XG5cbiAgcHAkNi5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAocGFyZW50ID09PSB0eXBlcy5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcy5mX3N0YXQpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMuYl9leHByKSlcbiAgICAgIHsgcmV0dXJuICFwYXJlbnQuaXNFeHByIH1cblxuICAgIC8vIFRoZSBjaGVjayBmb3IgYHR0Lm5hbWUgJiYgZXhwckFsbG93ZWRgIGRldGVjdHMgd2hldGhlciB3ZSBhcmVcbiAgICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAgIC8vIGB0dC5uYW1lYC5cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuc2VtaSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEucGFyZW5SIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLmFycm93KVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLmJyYWNlTClcbiAgICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEubmFtZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gIXRoaXMuZXhwckFsbG93ZWRcbiAgfTtcblxuICBwcCQ2LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTsgaSA+PSAxOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0W2ldO1xuICAgICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgeyByZXR1cm4gY29udGV4dC5nZW5lcmF0b3IgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ2LnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PT0gdHlwZXMkMS5kb3QpXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICAgIHsgdXBkYXRlLmNhbGwodGhpcywgcHJldlR5cGUpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byBoYW5kbGUgZWdkZSBjYXNlcyB3aGVuIHRva2VuIGNvbnRleHQgY291bGQgbm90IGJlIGluZmVycmVkIGNvcnJlY3RseSBkdXJpbmcgdG9rZW5pemF0aW9uIHBoYXNlXG5cbiAgcHAkNi5vdmVycmlkZUNvbnRleHQgPSBmdW5jdGlvbih0b2tlbkN0eCkge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdG9rZW5DdHgpIHtcbiAgICAgIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV0gPSB0b2tlbkN0eDtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG4gIHR5cGVzJDEucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcyQxLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgaWYgKG91dCA9PT0gdHlwZXMuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xuICB9O1xuXG4gIHR5cGVzJDEuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzLmJfc3RhdCA6IHR5cGVzLmJfZXhwcik7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzLmJfdG1wbCk7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcyQxLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aGlsZTtcbiAgICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcy5wX3N0YXQgOiB0eXBlcy5wX2V4cHIpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzJDEuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbiAgfTtcblxuICB0eXBlcyQxLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMkMS5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgaWYgKHByZXZUeXBlLmJlZm9yZUV4cHIgJiYgcHJldlR5cGUgIT09IHR5cGVzJDEuX2Vsc2UgJiZcbiAgICAgICAgIShwcmV2VHlwZSA9PT0gdHlwZXMkMS5zZW1pICYmIHRoaXMuY3VyQ29udGV4dCgpICE9PSB0eXBlcy5wX3N0YXQpICYmXG4gICAgICAgICEocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKSAmJlxuICAgICAgICAhKChwcmV2VHlwZSA9PT0gdHlwZXMkMS5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5iX3N0YXQpKVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX2V4cHIpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX3N0YXQpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzJDEuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbClcbiAgICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5xX3RtcGwpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzJDEuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX2Z1bmN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcy5mX2V4cHIpXG4gICAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzLmZfZXhwcl9nZW47IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMuZl9nZW47IH1cbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMkMS5uYW1lLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcyQxLmRvdCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICAgIHRoaXMudmFsdWUgPT09IFwieWllbGRcIiAmJiB0aGlzLmluR2VuZXJhdG9yQ29udGV4dCgpKVxuICAgICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBhbGxvd2VkO1xuICB9O1xuXG4gIC8vIEEgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyIG9wZXJhdGVzIGJ5IGRlZmluaW5nIGZ1bmN0aW9ucyBmb3IgYWxsXG4gIC8vIHN5bnRhY3RpYyBlbGVtZW50cywgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhvc2UsIGVhY2ggZnVuY3Rpb25cbiAgLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuICAvLyBvZiBjb25zdHJ1Y3RzIChmb3IgZXhhbXBsZSwgdGhlIGZhY3QgdGhhdCBgIXhbMV1gIG1lYW5zIGAhKHhbMV0pYFxuICAvLyBpbnN0ZWFkIG9mIGAoIXgpWzFdYCBpcyBoYW5kbGVkIGJ5IHRoZSBmYWN0IHRoYXQgdGhlIHBhcnNlclxuICAvLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4gIC8vIGluIHR1cm4gY2FsbHMgdGhlIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGBbXWAgc3Vic2NyaXB0cyDigJQgdGhhdFxuICAvLyB3YXksIGl0J2xsIHJlY2VpdmUgdGhlIG5vZGUgZm9yIGB4WzFdYCBhbHJlYWR5IHBhcnNlZCwgYW5kIHdyYXBzXG4gIC8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbiAgLy9cbiAgLy8gQWNvcm4gdXNlcyBhbiBbb3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzZXJdW29wcF0gdG8gaGFuZGxlIGJpbmFyeVxuICAvLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbiAgLy8gdGhlIHRlY2huaXF1ZSBvdXRsaW5lZCBhYm92ZSwgd2hpY2ggdXNlcyBkaWZmZXJlbnQsIG5lc3RpbmdcbiAgLy8gZnVuY3Rpb25zIHRvIHNwZWNpZnkgcHJlY2VkZW5jZSwgZm9yIGFsbCBvZiB0aGUgdGVuIGJpbmFyeVxuICAvLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbiAgLy9cbiAgLy8gW29wcF06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0b3ItcHJlY2VkZW5jZV9wYXJzZXJcblxuXG4gIHZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBDaGVjayBpZiBwcm9wZXJ0eSBuYW1lIGNsYXNoZXMgd2l0aCBhbHJlYWR5IGFkZGVkLlxuICAvLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4gIC8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbiAgLy8gc3RyaWN0IG1vZGUsIGluaXQgcHJvcGVydGllcyBhcmUgYWxzbyBub3QgYWxsb3dlZCB0byBiZSByZXBlYXRlZC5cblxuICBwcCQ1LmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICAgIHsgcmV0dXJuIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgICAgeyByZXR1cm4gfVxuICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICB2YXIgbmFtZTtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjogbmFtZSA9IGtleS5uYW1lOyBicmVha1xuICAgIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgICBkZWZhdWx0OiByZXR1cm5cbiAgICB9XG4gICAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiAmJiBraW5kID09PSBcImluaXRcIikge1xuICAgICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPCAwKSB7XG4gICAgICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBrZXkuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gICAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gICAgaWYgKG90aGVyKSB7XG4gICAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgICAgaWYgKGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IHRoaXMuc3RyaWN0ICYmIG90aGVyLmluaXQgfHwgb3RoZXIuZ2V0IHx8IG90aGVyLnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZGVmaW5pdGlvbiA9IG90aGVyLmluaXQgfHwgb3RoZXJba2luZF07XG4gICAgICB9XG4gICAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZhbHNlLFxuICAgICAgICBzZXQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBvdGhlcltraW5kXSA9IHRydWU7XG4gIH07XG5cbiAgLy8gIyMjIEV4cHJlc3Npb24gcGFyc2luZ1xuXG4gIC8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuICAvLyAnYXRvbWljJywgbm9uZGl2aXNpYmxlIGV4cHJlc3Npb24gdHlwZXMgYXQgdGhlIGJvdHRvbS4gTW9zdCBvZlxuICAvLyB0aGUgZnVuY3Rpb25zIHdpbGwgc2ltcGx5IGxldCB0aGUgZnVuY3Rpb24ocykgYmVsb3cgdGhlbSBwYXJzZSxcbiAgLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbiAgLy8gdGhlIEFTVCBub2RlIHRoYXQgdGhlIGlubmVyIHBhcnNlciBnYXZlIHRoZW0gaW4gYW5vdGhlciBub2RlLlxuXG4gIC8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4gIC8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4gIC8vIGFuZCBwcm92aWRlIHJlZmVyZW5jZSBmb3Igc3RvcmluZyAnPScgb3BlcmF0b3IgaW5zaWRlIHNob3J0aGFuZFxuICAvLyBwcm9wZXJ0eSBhc3NpZ25tZW50IGluIGNvbnRleHRzIHdoZXJlIGJvdGggb2JqZWN0IGV4cHJlc3Npb25cbiAgLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuICAvLyBkZWxheWVkIHN5bnRheCBlcnJvciBhdCBjb3JyZWN0IHBvc2l0aW9uKS5cblxuICBwcCQ1LnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzJDEuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cbiAgLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuICAvLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG4gIHBwJDUucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICAgIGlmICh0aGlzLmluR2VuZXJhdG9yKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQoZm9ySW5pdCkgfVxuICAgICAgLy8gVGhlIHRva2VuaXplciB3aWxsIGFzc3VtZSBhbiBleHByZXNzaW9uIGlzIGFsbG93ZWQgYWZ0ZXJcbiAgICAgIC8vIGB5aWVsZGAsIGJ1dCB0aGlzIGlzbid0IHRoYXQga2luZCBvZiB5aWVsZFxuICAgICAgZWxzZSB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIH1cblxuICAgIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMSwgb2xkRG91YmxlUHJvdG8gPSAtMTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgICBvbGRUcmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgICAgb2xkRG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDtcbiAgICAgIHRoaXMucG90ZW50aWFsQXJyb3dJbkZvckF3YWl0ID0gZm9ySW5pdCA9PT0gXCJhd2FpdFwiO1xuICAgIH1cbiAgICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChhZnRlckxlZnRQYXJzZSkgeyBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpOyB9XG4gICAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICAgIHsgbGVmdCA9IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA+PSBsZWZ0LnN0YXJ0KVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IH0gLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGxlZnQpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobGVmdCk7IH1cbiAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCk7XG4gICAgICBpZiAob2xkRG91YmxlUHJvdG8gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0gb2xkRG91YmxlUHJvdG87IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIH1cbiAgICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICAgIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxuICBwcCQ1LnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uKSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLnRlc3QgPSBleHByO1xuICAgICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbG9uKTtcbiAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9O1xuXG4gIC8vIFN0YXJ0IHRoZSBwcmVjZWRlbmNlIHBhcnNlci5cblxuICBwcCQ1LnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSwgZmFsc2UsIGZvckluaXQpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgcmV0dXJuIGV4cHIuc3RhcnQgPT09IHN0YXJ0UG9zICYmIGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID8gZXhwciA6IHRoaXMucGFyc2VFeHByT3AoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCAtMSwgZm9ySW5pdClcbiAgfTtcblxuICAvLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuICAvLyBhbGdvcml0aG0uIGBsZWZ0YCBpcyB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIG9wZXJhdG9yLlxuICAvLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbiAgLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuICAvLyBvcGVyYXRvciB0aGF0IGhhcyBhIGxvd2VyIHByZWNlZGVuY2UgdGhhbiB0aGUgc2V0IGl0IGlzIHBhcnNpbmcuXG5cbiAgcHAkNS5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBmb3JJbml0KSB7XG4gICAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIWZvckluaXQgfHwgdGhpcy50eXBlICE9PSB0eXBlcyQxLl9pbikpIHtcbiAgICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgICB2YXIgbG9naWNhbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQ7XG4gICAgICAgIHZhciBjb2FsZXNjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb2FsZXNjZTtcbiAgICAgICAgaWYgKGNvYWxlc2NlKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIHRoZSBwcmVjZWRlbmNlIG9mIGB0dC5jb2FsZXNjZWAgYXMgZXF1YWwgdG8gdGhlIHJhbmdlIG9mIGxvZ2ljYWwgZXhwcmVzc2lvbnMuXG4gICAgICAgICAgLy8gSW4gb3RoZXIgd29yZHMsIGBub2RlLnJpZ2h0YCBzaG91bGRuJ3QgY29udGFpbiBsb2dpY2FsIGV4cHJlc3Npb25zIGluIG9yZGVyIHRvIGNoZWNrIHRoZSBtaXhlZCBlcnJvci5cbiAgICAgICAgICBwcmVjID0gdHlwZXMkMS5sb2dpY2FsQU5ELmJpbm9wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UsIGZhbHNlLCBmb3JJbml0KSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBmb3JJbml0KTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwgfHwgY29hbGVzY2UpO1xuICAgICAgICBpZiAoKGxvZ2ljYWwgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvYWxlc2NlKSB8fCAoY29hbGVzY2UgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQpKSkge1xuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkxvZ2ljYWwgZXhwcmVzc2lvbnMgYW5kIGNvYWxlc2NlIGV4cHJlc3Npb25zIGNhbm5vdCBiZSBtaXhlZC4gV3JhcCBlaXRoZXIgYnkgcGFyZW50aGVzZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIGZvckluaXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgcHAkNS5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIikgeyB0aGlzLnJhaXNlKHJpZ2h0LnN0YXJ0LCBcIlByaXZhdGUgaWRlbnRpZmllciBjYW4gb25seSBiZSBsZWZ0IHNpZGUgb2YgYmluYXJ5IGV4cHJlc3Npb25cIik7IH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxuICBwcCQ1LnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5LCBpbmNEZWMsIGZvckluaXQpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikgJiYgdGhpcy5jYW5Bd2FpdCkge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdChmb3JJbml0KTtcbiAgICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5wcmVmaXgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgdXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLmluY0RlYztcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSwgdXBkYXRlLCBmb3JJbml0KTtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgaWYgKHVwZGF0ZSkgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmFyZ3VtZW50KTsgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJlxuICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgICAgZWxzZSBpZiAobm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmFyZ3VtZW50KSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJQcml2YXRlIGZpZWxkcyBjYW4gbm90IGJlIGRlbGV0ZWRcIik7IH1cbiAgICAgIGVsc2UgeyBzYXdVbmFyeSA9IHRydWU7IH1cbiAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKCFzYXdVbmFyeSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEucHJpdmF0ZUlkKSB7XG4gICAgICBpZiAoKGZvckluaXQgfHwgdGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aCA9PT0gMCkgJiYgdGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgZXhwciA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICAgIC8vIG9ubHkgY291bGQgYmUgcHJpdmF0ZSBmaWVsZHMgaW4gJ2luJywgc3VjaCBhcyAjeCBpbiBvYmpcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuX2luKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCk7XG4gICAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgIG5vZGUkMS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgICAgbm9kZSQxLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgICAgdGhpcy5jaGVja0xWYWxTaW1wbGUoZXhwcik7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW5jRGVjICYmIHRoaXMuZWF0KHR5cGVzJDEuc3RhcnN0YXIpKSB7XG4gICAgICBpZiAoc2F3VW5hcnkpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UsIGZhbHNlLCBmb3JJbml0KSwgXCIqKlwiLCBmYWxzZSkgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXhwclxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgbm9kZS5wcm9wZXJ0eS50eXBlID09PSBcIlByaXZhdGVJZGVudGlmaWVyXCIgfHxcbiAgICAgIG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmV4cHJlc3Npb24pXG4gICAgKVxuICB9XG5cbiAgLy8gUGFyc2UgY2FsbCwgZG90LCBhbmQgYFtdYC1zdWJzY3JpcHQgZXhwcmVzc2lvbnMuXG5cbiAgcHAkNS5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCkge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0KTtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCIpXG4gICAgICB7IHJldHVybiBleHByIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBmYWxzZSwgZm9ySW5pdCk7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVzdWx0LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSAtMTsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIHBwJDUucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBmb3JJbml0KSB7XG4gICAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgICAgdGhpcy5sYXN0VG9rRW5kID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiBiYXNlLmVuZCAtIGJhc2Uuc3RhcnQgPT09IDUgJiZcbiAgICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0O1xuICAgIHZhciBvcHRpb25hbENoYWluZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCk7XG5cbiAgICAgIGlmIChlbGVtZW50Lm9wdGlvbmFsKSB7IG9wdGlvbmFsQ2hhaW5lZCA9IHRydWU7IH1cbiAgICAgIGlmIChlbGVtZW50ID09PSBiYXNlIHx8IGVsZW1lbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgICB2YXIgY2hhaW5Ob2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgIGNoYWluTm9kZS5leHByZXNzaW9uID0gZWxlbWVudDtcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5maW5pc2hOb2RlKGNoYWluTm9kZSwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICAgIH1cblxuICAgICAgYmFzZSA9IGVsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDUuc2hvdWxkUGFyc2VBc3luY0Fycm93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzJDEuYXJyb3cpXG4gIH07XG5cbiAgcHAkNS5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3cgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgdHJ1ZSwgZm9ySW5pdClcbiAgfTtcblxuICBwcCQ1LnBhcnNlU3Vic2NyaXB0ID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCkge1xuICAgIHZhciBvcHRpb25hbFN1cHBvcnRlZCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgICB2YXIgb3B0aW9uYWwgPSBvcHRpb25hbFN1cHBvcnRlZCAmJiB0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uRG90KTtcbiAgICBpZiAobm9DYWxscyAmJiBvcHRpb25hbCkgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIGNhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbnNcIik7IH1cblxuICAgIHZhciBjb21wdXRlZCA9IHRoaXMuZWF0KHR5cGVzJDEuYnJhY2tldEwpO1xuICAgIGlmIChjb21wdXRlZCB8fCAob3B0aW9uYWwgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuTCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYmFja1F1b3RlKSB8fCB0aGlzLmVhdCh0eXBlcyQxLmRvdCkpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNrZXRSKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCAmJiBiYXNlLnR5cGUgIT09IFwiU3VwZXJcIikge1xuICAgICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVJZGVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICAgICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIH1cbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMkMS5wYXJlbkwpKSB7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzJDEucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhb3B0aW9uYWwgJiYgdGhpcy5zaG91bGRQYXJzZUFzeW5jQXJyb3coKSkge1xuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIGlmICh0aGlzLmF3YWl0SWRlbnRQb3MgPiAwKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0SWRlbnRQb3MsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3coc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdClcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3MgfHwgdGhpcy5hd2FpdElkZW50UG9zO1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMS5jYWxsZWUgPSBiYXNlO1xuICAgICAgbm9kZSQxLmFyZ3VtZW50cyA9IGV4cHJMaXN0O1xuICAgICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICAgIG5vZGUkMS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgfVxuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuYmFja1F1b3RlKSB7XG4gICAgICBpZiAob3B0aW9uYWwgfHwgb3B0aW9uYWxDaGFpbmVkKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSB0YWcgb2YgdGFnZ2VkIHRlbXBsYXRlIGV4cHJlc3Npb25zXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgICAgbm9kZSQyLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVxuICB9O1xuXG4gIC8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuICAvLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuICAvLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbiAgLy8gb3IgYHt9YC5cblxuICBwcCQ1LnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0LCBmb3JOZXcpIHtcbiAgICAvLyBJZiBhIGRpdmlzaW9uIG9wZXJhdG9yIGFwcGVhcnMgaW4gYW4gZXhwcmVzc2lvbiBwb3NpdGlvbiwgdGhlXG4gICAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNsYXNoKSB7IHRoaXMucmVhZFJlZ2V4cCgpOyB9XG5cbiAgICB2YXIgbm9kZSwgY2FuQmVBcnJvdyA9IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGFydDtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMkMS5fc3VwZXI6XG4gICAgICBpZiAoIXRoaXMuYWxsb3dTdXBlcilcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJzdXBlcigpIGNhbGwgb3V0c2lkZSBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzXCIpOyB9XG4gICAgICAvLyBUaGUgYHN1cGVyYCBrZXl3b3JkIGNhbiBhcHBlYXIgYXQgYmVsb3c6XG4gICAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgICAgLy8gICAgIHN1cGVyIFsgRXhwcmVzc2lvbiBdXG4gICAgICAvLyAgICAgc3VwZXIgLiBJZGVudGlmaWVyTmFtZVxuICAgICAgLy8gU3VwZXJDYWxsOlxuICAgICAgLy8gICAgIHN1cGVyICggQXJndW1lbnRzIClcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuZG90ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFja2V0TCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEucGFyZW5MKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICAgIGNhc2UgdHlwZXMkMS5fdGhpczpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHlwZXMkMS5uYW1lOlxuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5fZnVuY3Rpb24pKSB7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVDb250ZXh0KHR5cGVzLmZfZXhwcik7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCAwLCBmYWxzZSwgdHJ1ZSwgZm9ySW5pdClcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmFycm93KSlcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UsIGZvckluaXQpIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICghdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgfHwgdGhpcy52YWx1ZSAhPT0gXCJvZlwiIHx8IHRoaXMuY29udGFpbnNFc2MpKSB7XG4gICAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLmVhdCh0eXBlcyQxLmFycm93KSlcbiAgICAgICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUsIGZvckluaXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZFxuXG4gICAgY2FzZSB0eXBlcyQxLnJlZ2V4cDpcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWx1ZS5wYXR0ZXJuLCBmbGFnczogdmFsdWUuZmxhZ3N9O1xuICAgICAgcmV0dXJuIG5vZGVcblxuICAgIGNhc2UgdHlwZXMkMS5udW06IGNhc2UgdHlwZXMkMS5zdHJpbmc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSlcblxuICAgIGNhc2UgdHlwZXMkMS5fbnVsbDogY2FzZSB0eXBlcyQxLl90cnVlOiBjYXNlIHR5cGVzJDEuX2ZhbHNlOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9udWxsID8gbnVsbCA6IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fdHJ1ZTtcbiAgICAgIG5vZGUucmF3ID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgICBjYXNlIHR5cGVzJDEucGFyZW5MOlxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93LCBmb3JJbml0KTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwICYmICF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIpKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHN0YXJ0OyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwclxuXG4gICAgY2FzZSB0eXBlcyQxLmJyYWNrZXRMOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMkMS5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgICBjYXNlIHR5cGVzJDEuYnJhY2VMOlxuICAgICAgdGhpcy5vdmVycmlkZUNvbnRleHQodHlwZXMuYl9leHByKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gICAgY2FzZSB0eXBlcyQxLl9mdW5jdGlvbjpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDApXG5cbiAgICBjYXNlIHR5cGVzJDEuX2NsYXNzOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICAgIGNhc2UgdHlwZXMkMS5fbmV3OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gICAgY2FzZSB0eXBlcyQxLmJhY2tRdW90ZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gICAgY2FzZSB0eXBlcyQxLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckltcG9ydChmb3JOZXcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tRGVmYXVsdCgpXG4gICAgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VFeHByQXRvbURlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfTtcblxuICBwcCQ1LnBhcnNlRXhwckltcG9ydCA9IGZ1bmN0aW9uKGZvck5ldykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIC8vIENvbnN1bWUgYGltcG9ydGAgYXMgYW4gaWRlbnRpZmllciBmb3IgYGltcG9ydC5tZXRhYC5cbiAgICAvLyBCZWNhdXNlIGB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlgIGRvZXNuJ3QgY2hlY2sgZXNjYXBlIHNlcXVlbmNlcywgaXQgbmVlZHMgdGhlIGNoZWNrIG9mIGB0aGlzLmNvbnRhaW5zRXNjYC5cbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBpbXBvcnRcIik7IH1cbiAgICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MICYmICFmb3JOZXcpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydChub2RlKVxuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmRvdCkge1xuICAgICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0TWV0YShub2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkNS5wYXJzZUR5bmFtaWNJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7IC8vIHNraXAgYChgXG5cbiAgICAvLyBQYXJzZSBub2RlLnNvdXJjZS5cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuXG4gICAgLy8gVmVyaWZ5IGVuZGluZy5cbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEucGFyZW5SKSkge1xuICAgICAgdmFyIGVycm9yUG9zID0gdGhpcy5zdGFydDtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSAmJiB0aGlzLmVhdCh0eXBlcyQxLnBhcmVuUikpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVycm9yUG9zLCBcIlRyYWlsaW5nIGNvbW1hIGlzIG5vdCBhbGxvd2VkIGluIGltcG9ydCgpXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKGVycm9yUG9zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VJbXBvcnRNZXRhID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpOyAvLyBza2lwIGAuYFxuXG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuXG4gICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJtZXRhXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIGltcG9ydCBpcyAnaW1wb3J0Lm1ldGEnXCIpOyB9XG4gICAgaWYgKGNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInaW1wb3J0Lm1ldGEnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzXCIpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlICE9PSBcIm1vZHVsZVwiICYmICF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdpbXBvcnQubWV0YScgb3V0c2lkZSBhIG1vZHVsZVwiKTsgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgaWYgKG5vZGUucmF3LmNoYXJDb2RlQXQobm9kZS5yYXcubGVuZ3RoIC0gMSkgPT09IDExMCkgeyBub2RlLmJpZ2ludCA9IG5vZGUucmF3LnNsaWNlKDAsIC0xKS5yZXBsYWNlKC9fL2csIFwiXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbiAgfTtcblxuICBwcCQ1LnBhcnNlUGFyZW5FeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICAgIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcbiAgICByZXR1cm4gdmFsXG4gIH07XG5cbiAgcHAkNS5zaG91bGRQYXJzZUFycm93ID0gZnVuY3Rpb24oZXhwckxpc3QpIHtcbiAgICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKClcbiAgfTtcblxuICBwcCQ1LnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24gPSBmdW5jdGlvbihjYW5CZUFycm93LCBmb3JJbml0KSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycywgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIHNwcmVhZFN0YXJ0O1xuICAgICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAgIC8vIERvIG5vdCBzYXZlIGF3YWl0SWRlbnRQb3MgdG8gYWxsb3cgY2hlY2tpbmcgYXdhaXRzIG5lc3RlZCBpbiBwYXJhbWV0ZXJzXG4gICAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuUikge1xuICAgICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLnBhcmVuUiwgdHJ1ZSkpIHtcbiAgICAgICAgICBsYXN0SXNDb21tYSA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZWxsaXBzaXMpIHtcbiAgICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKFxuICAgICAgICAgICAgICB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgICBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0aGlzLnBhcnNlUGFyZW5JdGVtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpbm5lckVuZFBvcyA9IHRoaXMubGFzdFRva0VuZCwgaW5uZXJFbmRMb2MgPSB0aGlzLmxhc3RUb2tFbmRMb2M7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG5cbiAgICAgIGlmIChjYW5CZUFycm93ICYmIHRoaXMuc2hvdWxkUGFyc2VBcnJvdyhleHByTGlzdCkgJiYgdGhpcy5lYXQodHlwZXMkMS5hcnJvdykpIHtcbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgICBpZiAoc3ByZWFkU3RhcnQpIHsgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTsgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuXG4gICAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgICB2YXIgcGFyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICB9O1xuXG4gIHBwJDUucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1cbiAgfTtcblxuICBwcCQ1LnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgZmFsc2UsIGZvckluaXQpXG4gIH07XG5cbiAgLy8gTmV3J3MgcHJlY2VkZW5jZSBpcyBzbGlnaHRseSB0cmlja3kuIEl0IG11c3QgYWxsb3cgaXRzIGFyZ3VtZW50IHRvXG4gIC8vIGJlIGEgYFtdYCBvciBkb3Qgc3Vic2NyaXB0IGV4cHJlc3Npb24sIGJ1dCBub3QgYSBjYWxsIOKAlCBhdCBsZWFzdCxcbiAgLy8gbm90IHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gcGFyZW50aGVzZXMuIFRodXMsIGl0IHVzZXMgdGhlIG5vQ2FsbHNcbiAgLy8gYXJndW1lbnQgdG8gcGFyc2VTdWJzY3JpcHRzIHRvIHByZXZlbnQgaXQgZnJvbSBjb25zdW1pbmcgdGhlXG4gIC8vIGFyZ3VtZW50IGxpc3QuXG5cbiAgdmFyIGVtcHR5ID0gW107XG5cbiAgcHAkNS5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIG5ld1wiKTsgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodHlwZXMkMS5kb3QpKSB7XG4gICAgICBub2RlLm1ldGEgPSBtZXRhO1xuICAgICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcInRhcmdldFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyAnbmV3LnRhcmdldCdcIik7IH1cbiAgICAgIGlmIChjb250YWluc0VzYylcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInbmV3LnRhcmdldCcgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnNcIik7IH1cbiAgICAgIGlmICghdGhpcy5hbGxvd05ld0RvdFRhcmdldClcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInbmV3LnRhcmdldCcgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnMgYW5kIGNsYXNzIHN0YXRpYyBibG9ja1wiKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICAgIH1cbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20obnVsbCwgZmFsc2UsIHRydWUpLCBzdGFydFBvcywgc3RhcnRMb2MsIHRydWUsIGZhbHNlKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMkMS5wYXJlbkwpKSB7IG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzJDEucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UpOyB9XG4gICAgZWxzZSB7IG5vZGUuYXJndW1lbnRzID0gZW1wdHk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIHRlbXBsYXRlIGV4cHJlc3Npb24uXG5cbiAgcHAkNS5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHJlZikge1xuICAgIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDtcblxuICAgIHZhciBlbGVtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSkge1xuICAgICAgaWYgKCFpc1RhZ2dlZCkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJCYWQgZXNjYXBlIHNlcXVlbmNlIGluIHVudGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcIik7XG4gICAgICB9XG4gICAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgICByYXc6IHRoaXMudmFsdWUsXG4gICAgICAgIGNvb2tlZDogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgICBjb29rZWQ6IHRoaXMudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGVsZW0udGFpbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5iYWNrUXVvdGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7IGlmICggaXNUYWdnZWQgPT09IHZvaWQgMCApIGlzVGFnZ2VkID0gZmFsc2U7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICAgIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KTtcbiAgICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuICAgIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZW9mKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWxcIik7IH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuZG9sbGFyQnJhY2VMKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VSKTtcbiAgICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSkpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpXG4gIH07XG5cbiAgcHAkNS5pc0FzeW5jUHJvcCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICAodGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5icmFja2V0TCB8fCB0aGlzLnR5cGUua2V5d29yZCB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0YXIpKSAmJlxuICAgICAgIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgfTtcblxuICAvLyBQYXJzZSBhbiBvYmplY3QgbGl0ZXJhbCBvciBiaW5kaW5nIHBhdHRlcm4uXG5cbiAgcHAkNS5wYXJzZU9iaiA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBwcm9wSGFzaCA9IHt9O1xuICAgIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHkoaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmICghaXNQYXR0ZXJuKSB7IHRoaXMuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1BhdHRlcm4gPyBcIk9iamVjdFBhdHRlcm5cIiA6IFwiT2JqZWN0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBwcm9wID0gdGhpcy5zdGFydE5vZGUoKSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYztcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMkMS5lbGxpcHNpcykpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB9XG4gICAgICAvLyBQYXJzZSBhcmd1bWVudC5cbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgLy8gVG8gZGlzYWxsb3cgdHJhaWxpbmcgY29tbWEgdmlhIGB0aGlzLnRvQXNzaWduYWJsZSgpYC5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgICAvLyBGaW5pc2hcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUGF0dGVybilcbiAgICAgICAgeyBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzJDEuc3Rhcik7IH1cbiAgICB9XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5pc0FzeW5jUHJvcChwcm9wKSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzJDEuc3Rhcik7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FzeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VHZXR0ZXJTZXR0ZXIgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcHJvcC5raW5kID0gcHJvcC5rZXkubmFtZTtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGZhbHNlKTtcbiAgICB2YXIgcGFyYW1Db3VudCA9IHByb3Aua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIHZhciBzdGFydCA9IHByb3AudmFsdWUuc3RhcnQ7XG4gICAgICBpZiAocHJvcC5raW5kID09PSBcImdldFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcC5raW5kID09PSBcInNldFwiICYmIHByb3AudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocHJvcC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgICB9XG4gIH07XG5cbiAgcHAkNS5wYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKSB7XG4gICAgaWYgKChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29sb24pXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMkMS5jb2xvbikpIHtcbiAgICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCkge1xuICAgICAgaWYgKGlzUGF0dGVybikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBwcm9wLm1ldGhvZCA9IHRydWU7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gICAgfSBlbHNlIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJlxuICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcbiAgICAgICAgICAgICAgIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmXG4gICAgICAgICAgICAgICAodGhpcy50eXBlICE9PSB0eXBlcyQxLmNvbW1hICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmVxKSkge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMucGFyc2VHZXR0ZXJTZXR0ZXIocHJvcCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICAgIGlmIChwcm9wLmtleS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBzdGFydFBvczsgfVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgdGhpcy5jb3B5Tm9kZShwcm9wLmtleSkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSB0aGlzLnN0YXJ0OyB9XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgdGhpcy5jb3B5Tm9kZShwcm9wLmtleSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMuY29weU5vZGUocHJvcC5rZXkpO1xuICAgICAgfVxuICAgICAgcHJvcC5zaG9ydGhhbmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgcHAkNS5wYXJzZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmJyYWNrZXRMKSkge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFja2V0Uik7XG4gICAgICAgIHJldHVybiBwcm9wLmtleVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcC5rZXkgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKVxuICB9O1xuXG4gIC8vIEluaXRpYWxpemUgZW1wdHkgZnVuY3Rpb24gbm9kZS5cblxuICBwcCQ1LmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmlkID0gbnVsbDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgbm9kZS5nZW5lcmF0b3IgPSBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gZmFsc2U7IH1cbiAgfTtcblxuICAvLyBQYXJzZSBvYmplY3Qgb3IgY2xhc3MgbWV0aG9kLlxuXG4gIHBwJDUucGFyc2VNZXRob2QgPSBmdW5jdGlvbihpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dEaXJlY3RTdXBlcikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgICB7IG5vZGUuZ2VuZXJhdG9yID0gaXNHZW5lcmF0b3I7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpIHwgU0NPUEVfU1VQRVIgfCAoYWxsb3dEaXJlY3RTdXBlciA/IFNDT1BFX0RJUkVDVF9TVVBFUiA6IDApKTtcblxuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcyQxLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UsIHRydWUsIGZhbHNlKTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMuXG5cbiAgcHAkNS5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYywgZm9ySW5pdCkge1xuICAgIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICAgIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIGZhbHNlKSB8IFNDT1BFX0FSUk9XKTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcblxuICAgIG5vZGUucGFyYW1zID0gdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBmYWxzZSwgZm9ySW5pdCk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cblxuICBwcCQ1LnBhcnNlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24obm9kZSwgaXNBcnJvd0Z1bmN0aW9uLCBpc01ldGhvZCwgZm9ySW5pdCkge1xuICAgIHZhciBpc0V4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlTDtcbiAgICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3QsIHVzZVN0cmljdCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9uU2ltcGxlID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgICAgaWYgKCFvbGRTdHJpY3QgfHwgbm9uU2ltcGxlKSB7XG4gICAgICAgIHVzZVN0cmljdCA9IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMuZW5kKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmljdCBtb2RlIGZ1bmN0aW9uLCB2ZXJpZnkgdGhhdCBhcmd1bWVudCBuYW1lc1xuICAgICAgICAvLyBhcmUgbm90IHJlcGVhdGVkLCBhbmQgaXQgZG9lcyBub3QgdHJ5IHRvIGJpbmQgdGhlIHdvcmRzIGBldmFsYFxuICAgICAgICAvLyBvciBgYXJndW1lbnRzYC5cbiAgICAgICAgaWYgKHVzZVN0cmljdCAmJiBub25TaW1wbGUpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpOyB9XG4gICAgICB9XG4gICAgICAvLyBTdGFydCBhIG5ldyBzY29wZSB3aXRoIHJlZ2FyZCB0byBsYWJlbHMgYW5kIHRoZSBgaW5GdW5jdGlvbmBcbiAgICAgIC8vIGZsYWcgKHJlc3RvcmUgdGhlbSB0byB0aGVpciBvbGQgdmFsdWUgYWZ0ZXJ3YXJkcykuXG4gICAgICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgICAgaWYgKHVzZVN0cmljdCkgeyB0aGlzLnN0cmljdCA9IHRydWU7IH1cblxuICAgICAgLy8gQWRkIHRoZSBwYXJhbXMgdG8gdmFyRGVjbGFyZWROYW1lcyB0byBlbnN1cmUgdGhhdCBhbiBlcnJvciBpcyB0aHJvd25cbiAgICAgIC8vIGlmIGEgbGV0L2NvbnN0IGRlY2xhcmF0aW9uIGluIHRoZSBmdW5jdGlvbiBjbGFzaGVzIHdpdGggb25lIG9mIHRoZSBwYXJhbXMuXG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICFvbGRTdHJpY3QgJiYgIXVzZVN0cmljdCAmJiAhaXNBcnJvd0Z1bmN0aW9uICYmICFpc01ldGhvZCAmJiB0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKSk7XG4gICAgICAvLyBFbnN1cmUgdGhlIGZ1bmN0aW9uIG5hbWUgaXNuJ3QgYSBmb3JiaWRkZW4gaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZSwgZS5nLiAnZXZhbCdcbiAgICAgIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLmlkKSB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuaWQsIEJJTkRfT1VUU0lERSk7IH1cbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSwgdW5kZWZpbmVkLCB1c2VTdHJpY3QgJiYgIW9sZFN0cmljdCk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkuYm9keSk7XG4gICAgICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcbiAgICB9XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgfTtcblxuICBwcCQ1LmlzU2ltcGxlUGFyYW1MaXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7IHJldHVybiBmYWxzZVxuICAgIH0gfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLy8gQ2hlY2tzIGZ1bmN0aW9uIHBhcmFtcyBmb3IgdmFyaW91cyBkaXNhbGxvd2VkIHBhdHRlcm5zIHN1Y2ggYXMgdXNpbmcgXCJldmFsXCJcbiAgLy8gb3IgXCJhcmd1bWVudHNcIiBhbmQgZHVwbGljYXRlIHBhcmFtZXRlcnMuXG5cbiAgcHAkNS5jaGVja1BhcmFtcyA9IGZ1bmN0aW9uKG5vZGUsIGFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBuYW1lSGFzaCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihwYXJhbSwgQklORF9WQVIsIGFsbG93RHVwbGljYXRlcyA/IG51bGwgOiBuYW1lSGFzaCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGV4cHJlc3Npb25zLCBhbmQgcmV0dXJucyB0aGVtIGFzXG4gIC8vIGFuIGFycmF5LiBgY2xvc2VgIGlzIHRoZSB0b2tlbiB0eXBlIHRoYXQgZW5kcyB0aGUgbGlzdCwgYW5kXG4gIC8vIGBhbGxvd0VtcHR5YCBjYW4gYmUgdHVybmVkIG9uIHRvIGFsbG93IHN1YnNlcXVlbnQgY29tbWFzIHdpdGhcbiAgLy8gbm90aGluZyBpbiBiZXR3ZWVuIHRoZW0gdG8gYmUgcGFyc2VkIGFzIGBudWxsYCAod2hpY2ggaXMgbmVlZGVkXG4gIC8vIGZvciBhcnJheSBsaXRlcmFscykuXG5cbiAgcHAkNS5wYXJzZUV4cHJMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dFbXB0eSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWx0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpXG4gICAgICAgIHsgZWx0ID0gbnVsbDsgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVsbGlwc2lzKSB7XG4gICAgICAgIGVsdCA9IHRoaXMucGFyc2VTcHJlYWQocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWx0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaChlbHQpO1xuICAgIH1cbiAgICByZXR1cm4gZWx0c1xuICB9O1xuXG4gIHBwJDUuY2hlY2tVbnJlc2VydmVkID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgdmFyIHN0YXJ0ID0gcmVmLnN0YXJ0O1xuICAgIHZhciBlbmQgPSByZWYuZW5kO1xuICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG5cbiAgICBpZiAodGhpcy5pbkdlbmVyYXRvciAmJiBuYW1lID09PSBcInlpZWxkXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIGlmICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0ICYmIG5hbWUgPT09IFwiYXJndW1lbnRzXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICdhcmd1bWVudHMnIGluIGNsYXNzIGZpZWxkIGluaXRpYWxpemVyXCIpOyB9XG4gICAgaWYgKHRoaXMuaW5DbGFzc1N0YXRpY0Jsb2NrICYmIChuYW1lID09PSBcImFyZ3VtZW50c1wiIHx8IG5hbWUgPT09IFwiYXdhaXRcIikpXG4gICAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIkNhbm5vdCB1c2UgXCIgKyBuYW1lICsgXCIgaW4gY2xhc3Mgc3RhdGljIGluaXRpYWxpemF0aW9uIGJsb2NrXCIpKTsgfVxuICAgIGlmICh0aGlzLmtleXdvcmRzLnRlc3QobmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIlVuZXhwZWN0ZWQga2V5d29yZCAnXCIgKyBuYW1lICsgXCInXCIpKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgICB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkgeyByZXR1cm4gfVxuICAgIHZhciByZSA9IHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzO1xuICAgIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2Uga2V5d29yZCAnYXdhaXQnIG91dHNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4gIC8vIHdoZW4gcGFyc2luZyBwcm9wZXJ0aWVzKSwgaXQgd2lsbCBhbHNvIGNvbnZlcnQga2V5d29yZHMgaW50b1xuICAvLyBpZGVudGlmaWVycy5cblxuICBwcCQ1LnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlSWRlbnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCEhbGliZXJhbCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgICBpZiAoIWxpYmVyYWwpIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUpO1xuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gbm9kZS5zdGFydDsgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIHBwJDUucGFyc2VJZGVudE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtleXdvcmQpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRoaXMudHlwZS5rZXl3b3JkO1xuXG4gICAgICAvLyBUbyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzLzU3NVxuICAgICAgLy8gYGNsYXNzYCBhbmQgYGZ1bmN0aW9uYCBrZXl3b3JkcyBwdXNoIG5ldyBjb250ZXh0IGludG8gdGhpcy5jb250ZXh0LlxuICAgICAgLy8gQnV0IHRoZXJlIGlzIG5vIGNoYW5jZSB0byBwb3AgdGhlIGNvbnRleHQgaWYgdGhlIGtleXdvcmQgaXMgY29uc3VtZWQgYXMgYW4gaWRlbnRpZmllciBzdWNoIGFzIGEgcHJvcGVydHkgbmFtZS5cbiAgICAgIC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBhIGRvdCwgdGhpcyBkb2VzIG5vdCBhcHBseSBiZWNhdXNlIHRoZSBjb250ZXh0LW1hbmFnaW5nIGNvZGUgYWxyZWFkeSBpZ25vcmVkIHRoZSBrZXl3b3JkXG4gICAgICBpZiAoKG5vZGUubmFtZSA9PT0gXCJjbGFzc1wiIHx8IG5vZGUubmFtZSA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAodGhpcy5sYXN0VG9rRW5kICE9PSB0aGlzLmxhc3RUb2tTdGFydCArIDEgfHwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubGFzdFRva1N0YXJ0KSAhPT0gNDYpKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkNS5wYXJzZVByaXZhdGVJZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByaXZhdGVJZGVudGlmaWVyXCIpO1xuXG4gICAgLy8gRm9yIHZhbGlkYXRpbmcgZXhpc3RlbmNlXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jaGVja1ByaXZhdGVGaWVsZHMpIHtcbiAgICAgIGlmICh0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgKFwiUHJpdmF0ZSBmaWVsZCAnI1wiICsgKG5vZGUubmFtZSkgKyBcIicgbXVzdCBiZSBkZWNsYXJlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3NcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcml2YXRlTmFtZVN0YWNrW3RoaXMucHJpdmF0ZU5hbWVTdGFjay5sZW5ndGggLSAxXS51c2VkLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICAvLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG4gIHBwJDUucGFyc2VZaWVsZCA9IGZ1bmN0aW9uKGZvckluaXQpIHtcbiAgICBpZiAoIXRoaXMueWllbGRQb3MpIHsgdGhpcy55aWVsZFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNlbWkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAodGhpcy50eXBlICE9PSB0eXBlcyQxLnN0YXIgJiYgIXRoaXMudHlwZS5zdGFydHNFeHByKSkge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDUucGFyc2VBd2FpdCA9IGZ1bmN0aW9uKGZvckluaXQpIHtcbiAgICBpZiAoIXRoaXMuYXdhaXRQb3MpIHsgdGhpcy5hd2FpdFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSwgZmFsc2UsIGZvckluaXQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIilcbiAgfTtcblxuICB2YXIgcHAkNCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMgb24gcGFyc2UgZXJyb3JzLiBJdFxuICAvLyB0YWtlcyBhbiBvZmZzZXQgaW50ZWdlciAoaW50byB0aGUgY3VycmVudCBgaW5wdXRgKSB0byBpbmRpY2F0ZVxuICAvLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuICAvLyBvZiB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIHRoZW4gcmFpc2VzIGEgYFN5bnRheEVycm9yYCB3aXRoIHRoYXRcbiAgLy8gbWVzc2FnZS5cblxuICBwcCQ0LnJhaXNlID0gZnVuY3Rpb24ocG9zLCBtZXNzYWdlKSB7XG4gICAgdmFyIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gICAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICAgIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gICAgZXJyLnBvcyA9IHBvczsgZXJyLmxvYyA9IGxvYzsgZXJyLnJhaXNlZEF0ID0gdGhpcy5wb3M7XG4gICAgdGhyb3cgZXJyXG4gIH07XG5cbiAgcHAkNC5yYWlzZVJlY292ZXJhYmxlID0gcHAkNC5yYWlzZTtcblxuICBwcCQ0LmN1clBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0KVxuICAgIH1cbiAgfTtcblxuICB2YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgdmFyIFNjb3BlID0gZnVuY3Rpb24gU2NvcGUoZmxhZ3MpIHtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgLy8gQSBsaXN0IG9mIHZhci1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gICAgdGhpcy52YXIgPSBbXTtcbiAgICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgICB0aGlzLmxleGljYWwgPSBbXTtcbiAgICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIEZ1bmN0aW9uRGVjbGFyYXRpb24gbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICAgIHRoaXMuZnVuY3Rpb25zID0gW107XG4gICAgLy8gQSBzd2l0Y2ggdG8gZGlzYWxsb3cgdGhlIGlkZW50aWZpZXIgcmVmZXJlbmNlICdhcmd1bWVudHMnXG4gICAgdGhpcy5pbkNsYXNzRmllbGRJbml0ID0gZmFsc2U7XG4gIH07XG5cbiAgLy8gVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBrZWVwIHRyYWNrIG9mIGRlY2xhcmVkIHZhcmlhYmxlcyBpbiB0aGUgY3VycmVudCBzY29wZSBpbiBvcmRlciB0byBkZXRlY3QgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWVzLlxuXG4gIHBwJDMuZW50ZXJTY29wZSA9IGZ1bmN0aW9uKGZsYWdzKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnB1c2gobmV3IFNjb3BlKGZsYWdzKSk7XG4gIH07XG5cbiAgcHAkMy5leGl0U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG4gIH07XG5cbiAgLy8gVGhlIHNwZWMgc2F5czpcbiAgLy8gPiBBdCB0aGUgdG9wIGxldmVsIG9mIGEgZnVuY3Rpb24sIG9yIHNjcmlwdCwgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGFyZVxuICAvLyA+IHRyZWF0ZWQgbGlrZSB2YXIgZGVjbGFyYXRpb25zIHJhdGhlciB0aGFuIGxpa2UgbGV4aWNhbCBkZWNsYXJhdGlvbnMuXG4gIHBwJDMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUgPSBmdW5jdGlvbihzY29wZSkge1xuICAgIHJldHVybiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgfHwgIXRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKVxuICB9O1xuXG4gIHBwJDMuZGVjbGFyZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKSB7XG4gICAgdmFyIHJlZGVjbGFyZWQgPSBmYWxzZTtcbiAgICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIHJlZGVjbGFyZWQgPSBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLnZhci5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgICBzY29wZS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX1NJTVBMRV9DQVRDSCkge1xuICAgICAgdmFyIHNjb3BlJDEgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgc2NvcGUkMS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9GVU5DVElPTikge1xuICAgICAgdmFyIHNjb3BlJDIgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgaWYgKHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhcilcbiAgICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlJDIudmFyLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgICAgc2NvcGUkMi5mdW5jdGlvbnMucHVzaChuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgc2NvcGUkMyA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgICAgaWYgKHNjb3BlJDMubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgJiYgISgoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1NJTVBMRV9DQVRDSCkgJiYgc2NvcGUkMy5sZXhpY2FsWzBdID09PSBuYW1lKSB8fFxuICAgICAgICAgICAgIXRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUoc2NvcGUkMykgJiYgc2NvcGUkMy5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgICAgcmVkZWNsYXJlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzY29wZSQzLnZhci5wdXNoKG5hbWUpO1xuICAgICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgICAgIGlmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVkFSKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZGVjbGFyZWQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgKFwiSWRlbnRpZmllciAnXCIgKyBuYW1lICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWRcIikpOyB9XG4gIH07XG5cbiAgcHAkMy5jaGVja0xvY2FsRXhwb3J0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAvLyBzY29wZS5mdW5jdGlvbnMgbXVzdCBiZSBlbXB0eSBhcyBNb2R1bGUgY29kZSBpcyBhbHdheXMgc3RyaWN0LlxuICAgIGlmICh0aGlzLnNjb3BlU3RhY2tbMF0ubGV4aWNhbC5pbmRleE9mKGlkLm5hbWUpID09PSAtMSAmJlxuICAgICAgICB0aGlzLnNjb3BlU3RhY2tbMF0udmFyLmluZGV4T2YoaWQubmFtZSkgPT09IC0xKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbaWQubmFtZV0gPSBpZDtcbiAgICB9XG4gIH07XG5cbiAgcHAkMy5jdXJyZW50U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXVxuICB9O1xuXG4gIHBwJDMuY3VycmVudFZhclNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9WQVIpIHsgcmV0dXJuIHNjb3BlIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ291bGQgYmUgdXNlZnVsIGZvciBgdGhpc2AsIGBuZXcudGFyZ2V0YCwgYHN1cGVyKClgLCBgc3VwZXIucHJvcGVydHlgLCBhbmQgYHN1cGVyW3Byb3BlcnR5XWAuXG4gIHBwJDMuY3VycmVudFRoaXNTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSICYmICEoc2NvcGUuZmxhZ3MgJiBTQ09QRV9BUlJPVykpIHsgcmV0dXJuIHNjb3BlIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgICB0aGlzLnR5cGUgPSBcIlwiO1xuICAgIHRoaXMuc3RhcnQgPSBwb3M7XG4gICAgdGhpcy5lbmQgPSAwO1xuICAgIGlmIChwYXJzZXIub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHBhcnNlciwgbG9jKTsgfVxuICAgIGlmIChwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuICAgICAgeyB0aGlzLnNvdXJjZUZpbGUgPSBwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlOyB9XG4gICAgaWYgKHBhcnNlci5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgdGhpcy5yYW5nZSA9IFtwb3MsIDBdOyB9XG4gIH07XG5cbiAgLy8gU3RhcnQgYW4gQVNUIG5vZGUsIGF0dGFjaGluZyBhIHN0YXJ0IG9mZnNldC5cblxuICB2YXIgcHAkMiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgcHAkMi5zdGFydE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5zdGFydCwgdGhpcy5zdGFydExvYylcbiAgfTtcblxuICBwcCQyLnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24ocG9zLCBsb2MpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgcG9zLCBsb2MpXG4gIH07XG5cbiAgLy8gRmluaXNoIGFuIEFTVCBub2RlLCBhZGRpbmcgYHR5cGVgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzLlxuXG4gIGZ1bmN0aW9uIGZpbmlzaE5vZGVBdChub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICAgIG5vZGUudHlwZSA9IHR5cGU7XG4gICAgbm9kZS5lbmQgPSBwb3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IG5vZGUubG9jLmVuZCA9IGxvYzsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyBub2RlLnJhbmdlWzFdID0gcG9zOyB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIHBwJDIuZmluaXNoTm9kZSA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUpIHtcbiAgICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgdGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpXG4gIH07XG5cbiAgLy8gRmluaXNoIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cblxuICBwcCQyLmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHBvcywgbG9jKVxuICB9O1xuXG4gIHBwJDIuY29weU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIG5ld05vZGUgPSBuZXcgTm9kZSh0aGlzLCBub2RlLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG5vZGUpIHsgbmV3Tm9kZVtwcm9wXSA9IG5vZGVbcHJvcF07IH1cbiAgICByZXR1cm4gbmV3Tm9kZVxuICB9O1xuXG4gIC8vIFRoaXMgZmlsZSBjb250YWlucyBVbmljb2RlIHByb3BlcnRpZXMgZXh0cmFjdGVkIGZyb20gdGhlIEVDTUFTY3JpcHQgc3BlY2lmaWNhdGlvbi5cbiAgLy8gVGhlIGxpc3RzIGFyZSBleHRyYWN0ZWQgbGlrZSBzbzpcbiAgLy8gJCQoJyN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzID4gZmlndXJlID4gdGFibGUgPiB0Ym9keSA+IHRyID4gdGQ6bnRoLWNoaWxkKDEpIGNvZGUnKS5tYXAoZWwgPT4gZWwuaW5uZXJUZXh0KVxuXG4gIC8vICN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzXG4gIHZhciBlY21hOUJpbmFyeVByb3BlcnRpZXMgPSBcIkFTQ0lJIEFTQ0lJX0hleF9EaWdpdCBBSGV4IEFscGhhYmV0aWMgQWxwaGEgQW55IEFzc2lnbmVkIEJpZGlfQ29udHJvbCBCaWRpX0MgQmlkaV9NaXJyb3JlZCBCaWRpX00gQ2FzZV9JZ25vcmFibGUgQ0kgQ2FzZWQgQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQgQ1dDRiBDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNIENoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkIENXTCBDaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkIENXS0NGIENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVCBDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZCBDV1UgRGFzaCBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJIERlcHJlY2F0ZWQgRGVwIERpYWNyaXRpYyBEaWEgRW1vamkgRW1vamlfQ29tcG9uZW50IEVtb2ppX01vZGlmaWVyIEVtb2ppX01vZGlmaWVyX0Jhc2UgRW1vamlfUHJlc2VudGF0aW9uIEV4dGVuZGVyIEV4dCBHcmFwaGVtZV9CYXNlIEdyX0Jhc2UgR3JhcGhlbWVfRXh0ZW5kIEdyX0V4dCBIZXhfRGlnaXQgSGV4IElEU19CaW5hcnlfT3BlcmF0b3IgSURTQiBJRFNfVHJpbmFyeV9PcGVyYXRvciBJRFNUIElEX0NvbnRpbnVlIElEQyBJRF9TdGFydCBJRFMgSWRlb2dyYXBoaWMgSWRlbyBKb2luX0NvbnRyb2wgSm9pbl9DIExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRSBMb3dlcmNhc2UgTG93ZXIgTWF0aCBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhciBQYXR0ZXJuX1N5bnRheCBQYXRfU3luIFBhdHRlcm5fV2hpdGVfU3BhY2UgUGF0X1dTIFF1b3RhdGlvbl9NYXJrIFFNYXJrIFJhZGljYWwgUmVnaW9uYWxfSW5kaWNhdG9yIFJJIFNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtIFNvZnRfRG90dGVkIFNEIFRlcm1pbmFsX1B1bmN0dWF0aW9uIFRlcm0gVW5pZmllZF9JZGVvZ3JhcGggVUlkZW8gVXBwZXJjYXNlIFVwcGVyIFZhcmlhdGlvbl9TZWxlY3RvciBWUyBXaGl0ZV9TcGFjZSBzcGFjZSBYSURfQ29udGludWUgWElEQyBYSURfU3RhcnQgWElEU1wiO1xuICB2YXIgZWNtYTEwQmluYXJ5UHJvcGVydGllcyA9IGVjbWE5QmluYXJ5UHJvcGVydGllcyArIFwiIEV4dGVuZGVkX1BpY3RvZ3JhcGhpY1wiO1xuICB2YXIgZWNtYTExQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMEJpbmFyeVByb3BlcnRpZXM7XG4gIHZhciBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTExQmluYXJ5UHJvcGVydGllcyArIFwiIEVCYXNlIEVDb21wIEVNb2QgRVByZXMgRXh0UGljdFwiO1xuICB2YXIgZWNtYTEzQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMkJpbmFyeVByb3BlcnRpZXM7XG4gIHZhciBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTEzQmluYXJ5UHJvcGVydGllcztcblxuICB2YXIgdW5pY29kZUJpbmFyeVByb3BlcnRpZXMgPSB7XG4gICAgOTogZWNtYTlCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDEwOiBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDExOiBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDEyOiBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDEzOiBlY21hMTNCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDE0OiBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLy8gI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXMtb2Ytc3RyaW5nc1xuICB2YXIgZWNtYTE0QmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyA9IFwiQmFzaWNfRW1vamkgRW1vamlfS2V5Y2FwX1NlcXVlbmNlIFJHSV9FbW9qaV9Nb2RpZmllcl9TZXF1ZW5jZSBSR0lfRW1vamlfRmxhZ19TZXF1ZW5jZSBSR0lfRW1vamlfVGFnX1NlcXVlbmNlIFJHSV9FbW9qaV9aV0pfU2VxdWVuY2UgUkdJX0Vtb2ppXCI7XG5cbiAgdmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzID0ge1xuICAgIDk6IFwiXCIsXG4gICAgMTA6IFwiXCIsXG4gICAgMTE6IFwiXCIsXG4gICAgMTI6IFwiXCIsXG4gICAgMTM6IFwiXCIsXG4gICAgMTQ6IGVjbWExNEJpbmFyeVByb3BlcnRpZXNPZlN0cmluZ3NcbiAgfTtcblxuICAvLyAjdGFibGUtdW5pY29kZS1nZW5lcmFsLWNhdGVnb3J5LXZhbHVlc1xuICB2YXIgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyA9IFwiQ2FzZWRfTGV0dGVyIExDIENsb3NlX1B1bmN0dWF0aW9uIFBlIENvbm5lY3Rvcl9QdW5jdHVhdGlvbiBQYyBDb250cm9sIENjIGNudHJsIEN1cnJlbmN5X1N5bWJvbCBTYyBEYXNoX1B1bmN0dWF0aW9uIFBkIERlY2ltYWxfTnVtYmVyIE5kIGRpZ2l0IEVuY2xvc2luZ19NYXJrIE1lIEZpbmFsX1B1bmN0dWF0aW9uIFBmIEZvcm1hdCBDZiBJbml0aWFsX1B1bmN0dWF0aW9uIFBpIExldHRlciBMIExldHRlcl9OdW1iZXIgTmwgTGluZV9TZXBhcmF0b3IgWmwgTG93ZXJjYXNlX0xldHRlciBMbCBNYXJrIE0gQ29tYmluaW5nX01hcmsgTWF0aF9TeW1ib2wgU20gTW9kaWZpZXJfTGV0dGVyIExtIE1vZGlmaWVyX1N5bWJvbCBTayBOb25zcGFjaW5nX01hcmsgTW4gTnVtYmVyIE4gT3Blbl9QdW5jdHVhdGlvbiBQcyBPdGhlciBDIE90aGVyX0xldHRlciBMbyBPdGhlcl9OdW1iZXIgTm8gT3RoZXJfUHVuY3R1YXRpb24gUG8gT3RoZXJfU3ltYm9sIFNvIFBhcmFncmFwaF9TZXBhcmF0b3IgWnAgUHJpdmF0ZV9Vc2UgQ28gUHVuY3R1YXRpb24gUCBwdW5jdCBTZXBhcmF0b3IgWiBTcGFjZV9TZXBhcmF0b3IgWnMgU3BhY2luZ19NYXJrIE1jIFN1cnJvZ2F0ZSBDcyBTeW1ib2wgUyBUaXRsZWNhc2VfTGV0dGVyIEx0IFVuYXNzaWduZWQgQ24gVXBwZXJjYXNlX0xldHRlciBMdVwiO1xuXG4gIC8vICN0YWJsZS11bmljb2RlLXNjcmlwdC12YWx1ZXNcbiAgdmFyIGVjbWE5U2NyaXB0VmFsdWVzID0gXCJBZGxhbSBBZGxtIEFob20gQW5hdG9saWFuX0hpZXJvZ2x5cGhzIEhsdXcgQXJhYmljIEFyYWIgQXJtZW5pYW4gQXJtbiBBdmVzdGFuIEF2c3QgQmFsaW5lc2UgQmFsaSBCYW11bSBCYW11IEJhc3NhX1ZhaCBCYXNzIEJhdGFrIEJhdGsgQmVuZ2FsaSBCZW5nIEJoYWlrc3VraSBCaGtzIEJvcG9tb2ZvIEJvcG8gQnJhaG1pIEJyYWggQnJhaWxsZSBCcmFpIEJ1Z2luZXNlIEJ1Z2kgQnVoaWQgQnVoZCBDYW5hZGlhbl9BYm9yaWdpbmFsIENhbnMgQ2FyaWFuIENhcmkgQ2F1Y2FzaWFuX0FsYmFuaWFuIEFnaGIgQ2hha21hIENha20gQ2hhbSBDaGFtIENoZXJva2VlIENoZXIgQ29tbW9uIFp5eXkgQ29wdGljIENvcHQgUWFhYyBDdW5laWZvcm0gWHN1eCBDeXByaW90IENwcnQgQ3lyaWxsaWMgQ3lybCBEZXNlcmV0IERzcnQgRGV2YW5hZ2FyaSBEZXZhIER1cGxveWFuIER1cGwgRWd5cHRpYW5fSGllcm9nbHlwaHMgRWd5cCBFbGJhc2FuIEVsYmEgRXRoaW9waWMgRXRoaSBHZW9yZ2lhbiBHZW9yIEdsYWdvbGl0aWMgR2xhZyBHb3RoaWMgR290aCBHcmFudGhhIEdyYW4gR3JlZWsgR3JlayBHdWphcmF0aSBHdWpyIEd1cm11a2hpIEd1cnUgSGFuIEhhbmkgSGFuZ3VsIEhhbmcgSGFudW5vbyBIYW5vIEhhdHJhbiBIYXRyIEhlYnJldyBIZWJyIEhpcmFnYW5hIEhpcmEgSW1wZXJpYWxfQXJhbWFpYyBBcm1pIEluaGVyaXRlZCBaaW5oIFFhYWkgSW5zY3JpcHRpb25hbF9QYWhsYXZpIFBobGkgSW5zY3JpcHRpb25hbF9QYXJ0aGlhbiBQcnRpIEphdmFuZXNlIEphdmEgS2FpdGhpIEt0aGkgS2FubmFkYSBLbmRhIEthdGFrYW5hIEthbmEgS2F5YWhfTGkgS2FsaSBLaGFyb3NodGhpIEtoYXIgS2htZXIgS2htciBLaG9qa2kgS2hvaiBLaHVkYXdhZGkgU2luZCBMYW8gTGFvbyBMYXRpbiBMYXRuIExlcGNoYSBMZXBjIExpbWJ1IExpbWIgTGluZWFyX0EgTGluYSBMaW5lYXJfQiBMaW5iIExpc3UgTGlzdSBMeWNpYW4gTHljaSBMeWRpYW4gTHlkaSBNYWhhamFuaSBNYWhqIE1hbGF5YWxhbSBNbHltIE1hbmRhaWMgTWFuZCBNYW5pY2hhZWFuIE1hbmkgTWFyY2hlbiBNYXJjIE1hc2FyYW1fR29uZGkgR29ubSBNZWV0ZWlfTWF5ZWsgTXRlaSBNZW5kZV9LaWtha3VpIE1lbmQgTWVyb2l0aWNfQ3Vyc2l2ZSBNZXJjIE1lcm9pdGljX0hpZXJvZ2x5cGhzIE1lcm8gTWlhbyBQbHJkIE1vZGkgTW9uZ29saWFuIE1vbmcgTXJvIE1yb28gTXVsdGFuaSBNdWx0IE15YW5tYXIgTXltciBOYWJhdGFlYW4gTmJhdCBOZXdfVGFpX0x1ZSBUYWx1IE5ld2EgTmV3YSBOa28gTmtvbyBOdXNodSBOc2h1IE9naGFtIE9nYW0gT2xfQ2hpa2kgT2xjayBPbGRfSHVuZ2FyaWFuIEh1bmcgT2xkX0l0YWxpYyBJdGFsIE9sZF9Ob3J0aF9BcmFiaWFuIE5hcmIgT2xkX1Blcm1pYyBQZXJtIE9sZF9QZXJzaWFuIFhwZW8gT2xkX1NvdXRoX0FyYWJpYW4gU2FyYiBPbGRfVHVya2ljIE9ya2ggT3JpeWEgT3J5YSBPc2FnZSBPc2dlIE9zbWFueWEgT3NtYSBQYWhhd2hfSG1vbmcgSG1uZyBQYWxteXJlbmUgUGFsbSBQYXVfQ2luX0hhdSBQYXVjIFBoYWdzX1BhIFBoYWcgUGhvZW5pY2lhbiBQaG54IFBzYWx0ZXJfUGFobGF2aSBQaGxwIFJlamFuZyBSam5nIFJ1bmljIFJ1bnIgU2FtYXJpdGFuIFNhbXIgU2F1cmFzaHRyYSBTYXVyIFNoYXJhZGEgU2hyZCBTaGF2aWFuIFNoYXcgU2lkZGhhbSBTaWRkIFNpZ25Xcml0aW5nIFNnbncgU2luaGFsYSBTaW5oIFNvcmFfU29tcGVuZyBTb3JhIFNveW9tYm8gU295byBTdW5kYW5lc2UgU3VuZCBTeWxvdGlfTmFncmkgU3lsbyBTeXJpYWMgU3lyYyBUYWdhbG9nIFRnbGcgVGFnYmFud2EgVGFnYiBUYWlfTGUgVGFsZSBUYWlfVGhhbSBMYW5hIFRhaV9WaWV0IFRhdnQgVGFrcmkgVGFrciBUYW1pbCBUYW1sIFRhbmd1dCBUYW5nIFRlbHVndSBUZWx1IFRoYWFuYSBUaGFhIFRoYWkgVGhhaSBUaWJldGFuIFRpYnQgVGlmaW5hZ2ggVGZuZyBUaXJodXRhIFRpcmggVWdhcml0aWMgVWdhciBWYWkgVmFpaSBXYXJhbmdfQ2l0aSBXYXJhIFlpIFlpaWkgWmFuYWJhemFyX1NxdWFyZSBaYW5iXCI7XG4gIHZhciBlY21hMTBTY3JpcHRWYWx1ZXMgPSBlY21hOVNjcmlwdFZhbHVlcyArIFwiIERvZ3JhIERvZ3IgR3VuamFsYV9Hb25kaSBHb25nIEhhbmlmaV9Sb2hpbmd5YSBSb2hnIE1ha2FzYXIgTWFrYSBNZWRlZmFpZHJpbiBNZWRmIE9sZF9Tb2dkaWFuIFNvZ28gU29nZGlhbiBTb2dkXCI7XG4gIHZhciBlY21hMTFTY3JpcHRWYWx1ZXMgPSBlY21hMTBTY3JpcHRWYWx1ZXMgKyBcIiBFbHltYWljIEVseW0gTmFuZGluYWdhcmkgTmFuZCBOeWlha2VuZ19QdWFjaHVlX0htb25nIEhtbnAgV2FuY2hvIFdjaG9cIjtcbiAgdmFyIGVjbWExMlNjcmlwdFZhbHVlcyA9IGVjbWExMVNjcmlwdFZhbHVlcyArIFwiIENob3Jhc21pYW4gQ2hycyBEaWFrIERpdmVzX0FrdXJ1IEtoaXRhbl9TbWFsbF9TY3JpcHQgS2l0cyBZZXppIFllemlkaVwiO1xuICB2YXIgZWNtYTEzU2NyaXB0VmFsdWVzID0gZWNtYTEyU2NyaXB0VmFsdWVzICsgXCIgQ3lwcm9fTWlub2FuIENwbW4gT2xkX1V5Z2h1ciBPdWdyIFRhbmdzYSBUbnNhIFRvdG8gVml0aGt1cWkgVml0aFwiO1xuICB2YXIgZWNtYTE0U2NyaXB0VmFsdWVzID0gZWNtYTEzU2NyaXB0VmFsdWVzICsgXCIgSHJrdCBLYXRha2FuYV9Pcl9IaXJhZ2FuYSBLYXdpIE5hZ19NdW5kYXJpIE5hZ20gVW5rbm93biBaenp6XCI7XG5cbiAgdmFyIHVuaWNvZGVTY3JpcHRWYWx1ZXMgPSB7XG4gICAgOTogZWNtYTlTY3JpcHRWYWx1ZXMsXG4gICAgMTA6IGVjbWExMFNjcmlwdFZhbHVlcyxcbiAgICAxMTogZWNtYTExU2NyaXB0VmFsdWVzLFxuICAgIDEyOiBlY21hMTJTY3JpcHRWYWx1ZXMsXG4gICAgMTM6IGVjbWExM1NjcmlwdFZhbHVlcyxcbiAgICAxNDogZWNtYTE0U2NyaXB0VmFsdWVzXG4gIH07XG5cbiAgdmFyIGRhdGEgPSB7fTtcbiAgZnVuY3Rpb24gYnVpbGRVbmljb2RlRGF0YShlY21hVmVyc2lvbikge1xuICAgIHZhciBkID0gZGF0YVtlY21hVmVyc2lvbl0gPSB7XG4gICAgICBiaW5hcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzW2VjbWFWZXJzaW9uXSArIFwiIFwiICsgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICBiaW5hcnlPZlN0cmluZ3M6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzW2VjbWFWZXJzaW9uXSksXG4gICAgICBub25CaW5hcnk6IHtcbiAgICAgICAgR2VuZXJhbF9DYXRlZ29yeTogd29yZHNSZWdleHAodW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICAgIFNjcmlwdDogd29yZHNSZWdleHAodW5pY29kZVNjcmlwdFZhbHVlc1tlY21hVmVyc2lvbl0pXG4gICAgICB9XG4gICAgfTtcbiAgICBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcblxuICAgIGQubm9uQmluYXJ5LmdjID0gZC5ub25CaW5hcnkuR2VuZXJhbF9DYXRlZ29yeTtcbiAgICBkLm5vbkJpbmFyeS5zYyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcbiAgICBkLm5vbkJpbmFyeS5zY3ggPSBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gWzksIDEwLCAxMSwgMTIsIDEzLCAxNF07IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGVjbWFWZXJzaW9uID0gbGlzdFtpXTtcblxuICAgIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pO1xuICB9XG5cbiAgdmFyIHBwJDEgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHZhciBSZWdFeHBWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiBSZWdFeHBWYWxpZGF0aW9uU3RhdGUocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgPyBcImRcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE1ID8gXCJ2XCIgOiBcIlwiKTtcbiAgICB0aGlzLnVuaWNvZGVQcm9wZXJ0aWVzID0gZGF0YVtwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNCA/IDE0IDogcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb25dO1xuICAgIHRoaXMuc291cmNlID0gXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnN3aXRjaFUgPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaFYgPSBmYWxzZTtcbiAgICB0aGlzLnN3aXRjaE4gPSBmYWxzZTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHRoaXMubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB0aGlzLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgICB0aGlzLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICAgIHRoaXMuZ3JvdXBOYW1lcyA9IFtdO1xuICAgIHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzID0gW107XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0IChzdGFydCwgcGF0dGVybiwgZmxhZ3MpIHtcbiAgICB2YXIgdW5pY29kZVNldHMgPSBmbGFncy5pbmRleE9mKFwidlwiKSAhPT0gLTE7XG4gICAgdmFyIHVuaWNvZGUgPSBmbGFncy5pbmRleE9mKFwidVwiKSAhPT0gLTE7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0IHwgMDtcbiAgICB0aGlzLnNvdXJjZSA9IHBhdHRlcm4gKyBcIlwiO1xuICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICBpZiAodW5pY29kZVNldHMgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNSkge1xuICAgICAgdGhpcy5zd2l0Y2hVID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3dpdGNoViA9IHRydWU7XG4gICAgICB0aGlzLnN3aXRjaE4gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgICAgIHRoaXMuc3dpdGNoViA9IGZhbHNlO1xuICAgICAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG4gICAgfVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmFpc2UgPSBmdW5jdGlvbiByYWlzZSAobWVzc2FnZSkge1xuICAgIHRoaXMucGFyc2VyLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgKFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC9cIiArICh0aGlzLnNvdXJjZSkgKyBcIi86IFwiICsgbWVzc2FnZSkpO1xuICB9O1xuXG4gIC8vIElmIHUgZmxhZyBpcyBnaXZlbiwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBpbmRleCAoaXQgY29tYmluZXMgYSBzdXJyb2dhdGUgcGFpcikuXG4gIC8vIE90aGVyd2lzZSwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgdGhlIGluZGV4IChjYW4gYmUgYSBwYXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIpLlxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQgKGksIGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIGlmIChpID49IGwpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoIShmb3JjZVUgfHwgdGhpcy5zd2l0Y2hVKSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsKSB7XG4gICAgICByZXR1cm4gY1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSk7XG4gICAgcmV0dXJuIG5leHQgPj0gMHhEQzAwICYmIG5leHQgPD0gMHhERkZGID8gKGMgPDwgMTApICsgbmV4dCAtIDB4MzVGREMwMCA6IGNcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLm5leHRJbmRleCA9IGZ1bmN0aW9uIG5leHRJbmRleCAoaSwgZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgaWYgKGkgPj0gbCkge1xuICAgICAgcmV0dXJuIGxcbiAgICB9XG4gICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSksIG5leHQ7XG4gICAgaWYgKCEoZm9yY2VVIHx8IHRoaXMuc3dpdGNoVSkgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCB8fFxuICAgICAgICAobmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhEQzAwIHx8IG5leHQgPiAweERGRkYpIHtcbiAgICAgIHJldHVybiBpICsgMVxuICAgIH1cbiAgICByZXR1cm4gaSArIDJcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50IChmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzLmF0KHRoaXMucG9zLCBmb3JjZVUpXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5sb29rYWhlYWQgPSBmdW5jdGlvbiBsb29rYWhlYWQgKGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXMuYXQodGhpcy5uZXh0SW5kZXgodGhpcy5wb3MsIGZvcmNlVSksIGZvcmNlVSlcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiBhZHZhbmNlIChmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHRoaXMucG9zID0gdGhpcy5uZXh0SW5kZXgodGhpcy5wb3MsIGZvcmNlVSk7XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKGNoLCBmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnQoZm9yY2VVKSA9PT0gY2gpIHtcbiAgICAgIHRoaXMuYWR2YW5jZShmb3JjZVUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXRDaGFycyA9IGZ1bmN0aW9uIGVhdENoYXJzIChjaHMsIGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gY2hzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGNoID0gbGlzdFtpXTtcblxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYXQocG9zLCBmb3JjZVUpO1xuICAgICAgaWYgKGN1cnJlbnQgPT09IC0xIHx8IGN1cnJlbnQgIT09IGNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcG9zID0gdGhpcy5uZXh0SW5kZXgocG9zLCBmb3JjZVUpO1xuICAgIH1cbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgZmxhZ3MgcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHBwJDEudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHZhbGlkRmxhZ3MgPSBzdGF0ZS52YWxpZEZsYWdzO1xuICAgIHZhciBmbGFncyA9IHN0YXRlLmZsYWdzO1xuXG4gICAgdmFyIHUgPSBmYWxzZTtcbiAgICB2YXIgdiA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZsYWcgPSBmbGFncy5jaGFyQXQoaSk7XG4gICAgICBpZiAodmFsaWRGbGFncy5pbmRleE9mKGZsYWcpID09PSAtMSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZihmbGFnLCBpICsgMSkgPiAtMSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFnID09PSBcInVcIikgeyB1ID0gdHJ1ZTsgfVxuICAgICAgaWYgKGZsYWcgPT09IFwidlwiKSB7IHYgPSB0cnVlOyB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTUgJiYgdSAmJiB2KSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgcGF0dGVybiBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHAkMS52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuXG4gICAgLy8gVGhlIGdvYWwgc3ltYm9sIGZvciB0aGUgcGFyc2UgaXMgfFBhdHRlcm5bflUsIH5OXXwuIElmIHRoZSByZXN1bHQgb2ZcbiAgICAvLyBwYXJzaW5nIGNvbnRhaW5zIGEgfEdyb3VwTmFtZXwsIHJlcGFyc2Ugd2l0aCB0aGUgZ29hbCBzeW1ib2xcbiAgICAvLyB8UGF0dGVyblt+VSwgK05dfCBhbmQgdXNlIHRoaXMgcmVzdWx0IGluc3RlYWQuIFRocm93IGEgKlN5bnRheEVycm9yKlxuICAgIC8vIGV4Y2VwdGlvbiBpZiBfUF8gZGlkIG5vdCBjb25mb3JtIHRvIHRoZSBncmFtbWFyLCBpZiBhbnkgZWxlbWVudHMgb2YgX1BfXG4gICAgLy8gd2VyZSBub3QgbWF0Y2hlZCBieSB0aGUgcGFyc2UsIG9yIGlmIGFueSBFYXJseSBFcnJvciBjb25kaXRpb25zIGV4aXN0LlxuICAgIGlmICghc3RhdGUuc3dpdGNoTiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLnN3aXRjaE4gPSB0cnVlO1xuICAgICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5cbiAgcHAkMS5yZWdleHBfcGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUucG9zID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA9IDA7XG4gICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucG9zICE9PSBzdGF0ZS5zb3VyY2UubGVuZ3RoKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2VzIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW5tYXRjaGVkICcpJ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBdICovKSB8fCBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPiBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgY2FwdHVyZSByZWZlcmVuY2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EaXNqdW5jdGlvblxuICBwcCQxLnJlZ2V4cF9kaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICAgIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUFsdGVybmF0aXZlXG4gIHBwJDEucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlLmxlbmd0aCAmJiB0aGlzLnJlZ2V4cF9lYXRUZXJtKHN0YXRlKSlcbiAgICAgIHsgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1UZXJtXG4gIHBwJDEucmVnZXhwX2VhdFRlcm0gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oc3RhdGUpKSB7XG4gICAgICAvLyBIYW5kbGUgYFF1YW50aWZpYWJsZUFzc2VydGlvbiBRdWFudGlmaWVyYCBhbHRlcm5hdGl2ZS5cbiAgICAgIC8vIGBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGVgIGlzIHRydWUgaWYgdGhlIGxhc3QgZWF0ZW4gQXNzZXJ0aW9uXG4gICAgICAvLyBpcyBhIFF1YW50aWZpYWJsZUFzc2VydGlvbi5cbiAgICAgIGlmIChzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgJiYgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSkpIHtcbiAgICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBxdWFudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVID8gdGhpcy5yZWdleHBfZWF0QXRvbShzdGF0ZSkgOiB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20oc3RhdGUpKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUFzc2VydGlvblxuICBwcCQxLnJlZ2V4cF9lYXRBc3NlcnRpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcblxuICAgIC8vIF4sICRcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUUgLyogXiAqLykgfHwgc3RhdGUuZWF0KDB4MjQgLyogJCAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gXFxiIFxcQlxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg0MiAvKiBCICovKSB8fCBzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gTG9va2FoZWFkIC8gTG9va2JlaGluZFxuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSAmJiBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgICAgdmFyIGxvb2tiZWhpbmQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBsb29rYmVoaW5kID0gc3RhdGUuZWF0KDB4M0MgLyogPCAqLyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4M0QgLyogPSAqLykgfHwgc3RhdGUuZWF0KDB4MjEgLyogISAqLykpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgICBpZiAoIXN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gIWxvb2tiZWhpbmQ7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclxuICBwcCQxLnJlZ2V4cF9lYXRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICBpZiAoIG5vRXJyb3IgPT09IHZvaWQgMCApIG5vRXJyb3IgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4KHN0YXRlLCBub0Vycm9yKSkge1xuICAgICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLyk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyUHJlZml4XG4gIHBwJDEucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXggPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZS5lYXQoMHgyQSAvKiAqICovKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4MkIgLyogKyAqLykgfHxcbiAgICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCBub0Vycm9yKVxuICAgIClcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgICAgdmFyIG1pbiA9IDAsIG1heCA9IC0xO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgIG1pbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDJDIC8qICwgKi8pICYmIHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgICAgbWF4ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICAgIC8vIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtdGVybVxuICAgICAgICAgIGlmIChtYXggIT09IC0xICYmIG1heCA8IG1pbiAmJiAhbm9FcnJvcikge1xuICAgICAgICAgICAgc3RhdGUucmFpc2UoXCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAhbm9FcnJvcikge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkluY29tcGxldGUgcXVhbnRpZmllclwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BdG9tXG4gIHBwJDEucmVnZXhwX2VhdEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyhzdGF0ZSkgfHxcbiAgICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSlcbiAgICApXG4gIH07XG4gIHBwJDEucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBdG9tRXNjYXBlKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgJiYgc3RhdGUuZWF0KDB4M0EgLyogOiAqLykpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZ3JvdXBTcGVjaWZpZXIoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgLyogPyAqLykge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zICs9IDE7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkQXRvbVxuICBwcCQxLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUludmFsaWRCcmFjZWRRdWFudGlmaWVyXG4gIHBwJDEucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVN5bnRheENoYXJhY3RlclxuICBwcCQxLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1N5bnRheENoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyNCAvKiAkICovIHx8XG4gICAgICBjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovIHx8XG4gICAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgICBjaCA9PT0gMHgzRiAvKiA/ICovIHx8XG4gICAgICBjaCA+PSAweDVCIC8qIFsgKi8gJiYgY2ggPD0gMHg1RSAvKiBeICovIHx8XG4gICAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVybkNoYXJhY3RlclxuICAvLyBCdXQgZWF0IGVhZ2VyLlxuICBwcCQxLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgIT09IC0xICYmICFpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyXG4gIHBwJDEucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChcbiAgICAgIGNoICE9PSAtMSAmJlxuICAgICAgY2ggIT09IDB4MjQgLyogJCAqLyAmJlxuICAgICAgIShjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovKSAmJlxuICAgICAgY2ggIT09IDB4MkUgLyogLiAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YgLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4NUIgLyogWyAqLyAmJlxuICAgICAgY2ggIT09IDB4NUUgLyogXiAqLyAmJlxuICAgICAgY2ggIT09IDB4N0MgLyogfCAqL1xuICAgICkge1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gR3JvdXBTcGVjaWZpZXIgOjpcbiAgLy8gICBbZW1wdHldXG4gIC8vICAgYD9gIEdyb3VwTmFtZVxuICBwcCQxLnJlZ2V4cF9ncm91cFNwZWNpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmdyb3VwTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gR3JvdXBOYW1lIDo6XG4gIC8vICAgYDxgIFJlZ0V4cElkZW50aWZpZXJOYW1lIGA+YFxuICAvLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbiAgcHAkMS5yZWdleHBfZWF0R3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRSAvKiA+ICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gUmVnRXhwSWRlbnRpZmllck5hbWUgOjpcbiAgLy8gICBSZWdFeHBJZGVudGlmaWVyU3RhcnRcbiAgLy8gICBSZWdFeHBJZGVudGlmaWVyTmFtZSBSZWdFeHBJZGVudGlmaWVyUGFydFxuICAvLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbiAgcHAkMS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydChzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0KHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIFJlZ0V4cElkZW50aWZpZXJTdGFydCA6OlxuICAvLyAgIFVuaWNvZGVJRFN0YXJ0XG4gIC8vICAgYCRgXG4gIC8vICAgYF9gXG4gIC8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbK1VdXG4gIHBwJDEucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudChmb3JjZVUpO1xuICAgIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZvcmNlVSkpIHtcbiAgICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgcmV0dXJuIGlzSWRlbnRpZmllclN0YXJ0KGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbiAgfVxuXG4gIC8vIFJlZ0V4cElkZW50aWZpZXJQYXJ0IDo6XG4gIC8vICAgVW5pY29kZUlEQ29udGludWVcbiAgLy8gICBgJGBcbiAgLy8gICBgX2BcbiAgLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVsrVV1cbiAgLy8gICA8WldOSj5cbiAgLy8gICA8WldKPlxuICBwcCQxLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudChmb3JjZVUpO1xuICAgIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZvcmNlVSkpIHtcbiAgICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi8gfHwgY2ggPT09IDB4MjAwQyAvKiA8WldOSj4gKi8gfHwgY2ggPT09IDB4MjAwRCAvKiA8WldKPiAqL1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUF0b21Fc2NhcGVcbiAgcHAkMS5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWdleHBfZWF0QmFja1JlZmVyZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgKHN0YXRlLnN3aXRjaE4gJiYgdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShzdGF0ZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg2MyAvKiBjICovKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUoc3RhdGUpKSB7XG4gICAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIC8vIEZvciBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLWF0b21lc2NhcGVcbiAgICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChuIDw9IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQxLnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NkIgLyogayAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2hhcmFjdGVyRXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSwgZmFsc2UpIHx8XG4gICAgICAoIXN0YXRlLnN3aXRjaFUgJiYgdGhpcy5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShzdGF0ZSlcbiAgICApXG4gIH07XG4gIHBwJDEucmVnZXhwX2VhdENDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkMS5yZWdleHBfZWF0WmVybyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzMCAvKiAwICovICYmICFpc0RlY2ltYWxEaWdpdChzdGF0ZS5sb29rYWhlYWQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sRXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPT09IDB4NzQgLyogdCAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwOTsgLyogXFx0ICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NkUgLyogbiAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQTsgLyogXFxuICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NzYgLyogdiAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQjsgLyogXFx2ICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NjYgLyogZiAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQzsgLyogXFxmICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NzIgLyogciAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwRDsgLyogXFxyICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sTGV0dGVyXG4gIHBwJDEucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNDb250cm9sTGV0dGVyKGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzQ29udHJvbExldHRlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NUEgLyogWiAqLykgfHxcbiAgICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg3QSAvKiB6ICovKVxuICAgIClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVxuICBwcCQxLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSwgZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBzd2l0Y2hVID0gZm9yY2VVIHx8IHN0YXRlLnN3aXRjaFU7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NzUgLyogdSAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgdmFyIGxlYWQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChzd2l0Y2hVICYmIGxlYWQgPj0gMHhEODAwICYmIGxlYWQgPD0gMHhEQkZGKSB7XG4gICAgICAgICAgdmFyIGxlYWRTdXJyb2dhdGVFbmQgPSBzdGF0ZS5wb3M7XG4gICAgICAgICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSAmJiBzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgICAgIHZhciB0cmFpbCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmICh0cmFpbCA+PSAweERDMDAgJiYgdHJhaWwgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLnBvcyA9IGxlYWRTdXJyb2dhdGVFbmQ7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbGVhZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBzd2l0Y2hVICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICAgIHRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhzdGF0ZSkgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykgJiZcbiAgICAgICAgaXNWYWxpZFVuaWNvZGUoc3RhdGUubGFzdEludFZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNWYWxpZFVuaWNvZGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMCAmJiBjaCA8PSAweDEwRkZGRlxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUlkZW50aXR5RXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRiAvKiAvICovKSkge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJGOyAvKiAvICovXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoICE9PSAweDYzIC8qIGMgKi8gJiYgKCFzdGF0ZS5zd2l0Y2hOIHx8IGNoICE9PSAweDZCIC8qIGsgKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbEVzY2FwZVxuICBwcCQxLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPj0gMHgzMSAvKiAxICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykge1xuICAgICAgZG8ge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIH0gd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIFJldHVybiB2YWx1ZXMgdXNlZCBieSBjaGFyYWN0ZXIgc2V0IHBhcnNpbmcgbWV0aG9kcywgbmVlZGVkIHRvXG4gIC8vIGZvcmJpZCBuZWdhdGlvbiBvZiBzZXRzIHRoYXQgY2FuIG1hdGNoIHN0cmluZ3MuXG4gIHZhciBDaGFyU2V0Tm9uZSA9IDA7IC8vIE5vdGhpbmcgcGFyc2VkXG4gIHZhciBDaGFyU2V0T2sgPSAxOyAvLyBDb25zdHJ1Y3QgcGFyc2VkLCBjYW5ub3QgY29udGFpbiBzdHJpbmdzXG4gIHZhciBDaGFyU2V0U3RyaW5nID0gMjsgLy8gQ29uc3RydWN0IHBhcnNlZCwgY2FuIGNvbnRhaW4gc3RyaW5nc1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzRXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG5cbiAgICBpZiAoaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIENoYXJTZXRPa1xuICAgIH1cblxuICAgIHZhciBuZWdhdGUgPSBmYWxzZTtcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJlxuICAgICAgKChuZWdhdGUgPSBjaCA9PT0gMHg1MCAvKiBQICovKSB8fCBjaCA9PT0gMHg3MCAvKiBwICovKVxuICAgICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKFxuICAgICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgICAocmVzdWx0ID0gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uKHN0YXRlKSkgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLylcbiAgICAgICkge1xuICAgICAgICBpZiAobmVnYXRlICYmIHJlc3VsdCA9PT0gQ2hhclNldFN0cmluZykgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ2hhclNldE5vbmVcbiAgfTtcblxuICBmdW5jdGlvbiBpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNoID09PSAweDY0IC8qIGQgKi8gfHxcbiAgICAgIGNoID09PSAweDQ0IC8qIEQgKi8gfHxcbiAgICAgIGNoID09PSAweDczIC8qIHMgKi8gfHxcbiAgICAgIGNoID09PSAweDUzIC8qIFMgKi8gfHxcbiAgICAgIGNoID09PSAweDc3IC8qIHcgKi8gfHxcbiAgICAgIGNoID09PSAweDU3IC8qIFcgKi9cbiAgICApXG4gIH1cblxuICAvLyBVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuICAvLyAgIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxuICBwcCQxLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIC8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgYD1gIFVuaWNvZGVQcm9wZXJ0eVZhbHVlXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNEIC8qID0gKi8pKSB7XG4gICAgICB2YXIgbmFtZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZShzdGF0ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gQ2hhclNldE9rXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuXG4gICAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSkpIHtcbiAgICAgIHZhciBuYW1lT3JWYWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlLCBuYW1lT3JWYWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIENoYXJTZXROb25lXG4gIH07XG5cbiAgcHAkMS5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWhhc093bihzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnksIG5hbWUpKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICAgIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5W25hbWVdLnRlc3QodmFsdWUpKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgdmFsdWVcIik7IH1cbiAgfTtcblxuICBwcCQxLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWVPclZhbHVlKSB7XG4gICAgaWYgKHN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLmJpbmFyeS50ZXN0KG5hbWVPclZhbHVlKSkgeyByZXR1cm4gQ2hhclNldE9rIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoViAmJiBzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnlPZlN0cmluZ3MudGVzdChuYW1lT3JWYWx1ZSkpIHsgcmV0dXJuIENoYXJTZXRTdHJpbmcgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpO1xuICB9O1xuXG4gIC8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyc1xuICBwcCQxLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbiAgfTtcblxuICBmdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gaXNDb250cm9sTGV0dGVyKGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG4gIH1cblxuICAvLyBVbmljb2RlUHJvcGVydHlWYWx1ZSA6OlxuICAvLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xuICBwcCQxLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxuICB9O1xuICBmdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpXG4gIH1cblxuICAvLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbiAgcHAkMS5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NcbiAgcHAkMS5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QiAvKiBbICovKSkge1xuICAgICAgdmFyIG5lZ2F0ZSA9IHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVnZXhwX2NsYXNzQ29udGVudHMoc3RhdGUpO1xuICAgICAgaWYgKCFzdGF0ZS5lYXQoMHg1RCAvKiBdICovKSlcbiAgICAgICAgeyBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3NcIik7IH1cbiAgICAgIGlmIChuZWdhdGUgJiYgcmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKVxuICAgICAgICB7IHN0YXRlLnJhaXNlKFwiTmVnYXRlZCBjaGFyYWN0ZXIgY2xhc3MgbWF5IGNvbnRhaW4gc3RyaW5nc1wiKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NDb250ZW50c1xuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc1Jhbmdlc1xuICBwcCQxLnJlZ2V4cF9jbGFzc0NvbnRlbnRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDVEIC8qIF0gKi8pIHsgcmV0dXJuIENoYXJTZXRPayB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFYpIHsgcmV0dXJuIHRoaXMucmVnZXhwX2NsYXNzU2V0RXhwcmVzc2lvbihzdGF0ZSkgfVxuICAgIHRoaXMucmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXMoc3RhdGUpO1xuICAgIHJldHVybiBDaGFyU2V0T2tcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2hcbiAgcHAkMS5yZWdleHBfbm9uRW1wdHlDbGFzc1JhbmdlcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgIHZhciBsZWZ0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pICYmIHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbU5vRGFzaFxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc0F0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgICAgdmFyIGNoJDEgPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICAgIGlmIChjaCQxID09PSAweDYzIC8qIGMgKi8gfHwgaXNPY3RhbERpZ2l0KGNoJDEpKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNsYXNzIGVzY2FwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCAhPT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzRXNjYXBlXG4gIHBwJDEucmVnZXhwX2VhdENsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IC8qIDxCUz4gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4MkQgLyogLSAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkQ7IC8qIC0gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKVxuICAgIClcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldEV4cHJlc3Npb25cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NVbmlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc0ludGVyc2VjdGlvblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N1YnRyYWN0aW9uXG4gIHBwJDEucmVnZXhwX2NsYXNzU2V0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IENoYXJTZXRPaywgc3ViUmVzdWx0O1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlKHN0YXRlKSkgOyBlbHNlIGlmIChzdWJSZXN1bHQgPSB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoc3RhdGUpKSB7XG4gICAgICBpZiAoc3ViUmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKSB7IHJlc3VsdCA9IENoYXJTZXRTdHJpbmc7IH1cbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzSW50ZXJzZWN0aW9uXG4gICAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgICB3aGlsZSAoc3RhdGUuZWF0Q2hhcnMoWzB4MjYsIDB4MjZdIC8qICYmICovKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RhdGUuY3VycmVudCgpICE9PSAweDI2IC8qICYgKi8gJiZcbiAgICAgICAgICAoc3ViUmVzdWx0ID0gdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKHN0YXRlKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHN1YlJlc3VsdCAhPT0gQ2hhclNldFN0cmluZykgeyByZXN1bHQgPSBDaGFyU2V0T2s7IH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N1YnRyYWN0aW9uXG4gICAgICB3aGlsZSAoc3RhdGUuZWF0Q2hhcnMoWzB4MkQsIDB4MkRdIC8qIC0tICovKSkge1xuICAgICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKHN0YXRlKSkgeyBjb250aW51ZSB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgIH1cbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1VuaW9uXG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0UmFuZ2Uoc3RhdGUpKSB7IGNvbnRpbnVlIH1cbiAgICAgIHN1YlJlc3VsdCA9IHRoaXMucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZChzdGF0ZSk7XG4gICAgICBpZiAoIXN1YlJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IH1cbiAgICAgIGlmIChzdWJSZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldFN0cmluZzsgfVxuICAgIH1cbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldFJhbmdlXG4gIHBwJDEucmVnZXhwX2VhdENsYXNzU2V0UmFuZ2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAobGVmdCAhPT0gLTEgJiYgcmlnaHQgIT09IC0xICYmIGxlZnQgPiByaWdodCkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0T3BlcmFuZFxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHsgcmV0dXJuIENoYXJTZXRPayB9XG4gICAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdENsYXNzU3RyaW5nRGlzanVuY3Rpb24oc3RhdGUpIHx8IHRoaXMucmVnZXhwX2VhdE5lc3RlZENsYXNzKHN0YXRlKVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLU5lc3RlZENsYXNzXG4gIHBwJDEucmVnZXhwX2VhdE5lc3RlZENsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVCIC8qIFsgKi8pKSB7XG4gICAgICB2YXIgbmVnYXRlID0gc3RhdGUuZWF0KDB4NUUgLyogXiAqLyk7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWdleHBfY2xhc3NDb250ZW50cyhzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogXSAqLykpIHtcbiAgICAgICAgaWYgKG5lZ2F0ZSAmJiByZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIk5lZ2F0ZWQgY2hhcmFjdGVyIGNsYXNzIG1heSBjb250YWluIHN0cmluZ3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIHZhciByZXN1bHQkMSA9IHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKTtcbiAgICAgIGlmIChyZXN1bHQkMSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0JDFcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU3RyaW5nRGlzanVuY3Rpb25cbiAgcHAkMS5yZWdleHBfZWF0Q2xhc3NTdHJpbmdEaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXRDaGFycyhbMHg1QywgMHg3MV0gLyogXFxxICovKSkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHMoc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU3RyaW5nRGlzanVuY3Rpb25Db250ZW50c1xuICBwcCQxLnJlZ2V4cF9jbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc1N0cmluZyhzdGF0ZSk7XG4gICAgd2hpbGUgKHN0YXRlLmVhdCgweDdDIC8qIHwgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfY2xhc3NTdHJpbmcoc3RhdGUpID09PSBDaGFyU2V0U3RyaW5nKSB7IHJlc3VsdCA9IENoYXJTZXRTdHJpbmc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU3RyaW5nXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLU5vbkVtcHR5Q2xhc3NTdHJpbmdcbiAgcHAkMS5yZWdleHBfY2xhc3NTdHJpbmcgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyKHN0YXRlKSkgeyBjb3VudCsrOyB9XG4gICAgcmV0dXJuIGNvdW50ID09PSAxID8gQ2hhclNldE9rIDogQ2hhclNldFN0cmluZ1xuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0Q2hhcmFjdGVyXG4gIHBwJDEucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpIHx8XG4gICAgICAgIHRoaXMucmVnZXhwX2VhdENsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yKHN0YXRlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwODsgLyogPEJTPiAqL1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCA8IDAgfHwgY2ggPT09IHN0YXRlLmxvb2thaGVhZCgpICYmIGlzQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JDaGFyYWN0ZXIoY2gpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGlzQ2xhc3NTZXRTeW50YXhDaGFyYWN0ZXIoY2gpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JcbiAgZnVuY3Rpb24gaXNDbGFzc1NldFJlc2VydmVkRG91YmxlUHVuY3R1YXRvckNoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyMSAvKiAhICovIHx8XG4gICAgICBjaCA+PSAweDIzIC8qICMgKi8gJiYgY2ggPD0gMHgyNiAvKiAmICovIHx8XG4gICAgICBjaCA+PSAweDJBIC8qICogKi8gJiYgY2ggPD0gMHgyQyAvKiAsICovIHx8XG4gICAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgICBjaCA+PSAweDNBIC8qIDogKi8gJiYgY2ggPD0gMHg0MCAvKiBAICovIHx8XG4gICAgICBjaCA9PT0gMHg1RSAvKiBeICovIHx8XG4gICAgICBjaCA9PT0gMHg2MCAvKiBgICovIHx8XG4gICAgICBjaCA9PT0gMHg3RSAvKiB+ICovXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRTeW50YXhDaGFyYWN0ZXJcbiAgZnVuY3Rpb24gaXNDbGFzc1NldFN5bnRheENoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyOCAvKiAoICovIHx8XG4gICAgICBjaCA9PT0gMHgyOSAvKiApICovIHx8XG4gICAgICBjaCA9PT0gMHgyRCAvKiAtICovIHx8XG4gICAgICBjaCA9PT0gMHgyRiAvKiAvICovIHx8XG4gICAgICBjaCA+PSAweDVCIC8qIFsgKi8gJiYgY2ggPD0gMHg1RCAvKiBdICovIHx8XG4gICAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3JcbiAgcHAkMS5yZWdleHBfZWF0Q2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3JcbiAgZnVuY3Rpb24gaXNDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyMSAvKiAhICovIHx8XG4gICAgICBjaCA9PT0gMHgyMyAvKiAjICovIHx8XG4gICAgICBjaCA9PT0gMHgyNSAvKiAlICovIHx8XG4gICAgICBjaCA9PT0gMHgyNiAvKiAmICovIHx8XG4gICAgICBjaCA9PT0gMHgyQyAvKiAsICovIHx8XG4gICAgICBjaCA9PT0gMHgyRCAvKiAtICovIHx8XG4gICAgICBjaCA+PSAweDNBIC8qIDogKi8gJiYgY2ggPD0gMHgzRSAvKiA+ICovIHx8XG4gICAgICBjaCA9PT0gMHg0MCAvKiBAICovIHx8XG4gICAgICBjaCA9PT0gMHg2MCAvKiBgICovIHx8XG4gICAgICBjaCA9PT0gMHg3RSAvKiB+ICovXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzQ29udHJvbExldHRlclxuICBwcCQxLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG4gIHBwJDEucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDc4IC8qIHggKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxEaWdpdHNcbiAgcHAkMS5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG4gIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi9cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0c1xuICBwcCQxLnJlZ2V4cF9lYXRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgd2hpbGUgKGlzSGV4RGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcbiAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgIHJldHVybiAoXG4gICAgICAoY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykgfHxcbiAgICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB8fFxuICAgICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pXG4gICAgKVxuICB9XG4gIGZ1bmN0aW9uIGhleFRvSW50KGNoKSB7XG4gICAgaWYgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDQ2IC8qIEYgKi8pIHtcbiAgICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgLyogQSAqLylcbiAgICB9XG4gICAgaWYgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pIHtcbiAgICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgLyogYSAqLylcbiAgICB9XG4gICAgcmV0dXJuIGNoIC0gMHgzMCAvKiAwICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItTGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZVxuICAvLyBBbGxvd3Mgb25seSAwLTM3NyhvY3RhbCkgaS5lLiAwLTI1NShkZWNpbWFsKS5cbiAgcHAkMS5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICB2YXIgbjEgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgdmFyIG4yID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAobjEgPD0gMyAmJiB0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA4ICsgbjI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtT2N0YWxEaWdpdFxuICBwcCQxLnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgLyogMCAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM3IC8qIDcgKi9cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleDREaWdpdHNcbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RGlnaXRcbiAgLy8gQW5kIEhleERpZ2l0IEhleERpZ2l0IGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG4gIHBwJDEucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUsIGxlbmd0aCkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuICAvLyBzaW1wbHkgZXhpc3QgYXMgcHJvcGVydGllcyBvbiB0aGUgcGFyc2VyIG9iamVjdC4gVGhpcyBpcyBvbmx5XG4gIC8vIHVzZWQgZm9yIHRoZSBvblRva2VuIGNhbGxiYWNrIGFuZCB0aGUgZXh0ZXJuYWwgdG9rZW5pemVyLlxuXG4gIHZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgICB0aGlzLnR5cGUgPSBwLnR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHAudmFsdWU7XG4gICAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBwLmVuZDtcbiAgICBpZiAocC5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpOyB9XG4gICAgaWYgKHAub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IHRoaXMucmFuZ2UgPSBbcC5zdGFydCwgcC5lbmRdOyB9XG4gIH07XG5cbiAgLy8gIyMgVG9rZW5pemVyXG5cbiAgdmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHRva2VuXG5cbiAgcHAubmV4dCA9IGZ1bmN0aW9uKGlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkKSB7XG4gICAgaWYgKCFpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCAmJiB0aGlzLnR5cGUua2V5d29yZCAmJiB0aGlzLmNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBcIiArIHRoaXMudHlwZS5rZXl3b3JkKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbilcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVG9rZW4obmV3IFRva2VuKHRoaXMpKTsgfVxuXG4gICAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMuZW5kTG9jO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICB9O1xuXG4gIHBwLmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0aGlzKVxuICB9O1xuXG4gIC8vIElmIHdlJ3JlIGluIGFuIEVTNiBlbnZpcm9ubWVudCwgbWFrZSBwYXJzZXJzIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKVxuICAgIHsgcHBbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMkMSQxLmdldFRva2VuKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzJDEuZW9mLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgfVxuXG4gIC8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2VcbiAgLy8gcGVkYW50aWMgdGVzdHMgKGBcInVzZSBzdHJpY3RcIjsgMDEwO2Agc2hvdWxkIGZhaWwpLlxuXG4gIC8vIFJlYWQgYSBzaW5nbGUgdG9rZW4sIHVwZGF0aW5nIHRoZSBwYXJzZXIgb2JqZWN0J3MgdG9rZW4tcmVsYXRlZFxuICAvLyBwcm9wZXJ0aWVzLlxuXG4gIHBwLm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHsgdGhpcy5za2lwU3BhY2UoKTsgfVxuXG4gICAgdGhpcy5zdGFydCA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuc3RhcnRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5lb2YpIH1cblxuICAgIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7IHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpIH1cbiAgICBlbHNlIHsgdGhpcy5yZWFkVG9rZW4odGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKTsgfVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pXG4gICAgICB7IHJldHVybiB0aGlzLnJlYWRXb3JkKCkgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKVxuICB9O1xuXG4gIHBwLmZ1bGxDaGFyQ29kZUF0UG9zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmIChjb2RlIDw9IDB4ZDdmZiB8fCBjb2RlID49IDB4ZGMwMCkgeyByZXR1cm4gY29kZSB9XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICByZXR1cm4gbmV4dCA8PSAweGRiZmYgfHwgbmV4dCA+PSAweGUwMDAgPyBjb2RlIDogKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxuICB9O1xuXG4gIHBwLnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5wb3MgKz0gMik7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7IH1cbiAgICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIG5leHRCcmVhayA9ICh2b2lkIDApLCBwb3MgPSBzdGFydDsgKG5leHRCcmVhayA9IG5leHRMaW5lQnJlYWsodGhpcy5pbnB1dCwgcG9zLCB0aGlzLnBvcykpID4gLTE7KSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICBwb3MgPSB0aGlzLmxpbmVTdGFydCA9IG5leHRCcmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbiAgfTtcblxuICBwcC5za2lwTGluZUNvbW1lbnQgPSBmdW5jdGlvbihzdGFydFNraXApIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KGZhbHNlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0aGlzLnBvcyksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbiAgfTtcblxuICAvLyBDYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBhbmQgYWZ0ZXIgZXZlcnkgdG9rZW4uIFNraXBzXG4gIC8vIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBhbmQuXG5cbiAgcHAuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgbG9vcDogd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICBjYXNlIDMyOiBjYXNlIDE2MDogLy8gJyAnXG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDEzOlxuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEwKSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMDogY2FzZSA4MjMyOiBjYXNlIDgyMzM6XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICAgIHN3aXRjaCAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkpIHtcbiAgICAgICAgY2FzZSA0MjogLy8gJyonXG4gICAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrIGxvb3BcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbiAgLy8gbWFpbnRhaW5zIGBjb250ZXh0YCBhbmQgYGV4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlclxuICAvLyB0aGUgdG9rZW4sIHNvIHRoYXQgdGhlIG5leHQgb25lJ3MgYHN0YXJ0YCB3aWxsIHBvaW50IGF0IHRoZVxuICAvLyByaWdodCBwb3NpdGlvbi5cblxuICBwcC5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHZhbCkge1xuICAgIHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgICB2YXIgcHJldlR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgfTtcblxuICAvLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLiBJdFxuICAvLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbiAgLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbiAgLy8gaW50byBpdC5cbiAgLy9cbiAgLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuICAvL1xuICBwcC5yZWFkVG9rZW5fZG90ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7IHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSkgfVxuICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgICB0aGlzLnBvcyArPSAzO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5lbGxpcHNpcylcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuZG90KVxuICAgIH1cbiAgfTtcblxuICBwcC5yZWFkVG9rZW5fc2xhc2ggPSBmdW5jdGlvbigpIHsgLy8gJy8nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAodGhpcy5leHByQWxsb3dlZCkgeyArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5yZWFkUmVnZXhwKCkgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuc2xhc2gsIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJyUqJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgdmFyIHNpemUgPSAxO1xuICAgIHZhciB0b2tlbnR5cGUgPSBjb2RlID09PSA0MiA/IHR5cGVzJDEuc3RhciA6IHR5cGVzJDEubW9kdWxvO1xuXG4gICAgLy8gZXhwb25lbnRpYXRpb24gb3BlcmF0b3IgKiogYW5kICoqPVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiBjb2RlID09PSA0MiAmJiBuZXh0ID09PSA0Mikge1xuICAgICAgKytzaXplO1xuICAgICAgdG9rZW50eXBlID0gdHlwZXMkMS5zdGFyc3RhcjtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodG9rZW50eXBlLCBzaXplKVxuICB9O1xuXG4gIHBwLnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJ3wmJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDMpIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzJDEubG9naWNhbE9SIDogdHlwZXMkMS5sb2dpY2FsQU5ELCAyKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcyQxLmJpdHdpc2VPUiA6IHR5cGVzJDEuYml0d2lzZUFORCwgMSlcbiAgfTtcblxuICBwcC5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbigpIHsgLy8gJ14nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmJpdHdpc2VYT1IsIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX3BsdXNfbWluID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnKy0nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKG5leHQgPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiAmJlxuICAgICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAgIC8vIEEgYC0tPmAgbGluZSBjb21tZW50XG4gICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDMpO1xuICAgICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5pbmNEZWMsIDIpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucGx1c01pbiwgMSlcbiAgfTtcblxuICBwcC5yZWFkVG9rZW5fbHRfZ3QgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc8PidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHZhciBzaXplID0gMTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIHNpemUpID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYml0U2hpZnQsIHNpemUpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSAzMyAmJiBjb2RlID09PSA2MCAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNDUgJiZcbiAgICAgICAgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMykgPT09IDQ1KSB7XG4gICAgICAvLyBgPCEtLWAsIGFuIFhNTC1zdHlsZSBjb21tZW50IHRoYXQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgbGluZSBjb21tZW50XG4gICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCg0KTtcbiAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgc2l6ZSA9IDI7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnJlbGF0aW9uYWwsIHNpemUpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX2VxX2V4Y2wgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc9ISdcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMikgfVxuICAgIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2MiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyAvLyAnPT4nXG4gICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5hcnJvdylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcyQxLmVxIDogdHlwZXMkMS5wcmVmaXgsIDEpXG4gIH07XG5cbiAgcHAucmVhZFRva2VuX3F1ZXN0aW9uID0gZnVuY3Rpb24oKSB7IC8vICc/J1xuICAgIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgICBpZiAoZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICBpZiAobmV4dCA9PT0gNDYpIHtcbiAgICAgICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiA8IDQ4IHx8IG5leHQyID4gNTcpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5xdWVzdGlvbkRvdCwgMikgfVxuICAgICAgfVxuICAgICAgaWYgKG5leHQgPT09IDYzKSB7XG4gICAgICAgIGlmIChlY21hVmVyc2lvbiA+PSAxMikge1xuICAgICAgICAgIHZhciBuZXh0MiQxID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgICAgaWYgKG5leHQyJDEgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAzKSB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5jb2FsZXNjZSwgMilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5xdWVzdGlvbiwgMSlcbiAgfTtcblxuICBwcC5yZWFkVG9rZW5fbnVtYmVyU2lnbiA9IGZ1bmN0aW9uKCkgeyAvLyAnIydcbiAgICB2YXIgZWNtYVZlcnNpb24gPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb247XG4gICAgdmFyIGNvZGUgPSAzNTsgLy8gJyMnXG4gICAgaWYgKGVjbWFWZXJzaW9uID49IDEzKSB7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgY29kZSA9IHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlLCB0cnVlKSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucHJpdmF0ZUlkLCB0aGlzLnJlYWRXb3JkMSgpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG4gIH07XG5cbiAgcHAuZ2V0VG9rZW5Gcm9tQ29kZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAvLyBUaGUgaW50ZXJwcmV0YXRpb24gb2YgYSBkb3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGlzIGZvbGxvd2VkXG4gICAgLy8gYnkgYSBkaWdpdCBvciBhbm90aGVyIHR3byBkb3RzLlxuICAgIGNhc2UgNDY6IC8vICcuJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgICAvLyBQdW5jdHVhdGlvbiB0b2tlbnMuXG4gICAgY2FzZSA0MDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5wYXJlbkwpXG4gICAgY2FzZSA0MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5wYXJlblIpXG4gICAgY2FzZSA1OTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5zZW1pKVxuICAgIGNhc2UgNDQ6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuY29tbWEpXG4gICAgY2FzZSA5MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFja2V0TClcbiAgICBjYXNlIDkzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJyYWNrZXRSKVxuICAgIGNhc2UgMTIzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJyYWNlTClcbiAgICBjYXNlIDEyNTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5icmFjZVIpXG4gICAgY2FzZSA1ODogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5jb2xvbilcblxuICAgIGNhc2UgOTY6IC8vICdgJ1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgYnJlYWsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYmFja1F1b3RlKVxuXG4gICAgY2FzZSA0ODogLy8gJzAnXG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KSB9IC8vICcwbycsICcwTycgLSBvY3RhbCBudW1iZXJcbiAgICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlIGJlZ2lubmluZyB3aXRoIGEgZGlnaXQgaXMgYW4gaW50ZWdlciwgb2N0YWxcbiAgICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICAgIGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IC8vIDEtOVxuICAgICAgcmV0dXJuIHRoaXMucmVhZE51bWJlcihmYWxzZSlcblxuICAgIC8vIFF1b3RlcyBwcm9kdWNlIHN0cmluZ3MuXG4gICAgY2FzZSAzNDogY2FzZSAzOTogLy8gJ1wiJywgXCInXCJcbiAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSlcblxuICAgIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAgIC8vIG9mdGVuIHJlZmVycmVkIHRvLiBgZmluaXNoT3BgIHNpbXBseSBza2lwcyB0aGUgYW1vdW50IG9mXG4gICAgLy8gY2hhcmFjdGVycyBpdCBpcyBnaXZlbiBhcyBzZWNvbmQgYXJndW1lbnQsIGFuZCByZXR1cm5zIGEgdG9rZW5cbiAgICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG4gICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKVxuXG4gICAgY2FzZSAzNzogY2FzZSA0MjogLy8gJyUqJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChjb2RlKVxuXG4gICAgY2FzZSAxMjQ6IGNhc2UgMzg6IC8vICd8JidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKVxuXG4gICAgY2FzZSA5NDogLy8gJ14nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fY2FyZXQoKVxuXG4gICAgY2FzZSA0MzogY2FzZSA0NTogLy8gJystJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpXG5cbiAgICBjYXNlIDYwOiBjYXNlIDYyOiAvLyAnPD4nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICAgIGNhc2UgNjE6IGNhc2UgMzM6IC8vICc9ISdcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKGNvZGUpXG5cbiAgICBjYXNlIDYzOiAvLyAnPydcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9xdWVzdGlvbigpXG5cbiAgICBjYXNlIDEyNjogLy8gJ34nXG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnByZWZpeCwgMSlcblxuICAgIGNhc2UgMzU6IC8vICcjJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX251bWJlclNpZ24oKVxuICAgIH1cblxuICAgIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG4gIH07XG5cbiAgcHAuZmluaXNoT3AgPSBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgc2l6ZSk7XG4gICAgdGhpcy5wb3MgKz0gc2l6ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpXG4gIH07XG5cbiAgcHAucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChsaW5lQnJlYWsudGVzdChjaCkpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgeyBpbkNsYXNzID0gZmFsc2U7IH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSB7IGJyZWFrIH1cbiAgICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICAgIH0gZWxzZSB7IGVzY2FwZWQgPSBmYWxzZTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gICAgdmFyIHBhdHRlcm4gPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICB2YXIgZmxhZ3NTdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBmbGFncyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy51bmV4cGVjdGVkKGZsYWdzU3RhcnQpOyB9XG5cbiAgICAvLyBWYWxpZGF0ZSBwYXR0ZXJuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5yZWdleHBTdGF0ZSB8fCAodGhpcy5yZWdleHBTdGF0ZSA9IG5ldyBSZWdFeHBWYWxpZGF0aW9uU3RhdGUodGhpcykpO1xuICAgIHN0YXRlLnJlc2V0KHN0YXJ0LCBwYXR0ZXJuLCBmbGFncyk7XG4gICAgdGhpcy52YWxpZGF0ZVJlZ0V4cEZsYWdzKHN0YXRlKTtcbiAgICB0aGlzLnZhbGlkYXRlUmVnRXhwUGF0dGVybihzdGF0ZSk7XG5cbiAgICAvLyBDcmVhdGUgTGl0ZXJhbCN2YWx1ZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEVTVHJlZSByZXF1aXJlcyBudWxsIGlmIGl0IGZhaWxlZCB0byBpbnN0YW50aWF0ZSBSZWdFeHAgb2JqZWN0LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWUvYmxvYi9hMjcwMDNhZGY0ZmQ3YmZhZDQ0ZGU5Y2VmMzcyYTJlYWNkNTI3YjFjL2VzNS5tZCNyZWdleHBsaXRlcmFsXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5yZWdleHAsIHtwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZX0pXG4gIH07XG5cbiAgLy8gUmVhZCBhbiBpbnRlZ2VyIGluIHRoZSBnaXZlbiByYWRpeC4gUmV0dXJuIG51bGwgaWYgemVybyBkaWdpdHNcbiAgLy8gd2VyZSByZWFkLCB0aGUgaW50ZWdlciB2YWx1ZSBvdGhlcndpc2UuIFdoZW4gYGxlbmAgaXMgZ2l2ZW4sIHRoaXNcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgIHVubGVzcyB0aGUgaW50ZWdlciBoYXMgZXhhY3RseSBgbGVuYCBkaWdpdHMuXG5cbiAgcHAucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4sIG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgIC8vIGBsZW5gIGlzIHVzZWQgZm9yIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VzLiBJbiB0aGF0IGNhc2UsIGRpc2FsbG93IHNlcGFyYXRvcnMuXG4gICAgdmFyIGFsbG93U2VwYXJhdG9ycyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMiAmJiBsZW4gPT09IHVuZGVmaW5lZDtcblxuICAgIC8vIGBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWxgIGlzIHRydWUgaWYgaXQgZG9lc24ndCBoYXZlIHByZWZpeCAoMHgsMG8sMGIpXG4gICAgLy8gYW5kIGlzbid0IGZyYWN0aW9uIHBhcnQgbm9yIGV4cG9uZW50IHBhcnQuIEluIHRoYXQgY2FzZSwgaWYgdGhlIGZpcnN0IGRpZ2l0XG4gICAgLy8gaXMgemVybyB0aGVuIGRpc2FsbG93IHNlcGFyYXRvcnMuXG4gICAgdmFyIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCA9IG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSA0ODtcblxuICAgIHZhciBzdGFydCA9IHRoaXMucG9zLCB0b3RhbCA9IDAsIGxhc3RDb2RlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2ksICsrdGhpcy5wb3MpIHtcbiAgICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgdmFsID0gKHZvaWQgMCk7XG5cbiAgICAgIGlmIChhbGxvd1NlcGFyYXRvcnMgJiYgY29kZSA9PT0gOTUpIHtcbiAgICAgICAgaWYgKGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgaW4gbGVnYWN5IG9jdGFsIG51bWVyaWMgbGl0ZXJhbHNcIik7IH1cbiAgICAgICAgaWYgKGxhc3RDb2RlID09PSA5NSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgbXVzdCBiZSBleGFjdGx5IG9uZSB1bmRlcnNjb3JlXCIpOyB9XG4gICAgICAgIGlmIChpID09PSAwKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgZmlyc3Qgb2YgZGlnaXRzXCIpOyB9XG4gICAgICAgIGxhc3RDb2RlID0gY29kZTtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPj0gOTcpIHsgdmFsID0gY29kZSAtIDk3ICsgMTA7IH0gLy8gYVxuICAgICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgeyB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgfSAvLyBBXG4gICAgICBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHsgdmFsID0gY29kZSAtIDQ4OyB9IC8vIDAtOVxuICAgICAgZWxzZSB7IHZhbCA9IEluZmluaXR5OyB9XG4gICAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICAgIGxhc3RDb2RlID0gY29kZTtcbiAgICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dTZXBhcmF0b3JzICYmIGxhc3RDb2RlID09PSA5NSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MgLSAxLCBcIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGF0IHRoZSBsYXN0IG9mIGRpZ2l0c1wiKTsgfVxuICAgIGlmICh0aGlzLnBvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdGhpcy5wb3MgLSBzdGFydCAhPT0gbGVuKSB7IHJldHVybiBudWxsIH1cblxuICAgIHJldHVybiB0b3RhbFxuICB9O1xuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvTnVtYmVyKHN0ciwgaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7XG4gICAgaWYgKGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgOClcbiAgICB9XG5cbiAgICAvLyBgcGFyc2VGbG9hdCh2YWx1ZSlgIHN0b3BzIHBhcnNpbmcgYXQgdGhlIGZpcnN0IG51bWVyaWMgc2VwYXJhdG9yIHRoZW4gcmV0dXJucyBhIHdyb25nIHZhbHVlLlxuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0ci5yZXBsYWNlKC9fL2csIFwiXCIpKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5nVG9CaWdJbnQoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBCaWdJbnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBgQmlnSW50KHZhbHVlKWAgdGhyb3dzIHN5bnRheCBlcnJvciBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG51bWVyaWMgc2VwYXJhdG9ycy5cbiAgICByZXR1cm4gQmlnSW50KHN0ci5yZXBsYWNlKC9fL2csIFwiXCIpKVxuICB9XG5cbiAgcHAucmVhZFJhZGl4TnVtYmVyID0gZnVuY3Rpb24ocmFkaXgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnBvcyArPSAyOyAvLyAweFxuICAgIHZhciB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQgKyAyLCBcIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCBcIiArIHJhZGl4KTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTEwKSB7XG4gICAgICB2YWwgPSBzdHJpbmdUb0JpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEubnVtLCB2YWwpXG4gIH07XG5cbiAgLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbiAgcHAucmVhZE51bWJlciA9IGZ1bmN0aW9uKHN0YXJ0c1dpdGhEb3QpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwLCB1bmRlZmluZWQsIHRydWUpID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB2YXIgb2N0YWwgPSB0aGlzLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gICAgaWYgKG9jdGFsICYmIHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKCFvY3RhbCAmJiAhc3RhcnRzV2l0aERvdCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgbmV4dCA9PT0gMTEwKSB7XG4gICAgICB2YXIgdmFsJDEgPSBzdHJpbmdUb0JpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEubnVtLCB2YWwkMSlcbiAgICB9XG4gICAgaWYgKG9jdGFsICYmIC9bODldLy50ZXN0KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSkpIHsgb2N0YWwgPSBmYWxzZTsgfVxuICAgIGlmIChuZXh0ID09PSA0NiAmJiAhb2N0YWwpIHsgLy8gJy4nXG4gICAgICArK3RoaXMucG9zO1xuICAgICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIH1cbiAgICBpZiAoKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkgJiYgIW9jdGFsKSB7IC8vICdlRSdcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSAvLyAnKy0nXG4gICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgfVxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICAgIHZhciB2YWwgPSBzdHJpbmdUb051bWJlcih0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyksIG9jdGFsKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLm51bSwgdmFsKVxuICB9O1xuXG4gIC8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxuICBwcC5yZWFkQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZTtcblxuICAgIGlmIChjaCA9PT0gMTIzKSB7IC8vICd7J1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZihcIn1cIiwgdGhpcy5wb3MpIC0gdGhpcy5wb3MpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIoNCk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH07XG5cbiAgcHAucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gICAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSArK3RoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHsgYnJlYWsgfVxuICAgICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMDI4IHx8IGNoID09PSAweDIwMjkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDEwKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgdGhpcy5jdXJMaW5lKys7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5zdHJpbmcsIG91dClcbiAgfTtcblxuICAvLyBSZWFkcyB0ZW1wbGF0ZSBzdHJpbmcgdG9rZW5zLlxuXG4gIHZhciBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUiA9IHt9O1xuXG4gIHBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciA9PT0gSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IpIHtcbiAgICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSBmYWxzZTtcbiAgfTtcblxuICBwcC5pbnZhbGlkU3RyaW5nVG9rZW4gPSBmdW5jdGlvbihwb3NpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmluVGVtcGxhdGVFbGVtZW50ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICB0aHJvdyBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUlxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJhaXNlKHBvc2l0aW9uLCBtZXNzYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgcHAucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTIzKSB7IC8vICdgJywgJyR7J1xuICAgICAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuc3RhcnQgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS50ZW1wbGF0ZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuaW52YWxpZFRlbXBsYXRlKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmRvbGxhckJyYWNlTClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYmFja1F1b3RlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEudGVtcGxhdGUsIG91dClcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmVhZHMgYSB0ZW1wbGF0ZSB0b2tlbiB0byBzZWFyY2ggZm9yIHRoZSBlbmQsIHdpdGhvdXQgdmFsaWRhdGluZyBhbnkgZXNjYXBlIHNlcXVlbmNlc1xuICBwcC5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKDsgdGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aDsgdGhpcy5wb3MrKykge1xuICAgICAgc3dpdGNoICh0aGlzLmlucHV0W3RoaXMucG9zXSkge1xuICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRbdGhpcy5wb3MgKyAxXSAhPT0gXCJ7XCIpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJgXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuaW52YWxpZFRlbXBsYXRlLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKSlcblxuICAgICAgLy8gbm8gZGVmYXVsdFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpO1xuICB9O1xuXG4gIC8vIFVzZWQgdG8gcmVhZCBlc2NhcGVkIGNoYXJhY3RlcnNcblxuICBwcC5yZWFkRXNjYXBlZENoYXIgPSBmdW5jdGlvbihpblRlbXBsYXRlKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMTEwOiByZXR1cm4gXCJcXG5cIiAvLyAnbicgLT4gJ1xcbidcbiAgICBjYXNlIDExNDogcmV0dXJuIFwiXFxyXCIgLy8gJ3InIC0+ICdcXHInXG4gICAgY2FzZSAxMjA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEhleENoYXIoMikpIC8vICd4J1xuICAgIGNhc2UgMTE3OiByZXR1cm4gY29kZVBvaW50VG9TdHJpbmcodGhpcy5yZWFkQ29kZVBvaW50KCkpIC8vICd1J1xuICAgIGNhc2UgMTE2OiByZXR1cm4gXCJcXHRcIiAvLyAndCcgLT4gJ1xcdCdcbiAgICBjYXNlIDk4OiByZXR1cm4gXCJcXGJcIiAvLyAnYicgLT4gJ1xcYidcbiAgICBjYXNlIDExODogcmV0dXJuIFwiXFx1MDAwYlwiIC8vICd2JyAtPiAnXFx1MDAwYidcbiAgICBjYXNlIDEwMjogcmV0dXJuIFwiXFxmXCIgLy8gJ2YnIC0+ICdcXGYnXG4gICAgY2FzZSAxMzogaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH0gLy8gJ1xcclxcbidcbiAgICBjYXNlIDEwOiAvLyAnIFxcbidcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7ICsrdGhpcy5jdXJMaW5lOyB9XG4gICAgICByZXR1cm4gXCJcIlxuICAgIGNhc2UgNTY6XG4gICAgY2FzZSA1NzpcbiAgICAgIGlmICh0aGlzLnN0cmljdCkge1xuICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICB0aGlzLnBvcyAtIDEsXG4gICAgICAgICAgXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgICB2YXIgY29kZVBvcyA9IHRoaXMucG9zIC0gMTtcblxuICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICBjb2RlUG9zLFxuICAgICAgICAgIFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoID49IDQ4ICYmIGNoIDw9IDU1KSB7XG4gICAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgICAgdmFyIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICBpZiAob2N0YWwgPiAyNTUpIHtcbiAgICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICgob2N0YWxTdHIgIT09IFwiMFwiIHx8IGNoID09PSA1NiB8fCBjaCA9PT0gNTcpICYmICh0aGlzLnN0cmljdCB8fCBpblRlbXBsYXRlKSkge1xuICAgICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgICAgdGhpcy5wb3MgLSAxIC0gb2N0YWxTdHIubGVuZ3RoLFxuICAgICAgICAgICAgaW5UZW1wbGF0ZVxuICAgICAgICAgICAgICA/IFwiT2N0YWwgbGl0ZXJhbCBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICAgICAgICA6IFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbClcbiAgICAgIH1cbiAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIC8vIFVuaWNvZGUgbmV3IGxpbmUgY2hhcmFjdGVycyBhZnRlciBcXCBnZXQgcmVtb3ZlZCBmcm9tIG91dHB1dCBpbiBib3RoXG4gICAgICAgIC8vIHRlbXBsYXRlIGxpdGVyYWxzIGFuZCBzdHJpbmdzXG4gICAgICAgIHJldHVybiBcIlwiXG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaClcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZWFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VzICgnXFx4JywgJ1xcdScsICdcXFUnKS5cblxuICBwcC5yZWFkSGV4Q2hhciA9IGZ1bmN0aW9uKGxlbikge1xuICAgIHZhciBjb2RlUG9zID0gdGhpcy5wb3M7XG4gICAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbik7XG4gICAgaWYgKG4gPT09IG51bGwpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKTsgfVxuICAgIHJldHVybiBuXG4gIH07XG5cbiAgLy8gUmVhZCBhbiBpZGVudGlmaWVyLCBhbmQgcmV0dXJuIGl0IGFzIGEgc3RyaW5nLiBTZXRzIGB0aGlzLmNvbnRhaW5zRXNjYFxuICAvLyB0byB3aGV0aGVyIHRoZSB3b3JkIGNvbnRhaW5lZCBhICdcXHUnIGVzY2FwZS5cbiAgLy9cbiAgLy8gSW5jcmVtZW50YWxseSBhZGRzIG9ubHkgZXNjYXBlZCBjaGFycywgYWRkaW5nIG90aGVyIGNodW5rcyBhcy1pc1xuICAvLyBhcyBhIG1pY3JvLW9wdGltaXphdGlvbi5cblxuICBwcC5yZWFkV29yZDEgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgdmFyIHdvcmQgPSBcIlwiLCBmaXJzdCA9IHRydWUsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICAgIGlmIChpc0lkZW50aWZpZXJDaGFyKGNoLCBhc3RyYWwpKSB7XG4gICAgICAgIHRoaXMucG9zICs9IGNoIDw9IDB4ZmZmZiA/IDEgOiAyO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHsgLy8gXCJcXFwiXG4gICAgICAgIHRoaXMuY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgICB3b3JkICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICB2YXIgZXNjU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKSAhPT0gMTE3KSAvLyBcInVcIlxuICAgICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTsgfVxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICB2YXIgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KCk7XG4gICAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyKShlc2MsIGFzdHJhbCkpXG4gICAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihlc2NTdGFydCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpOyB9XG4gICAgICAgIHdvcmQgKz0gY29kZVBvaW50VG9TdHJpbmcoZXNjKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB3b3JkICsgdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcylcbiAgfTtcblxuICAvLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbiAgLy8gd29yZHMgd2hlbiBuZWNlc3NhcnkuXG5cbiAgcHAucmVhZFdvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgd29yZCA9IHRoaXMucmVhZFdvcmQxKCk7XG4gICAgdmFyIHR5cGUgPSB0eXBlcyQxLm5hbWU7XG4gICAgaWYgKHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSkge1xuICAgICAgdHlwZSA9IGtleXdvcmRzW3dvcmRdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCB3b3JkKVxuICB9O1xuXG4gIC8vIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQuXG4gIC8vXG4gIC8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UsIEluZ3ZhciBTdGVwYW55YW4sIGFuZFxuICAvLyB2YXJpb3VzIGNvbnRyaWJ1dG9ycyBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4gIC8vXG4gIC8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbiAgLy9cbiAgLy8gICAgIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvZ2l0L2Fjb3JuXG4gIC8vICAgICBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi5naXRcbiAgLy9cbiAgLy8gUGxlYXNlIHVzZSB0aGUgW2dpdGh1YiBidWcgdHJhY2tlcl1bZ2hidF0gdG8gcmVwb3J0IGlzc3Vlcy5cbiAgLy9cbiAgLy8gW2doYnRdOiBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi9pc3N1ZXNcbiAgLy9cbiAgLy8gW3dhbGtdOiB1dGlsL3dhbGsuanNcblxuXG4gIHZhciB2ZXJzaW9uID0gXCI4LjEwLjBcIjtcblxuICBQYXJzZXIuYWNvcm4gPSB7XG4gICAgUGFyc2VyOiBQYXJzZXIsXG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICBkZWZhdWx0T3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG4gICAgUG9zaXRpb246IFBvc2l0aW9uLFxuICAgIFNvdXJjZUxvY2F0aW9uOiBTb3VyY2VMb2NhdGlvbixcbiAgICBnZXRMaW5lSW5mbzogZ2V0TGluZUluZm8sXG4gICAgTm9kZTogTm9kZSxcbiAgICBUb2tlblR5cGU6IFRva2VuVHlwZSxcbiAgICB0b2tUeXBlczogdHlwZXMkMSxcbiAgICBrZXl3b3JkVHlwZXM6IGtleXdvcmRzLFxuICAgIFRva0NvbnRleHQ6IFRva0NvbnRleHQsXG4gICAgdG9rQ29udGV4dHM6IHR5cGVzLFxuICAgIGlzSWRlbnRpZmllckNoYXI6IGlzSWRlbnRpZmllckNoYXIsXG4gICAgaXNJZGVudGlmaWVyU3RhcnQ6IGlzSWRlbnRpZmllclN0YXJ0LFxuICAgIFRva2VuOiBUb2tlbixcbiAgICBpc05ld0xpbmU6IGlzTmV3TGluZSxcbiAgICBsaW5lQnJlYWs6IGxpbmVCcmVhayxcbiAgICBsaW5lQnJlYWtHOiBsaW5lQnJlYWtHLFxuICAgIG5vbkFTQ0lJd2hpdGVzcGFjZTogbm9uQVNDSUl3aGl0ZXNwYWNlXG4gIH07XG5cbiAgLy8gVGhlIG1haW4gZXhwb3J0ZWQgaW50ZXJmYWNlICh1bmRlciBgc2VsZi5hY29ybmAgd2hlbiBpbiB0aGVcbiAgLy8gYnJvd3NlcikgaXMgYSBgcGFyc2VgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjb2RlIHN0cmluZyBhbmRcbiAgLy8gcmV0dXJucyBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSBhcyBzcGVjaWZpZWQgYnkgW01vemlsbGEgcGFyc2VyXG4gIC8vIEFQSV1bYXBpXS5cbiAgLy9cbiAgLy8gW2FwaV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvU3BpZGVyTW9ua2V5L1BhcnNlcl9BUElcblxuICBmdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpXG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGEgc2luZ2xlIGV4cHJlc3Npb24gYXQgYSBnaXZlblxuICAvLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4gIC8vIHRoYXQgZW1iZWQgSmF2YVNjcmlwdCBleHByZXNzaW9ucy5cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKVxuICB9XG5cbiAgLy8gQWNvcm4gaXMgb3JnYW5pemVkIGFzIGEgdG9rZW5pemVyIGFuZCBhIHJlY3Vyc2l2ZS1kZXNjZW50IHBhcnNlci5cbiAgLy8gVGhlIGB0b2tlbml6ZXJgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cblxuICBmdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnRva2VuaXplcihpbnB1dCwgb3B0aW9ucylcbiAgfVxuXG4gIGV4cG9ydHMuTm9kZSA9IE5vZGU7XG4gIGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuICBleHBvcnRzLlBvc2l0aW9uID0gUG9zaXRpb247XG4gIGV4cG9ydHMuU291cmNlTG9jYXRpb24gPSBTb3VyY2VMb2NhdGlvbjtcbiAgZXhwb3J0cy5Ub2tDb250ZXh0ID0gVG9rQ29udGV4dDtcbiAgZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuICBleHBvcnRzLlRva2VuVHlwZSA9IFRva2VuVHlwZTtcbiAgZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICBleHBvcnRzLmdldExpbmVJbmZvID0gZ2V0TGluZUluZm87XG4gIGV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGlzSWRlbnRpZmllckNoYXI7XG4gIGV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBpc0lkZW50aWZpZXJTdGFydDtcbiAgZXhwb3J0cy5pc05ld0xpbmUgPSBpc05ld0xpbmU7XG4gIGV4cG9ydHMua2V5d29yZFR5cGVzID0ga2V5d29yZHM7XG4gIGV4cG9ydHMubGluZUJyZWFrID0gbGluZUJyZWFrO1xuICBleHBvcnRzLmxpbmVCcmVha0cgPSBsaW5lQnJlYWtHO1xuICBleHBvcnRzLm5vbkFTQ0lJd2hpdGVzcGFjZSA9IG5vbkFTQ0lJd2hpdGVzcGFjZTtcbiAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuICBleHBvcnRzLnBhcnNlRXhwcmVzc2lvbkF0ID0gcGFyc2VFeHByZXNzaW9uQXQ7XG4gIGV4cG9ydHMudG9rQ29udGV4dHMgPSB0eXBlcztcbiAgZXhwb3J0cy50b2tUeXBlcyA9IHR5cGVzJDE7XG4gIGV4cG9ydHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICBleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG59KSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwic2VsZiIsImFjb3JuIiwiYXN0cmFsSWRlbnRpZmllckNvZGVzIiwiYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMiLCJub25BU0NJSWlkZW50aWZpZXJDaGFycyIsIm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMiLCJyZXNlcnZlZFdvcmRzIiwic3RyaWN0Iiwic3RyaWN0QmluZCIsImVjbWE1QW5kTGVzc0tleXdvcmRzIiwia2V5d29yZHMkMSIsImtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IiLCJub25BU0NJSWlkZW50aWZpZXJTdGFydCIsIlJlZ0V4cCIsIm5vbkFTQ0lJaWRlbnRpZmllciIsImlzSW5Bc3RyYWxTZXQiLCJjb2RlIiwic2V0IiwicG9zIiwiaSIsImxlbmd0aCIsImlzSWRlbnRpZmllclN0YXJ0IiwiYXN0cmFsIiwidGVzdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImlzSWRlbnRpZmllckNoYXIiLCJUb2tlblR5cGUiLCJsYWJlbCIsImNvbmYiLCJrZXl3b3JkIiwiYmVmb3JlRXhwciIsInN0YXJ0c0V4cHIiLCJpc0xvb3AiLCJpc0Fzc2lnbiIsInByZWZpeCIsInBvc3RmaXgiLCJiaW5vcCIsInVwZGF0ZUNvbnRleHQiLCJuYW1lIiwicHJlYyIsImtleXdvcmRzIiwia3ciLCJvcHRpb25zIiwidHlwZXMkMSIsIm51bSIsInJlZ2V4cCIsInN0cmluZyIsInByaXZhdGVJZCIsImVvZiIsImJyYWNrZXRMIiwiYnJhY2tldFIiLCJicmFjZUwiLCJicmFjZVIiLCJwYXJlbkwiLCJwYXJlblIiLCJjb21tYSIsInNlbWkiLCJjb2xvbiIsImRvdCIsInF1ZXN0aW9uIiwicXVlc3Rpb25Eb3QiLCJhcnJvdyIsInRlbXBsYXRlIiwiaW52YWxpZFRlbXBsYXRlIiwiZWxsaXBzaXMiLCJiYWNrUXVvdGUiLCJkb2xsYXJCcmFjZUwiLCJlcSIsImFzc2lnbiIsImluY0RlYyIsImxvZ2ljYWxPUiIsImxvZ2ljYWxBTkQiLCJiaXR3aXNlT1IiLCJiaXR3aXNlWE9SIiwiYml0d2lzZUFORCIsImVxdWFsaXR5IiwicmVsYXRpb25hbCIsImJpdFNoaWZ0IiwicGx1c01pbiIsIm1vZHVsbyIsInN0YXIiLCJzbGFzaCIsInN0YXJzdGFyIiwiY29hbGVzY2UiLCJfYnJlYWsiLCJfY2FzZSIsIl9jYXRjaCIsIl9jb250aW51ZSIsIl9kZWJ1Z2dlciIsIl9kZWZhdWx0IiwiX2RvIiwiX2Vsc2UiLCJfZmluYWxseSIsIl9mb3IiLCJfZnVuY3Rpb24iLCJfaWYiLCJfcmV0dXJuIiwiX3N3aXRjaCIsIl90aHJvdyIsIl90cnkiLCJfdmFyIiwiX2NvbnN0IiwiX3doaWxlIiwiX3dpdGgiLCJfbmV3IiwiX3RoaXMiLCJfc3VwZXIiLCJfY2xhc3MiLCJfZXh0ZW5kcyIsIl9leHBvcnQiLCJfaW1wb3J0IiwiX251bGwiLCJfdHJ1ZSIsIl9mYWxzZSIsIl9pbiIsIl9pbnN0YW5jZW9mIiwiX3R5cGVvZiIsIl92b2lkIiwiX2RlbGV0ZSIsImxpbmVCcmVhayIsImxpbmVCcmVha0ciLCJzb3VyY2UiLCJpc05ld0xpbmUiLCJuZXh0TGluZUJyZWFrIiwiZnJvbSIsImVuZCIsIm5leHQiLCJjaGFyQ29kZUF0Iiwibm9uQVNDSUl3aGl0ZXNwYWNlIiwic2tpcFdoaXRlU3BhY2UiLCJyZWYiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInRvU3RyaW5nIiwiaGFzT3duIiwib2JqIiwicHJvcE5hbWUiLCJjYWxsIiwiaXNBcnJheSIsIkFycmF5Iiwid29yZHNSZWdleHAiLCJ3b3JkcyIsInJlcGxhY2UiLCJjb2RlUG9pbnRUb1N0cmluZyIsImxvbmVTdXJyb2dhdGUiLCJQb3NpdGlvbiIsImxpbmUiLCJjb2wiLCJjb2x1bW4iLCJvZmZzZXQiLCJuIiwiU291cmNlTG9jYXRpb24iLCJwIiwic3RhcnQiLCJzb3VyY2VGaWxlIiwiZ2V0TGluZUluZm8iLCJpbnB1dCIsImN1ciIsIm5leHRCcmVhayIsImRlZmF1bHRPcHRpb25zIiwiZWNtYVZlcnNpb24iLCJzb3VyY2VUeXBlIiwib25JbnNlcnRlZFNlbWljb2xvbiIsIm9uVHJhaWxpbmdDb21tYSIsImFsbG93UmVzZXJ2ZWQiLCJhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbiIsImFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSIsImFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24iLCJhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZCIsImFsbG93SGFzaEJhbmciLCJjaGVja1ByaXZhdGVGaWVsZHMiLCJsb2NhdGlvbnMiLCJvblRva2VuIiwib25Db21tZW50IiwicmFuZ2VzIiwicHJvZ3JhbSIsImRpcmVjdFNvdXJjZUZpbGUiLCJwcmVzZXJ2ZVBhcmVucyIsIndhcm5lZEFib3V0RWNtYVZlcnNpb24iLCJnZXRPcHRpb25zIiwib3B0cyIsIm9wdCIsImNvbnNvbGUiLCJ3YXJuIiwidG9rZW5zIiwidG9rZW4iLCJwdXNoIiwicHVzaENvbW1lbnQiLCJhcnJheSIsImJsb2NrIiwidGV4dCIsInN0YXJ0TG9jIiwiZW5kTG9jIiwiY29tbWVudCIsInR5cGUiLCJ2YWx1ZSIsImxvYyIsInJhbmdlIiwiU0NPUEVfVE9QIiwiU0NPUEVfRlVOQ1RJT04iLCJTQ09QRV9BU1lOQyIsIlNDT1BFX0dFTkVSQVRPUiIsIlNDT1BFX0FSUk9XIiwiU0NPUEVfU0lNUExFX0NBVENIIiwiU0NPUEVfU1VQRVIiLCJTQ09QRV9ESVJFQ1RfU1VQRVIiLCJTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0siLCJTQ09QRV9WQVIiLCJmdW5jdGlvbkZsYWdzIiwiYXN5bmMiLCJnZW5lcmF0b3IiLCJCSU5EX05PTkUiLCJCSU5EX1ZBUiIsIkJJTkRfTEVYSUNBTCIsIkJJTkRfRlVOQ1RJT04iLCJCSU5EX1NJTVBMRV9DQVRDSCIsIkJJTkRfT1VUU0lERSIsIlBhcnNlciIsInN0YXJ0UG9zIiwicmVzZXJ2ZWQiLCJyZXNlcnZlZFN0cmljdCIsInJlc2VydmVkV29yZHNTdHJpY3QiLCJyZXNlcnZlZFdvcmRzU3RyaWN0QmluZCIsImNvbnRhaW5zRXNjIiwibGluZVN0YXJ0IiwibGFzdEluZGV4T2YiLCJjdXJMaW5lIiwic2xpY2UiLCJzcGxpdCIsImN1clBvc2l0aW9uIiwibGFzdFRva0VuZExvYyIsImxhc3RUb2tTdGFydExvYyIsImxhc3RUb2tTdGFydCIsImxhc3RUb2tFbmQiLCJjb250ZXh0IiwiaW5pdGlhbENvbnRleHQiLCJleHByQWxsb3dlZCIsImluTW9kdWxlIiwic3RyaWN0RGlyZWN0aXZlIiwicG90ZW50aWFsQXJyb3dBdCIsInBvdGVudGlhbEFycm93SW5Gb3JBd2FpdCIsInlpZWxkUG9zIiwiYXdhaXRQb3MiLCJhd2FpdElkZW50UG9zIiwibGFiZWxzIiwidW5kZWZpbmVkRXhwb3J0cyIsImNyZWF0ZSIsInNraXBMaW5lQ29tbWVudCIsInNjb3BlU3RhY2siLCJlbnRlclNjb3BlIiwicmVnZXhwU3RhdGUiLCJwcml2YXRlTmFtZVN0YWNrIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiaW5GdW5jdGlvbiIsImNvbmZpZ3VyYWJsZSIsImluR2VuZXJhdG9yIiwiaW5Bc3luYyIsImNhbkF3YWl0IiwiYWxsb3dTdXBlciIsImFsbG93RGlyZWN0U3VwZXIiLCJ0cmVhdEZ1bmN0aW9uc0FzVmFyIiwiYWxsb3dOZXdEb3RUYXJnZXQiLCJpbkNsYXNzU3RhdGljQmxvY2siLCJwYXJzZSIsIm5vZGUiLCJzdGFydE5vZGUiLCJuZXh0VG9rZW4iLCJwYXJzZVRvcExldmVsIiwiZ2V0IiwiY3VycmVudFZhclNjb3BlIiwiZmxhZ3MiLCJpbkNsYXNzRmllbGRJbml0Iiwic2NvcGUiLCJjdXJyZW50VGhpc1Njb3BlIiwidHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUiLCJjdXJyZW50U2NvcGUiLCJleHRlbmQiLCJwbHVnaW5zIiwibGVuIiwiYXJndW1lbnRzIiwiY2xzIiwicGFyc2VFeHByZXNzaW9uQXQiLCJwYXJzZXIiLCJwYXJzZUV4cHJlc3Npb24iLCJ0b2tlbml6ZXIiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHAkOSIsImxpdGVyYWwiLCJsYXN0SW5kZXgiLCJleGVjIiwibWF0Y2giLCJzcGFjZUFmdGVyIiwiaW5kZXgiLCJjaGFyQXQiLCJlYXQiLCJpc0NvbnRleHR1YWwiLCJlYXRDb250ZXh0dWFsIiwiZXhwZWN0Q29udGV4dHVhbCIsInVuZXhwZWN0ZWQiLCJjYW5JbnNlcnRTZW1pY29sb24iLCJpbnNlcnRTZW1pY29sb24iLCJzZW1pY29sb24iLCJhZnRlclRyYWlsaW5nQ29tbWEiLCJ0b2tUeXBlIiwibm90TmV4dCIsImV4cGVjdCIsInJhaXNlIiwiRGVzdHJ1Y3R1cmluZ0Vycm9ycyIsInNob3J0aGFuZEFzc2lnbiIsInRyYWlsaW5nQ29tbWEiLCJwYXJlbnRoZXNpemVkQXNzaWduIiwicGFyZW50aGVzaXplZEJpbmQiLCJkb3VibGVQcm90byIsImNoZWNrUGF0dGVybkVycm9ycyIsInJlZkRlc3RydWN0dXJpbmdFcnJvcnMiLCJyYWlzZVJlY292ZXJhYmxlIiwicGFyZW5zIiwiY2hlY2tFeHByZXNzaW9uRXJyb3JzIiwiYW5kVGhyb3ciLCJjaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMiLCJpc1NpbXBsZUFzc2lnblRhcmdldCIsImV4cHIiLCJleHByZXNzaW9uIiwicHAkOCIsImJvZHkiLCJzdG10IiwicGFyc2VTdGF0ZW1lbnQiLCJsaXN0Iiwia2V5cyIsImFkYXB0RGlyZWN0aXZlUHJvbG9ndWUiLCJmaW5pc2hOb2RlIiwibG9vcExhYmVsIiwia2luZCIsInN3aXRjaExhYmVsIiwiaXNMZXQiLCJza2lwIiwibmV4dENoIiwiaWRlbnQiLCJpc0FzeW5jRnVuY3Rpb24iLCJhZnRlciIsInRvcExldmVsIiwic3RhcnR0eXBlIiwicGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50IiwicGFyc2VEZWJ1Z2dlclN0YXRlbWVudCIsInBhcnNlRG9TdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsInBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQiLCJwYXJzZUNsYXNzIiwicGFyc2VJZlN0YXRlbWVudCIsInBhcnNlUmV0dXJuU3RhdGVtZW50IiwicGFyc2VTd2l0Y2hTdGF0ZW1lbnQiLCJwYXJzZVRocm93U3RhdGVtZW50IiwicGFyc2VUcnlTdGF0ZW1lbnQiLCJwYXJzZVZhclN0YXRlbWVudCIsInBhcnNlV2hpbGVTdGF0ZW1lbnQiLCJwYXJzZVdpdGhTdGF0ZW1lbnQiLCJwYXJzZUJsb2NrIiwicGFyc2VFbXB0eVN0YXRlbWVudCIsInBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCIsInBhcnNlSW1wb3J0IiwicGFyc2VFeHBvcnQiLCJtYXliZU5hbWUiLCJwYXJzZUxhYmVsZWRTdGF0ZW1lbnQiLCJpc0JyZWFrIiwicGFyc2VJZGVudCIsImxhYiIsInBvcCIsInBhcnNlUGFyZW5FeHByZXNzaW9uIiwiYXdhaXRBdCIsInBhcnNlRm9yIiwiaW5pdCQxIiwicGFyc2VWYXIiLCJkZWNsYXJhdGlvbnMiLCJhd2FpdCIsInBhcnNlRm9ySW4iLCJzdGFydHNXaXRoTGV0IiwiaXNGb3JPZiIsImluaXQiLCJ0b0Fzc2lnbmFibGUiLCJjaGVja0xWYWxQYXR0ZXJuIiwiaXNBc3luYyIsImRlY2xhcmF0aW9uUG9zaXRpb24iLCJwYXJzZUZ1bmN0aW9uIiwiRlVOQ19TVEFURU1FTlQiLCJGVU5DX0hBTkdJTkdfU1RBVEVNRU5UIiwiY29uc2VxdWVudCIsImFsdGVybmF0ZSIsImFyZ3VtZW50IiwiZGlzY3JpbWluYW50IiwiY2FzZXMiLCJzYXdEZWZhdWx0IiwiaXNDYXNlIiwiZXhpdFNjb3BlIiwiZW1wdHkkMSIsInBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSIsInBhcmFtIiwicGFyc2VCaW5kaW5nQXRvbSIsInNpbXBsZSIsImhhbmRsZXIiLCJjbGF1c2UiLCJmaW5hbGl6ZXIiLCJhbGxvd01pc3NpbmdJbml0aWFsaXplciIsIm9iamVjdCIsImkkMSIsImxhYmVsJDEiLCJzdGF0ZW1lbnRTdGFydCIsImluZGV4T2YiLCJjcmVhdGVOZXdMZXhpY2FsU2NvcGUiLCJleGl0U3RyaWN0IiwidXBkYXRlIiwiaXNGb3JJbiIsImlkIiwibGVmdCIsInJpZ2h0IiwicGFyc2VNYXliZUFzc2lnbiIsImlzRm9yIiwiZGVjbCIsInBhcnNlVmFySWQiLCJGVU5DX05VTExBQkxFX0lEIiwic3RhdGVtZW50IiwiYWxsb3dFeHByZXNzaW9uQm9keSIsImZvckluaXQiLCJpbml0RnVuY3Rpb24iLCJjaGVja0xWYWxTaW1wbGUiLCJvbGRZaWVsZFBvcyIsIm9sZEF3YWl0UG9zIiwib2xkQXdhaXRJZGVudFBvcyIsInBhcnNlRnVuY3Rpb25QYXJhbXMiLCJwYXJzZUZ1bmN0aW9uQm9keSIsInBhcmFtcyIsInBhcnNlQmluZGluZ0xpc3QiLCJpc1N0YXRlbWVudCIsIm9sZFN0cmljdCIsInBhcnNlQ2xhc3NJZCIsInBhcnNlQ2xhc3NTdXBlciIsInByaXZhdGVOYW1lTWFwIiwiZW50ZXJDbGFzc0JvZHkiLCJjbGFzc0JvZHkiLCJoYWRDb25zdHJ1Y3RvciIsImVsZW1lbnQiLCJwYXJzZUNsYXNzRWxlbWVudCIsInN1cGVyQ2xhc3MiLCJrZXkiLCJpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZCIsImV4aXRDbGFzc0JvZHkiLCJjb25zdHJ1Y3RvckFsbG93c1N1cGVyIiwia2V5TmFtZSIsImlzR2VuZXJhdG9yIiwiaXNTdGF0aWMiLCJwYXJzZUNsYXNzU3RhdGljQmxvY2siLCJpc0NsYXNzRWxlbWVudE5hbWVTdGFydCIsInN0YXRpYyIsImxhc3RWYWx1ZSIsImNvbXB1dGVkIiwic3RhcnROb2RlQXQiLCJwYXJzZUNsYXNzRWxlbWVudE5hbWUiLCJpc0NvbnN0cnVjdG9yIiwiY2hlY2tLZXlOYW1lIiwiYWxsb3dzRGlyZWN0U3VwZXIiLCJwYXJzZUNsYXNzTWV0aG9kIiwicGFyc2VDbGFzc0ZpZWxkIiwicGFyc2VQcml2YXRlSWRlbnQiLCJwYXJzZVByb3BlcnR5TmFtZSIsIm1ldGhvZCIsInBhcnNlTWV0aG9kIiwiZmllbGQiLCJvbGRMYWJlbHMiLCJwYXJzZUV4cHJTdWJzY3JpcHRzIiwiZGVjbGFyZWQiLCJ1c2VkIiwicGFyZW50IiwiY3VyciIsInBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24iLCJleHBvcnRlZCIsInBhcnNlTW9kdWxlRXhwb3J0TmFtZSIsImNoZWNrRXhwb3J0IiwicGFyc2VFeHByQXRvbSIsImRlY2xhcmF0aW9uIiwicGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24iLCJzaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCIsInBhcnNlRXhwb3J0RGVjbGFyYXRpb24iLCJjaGVja1ZhcmlhYmxlRXhwb3J0Iiwic3BlY2lmaWVycyIsInBhcnNlRXhwb3J0U3BlY2lmaWVycyIsInNwZWMiLCJjaGVja1VucmVzZXJ2ZWQiLCJsb2NhbCIsImNoZWNrTG9jYWxFeHBvcnQiLCJmTm9kZSIsImNOb2RlIiwiY2hlY2tQYXR0ZXJuRXhwb3J0IiwicGF0IiwicHJvcGVydGllcyIsInByb3AiLCJsaXN0JDEiLCJlbGVtZW50cyIsImVsdCIsImRlY2xzIiwicGFyc2VFeHBvcnRTcGVjaWZpZXIiLCJub2RlcyIsImZpcnN0IiwicGFyc2VJbXBvcnRTcGVjaWZpZXJzIiwicGFyc2VJbXBvcnRTcGVjaWZpZXIiLCJpbXBvcnRlZCIsInBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllciIsInBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyIiwic3RyaW5nTGl0ZXJhbCIsInBhcnNlTGl0ZXJhbCIsInN0YXRlbWVudHMiLCJpc0RpcmVjdGl2ZUNhbmRpZGF0ZSIsImRpcmVjdGl2ZSIsInJhdyIsInBwJDciLCJpc0JpbmRpbmciLCJ0b0Fzc2lnbmFibGVMaXN0Iiwib3BlcmF0b3IiLCJleHByTGlzdCIsImxhc3QiLCJwYXJzZVNwcmVhZCIsInBhcnNlUmVzdEJpbmRpbmciLCJwYXJzZU9iaiIsImNsb3NlIiwiYWxsb3dFbXB0eSIsImFsbG93VHJhaWxpbmdDb21tYSIsImFsbG93TW9kaWZpZXJzIiwiZWx0cyIsInJlc3QiLCJwYXJzZUJpbmRpbmdMaXN0SXRlbSIsInBhcnNlQXNzaWduYWJsZUxpc3RJdGVtIiwiZWxlbSIsInBhcnNlTWF5YmVEZWZhdWx0IiwiYmluZGluZ1R5cGUiLCJjaGVja0NsYXNoZXMiLCJpc0JpbmQiLCJkZWNsYXJlTmFtZSIsImNoZWNrTFZhbElubmVyUGF0dGVybiIsIlRva0NvbnRleHQiLCJpc0V4cHIiLCJwcmVzZXJ2ZVNwYWNlIiwib3ZlcnJpZGUiLCJ0eXBlcyIsImJfc3RhdCIsImJfZXhwciIsImJfdG1wbCIsInBfc3RhdCIsInBfZXhwciIsInFfdG1wbCIsInRyeVJlYWRUZW1wbGF0ZVRva2VuIiwiZl9zdGF0IiwiZl9leHByIiwiZl9leHByX2dlbiIsImZfZ2VuIiwicHAkNiIsImN1ckNvbnRleHQiLCJicmFjZUlzQmxvY2siLCJwcmV2VHlwZSIsImluR2VuZXJhdG9yQ29udGV4dCIsIm92ZXJyaWRlQ29udGV4dCIsInRva2VuQ3R4Iiwib3V0Iiwic3RhdGVtZW50UGFyZW5zIiwiYWxsb3dlZCIsInBwJDUiLCJjaGVja1Byb3BDbGFzaCIsInByb3BIYXNoIiwic2hvcnRoYW5kIiwicHJvdG8iLCJvdGhlciIsInJlZGVmaW5pdGlvbiIsImV4cHJlc3Npb25zIiwiYWZ0ZXJMZWZ0UGFyc2UiLCJwYXJzZVlpZWxkIiwib3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyIsIm9sZFBhcmVuQXNzaWduIiwib2xkVHJhaWxpbmdDb21tYSIsIm9sZERvdWJsZVByb3RvIiwicGFyc2VNYXliZUNvbmRpdGlvbmFsIiwicGFyc2VFeHByT3BzIiwicGFyc2VNYXliZVVuYXJ5IiwicGFyc2VFeHByT3AiLCJsZWZ0U3RhcnRQb3MiLCJsZWZ0U3RhcnRMb2MiLCJtaW5QcmVjIiwibG9naWNhbCIsIm9wIiwiYnVpbGRCaW5hcnkiLCJzYXdVbmFyeSIsInBhcnNlQXdhaXQiLCJpc1ByaXZhdGVGaWVsZEFjY2VzcyIsIm5vZGUkMSIsInByb3BlcnR5IiwicmVzdWx0IiwicGFyc2VTdWJzY3JpcHRzIiwiYmFzZSIsIm5vQ2FsbHMiLCJtYXliZUFzeW5jQXJyb3ciLCJvcHRpb25hbENoYWluZWQiLCJwYXJzZVN1YnNjcmlwdCIsIm9wdGlvbmFsIiwiY2hhaW5Ob2RlIiwic2hvdWxkUGFyc2VBc3luY0Fycm93IiwicGFyc2VTdWJzY3JpcHRBc3luY0Fycm93IiwicGFyc2VBcnJvd0V4cHJlc3Npb24iLCJvcHRpb25hbFN1cHBvcnRlZCIsInBhcnNlRXhwckxpc3QiLCJjYWxsZWUiLCJub2RlJDIiLCJ0YWciLCJxdWFzaSIsInBhcnNlVGVtcGxhdGUiLCJpc1RhZ2dlZCIsImZvck5ldyIsInJlYWRSZWdleHAiLCJjYW5CZUFycm93IiwicmVnZXgiLCJwYXR0ZXJuIiwicGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiIsInBhcnNlTmV3IiwicGFyc2VFeHBySW1wb3J0IiwicGFyc2VFeHByQXRvbURlZmF1bHQiLCJtZXRhIiwicGFyc2VEeW5hbWljSW1wb3J0IiwicGFyc2VJbXBvcnRNZXRhIiwiZXJyb3JQb3MiLCJiaWdpbnQiLCJ2YWwiLCJzaG91bGRQYXJzZUFycm93IiwiaW5uZXJTdGFydFBvcyIsImlubmVyU3RhcnRMb2MiLCJsYXN0SXNDb21tYSIsInNwcmVhZFN0YXJ0IiwicGFyc2VQYXJlbkl0ZW0iLCJpbm5lckVuZFBvcyIsImlubmVyRW5kTG9jIiwicGFyc2VQYXJlbkFycm93TGlzdCIsImZpbmlzaE5vZGVBdCIsInBhciIsIml0ZW0iLCJlbXB0eSIsInBhcnNlVGVtcGxhdGVFbGVtZW50IiwiY29va2VkIiwidGFpbCIsImN1ckVsdCIsInF1YXNpcyIsImlzQXN5bmNQcm9wIiwiaXNQYXR0ZXJuIiwicGFyc2VQcm9wZXJ0eSIsInBhcnNlUHJvcGVydHlWYWx1ZSIsInBhcnNlR2V0dGVyU2V0dGVyIiwicGFyYW1Db3VudCIsImNvcHlOb2RlIiwiaXNBcnJvd0Z1bmN0aW9uIiwiaXNNZXRob2QiLCJpc0V4cHJlc3Npb24iLCJ1c2VTdHJpY3QiLCJjaGVja1BhcmFtcyIsIm5vblNpbXBsZSIsImlzU2ltcGxlUGFyYW1MaXN0IiwidW5kZWZpbmVkIiwiYWxsb3dEdXBsaWNhdGVzIiwibmFtZUhhc2giLCJyZSIsImxpYmVyYWwiLCJwYXJzZUlkZW50Tm9kZSIsImRlbGVnYXRlIiwicHAkNCIsIm1lc3NhZ2UiLCJlcnIiLCJTeW50YXhFcnJvciIsInJhaXNlZEF0IiwicHAkMyIsIlNjb3BlIiwidmFyIiwibGV4aWNhbCIsImZ1bmN0aW9ucyIsInJlZGVjbGFyZWQiLCJzY29wZSQxIiwic2NvcGUkMiIsInNjb3BlJDMiLCJOb2RlIiwicHAkMiIsIm5ld05vZGUiLCJlY21hOUJpbmFyeVByb3BlcnRpZXMiLCJlY21hMTBCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTExQmluYXJ5UHJvcGVydGllcyIsImVjbWExMkJpbmFyeVByb3BlcnRpZXMiLCJlY21hMTNCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTE0QmluYXJ5UHJvcGVydGllcyIsInVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTE0QmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyIsInVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzIiwidW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyIsImVjbWE5U2NyaXB0VmFsdWVzIiwiZWNtYTEwU2NyaXB0VmFsdWVzIiwiZWNtYTExU2NyaXB0VmFsdWVzIiwiZWNtYTEyU2NyaXB0VmFsdWVzIiwiZWNtYTEzU2NyaXB0VmFsdWVzIiwiZWNtYTE0U2NyaXB0VmFsdWVzIiwidW5pY29kZVNjcmlwdFZhbHVlcyIsImRhdGEiLCJidWlsZFVuaWNvZGVEYXRhIiwiZCIsImJpbmFyeSIsImJpbmFyeU9mU3RyaW5ncyIsIm5vbkJpbmFyeSIsIkdlbmVyYWxfQ2F0ZWdvcnkiLCJTY3JpcHQiLCJTY3JpcHRfRXh0ZW5zaW9ucyIsImdjIiwic2MiLCJzY3giLCJwcCQxIiwiUmVnRXhwVmFsaWRhdGlvblN0YXRlIiwidmFsaWRGbGFncyIsInVuaWNvZGVQcm9wZXJ0aWVzIiwic3dpdGNoVSIsInN3aXRjaFYiLCJzd2l0Y2hOIiwibGFzdEludFZhbHVlIiwibGFzdFN0cmluZ1ZhbHVlIiwibGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlIiwibnVtQ2FwdHVyaW5nUGFyZW5zIiwibWF4QmFja1JlZmVyZW5jZSIsImdyb3VwTmFtZXMiLCJiYWNrUmVmZXJlbmNlTmFtZXMiLCJyZXNldCIsInVuaWNvZGVTZXRzIiwidW5pY29kZSIsImF0IiwiZm9yY2VVIiwicyIsImwiLCJjIiwibmV4dEluZGV4IiwiY3VycmVudCIsImxvb2thaGVhZCIsImFkdmFuY2UiLCJjaCIsImVhdENoYXJzIiwiY2hzIiwidmFsaWRhdGVSZWdFeHBGbGFncyIsInN0YXRlIiwidSIsInYiLCJmbGFnIiwidmFsaWRhdGVSZWdFeHBQYXR0ZXJuIiwicmVnZXhwX3BhdHRlcm4iLCJyZWdleHBfZGlzanVuY3Rpb24iLCJyZWdleHBfYWx0ZXJuYXRpdmUiLCJyZWdleHBfZWF0UXVhbnRpZmllciIsInJlZ2V4cF9lYXRUZXJtIiwicmVnZXhwX2VhdEFzc2VydGlvbiIsInJlZ2V4cF9lYXRBdG9tIiwicmVnZXhwX2VhdEV4dGVuZGVkQXRvbSIsImxvb2tiZWhpbmQiLCJub0Vycm9yIiwicmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgiLCJyZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciIsIm1pbiIsIm1heCIsInJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzIiwicmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzIiwicmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSIsInJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyIsInJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwIiwicmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwIiwicmVnZXhwX2VhdEF0b21Fc2NhcGUiLCJyZWdleHBfZ3JvdXBTcGVjaWZpZXIiLCJyZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIiLCJyZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyIiwicmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciIsImlzU3ludGF4Q2hhcmFjdGVyIiwicmVnZXhwX2VhdEdyb3VwTmFtZSIsInJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSIsInJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQiLCJyZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQiLCJyZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlIiwiaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQiLCJpc1JlZ0V4cElkZW50aWZpZXJQYXJ0IiwicmVnZXhwX2VhdEJhY2tSZWZlcmVuY2UiLCJyZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUiLCJyZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlIiwicmVnZXhwX2VhdEtHcm91cE5hbWUiLCJyZWdleHBfZWF0RGVjaW1hbEVzY2FwZSIsInJlZ2V4cF9lYXRDb250cm9sRXNjYXBlIiwicmVnZXhwX2VhdENDb250cm9sTGV0dGVyIiwicmVnZXhwX2VhdFplcm8iLCJyZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2UiLCJyZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSIsInJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSIsInJlZ2V4cF9lYXRDb250cm9sTGV0dGVyIiwiaXNEZWNpbWFsRGlnaXQiLCJpc0NvbnRyb2xMZXR0ZXIiLCJyZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMiLCJsZWFkIiwibGVhZFN1cnJvZ2F0ZUVuZCIsInRyYWlsIiwicmVnZXhwX2VhdEhleERpZ2l0cyIsImlzVmFsaWRVbmljb2RlIiwiQ2hhclNldE5vbmUiLCJDaGFyU2V0T2siLCJDaGFyU2V0U3RyaW5nIiwiaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZSIsIm5lZ2F0ZSIsInJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24iLCJyZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSIsInJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSIsInJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZSIsInJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUiLCJuYW1lT3JWYWx1ZSIsInJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIiwiaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyIiwiaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlciIsInJlZ2V4cF9jbGFzc0NvbnRlbnRzIiwicmVnZXhwX2NsYXNzU2V0RXhwcmVzc2lvbiIsInJlZ2V4cF9ub25FbXB0eUNsYXNzUmFuZ2VzIiwicmVnZXhwX2VhdENsYXNzQXRvbSIsInJlZ2V4cF9lYXRDbGFzc0VzY2FwZSIsImNoJDEiLCJpc09jdGFsRGlnaXQiLCJyZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyIiwic3ViUmVzdWx0IiwicmVnZXhwX2VhdENsYXNzU2V0UmFuZ2UiLCJyZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kIiwicmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyIiwicmVnZXhwX2VhdENsYXNzU3RyaW5nRGlzanVuY3Rpb24iLCJyZWdleHBfZWF0TmVzdGVkQ2xhc3MiLCJyZXN1bHQkMSIsInJlZ2V4cF9jbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHMiLCJyZWdleHBfY2xhc3NTdHJpbmciLCJjb3VudCIsInJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvciIsImlzQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JDaGFyYWN0ZXIiLCJpc0NsYXNzU2V0U3ludGF4Q2hhcmFjdGVyIiwiaXNDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvciIsImlzSGV4RGlnaXQiLCJoZXhUb0ludCIsInJlZ2V4cF9lYXRPY3RhbERpZ2l0IiwibjEiLCJuMiIsIlRva2VuIiwicHAiLCJpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCIsImdldFRva2VuIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ0aGlzJDEkMSIsImRvbmUiLCJza2lwU3BhY2UiLCJmaW5pc2hUb2tlbiIsInJlYWRUb2tlbiIsImZ1bGxDaGFyQ29kZUF0UG9zIiwicmVhZFdvcmQiLCJnZXRUb2tlbkZyb21Db2RlIiwic2tpcEJsb2NrQ29tbWVudCIsInN0YXJ0U2tpcCIsImxvb3AiLCJyZWFkVG9rZW5fZG90IiwicmVhZE51bWJlciIsIm5leHQyIiwicmVhZFRva2VuX3NsYXNoIiwiZmluaXNoT3AiLCJyZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwIiwic2l6ZSIsInRva2VudHlwZSIsInJlYWRUb2tlbl9waXBlX2FtcCIsInJlYWRUb2tlbl9jYXJldCIsInJlYWRUb2tlbl9wbHVzX21pbiIsInJlYWRUb2tlbl9sdF9ndCIsInJlYWRUb2tlbl9lcV9leGNsIiwicmVhZFRva2VuX3F1ZXN0aW9uIiwibmV4dDIkMSIsInJlYWRUb2tlbl9udW1iZXJTaWduIiwicmVhZFdvcmQxIiwicmVhZFJhZGl4TnVtYmVyIiwicmVhZFN0cmluZyIsInN0ciIsImVzY2FwZWQiLCJpbkNsYXNzIiwiZmxhZ3NTdGFydCIsImUiLCJyZWFkSW50IiwicmFkaXgiLCJtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwiLCJhbGxvd1NlcGFyYXRvcnMiLCJpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwiLCJ0b3RhbCIsImxhc3RDb2RlIiwiSW5maW5pdHkiLCJzdHJpbmdUb051bWJlciIsInBhcnNlSW50IiwicGFyc2VGbG9hdCIsInN0cmluZ1RvQmlnSW50IiwiQmlnSW50Iiwic3RhcnRzV2l0aERvdCIsIm9jdGFsIiwidmFsJDEiLCJyZWFkQ29kZVBvaW50IiwiY29kZVBvcyIsInJlYWRIZXhDaGFyIiwiaW52YWxpZFN0cmluZ1Rva2VuIiwicXVvdGUiLCJjaHVua1N0YXJ0IiwicmVhZEVzY2FwZWRDaGFyIiwiSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IiLCJpblRlbXBsYXRlRWxlbWVudCIsInJlYWRUbXBsVG9rZW4iLCJyZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4iLCJwb3NpdGlvbiIsImluVGVtcGxhdGUiLCJvY3RhbFN0ciIsInN1YnN0ciIsIndvcmQiLCJlc2NTdGFydCIsImVzYyIsInZlcnNpb24iLCJ0b2tUeXBlcyIsImtleXdvcmRUeXBlcyIsInRva0NvbnRleHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/acorn/dist/acorn.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/acorn/dist/acorn.mjs":
/*!*******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   SourceLocation: () => (/* binding */ SourceLocation),\n/* harmony export */   TokContext: () => (/* binding */ TokContext),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   TokenType: () => (/* binding */ TokenType),\n/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions),\n/* harmony export */   getLineInfo: () => (/* binding */ getLineInfo),\n/* harmony export */   isIdentifierChar: () => (/* binding */ isIdentifierChar),\n/* harmony export */   isIdentifierStart: () => (/* binding */ isIdentifierStart),\n/* harmony export */   isNewLine: () => (/* binding */ isNewLine),\n/* harmony export */   keywordTypes: () => (/* binding */ keywords),\n/* harmony export */   lineBreak: () => (/* binding */ lineBreak),\n/* harmony export */   lineBreakG: () => (/* binding */ lineBreakG),\n/* harmony export */   nonASCIIwhitespace: () => (/* binding */ nonASCIIwhitespace),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseExpressionAt: () => (/* binding */ parseExpressionAt),\n/* harmony export */   tokContexts: () => (/* binding */ types),\n/* harmony export */   tokTypes: () => (/* binding */ types$1),\n/* harmony export */   tokenizer: () => (/* binding */ tokenizer),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// This file was generated. Do not modify manually!\nvar astralIdentifierCodes = [\n    509,\n    0,\n    227,\n    0,\n    150,\n    4,\n    294,\n    9,\n    1368,\n    2,\n    2,\n    1,\n    6,\n    3,\n    41,\n    2,\n    5,\n    0,\n    166,\n    1,\n    574,\n    3,\n    9,\n    9,\n    370,\n    1,\n    81,\n    2,\n    71,\n    10,\n    50,\n    3,\n    123,\n    2,\n    54,\n    14,\n    32,\n    10,\n    3,\n    1,\n    11,\n    3,\n    46,\n    10,\n    8,\n    0,\n    46,\n    9,\n    7,\n    2,\n    37,\n    13,\n    2,\n    9,\n    6,\n    1,\n    45,\n    0,\n    13,\n    2,\n    49,\n    13,\n    9,\n    3,\n    2,\n    11,\n    83,\n    11,\n    7,\n    0,\n    3,\n    0,\n    158,\n    11,\n    6,\n    9,\n    7,\n    3,\n    56,\n    1,\n    2,\n    6,\n    3,\n    1,\n    3,\n    2,\n    10,\n    0,\n    11,\n    1,\n    3,\n    6,\n    4,\n    4,\n    193,\n    17,\n    10,\n    9,\n    5,\n    0,\n    82,\n    19,\n    13,\n    9,\n    214,\n    6,\n    3,\n    8,\n    28,\n    1,\n    83,\n    16,\n    16,\n    9,\n    82,\n    12,\n    9,\n    9,\n    84,\n    14,\n    5,\n    9,\n    243,\n    14,\n    166,\n    9,\n    71,\n    5,\n    2,\n    1,\n    3,\n    3,\n    2,\n    0,\n    2,\n    1,\n    13,\n    9,\n    120,\n    6,\n    3,\n    6,\n    4,\n    0,\n    29,\n    9,\n    41,\n    6,\n    2,\n    3,\n    9,\n    0,\n    10,\n    10,\n    47,\n    15,\n    406,\n    7,\n    2,\n    7,\n    17,\n    9,\n    57,\n    21,\n    2,\n    13,\n    123,\n    5,\n    4,\n    0,\n    2,\n    1,\n    2,\n    6,\n    2,\n    0,\n    9,\n    9,\n    49,\n    4,\n    2,\n    1,\n    2,\n    4,\n    9,\n    9,\n    330,\n    3,\n    10,\n    1,\n    2,\n    0,\n    49,\n    6,\n    4,\n    4,\n    14,\n    9,\n    5351,\n    0,\n    7,\n    14,\n    13835,\n    9,\n    87,\n    9,\n    39,\n    4,\n    60,\n    6,\n    26,\n    9,\n    1014,\n    0,\n    2,\n    54,\n    8,\n    3,\n    82,\n    0,\n    12,\n    1,\n    19628,\n    1,\n    4706,\n    45,\n    3,\n    22,\n    543,\n    4,\n    4,\n    5,\n    9,\n    7,\n    3,\n    6,\n    31,\n    3,\n    149,\n    2,\n    1418,\n    49,\n    513,\n    54,\n    5,\n    49,\n    9,\n    0,\n    15,\n    0,\n    23,\n    4,\n    2,\n    14,\n    1361,\n    6,\n    2,\n    16,\n    3,\n    6,\n    2,\n    1,\n    2,\n    4,\n    101,\n    0,\n    161,\n    6,\n    10,\n    9,\n    357,\n    0,\n    62,\n    13,\n    499,\n    13,\n    983,\n    6,\n    110,\n    6,\n    6,\n    9,\n    4759,\n    9,\n    787719,\n    239\n];\n// This file was generated. Do not modify manually!\nvar astralIdentifierStartCodes = [\n    0,\n    11,\n    2,\n    25,\n    2,\n    18,\n    2,\n    1,\n    2,\n    14,\n    3,\n    13,\n    35,\n    122,\n    70,\n    52,\n    268,\n    28,\n    4,\n    48,\n    48,\n    31,\n    14,\n    29,\n    6,\n    37,\n    11,\n    29,\n    3,\n    35,\n    5,\n    7,\n    2,\n    4,\n    43,\n    157,\n    19,\n    35,\n    5,\n    35,\n    5,\n    39,\n    9,\n    51,\n    13,\n    10,\n    2,\n    14,\n    2,\n    6,\n    2,\n    1,\n    2,\n    10,\n    2,\n    14,\n    2,\n    6,\n    2,\n    1,\n    68,\n    310,\n    10,\n    21,\n    11,\n    7,\n    25,\n    5,\n    2,\n    41,\n    2,\n    8,\n    70,\n    5,\n    3,\n    0,\n    2,\n    43,\n    2,\n    1,\n    4,\n    0,\n    3,\n    22,\n    11,\n    22,\n    10,\n    30,\n    66,\n    18,\n    2,\n    1,\n    11,\n    21,\n    11,\n    25,\n    71,\n    55,\n    7,\n    1,\n    65,\n    0,\n    16,\n    3,\n    2,\n    2,\n    2,\n    28,\n    43,\n    28,\n    4,\n    28,\n    36,\n    7,\n    2,\n    27,\n    28,\n    53,\n    11,\n    21,\n    11,\n    18,\n    14,\n    17,\n    111,\n    72,\n    56,\n    50,\n    14,\n    50,\n    14,\n    35,\n    349,\n    41,\n    7,\n    1,\n    79,\n    28,\n    11,\n    0,\n    9,\n    21,\n    43,\n    17,\n    47,\n    20,\n    28,\n    22,\n    13,\n    52,\n    58,\n    1,\n    3,\n    0,\n    14,\n    44,\n    33,\n    24,\n    27,\n    35,\n    30,\n    0,\n    3,\n    0,\n    9,\n    34,\n    4,\n    0,\n    13,\n    47,\n    15,\n    3,\n    22,\n    0,\n    2,\n    0,\n    36,\n    17,\n    2,\n    24,\n    20,\n    1,\n    64,\n    6,\n    2,\n    0,\n    2,\n    3,\n    2,\n    14,\n    2,\n    9,\n    8,\n    46,\n    39,\n    7,\n    3,\n    1,\n    3,\n    21,\n    2,\n    6,\n    2,\n    1,\n    2,\n    4,\n    4,\n    0,\n    19,\n    0,\n    13,\n    4,\n    159,\n    52,\n    19,\n    3,\n    21,\n    2,\n    31,\n    47,\n    21,\n    1,\n    2,\n    0,\n    185,\n    46,\n    42,\n    3,\n    37,\n    47,\n    21,\n    0,\n    60,\n    42,\n    14,\n    0,\n    72,\n    26,\n    38,\n    6,\n    186,\n    43,\n    117,\n    63,\n    32,\n    7,\n    3,\n    0,\n    3,\n    7,\n    2,\n    1,\n    2,\n    23,\n    16,\n    0,\n    2,\n    0,\n    95,\n    7,\n    3,\n    38,\n    17,\n    0,\n    2,\n    0,\n    29,\n    0,\n    11,\n    39,\n    8,\n    0,\n    22,\n    0,\n    12,\n    45,\n    20,\n    0,\n    19,\n    72,\n    264,\n    8,\n    2,\n    36,\n    18,\n    0,\n    50,\n    29,\n    113,\n    6,\n    2,\n    1,\n    2,\n    37,\n    22,\n    0,\n    26,\n    5,\n    2,\n    1,\n    2,\n    31,\n    15,\n    0,\n    328,\n    18,\n    16,\n    0,\n    2,\n    12,\n    2,\n    33,\n    125,\n    0,\n    80,\n    921,\n    103,\n    110,\n    18,\n    195,\n    2637,\n    96,\n    16,\n    1071,\n    18,\n    5,\n    4026,\n    582,\n    8634,\n    568,\n    8,\n    30,\n    18,\n    78,\n    18,\n    29,\n    19,\n    47,\n    17,\n    3,\n    32,\n    20,\n    6,\n    18,\n    689,\n    63,\n    129,\n    74,\n    6,\n    0,\n    67,\n    12,\n    65,\n    1,\n    2,\n    0,\n    29,\n    6135,\n    9,\n    1237,\n    43,\n    8,\n    8936,\n    3,\n    2,\n    6,\n    2,\n    1,\n    2,\n    290,\n    16,\n    0,\n    30,\n    2,\n    3,\n    0,\n    15,\n    3,\n    9,\n    395,\n    2309,\n    106,\n    6,\n    12,\n    4,\n    8,\n    8,\n    9,\n    5991,\n    84,\n    2,\n    70,\n    2,\n    1,\n    3,\n    0,\n    3,\n    1,\n    3,\n    3,\n    2,\n    11,\n    2,\n    0,\n    2,\n    6,\n    2,\n    64,\n    2,\n    3,\n    3,\n    7,\n    2,\n    6,\n    2,\n    27,\n    2,\n    3,\n    2,\n    4,\n    2,\n    0,\n    4,\n    6,\n    2,\n    339,\n    3,\n    24,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    7,\n    1845,\n    30,\n    7,\n    5,\n    262,\n    61,\n    147,\n    44,\n    11,\n    6,\n    17,\n    0,\n    322,\n    29,\n    19,\n    43,\n    485,\n    27,\n    757,\n    6,\n    2,\n    3,\n    2,\n    1,\n    2,\n    14,\n    2,\n    196,\n    60,\n    67,\n    8,\n    0,\n    1205,\n    3,\n    2,\n    26,\n    2,\n    1,\n    2,\n    0,\n    3,\n    0,\n    2,\n    9,\n    2,\n    3,\n    2,\n    0,\n    2,\n    0,\n    7,\n    0,\n    5,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    2,\n    2,\n    1,\n    2,\n    0,\n    3,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    1,\n    2,\n    0,\n    3,\n    3,\n    2,\n    6,\n    2,\n    3,\n    2,\n    3,\n    2,\n    0,\n    2,\n    9,\n    2,\n    16,\n    6,\n    2,\n    2,\n    4,\n    2,\n    16,\n    4421,\n    42719,\n    33,\n    4153,\n    7,\n    221,\n    3,\n    5761,\n    15,\n    7472,\n    3104,\n    541,\n    1507,\n    4938,\n    6,\n    4191\n];\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierChars = \"‌‍\\xb7̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿\";\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ\";\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range.\n// Reserved word lists for various dialects of the language\nvar reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n};\n// And the keywords\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\nvar keywords$1 = {\n    5: ecma5AndLessKeywords,\n    \"5module\": ecma5AndLessKeywords + \" export import\",\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n// ## Character categories\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for(var i = 0; i < set.length; i += 2){\n        pos += set[i];\n        if (pos > code) {\n            return false;\n        }\n        pos += set[i + 1];\n        if (pos >= code) {\n            return true;\n        }\n    }\n    return false;\n}\n// Test whether a given character code starts an identifier.\nfunction isIdentifierStart(code, astral) {\n    if (code < 65) {\n        return code === 36;\n    }\n    if (code < 91) {\n        return true;\n    }\n    if (code < 97) {\n        return code === 95;\n    }\n    if (code < 123) {\n        return true;\n    }\n    if (code <= 0xffff) {\n        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n    }\n    if (astral === false) {\n        return false;\n    }\n    return isInAstralSet(code, astralIdentifierStartCodes);\n}\n// Test whether a given character is part of an identifier.\nfunction isIdentifierChar(code, astral) {\n    if (code < 48) {\n        return code === 36;\n    }\n    if (code < 58) {\n        return true;\n    }\n    if (code < 65) {\n        return false;\n    }\n    if (code < 91) {\n        return true;\n    }\n    if (code < 97) {\n        return code === 95;\n    }\n    if (code < 123) {\n        return true;\n    }\n    if (code <= 0xffff) {\n        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n    }\n    if (astral === false) {\n        return false;\n    }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n// ## Token types\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\nvar TokenType = function TokenType(label, conf) {\n    if (conf === void 0) conf = {};\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n};\nfunction binop(name, prec) {\n    return new TokenType(name, {\n        beforeExpr: true,\n        binop: prec\n    });\n}\nvar beforeExpr = {\n    beforeExpr: true\n}, startsExpr = {\n    startsExpr: true\n};\n// Map keyword names to token types.\nvar keywords = {};\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n    if (options === void 0) options = {};\n    options.keyword = name;\n    return keywords[name] = new TokenType(name, options);\n}\nvar types$1 = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    privateId: new TokenType(\"privateId\", startsExpr),\n    eof: new TokenType(\"eof\"),\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    questionDot: new TokenType(\"?.\"),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n    eq: new TokenType(\"=\", {\n        beforeExpr: true,\n        isAssign: true\n    }),\n    assign: new TokenType(\"_=\", {\n        beforeExpr: true,\n        isAssign: true\n    }),\n    incDec: new TokenType(\"++/--\", {\n        prefix: true,\n        postfix: true,\n        startsExpr: true\n    }),\n    prefix: new TokenType(\"!/~\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {\n        beforeExpr: true,\n        binop: 9,\n        prefix: true,\n        startsExpr: true\n    }),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {\n        beforeExpr: true\n    }),\n    coalesce: binop(\"??\", 1),\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {\n        isLoop: true,\n        beforeExpr: true\n    }),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {\n        isLoop: true\n    }),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {\n        isLoop: true\n    }),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\", startsExpr),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {\n        beforeExpr: true,\n        binop: 7\n    }),\n    _instanceof: kw(\"instanceof\", {\n        beforeExpr: true,\n        binop: 7\n    }),\n    _typeof: kw(\"typeof\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    _void: kw(\"void\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    _delete: kw(\"delete\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    })\n};\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n}\nfunction nextLineBreak(code, from, end) {\n    if (end === void 0) end = code.length;\n    for(var i = from; i < end; i++){\n        var next = code.charCodeAt(i);\n        if (isNewLine(next)) {\n            return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;\n        }\n    }\n    return -1;\n}\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\nvar hasOwn = Object.hasOwn || function(obj, propName) {\n    return hasOwnProperty.call(obj, propName);\n};\nvar isArray = Array.isArray || function(obj) {\n    return toString.call(obj) === \"[object Array]\";\n};\nfunction wordsRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\");\n}\nfunction codePointToString(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) {\n        return String.fromCharCode(code);\n    }\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n}\nvar loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\nvar Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n};\nPosition.prototype.offset = function offset(n) {\n    return new Position(this.line, this.column + n);\n};\nvar SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) {\n        this.source = p.sourceFile;\n    }\n};\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\nfunction getLineInfo(input, offset) {\n    for(var line = 1, cur = 0;;){\n        var nextBreak = nextLineBreak(input, cur, offset);\n        if (nextBreak < 0) {\n            return new Position(line, offset - cur);\n        }\n        ++line;\n        cur = nextBreak;\n    }\n}\n// A second argument must be given to configure the parser process.\n// These options are recognized (only `ecmaVersion` is required):\nvar defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n    // (the latest version the library supports). This influences\n    // support for strict mode, the set of reserved words, and support\n    // for new syntax features.\n    ecmaVersion: null,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // the position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program, and an import.meta expression\n    // in a script isn't considered an error.\n    allowImportExportEverywhere: false,\n    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: null,\n    // When enabled, super identifiers are not constrained to\n    // appearing in methods and do not raise an error when they appear elsewhere.\n    allowSuperOutsideMethod: null,\n    // When enabled, hashbang directive in the beginning of file is\n    // allowed and treated as a line comment. Enabled by default when\n    // `ecmaVersion` >= 2023.\n    allowHashBang: false,\n    // By default, the parser will verify that private properties are\n    // only used in places where they are valid and have been declared.\n    // Set this to false to turn such checks off.\n    checkPrivateFields: true,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callback—that will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback—that will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n};\n// Interpret and default an options object\nvar warnedAboutEcmaVersion = false;\nfunction getOptions(opts) {\n    var options = {};\n    for(var opt in defaultOptions){\n        options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];\n    }\n    if (options.ecmaVersion === \"latest\") {\n        options.ecmaVersion = 1e8;\n    } else if (options.ecmaVersion == null) {\n        if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n            warnedAboutEcmaVersion = true;\n            console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n        }\n        options.ecmaVersion = 11;\n    } else if (options.ecmaVersion >= 2015) {\n        options.ecmaVersion -= 2009;\n    }\n    if (options.allowReserved == null) {\n        options.allowReserved = options.ecmaVersion < 5;\n    }\n    if (!opts || opts.allowHashBang == null) {\n        options.allowHashBang = options.ecmaVersion >= 14;\n    }\n    if (isArray(options.onToken)) {\n        var tokens = options.onToken;\n        options.onToken = function(token) {\n            return tokens.push(token);\n        };\n    }\n    if (isArray(options.onComment)) {\n        options.onComment = pushComment(options, options.onComment);\n    }\n    return options;\n}\nfunction pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n        var comment = {\n            type: block ? \"Block\" : \"Line\",\n            value: text,\n            start: start,\n            end: end\n        };\n        if (options.locations) {\n            comment.loc = new SourceLocation(this, startLoc, endLoc);\n        }\n        if (options.ranges) {\n            comment.range = [\n                start,\n                end\n            ];\n        }\n        array.push(comment);\n    };\n}\n// Each scope gets a bitset that may contain these flags\nvar SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\nfunction functionFlags(async, generator) {\n    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);\n}\n// Used in checkLVal* and declareName to determine the type of a binding\nvar BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\nvar Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n        reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n        if (options.sourceType === \"module\") {\n            reserved += \" await\";\n        }\n    }\n    this.reservedWords = wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input);\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n    // Set up token state\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n        this.pos = startPos;\n        this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n        this.pos = this.lineStart = 0;\n        this.curLine = 1;\n    }\n    // Properties of the current token:\n    // Its type\n    this.type = types$1.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n    this.potentialArrowInForAwait = false;\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = Object.create(null);\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") {\n        this.skipLineComment(2);\n    }\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope(SCOPE_TOP);\n    // For RegExp validation\n    this.regexpState = null;\n    // The stack of private names.\n    // Each element has two properties: 'declared' and 'used'.\n    // When it exited from the outermost class definition, all used private names must be declared.\n    this.privateNameStack = [];\n};\nvar prototypeAccessors = {\n    inFunction: {\n        configurable: true\n    },\n    inGenerator: {\n        configurable: true\n    },\n    inAsync: {\n        configurable: true\n    },\n    canAwait: {\n        configurable: true\n    },\n    allowSuper: {\n        configurable: true\n    },\n    allowDirectSuper: {\n        configurable: true\n    },\n    treatFunctionsAsVar: {\n        configurable: true\n    },\n    allowNewDotTarget: {\n        configurable: true\n    },\n    inClassStaticBlock: {\n        configurable: true\n    }\n};\nParser.prototype.parse = function parse() {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node);\n};\nprototypeAccessors.inFunction.get = function() {\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n};\nprototypeAccessors.inGenerator.get = function() {\n    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;\n};\nprototypeAccessors.inAsync.get = function() {\n    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;\n};\nprototypeAccessors.canAwait.get = function() {\n    for(var i = this.scopeStack.length - 1; i >= 0; i--){\n        var scope = this.scopeStack[i];\n        if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {\n            return false;\n        }\n        if (scope.flags & SCOPE_FUNCTION) {\n            return (scope.flags & SCOPE_ASYNC) > 0;\n        }\n    }\n    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;\n};\nprototypeAccessors.allowSuper.get = function() {\n    var ref = this.currentThisScope();\n    var flags = ref.flags;\n    var inClassFieldInit = ref.inClassFieldInit;\n    return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;\n};\nprototypeAccessors.allowDirectSuper.get = function() {\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n};\nprototypeAccessors.treatFunctionsAsVar.get = function() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n};\nprototypeAccessors.allowNewDotTarget.get = function() {\n    var ref = this.currentThisScope();\n    var flags = ref.flags;\n    var inClassFieldInit = ref.inClassFieldInit;\n    return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;\n};\nprototypeAccessors.inClassStaticBlock.get = function() {\n    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;\n};\nParser.extend = function extend() {\n    var plugins = [], len = arguments.length;\n    while(len--)plugins[len] = arguments[len];\n    var cls = this;\n    for(var i = 0; i < plugins.length; i++){\n        cls = plugins[i](cls);\n    }\n    return cls;\n};\nParser.parse = function parse(input, options) {\n    return new this(options, input).parse();\n};\nParser.parseExpressionAt = function parseExpressionAt(input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression();\n};\nParser.tokenizer = function tokenizer(input, options) {\n    return new this(options, input);\n};\nObject.defineProperties(Parser.prototype, prototypeAccessors);\nvar pp$9 = Parser.prototype;\n// ## Parser utilities\nvar literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\npp$9.strictDirective = function(start) {\n    if (this.options.ecmaVersion < 5) {\n        return false;\n    }\n    for(;;){\n        // Try to find string literal.\n        skipWhiteSpace.lastIndex = start;\n        start += skipWhiteSpace.exec(this.input)[0].length;\n        var match = literal.exec(this.input.slice(start));\n        if (!match) {\n            return false;\n        }\n        if ((match[1] || match[2]) === \"use strict\") {\n            skipWhiteSpace.lastIndex = start + match[0].length;\n            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n            var next = this.input.charAt(end);\n            return next === \";\" || next === \"}\" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\");\n        }\n        start += match[0].length;\n        // Skip semicolon, if any.\n        skipWhiteSpace.lastIndex = start;\n        start += skipWhiteSpace.exec(this.input)[0].length;\n        if (this.input[start] === \";\") {\n            start++;\n        }\n    }\n};\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\npp$9.eat = function(type) {\n    if (this.type === type) {\n        this.next();\n        return true;\n    } else {\n        return false;\n    }\n};\n// Tests whether parsed token is a contextual keyword.\npp$9.isContextual = function(name) {\n    return this.type === types$1.name && this.value === name && !this.containsEsc;\n};\n// Consumes contextual keyword if possible.\npp$9.eatContextual = function(name) {\n    if (!this.isContextual(name)) {\n        return false;\n    }\n    this.next();\n    return true;\n};\n// Asserts that following token is given contextual keyword.\npp$9.expectContextual = function(name) {\n    if (!this.eatContextual(name)) {\n        this.unexpected();\n    }\n};\n// Test whether a semicolon can be inserted at the current position.\npp$9.canInsertSemicolon = function() {\n    return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\npp$9.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n        if (this.options.onInsertedSemicolon) {\n            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n        }\n        return true;\n    }\n};\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\npp$9.semicolon = function() {\n    if (!this.eat(types$1.semi) && !this.insertSemicolon()) {\n        this.unexpected();\n    }\n};\npp$9.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n        if (this.options.onTrailingComma) {\n            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n        }\n        if (!notNext) {\n            this.next();\n        }\n        return true;\n    }\n};\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\npp$9.expect = function(type) {\n    this.eat(type) || this.unexpected();\n};\n// Raise an unexpected token error.\npp$9.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\nvar DestructuringErrors = function DestructuringErrors() {\n    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n};\npp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) {\n        return;\n    }\n    if (refDestructuringErrors.trailingComma > -1) {\n        this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n    }\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) {\n        this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\");\n    }\n};\npp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) {\n        return false;\n    }\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) {\n        return shorthandAssign >= 0 || doubleProto >= 0;\n    }\n    if (shorthandAssign >= 0) {\n        this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n    }\n    if (doubleProto >= 0) {\n        this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n    }\n};\npp$9.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {\n        this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n    }\n    if (this.awaitPos) {\n        this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n    }\n};\npp$9.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\") {\n        return this.isSimpleAssignTarget(expr.expression);\n    }\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n};\nvar pp$8 = Parser.prototype;\n// ### Statement parsing\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\npp$8.parseTopLevel = function(node) {\n    var exports = Object.create(null);\n    if (!node.body) {\n        node.body = [];\n    }\n    while(this.type !== types$1.eof){\n        var stmt = this.parseStatement(null, true, exports);\n        node.body.push(stmt);\n    }\n    if (this.inModule) {\n        for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){\n            var name = list[i];\n            this.raiseRecoverable(this.undefinedExports[name].start, \"Export '\" + name + \"' is not defined\");\n        }\n    }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\");\n};\nvar loopLabel = {\n    kind: \"loop\"\n}, switchLabel = {\n    kind: \"switch\"\n};\npp$8.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) {\n        return false;\n    }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91 || nextCh === 92) {\n        return true;\n    } // '[', '/'\n    if (context) {\n        return false;\n    }\n    if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n        return true;\n    } // '{', astral\n    if (isIdentifierStart(nextCh, true)) {\n        var pos = next + 1;\n        while(isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)){\n            ++pos;\n        }\n        if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) {\n            return true;\n        }\n        var ident = this.input.slice(next, pos);\n        if (!keywordRelationalOperator.test(ident)) {\n            return true;\n        }\n    }\n    return false;\n};\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$8.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) {\n        return false;\n    }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, after;\n    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00));\n};\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\npp$8.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n    if (this.isLet(context)) {\n        starttype = types$1._var;\n        kind = \"let\";\n    }\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n    switch(starttype){\n        case types$1._break:\n        case types$1._continue:\n            return this.parseBreakContinueStatement(node, starttype.keyword);\n        case types$1._debugger:\n            return this.parseDebuggerStatement(node);\n        case types$1._do:\n            return this.parseDoStatement(node);\n        case types$1._for:\n            return this.parseForStatement(node);\n        case types$1._function:\n            // Function as sole body of either an if statement or a labeled statement\n            // works, but not when it is part of a labeled statement that is the sole\n            // body of an if statement.\n            if (context && (this.strict || context !== \"if\" && context !== \"label\") && this.options.ecmaVersion >= 6) {\n                this.unexpected();\n            }\n            return this.parseFunctionStatement(node, false, !context);\n        case types$1._class:\n            if (context) {\n                this.unexpected();\n            }\n            return this.parseClass(node, true);\n        case types$1._if:\n            return this.parseIfStatement(node);\n        case types$1._return:\n            return this.parseReturnStatement(node);\n        case types$1._switch:\n            return this.parseSwitchStatement(node);\n        case types$1._throw:\n            return this.parseThrowStatement(node);\n        case types$1._try:\n            return this.parseTryStatement(node);\n        case types$1._const:\n        case types$1._var:\n            kind = kind || this.value;\n            if (context && kind !== \"var\") {\n                this.unexpected();\n            }\n            return this.parseVarStatement(node, kind);\n        case types$1._while:\n            return this.parseWhileStatement(node);\n        case types$1._with:\n            return this.parseWithStatement(node);\n        case types$1.braceL:\n            return this.parseBlock(true, node);\n        case types$1.semi:\n            return this.parseEmptyStatement(node);\n        case types$1._export:\n        case types$1._import:\n            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n                skipWhiteSpace.lastIndex = this.pos;\n                var skip = skipWhiteSpace.exec(this.input);\n                var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n                if (nextCh === 40 || nextCh === 46) {\n                    return this.parseExpressionStatement(node, this.parseExpression());\n                }\n            }\n            if (!this.options.allowImportExportEverywhere) {\n                if (!topLevel) {\n                    this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n                }\n                if (!this.inModule) {\n                    this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n                }\n            }\n            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);\n        // If the statement does not start with a statement keyword or a\n        // brace, it's an ExpressionStatement or LabeledStatement. We\n        // simply start parsing an expression, and afterwards, if the\n        // next token is a colon and the expression was a simple\n        // Identifier node, we switch to interpreting it as a label.\n        default:\n            if (this.isAsyncFunction()) {\n                if (context) {\n                    this.unexpected();\n                }\n                this.next();\n                return this.parseFunctionStatement(node, true, !context);\n            }\n            var maybeName = this.value, expr = this.parseExpression();\n            if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon)) {\n                return this.parseLabeledStatement(node, maybeName, expr, context);\n            } else {\n                return this.parseExpressionStatement(node, expr);\n            }\n    }\n};\npp$8.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat(types$1.semi) || this.insertSemicolon()) {\n        node.label = null;\n    } else if (this.type !== types$1.name) {\n        this.unexpected();\n    } else {\n        node.label = this.parseIdent();\n        this.semicolon();\n    }\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for(; i < this.labels.length; ++i){\n        var lab = this.labels[i];\n        if (node.label == null || lab.name === node.label.name) {\n            if (lab.kind != null && (isBreak || lab.kind === \"loop\")) {\n                break;\n            }\n            if (node.label && isBreak) {\n                break;\n            }\n        }\n    }\n    if (i === this.labels.length) {\n        this.raise(node.start, \"Unsyntactic \" + keyword);\n    }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\npp$8.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n};\npp$8.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect(types$1._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6) {\n        this.eat(types$1.semi);\n    } else {\n        this.semicolon();\n    }\n    return this.finishNode(node, \"DoWhileStatement\");\n};\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\npp$8.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterScope(0);\n    this.expect(types$1.parenL);\n    if (this.type === types$1.semi) {\n        if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, null);\n    }\n    var isLet = this.isLet();\n    if (this.type === types$1._var || this.type === types$1._const || isLet) {\n        var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n        this.next();\n        this.parseVar(init$1, true, kind);\n        this.finishNode(init$1, \"VariableDeclaration\");\n        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1) {\n            if (this.options.ecmaVersion >= 9) {\n                if (this.type === types$1._in) {\n                    if (awaitAt > -1) {\n                        this.unexpected(awaitAt);\n                    }\n                } else {\n                    node.await = awaitAt > -1;\n                }\n            }\n            return this.parseForIn(node, init$1);\n        }\n        if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init$1);\n    }\n    var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n    var refDestructuringErrors = new DestructuringErrors;\n    var init = this.parseExpression(awaitAt > -1 ? \"await\" : true, refDestructuringErrors);\n    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n        if (this.options.ecmaVersion >= 9) {\n            if (this.type === types$1._in) {\n                if (awaitAt > -1) {\n                    this.unexpected(awaitAt);\n                }\n            } else {\n                node.await = awaitAt > -1;\n            }\n        }\n        if (startsWithLet && isForOf) {\n            this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\");\n        }\n        this.toAssignable(init, false, refDestructuringErrors);\n        this.checkLValPattern(init);\n        return this.parseForIn(node, init);\n    } else {\n        this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n    if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n};\npp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);\n};\npp$8.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n};\npp$8.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction) {\n        this.raise(this.start, \"'return' outside of function\");\n    }\n    this.next();\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n    if (this.eat(types$1.semi) || this.insertSemicolon()) {\n        node.argument = null;\n    } else {\n        node.argument = this.parseExpression();\n        this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n};\npp$8.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types$1.braceL);\n    this.labels.push(switchLabel);\n    this.enterScope(0);\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n    var cur;\n    for(var sawDefault = false; this.type !== types$1.braceR;){\n        if (this.type === types$1._case || this.type === types$1._default) {\n            var isCase = this.type === types$1._case;\n            if (cur) {\n                this.finishNode(cur, \"SwitchCase\");\n            }\n            node.cases.push(cur = this.startNode());\n            cur.consequent = [];\n            this.next();\n            if (isCase) {\n                cur.test = this.parseExpression();\n            } else {\n                if (sawDefault) {\n                    this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\");\n                }\n                sawDefault = true;\n                cur.test = null;\n            }\n            this.expect(types$1.colon);\n        } else {\n            if (!cur) {\n                this.unexpected();\n            }\n            cur.consequent.push(this.parseStatement(null));\n        }\n    }\n    this.exitScope();\n    if (cur) {\n        this.finishNode(cur, \"SwitchCase\");\n    }\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n};\npp$8.parseThrowStatement = function(node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {\n        this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n};\n// Reused empty array added for node fields that are always empty.\nvar empty$1 = [];\npp$8.parseCatchClauseParam = function() {\n    var param = this.parseBindingAtom();\n    var simple = param.type === \"Identifier\";\n    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n    this.expect(types$1.parenR);\n    return param;\n};\npp$8.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === types$1._catch) {\n        var clause = this.startNode();\n        this.next();\n        if (this.eat(types$1.parenL)) {\n            clause.param = this.parseCatchClauseParam();\n        } else {\n            if (this.options.ecmaVersion < 10) {\n                this.unexpected();\n            }\n            clause.param = null;\n            this.enterScope(0);\n        }\n        clause.body = this.parseBlock(false);\n        this.exitScope();\n        node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n        this.raise(node.start, \"Missing catch or finally clause\");\n    }\n    return this.finishNode(node, \"TryStatement\");\n};\npp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n};\npp$8.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n};\npp$8.parseWithStatement = function(node) {\n    if (this.strict) {\n        this.raise(this.start, \"'with' in strict mode\");\n    }\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\");\n};\npp$8.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n};\npp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){\n        var label = list[i$1];\n        if (label.name === maybeName) {\n            this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n        }\n    }\n    var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n    for(var i = this.labels.length - 1; i >= 0; i--){\n        var label$1 = this.labels[i];\n        if (label$1.statementStart === node.start) {\n            // Update information about previous labels on this node\n            label$1.statementStart = this.start;\n            label$1.kind = kind;\n        } else {\n            break;\n        }\n    }\n    this.labels.push({\n        name: maybeName,\n        kind: kind,\n        statementStart: this.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n};\npp$8.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n};\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\npp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n    if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n    if (node === void 0) node = this.startNode();\n    node.body = [];\n    this.expect(types$1.braceL);\n    if (createNewLexicalScope) {\n        this.enterScope(0);\n    }\n    while(this.type !== types$1.braceR){\n        var stmt = this.parseStatement(null);\n        node.body.push(stmt);\n    }\n    if (exitStrict) {\n        this.strict = false;\n    }\n    this.next();\n    if (createNewLexicalScope) {\n        this.exitScope();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n};\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\npp$8.parseFor = function(node, init) {\n    node.init = init;\n    this.expect(types$1.semi);\n    node.test = this.type === types$1.semi ? null : this.parseExpression();\n    this.expect(types$1.semi);\n    node.update = this.type === types$1.parenR ? null : this.parseExpression();\n    this.expect(types$1.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n};\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\npp$8.parseForIn = function(node, init) {\n    var isForIn = this.type === types$1._in;\n    this.next();\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n        this.raise(init.start, (isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\");\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types$1.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n};\n// Parse a list of variable declarations.\npp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n    node.declarations = [];\n    node.kind = kind;\n    for(;;){\n        var decl = this.startNode();\n        this.parseVarId(decl, kind);\n        if (this.eat(types$1.eq)) {\n            decl.init = this.parseMaybeAssign(isFor);\n        } else if (!allowMissingInitializer && kind === \"const\" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n            this.unexpected();\n        } else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n            this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n        } else {\n            decl.init = null;\n        }\n        node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n        if (!this.eat(types$1.comma)) {\n            break;\n        }\n    }\n    return node;\n};\npp$8.parseVarId = function(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n        if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {\n            this.unexpected();\n        }\n        node.generator = this.eat(types$1.star);\n    }\n    if (this.options.ecmaVersion >= 8) {\n        node.async = !!isAsync;\n    }\n    if (statement & FUNC_STATEMENT) {\n        node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();\n        if (node.id && !(statement & FUNC_HANGING_STATEMENT)) // If it is a regular function declaration in sloppy mode, then it is\n        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n        // mode depends on properties of the current scope (see\n        // treatFunctionsAsVar).\n        {\n            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);\n        }\n    }\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(node.async, node.generator));\n    if (!(statement & FUNC_STATEMENT)) {\n        node.id = this.type === types$1.name ? this.parseIdent() : null;\n    }\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, statement & FUNC_STATEMENT ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\npp$8.parseFunctionParams = function(node) {\n    this.expect(types$1.parenL);\n    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n};\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\npp$8.parseClass = function(node, isStatement) {\n    this.next();\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var privateNameMap = this.enterClassBody();\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types$1.braceL);\n    while(this.type !== types$1.braceR){\n        var element = this.parseClassElement(node.superClass !== null);\n        if (element) {\n            classBody.body.push(element);\n            if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n                if (hadConstructor) {\n                    this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\");\n                }\n                hadConstructor = true;\n            } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n                this.raiseRecoverable(element.key.start, \"Identifier '#\" + element.key.name + \"' has already been declared\");\n            }\n        }\n    }\n    this.strict = oldStrict;\n    this.next();\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.exitClassBody();\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\npp$8.parseClassElement = function(constructorAllowsSuper) {\n    if (this.eat(types$1.semi)) {\n        return null;\n    }\n    var ecmaVersion = this.options.ecmaVersion;\n    var node = this.startNode();\n    var keyName = \"\";\n    var isGenerator = false;\n    var isAsync = false;\n    var kind = \"method\";\n    var isStatic = false;\n    if (this.eatContextual(\"static\")) {\n        // Parse static init block\n        if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n            this.parseClassStaticBlock(node);\n            return node;\n        }\n        if (this.isClassElementNameStart() || this.type === types$1.star) {\n            isStatic = true;\n        } else {\n            keyName = \"static\";\n        }\n    }\n    node.static = isStatic;\n    if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n        if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n            isAsync = true;\n        } else {\n            keyName = \"async\";\n        }\n    }\n    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n        isGenerator = true;\n    }\n    if (!keyName && !isAsync && !isGenerator) {\n        var lastValue = this.value;\n        if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n            if (this.isClassElementNameStart()) {\n                kind = lastValue;\n            } else {\n                keyName = lastValue;\n            }\n        }\n    }\n    // Parse element name\n    if (keyName) {\n        // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n        // The last token is any of those. Make it the element name.\n        node.computed = false;\n        node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n        node.key.name = keyName;\n        this.finishNode(node.key, \"Identifier\");\n    } else {\n        this.parseClassElementName(node);\n    }\n    // Parse element value\n    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n        var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n        var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n        // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n        if (isConstructor && kind !== \"method\") {\n            this.raise(node.key.start, \"Constructor can't have get/set modifier\");\n        }\n        node.kind = isConstructor ? \"constructor\" : kind;\n        this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n    } else {\n        this.parseClassField(node);\n    }\n    return node;\n};\npp$8.isClassElementNameStart = function() {\n    return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;\n};\npp$8.parseClassElementName = function(element) {\n    if (this.type === types$1.privateId) {\n        if (this.value === \"constructor\") {\n            this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n        }\n        element.computed = false;\n        element.key = this.parsePrivateIdent();\n    } else {\n        this.parsePropertyName(element);\n    }\n};\npp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    // Check key and flags\n    var key = method.key;\n    if (method.kind === \"constructor\") {\n        if (isGenerator) {\n            this.raise(key.start, \"Constructor can't be a generator\");\n        }\n        if (isAsync) {\n            this.raise(key.start, \"Constructor can't be an async method\");\n        }\n    } else if (method.static && checkKeyName(method, \"prototype\")) {\n        this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n    // Parse value\n    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n    // Check value\n    if (method.kind === \"get\" && value.params.length !== 0) {\n        this.raiseRecoverable(value.start, \"getter should have no params\");\n    }\n    if (method.kind === \"set\" && value.params.length !== 1) {\n        this.raiseRecoverable(value.start, \"setter should have exactly one param\");\n    }\n    if (method.kind === \"set\" && value.params[0].type === \"RestElement\") {\n        this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\");\n    }\n    return this.finishNode(method, \"MethodDefinition\");\n};\npp$8.parseClassField = function(field) {\n    if (checkKeyName(field, \"constructor\")) {\n        this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n    } else if (field.static && checkKeyName(field, \"prototype\")) {\n        this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n    }\n    if (this.eat(types$1.eq)) {\n        // To raise SyntaxError if 'arguments' exists in the initializer.\n        var scope = this.currentThisScope();\n        var inClassFieldInit = scope.inClassFieldInit;\n        scope.inClassFieldInit = true;\n        field.value = this.parseMaybeAssign();\n        scope.inClassFieldInit = inClassFieldInit;\n    } else {\n        field.value = null;\n    }\n    this.semicolon();\n    return this.finishNode(field, \"PropertyDefinition\");\n};\npp$8.parseClassStaticBlock = function(node) {\n    node.body = [];\n    var oldLabels = this.labels;\n    this.labels = [];\n    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n    while(this.type !== types$1.braceR){\n        var stmt = this.parseStatement(null);\n        node.body.push(stmt);\n    }\n    this.next();\n    this.exitScope();\n    this.labels = oldLabels;\n    return this.finishNode(node, \"StaticBlock\");\n};\npp$8.parseClassId = function(node, isStatement) {\n    if (this.type === types$1.name) {\n        node.id = this.parseIdent();\n        if (isStatement) {\n            this.checkLValSimple(node.id, BIND_LEXICAL, false);\n        }\n    } else {\n        if (isStatement === true) {\n            this.unexpected();\n        }\n        node.id = null;\n    }\n};\npp$8.parseClassSuper = function(node) {\n    node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;\n};\npp$8.enterClassBody = function() {\n    var element = {\n        declared: Object.create(null),\n        used: []\n    };\n    this.privateNameStack.push(element);\n    return element.declared;\n};\npp$8.exitClassBody = function() {\n    var ref = this.privateNameStack.pop();\n    var declared = ref.declared;\n    var used = ref.used;\n    if (!this.options.checkPrivateFields) {\n        return;\n    }\n    var len = this.privateNameStack.length;\n    var parent = len === 0 ? null : this.privateNameStack[len - 1];\n    for(var i = 0; i < used.length; ++i){\n        var id = used[i];\n        if (!hasOwn(declared, id.name)) {\n            if (parent) {\n                parent.used.push(id);\n            } else {\n                this.raiseRecoverable(id.start, \"Private field '#\" + id.name + \"' must be declared in an enclosing class\");\n            }\n        }\n    }\n};\nfunction isPrivateNameConflicted(privateNameMap, element) {\n    var name = element.key.name;\n    var curr = privateNameMap[name];\n    var next = \"true\";\n    if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n        next = (element.static ? \"s\" : \"i\") + element.kind;\n    }\n    // `class { get #a(){}; static set #a(_){} }` is also conflict.\n    if (curr === \"iget\" && next === \"iset\" || curr === \"iset\" && next === \"iget\" || curr === \"sget\" && next === \"sset\" || curr === \"sset\" && next === \"sget\") {\n        privateNameMap[name] = \"true\";\n        return false;\n    } else if (!curr) {\n        privateNameMap[name] = next;\n        return false;\n    } else {\n        return true;\n    }\n}\nfunction checkKeyName(node, name) {\n    var computed = node.computed;\n    var key = node.key;\n    return !computed && (key.type === \"Identifier\" && key.name === name || key.type === \"Literal\" && key.value === name);\n}\n// Parses module export declaration.\npp$8.parseExportAllDeclaration = function(node, exports) {\n    if (this.options.ecmaVersion >= 11) {\n        if (this.eatContextual(\"as\")) {\n            node.exported = this.parseModuleExportName();\n            this.checkExport(exports, node.exported, this.lastTokStart);\n        } else {\n            node.exported = null;\n        }\n    }\n    this.expectContextual(\"from\");\n    if (this.type !== types$1.string) {\n        this.unexpected();\n    }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n};\npp$8.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat(types$1.star)) {\n        return this.parseExportAllDeclaration(node, exports);\n    }\n    if (this.eat(types$1._default)) {\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        node.declaration = this.parseExportDefaultDeclaration();\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseExportDeclaration(node);\n        if (node.declaration.type === \"VariableDeclaration\") {\n            this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n            this.checkExport(exports, node.declaration.id, node.declaration.id.start);\n        }\n        node.specifiers = [];\n        node.source = null;\n    } else {\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n            if (this.type !== types$1.string) {\n                this.unexpected();\n            }\n            node.source = this.parseExprAtom();\n        } else {\n            for(var i = 0, list = node.specifiers; i < list.length; i += 1){\n                // check for keywords used as local names\n                var spec = list[i];\n                this.checkUnreserved(spec.local);\n                // check if export is defined\n                this.checkLocalExport(spec.local);\n                if (spec.local.type === \"Literal\") {\n                    this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n                }\n            }\n            node.source = null;\n        }\n        this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\");\n};\npp$8.parseExportDeclaration = function(node) {\n    return this.parseStatement(null);\n};\npp$8.parseExportDefaultDeclaration = function() {\n    var isAsync;\n    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) {\n            this.next();\n        }\n        return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === types$1._class) {\n        var cNode = this.startNode();\n        return this.parseClass(cNode, \"nullableID\");\n    } else {\n        var declaration = this.parseMaybeAssign();\n        this.semicolon();\n        return declaration;\n    }\n};\npp$8.checkExport = function(exports, name, pos) {\n    if (!exports) {\n        return;\n    }\n    if (typeof name !== \"string\") {\n        name = name.type === \"Identifier\" ? name.name : name.value;\n    }\n    if (hasOwn(exports, name)) {\n        this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n    }\n    exports[name] = true;\n};\npp$8.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\") {\n        this.checkExport(exports, pat, pat.start);\n    } else if (type === \"ObjectPattern\") {\n        for(var i = 0, list = pat.properties; i < list.length; i += 1){\n            var prop = list[i];\n            this.checkPatternExport(exports, prop);\n        }\n    } else if (type === \"ArrayPattern\") {\n        for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){\n            var elt = list$1[i$1];\n            if (elt) {\n                this.checkPatternExport(exports, elt);\n            }\n        }\n    } else if (type === \"Property\") {\n        this.checkPatternExport(exports, pat.value);\n    } else if (type === \"AssignmentPattern\") {\n        this.checkPatternExport(exports, pat.left);\n    } else if (type === \"RestElement\") {\n        this.checkPatternExport(exports, pat.argument);\n    } else if (type === \"ParenthesizedExpression\") {\n        this.checkPatternExport(exports, pat.expression);\n    }\n};\npp$8.checkVariableExport = function(exports, decls) {\n    if (!exports) {\n        return;\n    }\n    for(var i = 0, list = decls; i < list.length; i += 1){\n        var decl = list[i];\n        this.checkPatternExport(exports, decl.id);\n    }\n};\npp$8.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n};\n// Parses a comma-separated list of module exports.\npp$8.parseExportSpecifier = function(exports) {\n    var node = this.startNode();\n    node.local = this.parseModuleExportName();\n    node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n    this.checkExport(exports, node.exported, node.exported.start);\n    return this.finishNode(node, \"ExportSpecifier\");\n};\npp$8.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect(types$1.braceL);\n    while(!this.eat(types$1.braceR)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (this.afterTrailingComma(types$1.braceR)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        nodes.push(this.parseExportSpecifier(exports));\n    }\n    return nodes;\n};\n// Parses import declaration.\npp$8.parseImport = function(node) {\n    this.next();\n    // import '...'\n    if (this.type === types$1.string) {\n        node.specifiers = empty$1;\n        node.source = this.parseExprAtom();\n    } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n};\n// Parses a comma-separated list of module imports.\npp$8.parseImportSpecifier = function() {\n    var node = this.startNode();\n    node.imported = this.parseModuleExportName();\n    if (this.eatContextual(\"as\")) {\n        node.local = this.parseIdent();\n    } else {\n        this.checkUnreserved(node.imported);\n        node.local = node.imported;\n    }\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportSpecifier\");\n};\npp$8.parseImportDefaultSpecifier = function() {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportDefaultSpecifier\");\n};\npp$8.parseImportNamespaceSpecifier = function() {\n    var node = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node.local = this.parseIdent();\n    this.checkLValSimple(node.local, BIND_LEXICAL);\n    return this.finishNode(node, \"ImportNamespaceSpecifier\");\n};\npp$8.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === types$1.name) {\n        nodes.push(this.parseImportDefaultSpecifier());\n        if (!this.eat(types$1.comma)) {\n            return nodes;\n        }\n    }\n    if (this.type === types$1.star) {\n        nodes.push(this.parseImportNamespaceSpecifier());\n        return nodes;\n    }\n    this.expect(types$1.braceL);\n    while(!this.eat(types$1.braceR)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (this.afterTrailingComma(types$1.braceR)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        nodes.push(this.parseImportSpecifier());\n    }\n    return nodes;\n};\npp$8.parseModuleExportName = function() {\n    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n        var stringLiteral = this.parseLiteral(this.value);\n        if (loneSurrogate.test(stringLiteral.value)) {\n            this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n        }\n        return stringLiteral;\n    }\n    return this.parseIdent(true);\n};\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$8.adaptDirectivePrologue = function(statements) {\n    for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i){\n        statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n};\npp$8.isDirectiveCandidate = function(statement) {\n    return this.options.ecmaVersion >= 5 && statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && // Reject parenthesized strings.\n    (this.input[statement.start] === '\"' || this.input[statement.start] === \"'\");\n};\nvar pp$7 = Parser.prototype;\n// Convert existing expression atom to assignable pattern\n// if possible.\npp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) {\n        switch(node.type){\n            case \"Identifier\":\n                if (this.inAsync && node.name === \"await\") {\n                    this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\");\n                }\n                break;\n            case \"ObjectPattern\":\n            case \"ArrayPattern\":\n            case \"AssignmentPattern\":\n            case \"RestElement\":\n                break;\n            case \"ObjectExpression\":\n                node.type = \"ObjectPattern\";\n                if (refDestructuringErrors) {\n                    this.checkPatternErrors(refDestructuringErrors, true);\n                }\n                for(var i = 0, list = node.properties; i < list.length; i += 1){\n                    var prop = list[i];\n                    this.toAssignable(prop, isBinding);\n                    // Early error:\n                    //   AssignmentRestProperty[Yield, Await] :\n                    //     `...` DestructuringAssignmentTarget[Yield, Await]\n                    //\n                    //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n                    if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) {\n                        this.raise(prop.argument.start, \"Unexpected token\");\n                    }\n                }\n                break;\n            case \"Property\":\n                // AssignmentProperty has type === \"Property\"\n                if (node.kind !== \"init\") {\n                    this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n                }\n                this.toAssignable(node.value, isBinding);\n                break;\n            case \"ArrayExpression\":\n                node.type = \"ArrayPattern\";\n                if (refDestructuringErrors) {\n                    this.checkPatternErrors(refDestructuringErrors, true);\n                }\n                this.toAssignableList(node.elements, isBinding);\n                break;\n            case \"SpreadElement\":\n                node.type = \"RestElement\";\n                this.toAssignable(node.argument, isBinding);\n                if (node.argument.type === \"AssignmentPattern\") {\n                    this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n                }\n                break;\n            case \"AssignmentExpression\":\n                if (node.operator !== \"=\") {\n                    this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n                }\n                node.type = \"AssignmentPattern\";\n                delete node.operator;\n                this.toAssignable(node.left, isBinding);\n                break;\n            case \"ParenthesizedExpression\":\n                this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n                break;\n            case \"ChainExpression\":\n                this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n                break;\n            case \"MemberExpression\":\n                if (!isBinding) {\n                    break;\n                }\n            default:\n                this.raise(node.start, \"Assigning to rvalue\");\n        }\n    } else if (refDestructuringErrors) {\n        this.checkPatternErrors(refDestructuringErrors, true);\n    }\n    return node;\n};\n// Convert list of expression atoms to binding list.\npp$7.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for(var i = 0; i < end; i++){\n        var elt = exprList[i];\n        if (elt) {\n            this.toAssignable(elt, isBinding);\n        }\n    }\n    if (end) {\n        var last = exprList[end - 1];\n        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") {\n            this.unexpected(last.argument.start);\n        }\n    }\n    return exprList;\n};\n// Parses spread element.\npp$7.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\");\n};\npp$7.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {\n        this.unexpected();\n    }\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n};\n// Parses lvalue (assignable) atom.\npp$7.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) {\n        switch(this.type){\n            case types$1.bracketL:\n                var node = this.startNode();\n                this.next();\n                node.elements = this.parseBindingList(types$1.bracketR, true, true);\n                return this.finishNode(node, \"ArrayPattern\");\n            case types$1.braceL:\n                return this.parseObj(true);\n        }\n    }\n    return this.parseIdent();\n};\npp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n    var elts = [], first = true;\n    while(!this.eat(close)){\n        if (first) {\n            first = false;\n        } else {\n            this.expect(types$1.comma);\n        }\n        if (allowEmpty && this.type === types$1.comma) {\n            elts.push(null);\n        } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n            break;\n        } else if (this.type === types$1.ellipsis) {\n            var rest = this.parseRestBinding();\n            this.parseBindingListItem(rest);\n            elts.push(rest);\n            if (this.type === types$1.comma) {\n                this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n            }\n            this.expect(close);\n            break;\n        } else {\n            elts.push(this.parseAssignableListItem(allowModifiers));\n        }\n    }\n    return elts;\n};\npp$7.parseAssignableListItem = function(allowModifiers) {\n    var elem = this.parseMaybeDefault(this.start, this.startLoc);\n    this.parseBindingListItem(elem);\n    return elem;\n};\npp$7.parseBindingListItem = function(param) {\n    return param;\n};\n// Parses assignment pattern around given atom if possible.\npp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {\n        return left;\n    }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n};\n// The following three functions all verify that a node is an lvalue —\n// something that can be bound, or assigned to. In order to do so, they perform\n// a variety of checks:\n//\n// - Check that none of the bound/assigned-to identifiers are reserved words.\n// - Record name declarations for bindings in the appropriate scope.\n// - Check duplicate argument names, if checkClashes is set.\n//\n// If a complex binding pattern is encountered (e.g., object and array\n// destructuring), the entire pattern is recursively checked.\n//\n// There are three versions of checkLVal*() appropriate for different\n// circumstances:\n//\n// - checkLValSimple() shall be used if the syntactic construct supports\n//   nothing other than identifiers and member expressions. Parenthesized\n//   expressions are also correctly handled. This is generally appropriate for\n//   constructs for which the spec says\n//\n//   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   It is also appropriate for checking if an identifier is valid and not\n//   defined elsewhere, like import declarations or function/class identifiers.\n//\n//   Examples where this is used include:\n//     a += …;\n//     import a from '…';\n//   where a is the node to be checked.\n//\n// - checkLValPattern() shall be used if the syntactic construct supports\n//   anything checkLValSimple() supports, as well as object and array\n//   destructuring patterns. This is generally appropriate for constructs for\n//   which the spec says\n//\n//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n//   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   Examples where this is used include:\n//     (a = …);\n//     const a = …;\n//     try { … } catch (a) { … }\n//   where a is the node to be checked.\n//\n// - checkLValInnerPattern() shall be used if the syntactic construct supports\n//   anything checkLValPattern() supports, as well as default assignment\n//   patterns, rest elements, and other constructs that may appear within an\n//   object or array destructuring pattern.\n//\n//   As a special case, function parameters also use checkLValInnerPattern(),\n//   as they also support defaults and rest constructs.\n//\n// These functions deliberately support both assignment and binding constructs,\n// as the logic for both is exceedingly similar. If the node is the target of\n// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n// should be set to the appropriate BIND_* constant, like BIND_VAR or\n// BIND_LEXICAL.\n//\n// If the function is called with a non-BIND_NONE bindingType, then\n// additionally a checkClashes object may be specified to allow checking for\n// duplicate argument names. checkClashes is ignored if the provided construct\n// is an assignment (i.e., bindingType is BIND_NONE).\npp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = BIND_NONE;\n    var isBind = bindingType !== BIND_NONE;\n    switch(expr.type){\n        case \"Identifier\":\n            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {\n                this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n            }\n            if (isBind) {\n                if (bindingType === BIND_LEXICAL && expr.name === \"let\") {\n                    this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\");\n                }\n                if (checkClashes) {\n                    if (hasOwn(checkClashes, expr.name)) {\n                        this.raiseRecoverable(expr.start, \"Argument name clash\");\n                    }\n                    checkClashes[expr.name] = true;\n                }\n                if (bindingType !== BIND_OUTSIDE) {\n                    this.declareName(expr.name, bindingType, expr.start);\n                }\n            }\n            break;\n        case \"ChainExpression\":\n            this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n            break;\n        case \"MemberExpression\":\n            if (isBind) {\n                this.raiseRecoverable(expr.start, \"Binding member expression\");\n            }\n            break;\n        case \"ParenthesizedExpression\":\n            if (isBind) {\n                this.raiseRecoverable(expr.start, \"Binding parenthesized expression\");\n            }\n            return this.checkLValSimple(expr.expression, bindingType, checkClashes);\n        default:\n            this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n};\npp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = BIND_NONE;\n    switch(expr.type){\n        case \"ObjectPattern\":\n            for(var i = 0, list = expr.properties; i < list.length; i += 1){\n                var prop = list[i];\n                this.checkLValInnerPattern(prop, bindingType, checkClashes);\n            }\n            break;\n        case \"ArrayPattern\":\n            for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){\n                var elem = list$1[i$1];\n                if (elem) {\n                    this.checkLValInnerPattern(elem, bindingType, checkClashes);\n                }\n            }\n            break;\n        default:\n            this.checkLValSimple(expr, bindingType, checkClashes);\n    }\n};\npp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = BIND_NONE;\n    switch(expr.type){\n        case \"Property\":\n            // AssignmentProperty has type === \"Property\"\n            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n            break;\n        case \"AssignmentPattern\":\n            this.checkLValPattern(expr.left, bindingType, checkClashes);\n            break;\n        case \"RestElement\":\n            this.checkLValPattern(expr.argument, bindingType, checkClashes);\n            break;\n        default:\n            this.checkLValPattern(expr, bindingType, checkClashes);\n    }\n};\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n};\nvar types = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function(p) {\n        return p.tryReadTemplateToken();\n    }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n};\nvar pp$6 = Parser.prototype;\npp$6.initialContext = function() {\n    return [\n        types.b_stat\n    ];\n};\npp$6.curContext = function() {\n    return this.context[this.context.length - 1];\n};\npp$6.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === types.f_expr || parent === types.f_stat) {\n        return true;\n    }\n    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {\n        return !parent.isExpr;\n    }\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {\n        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    }\n    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {\n        return true;\n    }\n    if (prevType === types$1.braceL) {\n        return parent === types.b_stat;\n    }\n    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {\n        return false;\n    }\n    return !this.exprAllowed;\n};\npp$6.inGeneratorContext = function() {\n    for(var i = this.context.length - 1; i >= 1; i--){\n        var context = this.context[i];\n        if (context.token === \"function\") {\n            return context.generator;\n        }\n    }\n    return false;\n};\npp$6.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === types$1.dot) {\n        this.exprAllowed = false;\n    } else if (update = type.updateContext) {\n        update.call(this, prevType);\n    } else {\n        this.exprAllowed = type.beforeExpr;\n    }\n};\n// Used to handle egde cases when token context could not be inferred correctly during tokenization phase\npp$6.overrideContext = function(tokenCtx) {\n    if (this.curContext() !== tokenCtx) {\n        this.context[this.context.length - 1] = tokenCtx;\n    }\n};\n// Token-specific context update code\ntypes$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n        this.exprAllowed = true;\n        return;\n    }\n    var out = this.context.pop();\n    if (out === types.b_stat && this.curContext().token === \"function\") {\n        out = this.context.pop();\n    }\n    this.exprAllowed = !out.isExpr;\n};\ntypes$1.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n    this.exprAllowed = true;\n};\ntypes$1.dollarBraceL.updateContext = function() {\n    this.context.push(types.b_tmpl);\n    this.exprAllowed = true;\n};\ntypes$1.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n    this.context.push(statementParens ? types.p_stat : types.p_expr);\n    this.exprAllowed = true;\n};\ntypes$1.incDec.updateContext = function() {\n// tokExprAllowed stays unchanged\n};\ntypes$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {\n        this.context.push(types.f_expr);\n    } else {\n        this.context.push(types.f_stat);\n    }\n    this.exprAllowed = false;\n};\ntypes$1.backQuote.updateContext = function() {\n    if (this.curContext() === types.q_tmpl) {\n        this.context.pop();\n    } else {\n        this.context.push(types.q_tmpl);\n    }\n    this.exprAllowed = false;\n};\ntypes$1.star.updateContext = function(prevType) {\n    if (prevType === types$1._function) {\n        var index = this.context.length - 1;\n        if (this.context[index] === types.f_expr) {\n            this.context[index] = types.f_expr_gen;\n        } else {\n            this.context[index] = types.f_gen;\n        }\n    }\n    this.exprAllowed = true;\n};\ntypes$1.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n        if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) {\n            allowed = true;\n        }\n    }\n    this.exprAllowed = allowed;\n};\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\nvar pp$5 = Parser.prototype;\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\npp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") {\n        return;\n    }\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {\n        return;\n    }\n    var key = prop.key;\n    var name;\n    switch(key.type){\n        case \"Identifier\":\n            name = key.name;\n            break;\n        case \"Literal\":\n            name = String(key.value);\n            break;\n        default:\n            return;\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n        if (name === \"__proto__\" && kind === \"init\") {\n            if (propHash.proto) {\n                if (refDestructuringErrors) {\n                    if (refDestructuringErrors.doubleProto < 0) {\n                        refDestructuringErrors.doubleProto = key.start;\n                    }\n                } else {\n                    this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n                }\n            }\n            propHash.proto = true;\n        }\n        return;\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n        var redefinition;\n        if (kind === \"init\") {\n            redefinition = this.strict && other.init || other.get || other.set;\n        } else {\n            redefinition = other.init || other[kind];\n        }\n        if (redefinition) {\n            this.raiseRecoverable(key.start, \"Redefinition of property\");\n        }\n    } else {\n        other = propHash[name] = {\n            init: false,\n            get: false,\n            set: false\n        };\n    }\n    other[kind] = true;\n};\n// ### Expression parsing\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\npp$5.parseExpression = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n    if (this.type === types$1.comma) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.expressions = [\n            expr\n        ];\n        while(this.eat(types$1.comma)){\n            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));\n        }\n        return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n};\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\npp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n        if (this.inGenerator) {\n            return this.parseYield(forInit);\n        } else {\n            this.exprAllowed = false;\n        }\n    }\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n    if (refDestructuringErrors) {\n        oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n        oldTrailingComma = refDestructuringErrors.trailingComma;\n        oldDoubleProto = refDestructuringErrors.doubleProto;\n        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n    } else {\n        refDestructuringErrors = new DestructuringErrors;\n        ownDestructuringErrors = true;\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === types$1.parenL || this.type === types$1.name) {\n        this.potentialArrowAt = this.start;\n        this.potentialArrowInForAwait = forInit === \"await\";\n    }\n    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n    if (afterLeftParse) {\n        left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n    if (this.type.isAssign) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.operator = this.value;\n        if (this.type === types$1.eq) {\n            left = this.toAssignable(left, false, refDestructuringErrors);\n        }\n        if (!ownDestructuringErrors) {\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n        }\n        if (refDestructuringErrors.shorthandAssign >= left.start) {\n            refDestructuringErrors.shorthandAssign = -1;\n        } // reset because shorthand default was used correctly\n        if (this.type === types$1.eq) {\n            this.checkLValPattern(left);\n        } else {\n            this.checkLValSimple(left);\n        }\n        node.left = left;\n        this.next();\n        node.right = this.parseMaybeAssign(forInit);\n        if (oldDoubleProto > -1) {\n            refDestructuringErrors.doubleProto = oldDoubleProto;\n        }\n        return this.finishNode(node, \"AssignmentExpression\");\n    } else {\n        if (ownDestructuringErrors) {\n            this.checkExpressionErrors(refDestructuringErrors, true);\n        }\n    }\n    if (oldParenAssign > -1) {\n        refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n    }\n    if (oldTrailingComma > -1) {\n        refDestructuringErrors.trailingComma = oldTrailingComma;\n    }\n    return left;\n};\n// Parse a ternary conditional (`?:`) operator.\npp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(forInit, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n        return expr;\n    }\n    if (this.eat(types$1.question)) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.test = expr;\n        node.consequent = this.parseMaybeAssign();\n        this.expect(types$1.colon);\n        node.alternate = this.parseMaybeAssign(forInit);\n        return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n};\n// Start the precedence parser.\npp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n        return expr;\n    }\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);\n};\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\npp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n    var prec = this.type.binop;\n    if (prec != null && (!forInit || this.type !== types$1._in)) {\n        if (prec > minPrec) {\n            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n            var coalesce = this.type === types$1.coalesce;\n            if (coalesce) {\n                // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n                // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n                prec = types$1.logicalAND.binop;\n            }\n            var op = this.value;\n            this.next();\n            var startPos = this.start, startLoc = this.startLoc;\n            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {\n                this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n            }\n            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);\n        }\n    }\n    return left;\n};\npp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    if (right.type === \"PrivateIdentifier\") {\n        this.raise(right.start, \"Private identifier can only be left side of binary expression\");\n    }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n};\n// Parse unary operators, both prefix and postfix.\npp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && this.canAwait) {\n        expr = this.parseAwait(forInit);\n        sawUnary = true;\n    } else if (this.type.prefix) {\n        var node = this.startNode(), update = this.type === types$1.incDec;\n        node.operator = this.value;\n        node.prefix = true;\n        this.next();\n        node.argument = this.parseMaybeUnary(null, true, update, forInit);\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        if (update) {\n            this.checkLValSimple(node.argument);\n        } else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n            this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n        } else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument)) {\n            this.raiseRecoverable(node.start, \"Private fields can not be deleted\");\n        } else {\n            sawUnary = true;\n        }\n        expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (!sawUnary && this.type === types$1.privateId) {\n        if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {\n            this.unexpected();\n        }\n        expr = this.parsePrivateIdent();\n        // only could be private fields in 'in', such as #x in obj\n        if (this.type !== types$1._in) {\n            this.unexpected();\n        }\n    } else {\n        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n        if (this.checkExpressionErrors(refDestructuringErrors)) {\n            return expr;\n        }\n        while(this.type.postfix && !this.canInsertSemicolon()){\n            var node$1 = this.startNodeAt(startPos, startLoc);\n            node$1.operator = this.value;\n            node$1.prefix = false;\n            node$1.argument = expr;\n            this.checkLValSimple(expr);\n            this.next();\n            expr = this.finishNode(node$1, \"UpdateExpression\");\n        }\n    }\n    if (!incDec && this.eat(types$1.starstar)) {\n        if (sawUnary) {\n            this.unexpected(this.lastTokStart);\n        } else {\n            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false);\n        }\n    } else {\n        return expr;\n    }\n};\nfunction isPrivateFieldAccess(node) {\n    return node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" || node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression);\n}\n// Parse call, dot, and `[]`-subscript expressions.\npp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n    if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\") {\n        return expr;\n    }\n    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n        if (refDestructuringErrors.parenthesizedAssign >= result.start) {\n            refDestructuringErrors.parenthesizedAssign = -1;\n        }\n        if (refDestructuringErrors.parenthesizedBind >= result.start) {\n            refDestructuringErrors.parenthesizedBind = -1;\n        }\n        if (refDestructuringErrors.trailingComma >= result.start) {\n            refDestructuringErrors.trailingComma = -1;\n        }\n    }\n    return result;\n};\npp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;\n    var optionalChained = false;\n    while(true){\n        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n        if (element.optional) {\n            optionalChained = true;\n        }\n        if (element === base || element.type === \"ArrowFunctionExpression\") {\n            if (optionalChained) {\n                var chainNode = this.startNodeAt(startPos, startLoc);\n                chainNode.expression = element;\n                element = this.finishNode(chainNode, \"ChainExpression\");\n            }\n            return element;\n        }\n        base = element;\n    }\n};\npp$5.shouldParseAsyncArrow = function() {\n    return !this.canInsertSemicolon() && this.eat(types$1.arrow);\n};\npp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);\n};\npp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n    var optionalSupported = this.options.ecmaVersion >= 11;\n    var optional = optionalSupported && this.eat(types$1.questionDot);\n    if (noCalls && optional) {\n        this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\");\n    }\n    var computed = this.eat(types$1.bracketL);\n    if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.object = base;\n        if (computed) {\n            node.property = this.parseExpression();\n            this.expect(types$1.bracketR);\n        } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n            node.property = this.parsePrivateIdent();\n        } else {\n            node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n        }\n        node.computed = !!computed;\n        if (optionalSupported) {\n            node.optional = optional;\n        }\n        base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(types$1.parenL)) {\n        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n        if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n            this.checkPatternErrors(refDestructuringErrors, false);\n            this.checkYieldAwaitInDefaultParams();\n            if (this.awaitIdentPos > 0) {\n                this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\");\n            }\n            this.yieldPos = oldYieldPos;\n            this.awaitPos = oldAwaitPos;\n            this.awaitIdentPos = oldAwaitIdentPos;\n            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);\n        }\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        this.yieldPos = oldYieldPos || this.yieldPos;\n        this.awaitPos = oldAwaitPos || this.awaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.callee = base;\n        node$1.arguments = exprList;\n        if (optionalSupported) {\n            node$1.optional = optional;\n        }\n        base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === types$1.backQuote) {\n        if (optional || optionalChained) {\n            this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n        }\n        var node$2 = this.startNodeAt(startPos, startLoc);\n        node$2.tag = base;\n        node$2.quasi = this.parseTemplate({\n            isTagged: true\n        });\n        base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base;\n};\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\npp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === types$1.slash) {\n        this.readRegexp();\n    }\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch(this.type){\n        case types$1._super:\n            if (!this.allowSuper) {\n                this.raise(this.start, \"'super' keyword outside a method\");\n            }\n            node = this.startNode();\n            this.next();\n            if (this.type === types$1.parenL && !this.allowDirectSuper) {\n                this.raise(node.start, \"super() call outside constructor of a subclass\");\n            }\n            // The `super` keyword can appear at below:\n            // SuperProperty:\n            //     super [ Expression ]\n            //     super . IdentifierName\n            // SuperCall:\n            //     super ( Arguments )\n            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {\n                this.unexpected();\n            }\n            return this.finishNode(node, \"Super\");\n        case types$1._this:\n            node = this.startNode();\n            this.next();\n            return this.finishNode(node, \"ThisExpression\");\n        case types$1.name:\n            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n            var id = this.parseIdent(false);\n            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n                this.overrideContext(types.f_expr);\n                return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);\n            }\n            if (canBeArrow && !this.canInsertSemicolon()) {\n                if (this.eat(types$1.arrow)) {\n                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                        id\n                    ], false, forInit);\n                }\n                if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n                    id = this.parseIdent(false);\n                    if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {\n                        this.unexpected();\n                    }\n                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                        id\n                    ], true, forInit);\n                }\n            }\n            return id;\n        case types$1.regexp:\n            var value = this.value;\n            node = this.parseLiteral(value.value);\n            node.regex = {\n                pattern: value.pattern,\n                flags: value.flags\n            };\n            return node;\n        case types$1.num:\n        case types$1.string:\n            return this.parseLiteral(this.value);\n        case types$1._null:\n        case types$1._true:\n        case types$1._false:\n            node = this.startNode();\n            node.value = this.type === types$1._null ? null : this.type === types$1._true;\n            node.raw = this.type.keyword;\n            this.next();\n            return this.finishNode(node, \"Literal\");\n        case types$1.parenL:\n            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n            if (refDestructuringErrors) {\n                if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {\n                    refDestructuringErrors.parenthesizedAssign = start;\n                }\n                if (refDestructuringErrors.parenthesizedBind < 0) {\n                    refDestructuringErrors.parenthesizedBind = start;\n                }\n            }\n            return expr;\n        case types$1.bracketL:\n            node = this.startNode();\n            this.next();\n            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n            return this.finishNode(node, \"ArrayExpression\");\n        case types$1.braceL:\n            this.overrideContext(types.b_expr);\n            return this.parseObj(false, refDestructuringErrors);\n        case types$1._function:\n            node = this.startNode();\n            this.next();\n            return this.parseFunction(node, 0);\n        case types$1._class:\n            return this.parseClass(this.startNode(), false);\n        case types$1._new:\n            return this.parseNew();\n        case types$1.backQuote:\n            return this.parseTemplate();\n        case types$1._import:\n            if (this.options.ecmaVersion >= 11) {\n                return this.parseExprImport(forNew);\n            } else {\n                return this.unexpected();\n            }\n        default:\n            return this.parseExprAtomDefault();\n    }\n};\npp$5.parseExprAtomDefault = function() {\n    this.unexpected();\n};\npp$5.parseExprImport = function(forNew) {\n    var node = this.startNode();\n    // Consume `import` as an identifier for `import.meta`.\n    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n    if (this.containsEsc) {\n        this.raiseRecoverable(this.start, \"Escape sequence in keyword import\");\n    }\n    var meta = this.parseIdent(true);\n    if (this.type === types$1.parenL && !forNew) {\n        return this.parseDynamicImport(node);\n    } else if (this.type === types$1.dot) {\n        node.meta = meta;\n        return this.parseImportMeta(node);\n    } else {\n        this.unexpected();\n    }\n};\npp$5.parseDynamicImport = function(node) {\n    this.next(); // skip `(`\n    // Parse node.source.\n    node.source = this.parseMaybeAssign();\n    // Verify ending.\n    if (!this.eat(types$1.parenR)) {\n        var errorPos = this.start;\n        if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n            this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n        } else {\n            this.unexpected(errorPos);\n        }\n    }\n    return this.finishNode(node, \"ImportExpression\");\n};\npp$5.parseImportMeta = function(node) {\n    this.next(); // skip `.`\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"meta\") {\n        this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\");\n    }\n    if (containsEsc) {\n        this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\");\n    }\n    if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere) {\n        this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\");\n    }\n    return this.finishNode(node, \"MetaProperty\");\n};\npp$5.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110) {\n        node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\");\n    }\n    this.next();\n    return this.finishNode(node, \"Literal\");\n};\npp$5.parseParenExpression = function() {\n    this.expect(types$1.parenL);\n    var val = this.parseExpression();\n    this.expect(types$1.parenR);\n    return val;\n};\npp$5.shouldParseArrow = function(exprList) {\n    return !this.canInsertSemicolon();\n};\npp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n        this.next();\n        var innerStartPos = this.start, innerStartLoc = this.startLoc;\n        var exprList = [], first = true, lastIsComma = false;\n        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        // Do not save awaitIdentPos to allow checking awaits nested in parameters\n        while(this.type !== types$1.parenR){\n            first ? first = false : this.expect(types$1.comma);\n            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n                lastIsComma = true;\n                break;\n            } else if (this.type === types$1.ellipsis) {\n                spreadStart = this.start;\n                exprList.push(this.parseParenItem(this.parseRestBinding()));\n                if (this.type === types$1.comma) {\n                    this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                }\n                break;\n            } else {\n                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n            }\n        }\n        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n        this.expect(types$1.parenR);\n        if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {\n            this.checkPatternErrors(refDestructuringErrors, false);\n            this.checkYieldAwaitInDefaultParams();\n            this.yieldPos = oldYieldPos;\n            this.awaitPos = oldAwaitPos;\n            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);\n        }\n        if (!exprList.length || lastIsComma) {\n            this.unexpected(this.lastTokStart);\n        }\n        if (spreadStart) {\n            this.unexpected(spreadStart);\n        }\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        this.yieldPos = oldYieldPos || this.yieldPos;\n        this.awaitPos = oldAwaitPos || this.awaitPos;\n        if (exprList.length > 1) {\n            val = this.startNodeAt(innerStartPos, innerStartLoc);\n            val.expressions = exprList;\n            this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n        } else {\n            val = exprList[0];\n        }\n    } else {\n        val = this.parseParenExpression();\n    }\n    if (this.options.preserveParens) {\n        var par = this.startNodeAt(startPos, startLoc);\n        par.expression = val;\n        return this.finishNode(par, \"ParenthesizedExpression\");\n    } else {\n        return val;\n    }\n};\npp$5.parseParenItem = function(item) {\n    return item;\n};\npp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);\n};\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nvar empty = [];\npp$5.parseNew = function() {\n    if (this.containsEsc) {\n        this.raiseRecoverable(this.start, \"Escape sequence in keyword new\");\n    }\n    var node = this.startNode();\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {\n        node.meta = meta;\n        var containsEsc = this.containsEsc;\n        node.property = this.parseIdent(true);\n        if (node.property.name !== \"target\") {\n            this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\");\n        }\n        if (containsEsc) {\n            this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\");\n        }\n        if (!this.allowNewDotTarget) {\n            this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\");\n        }\n        return this.finishNode(node, \"MetaProperty\");\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n    if (this.eat(types$1.parenL)) {\n        node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);\n    } else {\n        node.arguments = empty;\n    }\n    return this.finishNode(node, \"NewExpression\");\n};\n// Parse template expression.\npp$5.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n    var elem = this.startNode();\n    if (this.type === types$1.invalidTemplate) {\n        if (!isTagged) {\n            this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n        }\n        elem.value = {\n            raw: this.value,\n            cooked: null\n        };\n    } else {\n        elem.value = {\n            raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n            cooked: this.value\n        };\n    }\n    this.next();\n    elem.tail = this.type === types$1.backQuote;\n    return this.finishNode(elem, \"TemplateElement\");\n};\npp$5.parseTemplate = function(ref) {\n    if (ref === void 0) ref = {};\n    var isTagged = ref.isTagged;\n    if (isTagged === void 0) isTagged = false;\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({\n        isTagged: isTagged\n    });\n    node.quasis = [\n        curElt\n    ];\n    while(!curElt.tail){\n        if (this.type === types$1.eof) {\n            this.raise(this.pos, \"Unterminated template literal\");\n        }\n        this.expect(types$1.dollarBraceL);\n        node.expressions.push(this.parseExpression());\n        this.expect(types$1.braceR);\n        node.quasis.push(curElt = this.parseTemplateElement({\n            isTagged: isTagged\n        }));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n};\npp$5.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\n// Parse an object literal or binding pattern.\npp$5.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while(!this.eat(types$1.braceR)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        var prop = this.parseProperty(isPattern, refDestructuringErrors);\n        if (!isPattern) {\n            this.checkPropClash(prop, propHash, refDestructuringErrors);\n        }\n        node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\npp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n        if (isPattern) {\n            prop.argument = this.parseIdent(false);\n            if (this.type === types$1.comma) {\n                this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n            }\n            return this.finishNode(prop, \"RestElement\");\n        }\n        // Parse argument.\n        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n        // To disallow trailing comma via `this.toAssignable()`.\n        if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n            refDestructuringErrors.trailingComma = this.start;\n        }\n        // Finish\n        return this.finishNode(prop, \"SpreadElement\");\n    }\n    if (this.options.ecmaVersion >= 6) {\n        prop.method = false;\n        prop.shorthand = false;\n        if (isPattern || refDestructuringErrors) {\n            startPos = this.start;\n            startLoc = this.startLoc;\n        }\n        if (!isPattern) {\n            isGenerator = this.eat(types$1.star);\n        }\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n        this.parsePropertyName(prop);\n    } else {\n        isAsync = false;\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\");\n};\npp$5.parseGetterSetter = function(prop) {\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\") {\n            this.raiseRecoverable(start, \"getter should have no params\");\n        } else {\n            this.raiseRecoverable(start, \"setter should have exactly one param\");\n        }\n    } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n            this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n        }\n    }\n};\npp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types$1.colon) {\n        this.unexpected();\n    }\n    if (this.eat(types$1.colon)) {\n        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n        prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n        if (isPattern) {\n            this.unexpected();\n        }\n        prop.kind = \"init\";\n        prop.method = true;\n        prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {\n        if (isGenerator || isAsync) {\n            this.unexpected();\n        }\n        this.parseGetterSetter(prop);\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n        if (isGenerator || isAsync) {\n            this.unexpected();\n        }\n        this.checkUnreserved(prop.key);\n        if (prop.key.name === \"await\" && !this.awaitIdentPos) {\n            this.awaitIdentPos = startPos;\n        }\n        prop.kind = \"init\";\n        if (isPattern) {\n            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n        } else if (this.type === types$1.eq && refDestructuringErrors) {\n            if (refDestructuringErrors.shorthandAssign < 0) {\n                refDestructuringErrors.shorthandAssign = this.start;\n            }\n            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n        } else {\n            prop.value = this.copyNode(prop.key);\n        }\n        prop.shorthand = true;\n    } else {\n        this.unexpected();\n    }\n};\npp$5.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n        if (this.eat(types$1.bracketL)) {\n            prop.computed = true;\n            prop.key = this.parseMaybeAssign();\n            this.expect(types$1.bracketR);\n            return prop.key;\n        } else {\n            prop.computed = false;\n        }\n    }\n    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n};\n// Initialize empty function node.\npp$5.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) {\n        node.generator = node.expression = false;\n    }\n    if (this.options.ecmaVersion >= 8) {\n        node.async = false;\n    }\n};\n// Parse object or class method.\npp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6) {\n        node.generator = isGenerator;\n    }\n    if (this.options.ecmaVersion >= 8) {\n        node.async = !!isAsync;\n    }\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.expect(types$1.parenL);\n    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true, false);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\");\n};\n// Parse arrow function expression with given parameters.\npp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) {\n        node.async = !!isAsync;\n    }\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false, forInit);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n// Parse function body and check parameters.\npp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n    var isExpression = isArrowFunction && this.type !== types$1.braceL;\n    var oldStrict = this.strict, useStrict = false;\n    if (isExpression) {\n        node.body = this.parseMaybeAssign(forInit);\n        node.expression = true;\n        this.checkParams(node, false);\n    } else {\n        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n        if (!oldStrict || nonSimple) {\n            useStrict = this.strictDirective(this.end);\n            // If this is a strict mode function, verify that argument names\n            // are not repeated, and it does not try to bind the words `eval`\n            // or `arguments`.\n            if (useStrict && nonSimple) {\n                this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n            }\n        }\n        // Start a new scope with regard to labels and the `inFunction`\n        // flag (restore them to their old value afterwards).\n        var oldLabels = this.labels;\n        this.labels = [];\n        if (useStrict) {\n            this.strict = true;\n        }\n        // Add the params to varDeclaredNames to ensure that an error is thrown\n        // if a let/const declaration in the function clashes with one of the params.\n        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n        // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n        if (this.strict && node.id) {\n            this.checkLValSimple(node.id, BIND_OUTSIDE);\n        }\n        node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n        node.expression = false;\n        this.adaptDirectivePrologue(node.body.body);\n        this.labels = oldLabels;\n    }\n    this.exitScope();\n};\npp$5.isSimpleParamList = function(params) {\n    for(var i = 0, list = params; i < list.length; i += 1){\n        var param = list[i];\n        if (param.type !== \"Identifier\") {\n            return false;\n        }\n    }\n    return true;\n};\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\npp$5.checkParams = function(node, allowDuplicates) {\n    var nameHash = Object.create(null);\n    for(var i = 0, list = node.params; i < list.length; i += 1){\n        var param = list[i];\n        this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n};\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\npp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while(!this.eat(close)){\n        if (!first) {\n            this.expect(types$1.comma);\n            if (allowTrailingComma && this.afterTrailingComma(close)) {\n                break;\n            }\n        } else {\n            first = false;\n        }\n        var elt = void 0;\n        if (allowEmpty && this.type === types$1.comma) {\n            elt = null;\n        } else if (this.type === types$1.ellipsis) {\n            elt = this.parseSpread(refDestructuringErrors);\n            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {\n                refDestructuringErrors.trailingComma = this.start;\n            }\n        } else {\n            elt = this.parseMaybeAssign(false, refDestructuringErrors);\n        }\n        elts.push(elt);\n    }\n    return elts;\n};\npp$5.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n    if (this.inGenerator && name === \"yield\") {\n        this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\");\n    }\n    if (this.inAsync && name === \"await\") {\n        this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\");\n    }\n    if (this.currentThisScope().inClassFieldInit && name === \"arguments\") {\n        this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\");\n    }\n    if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\")) {\n        this.raise(start, \"Cannot use \" + name + \" in class static initialization block\");\n    }\n    if (this.keywords.test(name)) {\n        this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n    }\n    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) {\n        return;\n    }\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n        if (!this.inAsync && name === \"await\") {\n            this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\");\n        }\n        this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n    }\n};\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\npp$5.parseIdent = function(liberal) {\n    var node = this.parseIdentNode();\n    this.next(!!liberal);\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n        this.checkUnreserved(node);\n        if (node.name === \"await\" && !this.awaitIdentPos) {\n            this.awaitIdentPos = node.start;\n        }\n    }\n    return node;\n};\npp$5.parseIdentNode = function() {\n    var node = this.startNode();\n    if (this.type === types$1.name) {\n        node.name = this.value;\n    } else if (this.type.keyword) {\n        node.name = this.type.keyword;\n        // To fix https://github.com/acornjs/acorn/issues/575\n        // `class` and `function` keywords push new context into this.context.\n        // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n        // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n        if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n            this.context.pop();\n        }\n    } else {\n        this.unexpected();\n    }\n    return node;\n};\npp$5.parsePrivateIdent = function() {\n    var node = this.startNode();\n    if (this.type === types$1.privateId) {\n        node.name = this.value;\n    } else {\n        this.unexpected();\n    }\n    this.next();\n    this.finishNode(node, \"PrivateIdentifier\");\n    // For validating existence\n    if (this.options.checkPrivateFields) {\n        if (this.privateNameStack.length === 0) {\n            this.raise(node.start, \"Private field '#\" + node.name + \"' must be declared in an enclosing class\");\n        } else {\n            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n        }\n    }\n    return node;\n};\n// Parses yield expression inside generator.\npp$5.parseYield = function(forInit) {\n    if (!this.yieldPos) {\n        this.yieldPos = this.start;\n    }\n    var node = this.startNode();\n    this.next();\n    if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {\n        node.delegate = false;\n        node.argument = null;\n    } else {\n        node.delegate = this.eat(types$1.star);\n        node.argument = this.parseMaybeAssign(forInit);\n    }\n    return this.finishNode(node, \"YieldExpression\");\n};\npp$5.parseAwait = function(forInit) {\n    if (!this.awaitPos) {\n        this.awaitPos = this.start;\n    }\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true, false, forInit);\n    return this.finishNode(node, \"AwaitExpression\");\n};\nvar pp$4 = Parser.prototype;\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\npp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos;\n    err.loc = loc;\n    err.raisedAt = this.pos;\n    throw err;\n};\npp$4.raiseRecoverable = pp$4.raise;\npp$4.curPosition = function() {\n    if (this.options.locations) {\n        return new Position(this.curLine, this.pos - this.lineStart);\n    }\n};\nvar pp$3 = Parser.prototype;\nvar Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n    // A switch to disallow the identifier reference 'arguments'\n    this.inClassFieldInit = false;\n};\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\npp$3.enterScope = function(flags) {\n    this.scopeStack.push(new Scope(flags));\n};\npp$3.exitScope = function() {\n    this.scopeStack.pop();\n};\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$3.treatFunctionsAsVarInScope = function(scope) {\n    return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;\n};\npp$3.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === BIND_LEXICAL) {\n        var scope = this.currentScope();\n        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n        scope.lexical.push(name);\n        if (this.inModule && scope.flags & SCOPE_TOP) {\n            delete this.undefinedExports[name];\n        }\n    } else if (bindingType === BIND_SIMPLE_CATCH) {\n        var scope$1 = this.currentScope();\n        scope$1.lexical.push(name);\n    } else if (bindingType === BIND_FUNCTION) {\n        var scope$2 = this.currentScope();\n        if (this.treatFunctionsAsVar) {\n            redeclared = scope$2.lexical.indexOf(name) > -1;\n        } else {\n            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;\n        }\n        scope$2.functions.push(name);\n    } else {\n        for(var i = this.scopeStack.length - 1; i >= 0; --i){\n            var scope$3 = this.scopeStack[i];\n            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n                redeclared = true;\n                break;\n            }\n            scope$3.var.push(name);\n            if (this.inModule && scope$3.flags & SCOPE_TOP) {\n                delete this.undefinedExports[name];\n            }\n            if (scope$3.flags & SCOPE_VAR) {\n                break;\n            }\n        }\n    }\n    if (redeclared) {\n        this.raiseRecoverable(pos, \"Identifier '\" + name + \"' has already been declared\");\n    }\n};\npp$3.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {\n        this.undefinedExports[id.name] = id;\n    }\n};\npp$3.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1];\n};\npp$3.currentVarScope = function() {\n    for(var i = this.scopeStack.length - 1;; i--){\n        var scope = this.scopeStack[i];\n        if (scope.flags & SCOPE_VAR) {\n            return scope;\n        }\n    }\n};\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$3.currentThisScope = function() {\n    for(var i = this.scopeStack.length - 1;; i--){\n        var scope = this.scopeStack[i];\n        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {\n            return scope;\n        }\n    }\n};\nvar Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations) {\n        this.loc = new SourceLocation(parser, loc);\n    }\n    if (parser.options.directSourceFile) {\n        this.sourceFile = parser.options.directSourceFile;\n    }\n    if (parser.options.ranges) {\n        this.range = [\n            pos,\n            0\n        ];\n    }\n};\n// Start an AST node, attaching a start offset.\nvar pp$2 = Parser.prototype;\npp$2.startNode = function() {\n    return new Node(this, this.start, this.startLoc);\n};\npp$2.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc);\n};\n// Finish an AST node, adding `type` and `end` properties.\nfunction finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations) {\n        node.loc.end = loc;\n    }\n    if (this.options.ranges) {\n        node.range[1] = pos;\n    }\n    return node;\n}\npp$2.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n};\n// Finish node at given position\npp$2.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc);\n};\npp$2.copyNode = function(node) {\n    var newNode = new Node(this, node.start, this.startLoc);\n    for(var prop in node){\n        newNode[prop] = node[prop];\n    }\n    return newNode;\n};\n// This file contains Unicode properties extracted from the ECMAScript specification.\n// The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\nvar ecma13BinaryProperties = ecma12BinaryProperties;\nvar ecma14BinaryProperties = ecma13BinaryProperties;\nvar unicodeBinaryProperties = {\n    9: ecma9BinaryProperties,\n    10: ecma10BinaryProperties,\n    11: ecma11BinaryProperties,\n    12: ecma12BinaryProperties,\n    13: ecma13BinaryProperties,\n    14: ecma14BinaryProperties\n};\n// #table-binary-unicode-properties-of-strings\nvar ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\nvar unicodeBinaryPropertiesOfStrings = {\n    9: \"\",\n    10: \"\",\n    11: \"\",\n    12: \"\",\n    13: \"\",\n    14: ecma14BinaryPropertiesOfStrings\n};\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\nvar ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\nvar ecma14ScriptValues = ecma13ScriptValues + \" Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz\";\nvar unicodeScriptValues = {\n    9: ecma9ScriptValues,\n    10: ecma10ScriptValues,\n    11: ecma11ScriptValues,\n    12: ecma12ScriptValues,\n    13: ecma13ScriptValues,\n    14: ecma14ScriptValues\n};\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n        binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n        nonBinary: {\n            General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n        }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\nfor(var i = 0, list = [\n    9,\n    10,\n    11,\n    12,\n    13,\n    14\n]; i < list.length; i += 1){\n    var ecmaVersion = list[i];\n    buildUnicodeData(ecmaVersion);\n}\nvar pp$1 = Parser.prototype;\nvar RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n    this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchV = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = [];\n    this.backReferenceNames = [];\n};\nRegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n    var unicodeSets = flags.indexOf(\"v\") !== -1;\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n        this.switchU = true;\n        this.switchV = true;\n        this.switchN = true;\n    } else {\n        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n        this.switchV = false;\n        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n    }\n};\nRegExpValidationState.prototype.raise = function raise(message) {\n    this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n};\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at(i, forceU) {\n    if (forceU === void 0) forceU = false;\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n        return -1;\n    }\n    var c = s.charCodeAt(i);\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n        return c;\n    }\n    var next = s.charCodeAt(i + 1);\n    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n};\nRegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {\n    if (forceU === void 0) forceU = false;\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n        return l;\n    }\n    var c = s.charCodeAt(i), next;\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n        return i + 1;\n    }\n    return i + 2;\n};\nRegExpValidationState.prototype.current = function current(forceU) {\n    if (forceU === void 0) forceU = false;\n    return this.at(this.pos, forceU);\n};\nRegExpValidationState.prototype.lookahead = function lookahead(forceU) {\n    if (forceU === void 0) forceU = false;\n    return this.at(this.nextIndex(this.pos, forceU), forceU);\n};\nRegExpValidationState.prototype.advance = function advance(forceU) {\n    if (forceU === void 0) forceU = false;\n    this.pos = this.nextIndex(this.pos, forceU);\n};\nRegExpValidationState.prototype.eat = function eat(ch, forceU) {\n    if (forceU === void 0) forceU = false;\n    if (this.current(forceU) === ch) {\n        this.advance(forceU);\n        return true;\n    }\n    return false;\n};\nRegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {\n    if (forceU === void 0) forceU = false;\n    var pos = this.pos;\n    for(var i = 0, list = chs; i < list.length; i += 1){\n        var ch = list[i];\n        var current = this.at(pos, forceU);\n        if (current === -1 || current !== ch) {\n            return false;\n        }\n        pos = this.nextIndex(pos, forceU);\n    }\n    this.pos = pos;\n    return true;\n};\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */ pp$1.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n    var u = false;\n    var v = false;\n    for(var i = 0; i < flags.length; i++){\n        var flag = flags.charAt(i);\n        if (validFlags.indexOf(flag) === -1) {\n            this.raise(state.start, \"Invalid regular expression flag\");\n        }\n        if (flags.indexOf(flag, i + 1) > -1) {\n            this.raise(state.start, \"Duplicate regular expression flag\");\n        }\n        if (flag === \"u\") {\n            u = true;\n        }\n        if (flag === \"v\") {\n            v = true;\n        }\n    }\n    if (this.options.ecmaVersion >= 15 && u && v) {\n        this.raise(state.start, \"Invalid regular expression flag\");\n    }\n};\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */ pp$1.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n        state.switchN = true;\n        this.regexp_pattern(state);\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$1.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames.length = 0;\n    state.backReferenceNames.length = 0;\n    this.regexp_disjunction(state);\n    if (state.pos !== state.source.length) {\n        // Make the same messages as V8.\n        if (state.eat(0x29 /* ) */ )) {\n            state.raise(\"Unmatched ')'\");\n        }\n        if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) {\n            state.raise(\"Lone quantifier brackets\");\n        }\n    }\n    if (state.maxBackReference > state.numCapturingParens) {\n        state.raise(\"Invalid escape\");\n    }\n    for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){\n        var name = list[i];\n        if (state.groupNames.indexOf(name) === -1) {\n            state.raise(\"Invalid named capture referenced\");\n        }\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$1.regexp_disjunction = function(state) {\n    this.regexp_alternative(state);\n    while(state.eat(0x7C /* | */ )){\n        this.regexp_alternative(state);\n    }\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) {\n        state.raise(\"Nothing to repeat\");\n    }\n    if (state.eat(0x7B /* { */ )) {\n        state.raise(\"Lone quantifier brackets\");\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$1.regexp_alternative = function(state) {\n    while(state.pos < state.source.length && this.regexp_eatTerm(state)){}\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$1.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n        // Handle `QuantifiableAssertion Quantifier` alternative.\n        // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n        // is a QuantifiableAssertion.\n        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n            // Make the same message as V8.\n            if (state.switchU) {\n                state.raise(\"Invalid quantifier\");\n            }\n        }\n        return true;\n    }\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n        this.regexp_eatQuantifier(state);\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$1.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n    // ^, $\n    if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) {\n        return true;\n    }\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */ )) {\n        if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) {\n            return true;\n        }\n        state.pos = start;\n    }\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {\n        var lookbehind = false;\n        if (this.options.ecmaVersion >= 9) {\n            lookbehind = state.eat(0x3C /* < */ );\n        }\n        if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {\n            this.regexp_disjunction(state);\n            if (!state.eat(0x29 /* ) */ )) {\n                state.raise(\"Unterminated group\");\n            }\n            state.lastAssertionIsQuantifiable = !lookbehind;\n            return true;\n        }\n    }\n    state.pos = start;\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$1.regexp_eatQuantifier = function(state, noError) {\n    if (noError === void 0) noError = false;\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n        state.eat(0x3F /* ? */ );\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n    return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);\n};\npp$1.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */ )) {\n        var min = 0, max = -1;\n        if (this.regexp_eatDecimalDigits(state)) {\n            min = state.lastIntValue;\n            if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) {\n                max = state.lastIntValue;\n            }\n            if (state.eat(0x7D /* } */ )) {\n                // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n                if (max !== -1 && max < min && !noError) {\n                    state.raise(\"numbers out of order in {} quantifier\");\n                }\n                return true;\n            }\n        }\n        if (state.switchU && !noError) {\n            state.raise(\"Incomplete quantifier\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$1.regexp_eatAtom = function(state) {\n    return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n};\npp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatAtomEscape(state)) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */ )) {\n        if (state.eat(0x3F /* ? */ ) && state.eat(0x3A /* : */ )) {\n            this.regexp_disjunction(state);\n            if (state.eat(0x29 /* ) */ )) {\n                return true;\n            }\n            state.raise(\"Unterminated group\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */ )) {\n        if (this.options.ecmaVersion >= 9) {\n            this.regexp_groupSpecifier(state);\n        } else if (state.current() === 0x3F /* ? */ ) {\n            state.raise(\"Invalid group\");\n        }\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */ )) {\n            state.numCapturingParens += 1;\n            return true;\n        }\n        state.raise(\"Unterminated group\");\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$1.regexp_eatExtendedAtom = function(state) {\n    return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n        state.raise(\"Nothing to repeat\");\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$1.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if (isSyntaxCharacter(ch)) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\nfunction isSyntaxCharacter(ch) {\n    return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$1.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)){\n        state.advance();\n    }\n    return state.pos !== start;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$1.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\npp$1.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */ )) {\n        if (this.regexp_eatGroupName(state)) {\n            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n                state.raise(\"Duplicate capture group name\");\n            }\n            state.groupNames.push(state.lastStringValue);\n            return;\n        }\n        state.raise(\"Invalid group\");\n    }\n};\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */ )) {\n        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) {\n            return true;\n        }\n        state.raise(\"Invalid capture group name\");\n    }\n    return false;\n};\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n        state.lastStringValue += codePointToString(state.lastIntValue);\n        while(this.regexp_eatRegExpIdentifierPart(state)){\n            state.lastStringValue += codePointToString(state.lastIntValue);\n        }\n        return true;\n    }\n    return false;\n};\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\npp$1.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n    if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n        ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierStart(ch)) {\n        state.lastIntValue = ch;\n        return true;\n    }\n    state.pos = start;\n    return false;\n};\nfunction isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;\n}\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\npp$1.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n    if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n        ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierPart(ch)) {\n        state.lastIntValue = ch;\n        return true;\n    }\n    state.pos = start;\n    return false;\n};\nfunction isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$1.regexp_eatAtomEscape = function(state) {\n    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n        return true;\n    }\n    if (state.switchU) {\n        // Make the same message as V8.\n        if (state.current() === 0x63 /* c */ ) {\n            state.raise(\"Invalid unicode escape\");\n        }\n        state.raise(\"Invalid escape\");\n    }\n    return false;\n};\npp$1.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n        var n = state.lastIntValue;\n        if (state.switchU) {\n            // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n            if (n > state.maxBackReference) {\n                state.maxBackReference = n;\n            }\n            return true;\n        }\n        if (n <= state.numCapturingParens) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */ )) {\n        if (this.regexp_eatGroupName(state)) {\n            state.backReferenceNames.push(state.lastStringValue);\n            return true;\n        }\n        state.raise(\"Invalid named reference\");\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$1.regexp_eatCharacterEscape = function(state) {\n    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n};\npp$1.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */ )) {\n        if (this.regexp_eatControlLetter(state)) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\npp$1.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */  && !isDecimalDigit(state.lookahead())) {\n        state.lastIntValue = 0;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$1.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */ ) {\n        state.lastIntValue = 0x09; /* \\t */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x6E /* n */ ) {\n        state.lastIntValue = 0x0A; /* \\n */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x76 /* v */ ) {\n        state.lastIntValue = 0x0B; /* \\v */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x66 /* f */ ) {\n        state.lastIntValue = 0x0C; /* \\f */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x72 /* r */ ) {\n        state.lastIntValue = 0x0D; /* \\r */ \n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$1.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if (isControlLetter(ch)) {\n        state.lastIntValue = ch % 0x20;\n        state.advance();\n        return true;\n    }\n    return false;\n};\nfunction isControlLetter(ch) {\n    return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n    if (forceU === void 0) forceU = false;\n    var start = state.pos;\n    var switchU = forceU || state.switchU;\n    if (state.eat(0x75 /* u */ )) {\n        if (this.regexp_eatFixedHexDigits(state, 4)) {\n            var lead = state.lastIntValue;\n            if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n                var leadSurrogateEnd = state.pos;\n                if (state.eat(0x5C /* \\ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {\n                    var trail = state.lastIntValue;\n                    if (trail >= 0xDC00 && trail <= 0xDFFF) {\n                        state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n                        return true;\n                    }\n                }\n                state.pos = leadSurrogateEnd;\n                state.lastIntValue = lead;\n            }\n            return true;\n        }\n        if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && isValidUnicode(state.lastIntValue)) {\n            return true;\n        }\n        if (switchU) {\n            state.raise(\"Invalid unicode escape\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\nfunction isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$1.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n        if (this.regexp_eatSyntaxCharacter(state)) {\n            return true;\n        }\n        if (state.eat(0x2F /* / */ )) {\n            state.lastIntValue = 0x2F; /* / */ \n            return true;\n        }\n        return false;\n    }\n    var ch = state.current();\n    if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$1.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {\n        do {\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n            state.advance();\n        }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );\n        return true;\n    }\n    return false;\n};\n// Return values used by character set parsing methods, needed to\n// forbid negation of sets that can match strings.\nvar CharSetNone = 0; // Nothing parsed\nvar CharSetOk = 1; // Construct parsed, cannot contain strings\nvar CharSetString = 2; // Construct parsed, can contain strings\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$1.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n    if (isCharacterClassEscape(ch)) {\n        state.lastIntValue = -1;\n        state.advance();\n        return CharSetOk;\n    }\n    var negate = false;\n    if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 0x50 /* P */ ) || ch === 0x70 /* p */ )) {\n        state.lastIntValue = -1;\n        state.advance();\n        var result;\n        if (state.eat(0x7B /* { */ ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(0x7D /* } */ )) {\n            if (negate && result === CharSetString) {\n                state.raise(\"Invalid property name\");\n            }\n            return result;\n        }\n        state.raise(\"Invalid property name\");\n    }\n    return CharSetNone;\n};\nfunction isCharacterClassEscape(ch) {\n    return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;\n}\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {\n        var name = state.lastStringValue;\n        if (this.regexp_eatUnicodePropertyValue(state)) {\n            var value = state.lastStringValue;\n            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n            return CharSetOk;\n        }\n    }\n    state.pos = start;\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n        var nameOrValue = state.lastStringValue;\n        return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    }\n    return CharSetNone;\n};\npp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!hasOwn(state.unicodeProperties.nonBinary, name)) {\n        state.raise(\"Invalid property name\");\n    }\n    if (!state.unicodeProperties.nonBinary[name].test(value)) {\n        state.raise(\"Invalid property value\");\n    }\n};\npp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (state.unicodeProperties.binary.test(nameOrValue)) {\n        return CharSetOk;\n    }\n    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {\n        return CharSetString;\n    }\n    state.raise(\"Invalid property name\");\n};\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$1.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while(isUnicodePropertyNameCharacter(ch = state.current())){\n        state.lastStringValue += codePointToString(ch);\n        state.advance();\n    }\n    return state.lastStringValue !== \"\";\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F /* _ */ ;\n}\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while(isUnicodePropertyValueCharacter(ch = state.current())){\n        state.lastStringValue += codePointToString(ch);\n        state.advance();\n    }\n    return state.lastStringValue !== \"\";\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n}\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state);\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$1.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */ )) {\n        var negate = state.eat(0x5E /* ^ */ );\n        var result = this.regexp_classContents(state);\n        if (!state.eat(0x5D /* ] */ )) {\n            state.raise(\"Unterminated character class\");\n        }\n        if (negate && result === CharSetString) {\n            state.raise(\"Negated character class may contain strings\");\n        }\n        return true;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassContents\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\npp$1.regexp_classContents = function(state) {\n    if (state.current() === 0x5D /* ] */ ) {\n        return CharSetOk;\n    }\n    if (state.switchV) {\n        return this.regexp_classSetExpression(state);\n    }\n    this.regexp_nonEmptyClassRanges(state);\n    return CharSetOk;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$1.regexp_nonEmptyClassRanges = function(state) {\n    while(this.regexp_eatClassAtom(state)){\n        var left = state.lastIntValue;\n        if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {\n            var right = state.lastIntValue;\n            if (state.switchU && (left === -1 || right === -1)) {\n                state.raise(\"Invalid character class\");\n            }\n            if (left !== -1 && right !== -1 && left > right) {\n                state.raise(\"Range out of order in character class\");\n            }\n        }\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$1.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatClassEscape(state)) {\n            return true;\n        }\n        if (state.switchU) {\n            // Make the same message as V8.\n            var ch$1 = state.current();\n            if (ch$1 === 0x63 /* c */  || isOctalDigit(ch$1)) {\n                state.raise(\"Invalid class escape\");\n            }\n            state.raise(\"Invalid escape\");\n        }\n        state.pos = start;\n    }\n    var ch = state.current();\n    if (ch !== 0x5D /* ] */ ) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$1.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x62 /* b */ )) {\n        state.lastIntValue = 0x08; /* <BS> */ \n        return true;\n    }\n    if (state.switchU && state.eat(0x2D /* - */ )) {\n        state.lastIntValue = 0x2D; /* - */ \n        return true;\n    }\n    if (!state.switchU && state.eat(0x63 /* c */ )) {\n        if (this.regexp_eatClassControlLetter(state)) {\n            return true;\n        }\n        state.pos = start;\n    }\n    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n};\n// https://tc39.es/ecma262/#prod-ClassSetExpression\n// https://tc39.es/ecma262/#prod-ClassUnion\n// https://tc39.es/ecma262/#prod-ClassIntersection\n// https://tc39.es/ecma262/#prod-ClassSubtraction\npp$1.regexp_classSetExpression = function(state) {\n    var result = CharSetOk, subResult;\n    if (this.regexp_eatClassSetRange(state)) ;\n    else if (subResult = this.regexp_eatClassSetOperand(state)) {\n        if (subResult === CharSetString) {\n            result = CharSetString;\n        }\n        // https://tc39.es/ecma262/#prod-ClassIntersection\n        var start = state.pos;\n        while(state.eatChars([\n            0x26,\n            0x26\n        ])){\n            if (state.current() !== 0x26 /* & */  && (subResult = this.regexp_eatClassSetOperand(state))) {\n                if (subResult !== CharSetString) {\n                    result = CharSetOk;\n                }\n                continue;\n            }\n            state.raise(\"Invalid character in character class\");\n        }\n        if (start !== state.pos) {\n            return result;\n        }\n        // https://tc39.es/ecma262/#prod-ClassSubtraction\n        while(state.eatChars([\n            0x2D,\n            0x2D\n        ])){\n            if (this.regexp_eatClassSetOperand(state)) {\n                continue;\n            }\n            state.raise(\"Invalid character in character class\");\n        }\n        if (start !== state.pos) {\n            return result;\n        }\n    } else {\n        state.raise(\"Invalid character in character class\");\n    }\n    // https://tc39.es/ecma262/#prod-ClassUnion\n    for(;;){\n        if (this.regexp_eatClassSetRange(state)) {\n            continue;\n        }\n        subResult = this.regexp_eatClassSetOperand(state);\n        if (!subResult) {\n            return result;\n        }\n        if (subResult === CharSetString) {\n            result = CharSetString;\n        }\n    }\n};\n// https://tc39.es/ecma262/#prod-ClassSetRange\npp$1.regexp_eatClassSetRange = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatClassSetCharacter(state)) {\n        var left = state.lastIntValue;\n        if (state.eat(0x2D /* - */ ) && this.regexp_eatClassSetCharacter(state)) {\n            var right = state.lastIntValue;\n            if (left !== -1 && right !== -1 && left > right) {\n                state.raise(\"Range out of order in character class\");\n            }\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassSetOperand\npp$1.regexp_eatClassSetOperand = function(state) {\n    if (this.regexp_eatClassSetCharacter(state)) {\n        return CharSetOk;\n    }\n    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);\n};\n// https://tc39.es/ecma262/#prod-NestedClass\npp$1.regexp_eatNestedClass = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5B /* [ */ )) {\n        var negate = state.eat(0x5E /* ^ */ );\n        var result = this.regexp_classContents(state);\n        if (state.eat(0x5D /* ] */ )) {\n            if (negate && result === CharSetString) {\n                state.raise(\"Negated character class may contain strings\");\n            }\n            return result;\n        }\n        state.pos = start;\n    }\n    if (state.eat(0x5C /* \\ */ )) {\n        var result$1 = this.regexp_eatCharacterClassEscape(state);\n        if (result$1) {\n            return result$1;\n        }\n        state.pos = start;\n    }\n    return null;\n};\n// https://tc39.es/ecma262/#prod-ClassStringDisjunction\npp$1.regexp_eatClassStringDisjunction = function(state) {\n    var start = state.pos;\n    if (state.eatChars([\n        0x5C,\n        0x71\n    ])) {\n        if (state.eat(0x7B /* { */ )) {\n            var result = this.regexp_classStringDisjunctionContents(state);\n            if (state.eat(0x7D /* } */ )) {\n                return result;\n            }\n        } else {\n            // Make the same message as V8.\n            state.raise(\"Invalid escape\");\n        }\n        state.pos = start;\n    }\n    return null;\n};\n// https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\npp$1.regexp_classStringDisjunctionContents = function(state) {\n    var result = this.regexp_classString(state);\n    while(state.eat(0x7C /* | */ )){\n        if (this.regexp_classString(state) === CharSetString) {\n            result = CharSetString;\n        }\n    }\n    return result;\n};\n// https://tc39.es/ecma262/#prod-ClassString\n// https://tc39.es/ecma262/#prod-NonEmptyClassString\npp$1.regexp_classString = function(state) {\n    var count = 0;\n    while(this.regexp_eatClassSetCharacter(state)){\n        count++;\n    }\n    return count === 1 ? CharSetOk : CharSetString;\n};\n// https://tc39.es/ecma262/#prod-ClassSetCharacter\npp$1.regexp_eatClassSetCharacter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {\n            return true;\n        }\n        if (state.eat(0x62 /* b */ )) {\n            state.lastIntValue = 0x08; /* <BS> */ \n            return true;\n        }\n        state.pos = start;\n        return false;\n    }\n    var ch = state.current();\n    if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {\n        return false;\n    }\n    if (isClassSetSyntaxCharacter(ch)) {\n        return false;\n    }\n    state.advance();\n    state.lastIntValue = ch;\n    return true;\n};\n// https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\nfunction isClassSetReservedDoublePunctuatorCharacter(ch) {\n    return ch === 0x21 /* ! */  || ch >= 0x23 /* # */  && ch <= 0x26 /* & */  || ch >= 0x2A /* * */  && ch <= 0x2C /* , */  || ch === 0x2E /* . */  || ch >= 0x3A /* : */  && ch <= 0x40 /* @ */  || ch === 0x5E /* ^ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n}\n// https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\nfunction isClassSetSyntaxCharacter(ch) {\n    return ch === 0x28 /* ( */  || ch === 0x29 /* ) */  || ch === 0x2D /* - */  || ch === 0x2F /* / */  || ch >= 0x5B /* [ */  && ch <= 0x5D /* ] */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n}\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\npp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n    var ch = state.current();\n    if (isClassSetReservedPunctuator(ch)) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\nfunction isClassSetReservedPunctuator(ch) {\n    return ch === 0x21 /* ! */  || ch === 0x23 /* # */  || ch === 0x25 /* % */  || ch === 0x26 /* & */  || ch === 0x2C /* , */  || ch === 0x2D /* - */  || ch >= 0x3A /* : */  && ch <= 0x3E /* > */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$1.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {\n        state.lastIntValue = ch % 0x20;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */ )) {\n        if (this.regexp_eatFixedHexDigits(state, 2)) {\n            return true;\n        }\n        if (state.switchU) {\n            state.raise(\"Invalid escape\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$1.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while(isDecimalDigit(ch = state.current())){\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n        state.advance();\n    }\n    return state.pos !== start;\n};\nfunction isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$1.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while(isHexDigit(ch = state.current())){\n        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n        state.advance();\n    }\n    return state.pos !== start;\n};\nfunction isHexDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;\n}\nfunction hexToInt(ch) {\n    if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) {\n        return 10 + (ch - 0x41 /* A */ );\n    }\n    if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) {\n        return 10 + (ch - 0x61 /* a */ );\n    }\n    return ch - 0x30 /* 0 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n        var n1 = state.lastIntValue;\n        if (this.regexp_eatOctalDigit(state)) {\n            var n2 = state.lastIntValue;\n            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n                state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n            } else {\n                state.lastIntValue = n1 * 8 + n2;\n            }\n        } else {\n            state.lastIntValue = n1;\n        }\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$1.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if (isOctalDigit(ch)) {\n        state.lastIntValue = ch - 0x30; /* 0 */ \n        state.advance();\n        return true;\n    }\n    state.lastIntValue = 0;\n    return false;\n};\nfunction isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for(var i = 0; i < length; ++i){\n        var ch = state.current();\n        if (!isHexDigit(ch)) {\n            state.pos = start;\n            return false;\n        }\n        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n        state.advance();\n    }\n    return true;\n};\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\nvar Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations) {\n        this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n    }\n    if (p.options.ranges) {\n        this.range = [\n            p.start,\n            p.end\n        ];\n    }\n};\n// ## Tokenizer\nvar pp = Parser.prototype;\n// Move to the next token\npp.next = function(ignoreEscapeSequenceInKeyword) {\n    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {\n        this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword);\n    }\n    if (this.options.onToken) {\n        this.options.onToken(new Token(this));\n    }\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n};\npp.getToken = function() {\n    this.next();\n    return new Token(this);\n};\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\") {\n    pp[Symbol.iterator] = function() {\n        var this$1$1 = this;\n        return {\n            next: function() {\n                var token = this$1$1.getToken();\n                return {\n                    done: token.type === types$1.eof,\n                    value: token\n                };\n            }\n        };\n    };\n}\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n// Read a single token, updating the parser object's token-related\n// properties.\npp.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) {\n        this.skipSpace();\n    }\n    this.start = this.pos;\n    if (this.options.locations) {\n        this.startLoc = this.curPosition();\n    }\n    if (this.pos >= this.input.length) {\n        return this.finishToken(types$1.eof);\n    }\n    if (curContext.override) {\n        return curContext.override(this);\n    } else {\n        this.readToken(this.fullCharCodeAtPos());\n    }\n};\npp.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */ ) {\n        return this.readWord();\n    }\n    return this.getTokenFromCode(code);\n};\npp.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xdc00) {\n        return code;\n    }\n    var next = this.input.charCodeAt(this.pos + 1);\n    return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00;\n};\npp.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) {\n        this.raise(this.pos - 2, \"Unterminated comment\");\n    }\n    this.pos = end + 2;\n    if (this.options.locations) {\n        for(var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;){\n            ++this.curLine;\n            pos = this.lineStart = nextBreak;\n        }\n    }\n    if (this.options.onComment) {\n        this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n    }\n};\npp.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while(this.pos < this.input.length && !isNewLine(ch)){\n        ch = this.input.charCodeAt(++this.pos);\n    }\n    if (this.options.onComment) {\n        this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n    }\n};\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\npp.skipSpace = function() {\n    loop: while(this.pos < this.input.length){\n        var ch = this.input.charCodeAt(this.pos);\n        switch(ch){\n            case 32:\n            case 160:\n                ++this.pos;\n                break;\n            case 13:\n                if (this.input.charCodeAt(this.pos + 1) === 10) {\n                    ++this.pos;\n                }\n            case 10:\n            case 8232:\n            case 8233:\n                ++this.pos;\n                if (this.options.locations) {\n                    ++this.curLine;\n                    this.lineStart = this.pos;\n                }\n                break;\n            case 47:\n                switch(this.input.charCodeAt(this.pos + 1)){\n                    case 42:\n                        this.skipBlockComment();\n                        break;\n                    case 47:\n                        this.skipLineComment(2);\n                        break;\n                    default:\n                        break loop;\n                }\n                break;\n            default:\n                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n                    ++this.pos;\n                } else {\n                    break loop;\n                }\n        }\n    }\n};\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\npp.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) {\n        this.endLoc = this.curPosition();\n    }\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n    this.updateContext(prevType);\n};\n// ### Token reading\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) {\n        return this.readNumber(true);\n    }\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n        this.pos += 3;\n        return this.finishToken(types$1.ellipsis);\n    } else {\n        ++this.pos;\n        return this.finishToken(types$1.dot);\n    }\n};\npp.readToken_slash = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) {\n        ++this.pos;\n        return this.readRegexp();\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(types$1.slash, 1);\n};\npp.readToken_mult_modulo_exp = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types$1.star : types$1.modulo;\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n        ++size;\n        tokentype = types$1.starstar;\n        next = this.input.charCodeAt(this.pos + 2);\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, size + 1);\n    }\n    return this.finishOp(tokentype, size);\n};\npp.readToken_pipe_amp = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n        if (this.options.ecmaVersion >= 12) {\n            var next2 = this.input.charCodeAt(this.pos + 2);\n            if (next2 === 61) {\n                return this.finishOp(types$1.assign, 3);\n            }\n        }\n        return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);\n};\npp.readToken_caret = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(types$1.bitwiseXOR, 1);\n};\npp.readToken_plus_min = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n            // A `-->` line comment\n            this.skipLineComment(3);\n            this.skipSpace();\n            return this.nextToken();\n        }\n        return this.finishOp(types$1.incDec, 2);\n    }\n    if (next === 61) {\n        return this.finishOp(types$1.assign, 2);\n    }\n    return this.finishOp(types$1.plusMin, 1);\n};\npp.readToken_lt_gt = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n        if (this.input.charCodeAt(this.pos + size) === 61) {\n            return this.finishOp(types$1.assign, size + 1);\n        }\n        return this.finishOp(types$1.bitShift, size);\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n        // `<!--`, an XML-style comment that should be interpreted as a line comment\n        this.skipLineComment(4);\n        this.skipSpace();\n        return this.nextToken();\n    }\n    if (next === 61) {\n        size = 2;\n    }\n    return this.finishOp(types$1.relational, size);\n};\npp.readToken_eq_excl = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) {\n        return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n    }\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n        this.pos += 2;\n        return this.finishToken(types$1.arrow);\n    }\n    return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);\n};\npp.readToken_question = function() {\n    var ecmaVersion = this.options.ecmaVersion;\n    if (ecmaVersion >= 11) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 46) {\n            var next2 = this.input.charCodeAt(this.pos + 2);\n            if (next2 < 48 || next2 > 57) {\n                return this.finishOp(types$1.questionDot, 2);\n            }\n        }\n        if (next === 63) {\n            if (ecmaVersion >= 12) {\n                var next2$1 = this.input.charCodeAt(this.pos + 2);\n                if (next2$1 === 61) {\n                    return this.finishOp(types$1.assign, 3);\n                }\n            }\n            return this.finishOp(types$1.coalesce, 2);\n        }\n    }\n    return this.finishOp(types$1.question, 1);\n};\npp.readToken_numberSign = function() {\n    var ecmaVersion = this.options.ecmaVersion;\n    var code = 35; // '#'\n    if (ecmaVersion >= 13) {\n        ++this.pos;\n        code = this.fullCharCodeAtPos();\n        if (isIdentifierStart(code, true) || code === 92 /* '\\' */ ) {\n            return this.finishToken(types$1.privateId, this.readWord1());\n        }\n    }\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\npp.getTokenFromCode = function(code) {\n    switch(code){\n        // The interpretation of a dot depends on whether it is followed\n        // by a digit or another two dots.\n        case 46:\n            return this.readToken_dot();\n        // Punctuation tokens.\n        case 40:\n            ++this.pos;\n            return this.finishToken(types$1.parenL);\n        case 41:\n            ++this.pos;\n            return this.finishToken(types$1.parenR);\n        case 59:\n            ++this.pos;\n            return this.finishToken(types$1.semi);\n        case 44:\n            ++this.pos;\n            return this.finishToken(types$1.comma);\n        case 91:\n            ++this.pos;\n            return this.finishToken(types$1.bracketL);\n        case 93:\n            ++this.pos;\n            return this.finishToken(types$1.bracketR);\n        case 123:\n            ++this.pos;\n            return this.finishToken(types$1.braceL);\n        case 125:\n            ++this.pos;\n            return this.finishToken(types$1.braceR);\n        case 58:\n            ++this.pos;\n            return this.finishToken(types$1.colon);\n        case 96:\n            if (this.options.ecmaVersion < 6) {\n                break;\n            }\n            ++this.pos;\n            return this.finishToken(types$1.backQuote);\n        case 48:\n            var next = this.input.charCodeAt(this.pos + 1);\n            if (next === 120 || next === 88) {\n                return this.readRadixNumber(16);\n            } // '0x', '0X' - hex number\n            if (this.options.ecmaVersion >= 6) {\n                if (next === 111 || next === 79) {\n                    return this.readRadixNumber(8);\n                } // '0o', '0O' - octal number\n                if (next === 98 || next === 66) {\n                    return this.readRadixNumber(2);\n                } // '0b', '0B' - binary number\n            }\n        // Anything else beginning with a digit is an integer, octal\n        // number, or float.\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n            return this.readNumber(false);\n        // Quotes produce strings.\n        case 34:\n        case 39:\n            return this.readString(code);\n        // Operators are parsed inline in tiny state machines. '=' (61) is\n        // often referred to. `finishOp` simply skips the amount of\n        // characters it is given as second argument, and returns a token\n        // of the type given by its first argument.\n        case 47:\n            return this.readToken_slash();\n        case 37:\n        case 42:\n            return this.readToken_mult_modulo_exp(code);\n        case 124:\n        case 38:\n            return this.readToken_pipe_amp(code);\n        case 94:\n            return this.readToken_caret();\n        case 43:\n        case 45:\n            return this.readToken_plus_min(code);\n        case 60:\n        case 62:\n            return this.readToken_lt_gt(code);\n        case 61:\n        case 33:\n            return this.readToken_eq_excl(code);\n        case 63:\n            return this.readToken_question();\n        case 126:\n            return this.finishOp(types$1.prefix, 1);\n        case 35:\n            return this.readToken_numberSign();\n    }\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\npp.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str);\n};\npp.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) {\n            this.raise(start, \"Unterminated regular expression\");\n        }\n        var ch = this.input.charAt(this.pos);\n        if (lineBreak.test(ch)) {\n            this.raise(start, \"Unterminated regular expression\");\n        }\n        if (!escaped) {\n            if (ch === \"[\") {\n                inClass = true;\n            } else if (ch === \"]\" && inClass) {\n                inClass = false;\n            } else if (ch === \"/\" && !inClass) {\n                break;\n            }\n            escaped = ch === \"\\\\\";\n        } else {\n            escaped = false;\n        }\n        ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) {\n        this.unexpected(flagsStart);\n    }\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n    // Create Literal#value property value.\n    var value = null;\n    try {\n        value = new RegExp(pattern, flags);\n    } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n    return this.finishToken(types$1.regexp, {\n        pattern: pattern,\n        flags: flags,\n        value: value\n    });\n};\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\npp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n    // `len` is used for character escape sequences. In that case, disallow separators.\n    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n    // and isn't fraction part nor exponent part. In that case, if the first digit\n    // is zero then disallow separators.\n    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n    var start = this.pos, total = 0, lastCode = 0;\n    for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){\n        var code = this.input.charCodeAt(this.pos), val = void 0;\n        if (allowSeparators && code === 95) {\n            if (isLegacyOctalNumericLiteral) {\n                this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\");\n            }\n            if (lastCode === 95) {\n                this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\");\n            }\n            if (i === 0) {\n                this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\");\n            }\n            lastCode = code;\n            continue;\n        }\n        if (code >= 97) {\n            val = code - 97 + 10;\n        } else if (code >= 65) {\n            val = code - 65 + 10;\n        } else if (code >= 48 && code <= 57) {\n            val = code - 48;\n        } else {\n            val = Infinity;\n        }\n        if (val >= radix) {\n            break;\n        }\n        lastCode = code;\n        total = total * radix + val;\n    }\n    if (allowSeparators && lastCode === 95) {\n        this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\");\n    }\n    if (this.pos === start || len != null && this.pos - start !== len) {\n        return null;\n    }\n    return total;\n};\nfunction stringToNumber(str, isLegacyOctalNumericLiteral) {\n    if (isLegacyOctalNumericLiteral) {\n        return parseInt(str, 8);\n    }\n    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n    return parseFloat(str.replace(/_/g, \"\"));\n}\nfunction stringToBigInt(str) {\n    if (typeof BigInt !== \"function\") {\n        return null;\n    }\n    // `BigInt(value)` throws syntax error if the string contains numeric separators.\n    return BigInt(str.replace(/_/g, \"\"));\n}\npp.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) {\n        this.raise(this.start + 2, \"Expected number in radix \" + radix);\n    }\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n        val = stringToBigInt(this.input.slice(start, this.pos));\n        ++this.pos;\n    } else if (isIdentifierStart(this.fullCharCodeAtPos())) {\n        this.raise(this.pos, \"Identifier directly after number\");\n    }\n    return this.finishToken(types$1.num, val);\n};\n// Read an integer, octal integer, or floating-point number.\npp.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10, undefined, true) === null) {\n        this.raise(start, \"Invalid number\");\n    }\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) {\n        this.raise(start, \"Invalid number\");\n    }\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n        var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n        ++this.pos;\n        if (isIdentifierStart(this.fullCharCodeAtPos())) {\n            this.raise(this.pos, \"Identifier directly after number\");\n        }\n        return this.finishToken(types$1.num, val$1);\n    }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) {\n        octal = false;\n    }\n    if (next === 46 && !octal) {\n        ++this.pos;\n        this.readInt(10);\n        next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) {\n        next = this.input.charCodeAt(++this.pos);\n        if (next === 43 || next === 45) {\n            ++this.pos;\n        } // '+-'\n        if (this.readInt(10) === null) {\n            this.raise(start, \"Invalid number\");\n        }\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) {\n        this.raise(this.pos, \"Identifier directly after number\");\n    }\n    var val = stringToNumber(this.input.slice(start, this.pos), octal);\n    return this.finishToken(types$1.num, val);\n};\n// Read a string value, interpreting backslash-escapes.\npp.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n    if (ch === 123) {\n        if (this.options.ecmaVersion < 6) {\n            this.unexpected();\n        }\n        var codePos = ++this.pos;\n        code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n        ++this.pos;\n        if (code > 0x10FFFF) {\n            this.invalidStringToken(codePos, \"Code point out of bounds\");\n        }\n    } else {\n        code = this.readHexChar(4);\n    }\n    return code;\n};\npp.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) {\n            this.raise(this.start, \"Unterminated string constant\");\n        }\n        var ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) {\n            break;\n        }\n        if (ch === 92) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.readEscapedChar(false);\n            chunkStart = this.pos;\n        } else if (ch === 0x2028 || ch === 0x2029) {\n            if (this.options.ecmaVersion < 10) {\n                this.raise(this.start, \"Unterminated string constant\");\n            }\n            ++this.pos;\n            if (this.options.locations) {\n                this.curLine++;\n                this.lineStart = this.pos;\n            }\n        } else {\n            if (isNewLine(ch)) {\n                this.raise(this.start, \"Unterminated string constant\");\n            }\n            ++this.pos;\n        }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types$1.string, out);\n};\n// Reads template string tokens.\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\npp.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n        this.readTmplToken();\n    } catch (err) {\n        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n            this.readInvalidTemplateToken();\n        } else {\n            throw err;\n        }\n    }\n    this.inTemplateElement = false;\n};\npp.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n        throw INVALID_TEMPLATE_ESCAPE_ERROR;\n    } else {\n        this.raise(position, message);\n    }\n};\npp.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) {\n            this.raise(this.start, \"Unterminated template\");\n        }\n        var ch = this.input.charCodeAt(this.pos);\n        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {\n            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n                if (ch === 36) {\n                    this.pos += 2;\n                    return this.finishToken(types$1.dollarBraceL);\n                } else {\n                    ++this.pos;\n                    return this.finishToken(types$1.backQuote);\n                }\n            }\n            out += this.input.slice(chunkStart, this.pos);\n            return this.finishToken(types$1.template, out);\n        }\n        if (ch === 92) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.readEscapedChar(true);\n            chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            ++this.pos;\n            switch(ch){\n                case 13:\n                    if (this.input.charCodeAt(this.pos) === 10) {\n                        ++this.pos;\n                    }\n                case 10:\n                    out += \"\\n\";\n                    break;\n                default:\n                    out += String.fromCharCode(ch);\n                    break;\n            }\n            if (this.options.locations) {\n                ++this.curLine;\n                this.lineStart = this.pos;\n            }\n            chunkStart = this.pos;\n        } else {\n            ++this.pos;\n        }\n    }\n};\n// Reads a template token to search for the end, without validating any escape sequences\npp.readInvalidTemplateToken = function() {\n    for(; this.pos < this.input.length; this.pos++){\n        switch(this.input[this.pos]){\n            case \"\\\\\":\n                ++this.pos;\n                break;\n            case \"$\":\n                if (this.input[this.pos + 1] !== \"{\") {\n                    break;\n                }\n            // falls through\n            case \"`\":\n                return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));\n        }\n    }\n    this.raise(this.start, \"Unterminated template\");\n};\n// Used to read escaped characters\npp.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch(ch){\n        case 110:\n            return \"\\n\" // 'n' -> '\\n'\n            ;\n        case 114:\n            return \"\\r\" // 'r' -> '\\r'\n            ;\n        case 120:\n            return String.fromCharCode(this.readHexChar(2)) // 'x'\n            ;\n        case 117:\n            return codePointToString(this.readCodePoint()) // 'u'\n            ;\n        case 116:\n            return \"\t\" // 't' -> '\\t'\n            ;\n        case 98:\n            return \"\\b\" // 'b' -> '\\b'\n            ;\n        case 118:\n            return \"\\v\" // 'v' -> '\\u000b'\n            ;\n        case 102:\n            return \"\\f\" // 'f' -> '\\f'\n            ;\n        case 13:\n            if (this.input.charCodeAt(this.pos) === 10) {\n                ++this.pos;\n            } // '\\r\\n'\n        case 10:\n            if (this.options.locations) {\n                this.lineStart = this.pos;\n                ++this.curLine;\n            }\n            return \"\";\n        case 56:\n        case 57:\n            if (this.strict) {\n                this.invalidStringToken(this.pos - 1, \"Invalid escape sequence\");\n            }\n            if (inTemplate) {\n                var codePos = this.pos - 1;\n                this.invalidStringToken(codePos, \"Invalid escape sequence in template string\");\n            }\n        default:\n            if (ch >= 48 && ch <= 55) {\n                var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n                var octal = parseInt(octalStr, 8);\n                if (octal > 255) {\n                    octalStr = octalStr.slice(0, -1);\n                    octal = parseInt(octalStr, 8);\n                }\n                this.pos += octalStr.length - 1;\n                ch = this.input.charCodeAt(this.pos);\n                if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n                    this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n                }\n                return String.fromCharCode(octal);\n            }\n            if (isNewLine(ch)) {\n                // Unicode new line characters after \\ get removed from output in both\n                // template literals and strings\n                return \"\";\n            }\n            return String.fromCharCode(ch);\n    }\n};\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\npp.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) {\n        this.invalidStringToken(codePos, \"Bad character escape sequence\");\n    }\n    return n;\n};\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\npp.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while(this.pos < this.input.length){\n        var ch = this.fullCharCodeAtPos();\n        if (isIdentifierChar(ch, astral)) {\n            this.pos += ch <= 0xffff ? 1 : 2;\n        } else if (ch === 92) {\n            this.containsEsc = true;\n            word += this.input.slice(chunkStart, this.pos);\n            var escStart = this.pos;\n            if (this.input.charCodeAt(++this.pos) !== 117) {\n                this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n            }\n            ++this.pos;\n            var esc = this.readCodePoint();\n            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {\n                this.invalidStringToken(escStart, \"Invalid Unicode escape\");\n            }\n            word += codePointToString(esc);\n            chunkStart = this.pos;\n        } else {\n            break;\n        }\n        first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos);\n};\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\npp.readWord = function() {\n    var word = this.readWord1();\n    var type = types$1.name;\n    if (this.keywords.test(word)) {\n        type = keywords[word];\n    }\n    return this.finishToken(type, word);\n};\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// [walk]: util/walk.js\nvar version = \"8.10.0\";\nParser.acorn = {\n    Parser: Parser,\n    version: version,\n    defaultOptions: defaultOptions,\n    Position: Position,\n    SourceLocation: SourceLocation,\n    getLineInfo: getLineInfo,\n    Node: Node,\n    TokenType: TokenType,\n    tokTypes: types$1,\n    keywordTypes: keywords,\n    TokContext: TokContext,\n    tokContexts: types,\n    isIdentifierChar: isIdentifierChar,\n    isIdentifierStart: isIdentifierStart,\n    Token: Token,\n    isNewLine: isNewLine,\n    lineBreak: lineBreak,\n    lineBreakG: lineBreakG,\n    nonASCIIwhitespace: nonASCIIwhitespace\n};\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\nfunction parse(input, options) {\n    return Parser.parse(input, options);\n}\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\nfunction parseExpressionAt(input, pos, options) {\n    return Parser.parseExpressionAt(input, pos, options);\n}\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\nfunction tokenizer(input, options) {\n    return Parser.tokenizer(input, options);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1EQUFtRDtBQUNuRCxJQUFJQSx3QkFBd0I7SUFBQztJQUFLO0lBQUc7SUFBSztJQUFHO0lBQUs7SUFBRztJQUFLO0lBQUc7SUFBTTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBSztJQUFJO0lBQUs7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFLO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUs7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFNO0lBQUc7SUFBRztJQUFJO0lBQU87SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBTTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFPO0lBQUc7SUFBTTtJQUFJO0lBQUc7SUFBSTtJQUFLO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUs7SUFBRztJQUFNO0lBQUk7SUFBSztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBTTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFLO0lBQUc7SUFBSztJQUFHO0lBQUk7SUFBRztJQUFLO0lBQUc7SUFBSTtJQUFJO0lBQUs7SUFBSTtJQUFLO0lBQUc7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFNO0lBQUc7SUFBUTtDQUFJO0FBRTVoQyxtREFBbUQ7QUFDbkQsSUFBSUMsNkJBQTZCO0lBQUM7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFLO0lBQUk7SUFBSTtJQUFLO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFLO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSztJQUFJO0lBQUs7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFLO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFLO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSztJQUFHO0lBQUk7SUFBSztJQUFLO0lBQUs7SUFBSTtJQUFLO0lBQU07SUFBSTtJQUFJO0lBQU07SUFBSTtJQUFHO0lBQU07SUFBSztJQUFNO0lBQUs7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUs7SUFBSTtJQUFLO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBTTtJQUFHO0lBQU07SUFBSTtJQUFHO0lBQU07SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFLO0lBQU07SUFBSztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFNO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7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QTtJQUNYQyxZQUFZQTtJQUNaUSxvQkFBb0JBO0FBQ3RCO0FBRUEsOERBQThEO0FBQzlELDhEQUE4RDtBQUM5RCxrRUFBa0U7QUFDbEUsYUFBYTtBQUNiLEVBQUU7QUFDRiwwRUFBMEU7QUFFMUUsU0FBU3dJLE1BQU0zRyxLQUFLLEVBQUVuSCxPQUFPO0lBQzNCLE9BQU9nTCxPQUFPOEMsS0FBSyxDQUFDM0csT0FBT25IO0FBQzdCO0FBRUEsOERBQThEO0FBQzlELGdFQUFnRTtBQUNoRSxxQ0FBcUM7QUFFckMsU0FBU2dQLGtCQUFrQjdILEtBQUssRUFBRTVJLEdBQUcsRUFBRXlCLE9BQU87SUFDNUMsT0FBT2dMLE9BQU9nRSxpQkFBaUIsQ0FBQzdILE9BQU81SSxLQUFLeUI7QUFDOUM7QUFFQSxvRUFBb0U7QUFDcEUsaUVBQWlFO0FBRWpFLFNBQVNtUCxVQUFVaEksS0FBSyxFQUFFbkgsT0FBTztJQUMvQixPQUFPZ0wsT0FBT21FLFNBQVMsQ0FBQ2hJLE9BQU9uSDtBQUNqQztBQUUyVCIsInNvdXJjZXMiOlsid2VicGFjazovL292ZXJyZWFjdGVkLy4vbm9kZV9tb2R1bGVzL2Fjb3JuL2Rpc3QvYWNvcm4ubWpzPzA4NjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG52YXIgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwgMCwgMjI3LCAwLCAxNTAsIDQsIDI5NCwgOSwgMTM2OCwgMiwgMiwgMSwgNiwgMywgNDEsIDIsIDUsIDAsIDE2NiwgMSwgNTc0LCAzLCA5LCA5LCAzNzAsIDEsIDgxLCAyLCA3MSwgMTAsIDUwLCAzLCAxMjMsIDIsIDU0LCAxNCwgMzIsIDEwLCAzLCAxLCAxMSwgMywgNDYsIDEwLCA4LCAwLCA0NiwgOSwgNywgMiwgMzcsIDEzLCAyLCA5LCA2LCAxLCA0NSwgMCwgMTMsIDIsIDQ5LCAxMywgOSwgMywgMiwgMTEsIDgzLCAxMSwgNywgMCwgMywgMCwgMTU4LCAxMSwgNiwgOSwgNywgMywgNTYsIDEsIDIsIDYsIDMsIDEsIDMsIDIsIDEwLCAwLCAxMSwgMSwgMywgNiwgNCwgNCwgMTkzLCAxNywgMTAsIDksIDUsIDAsIDgyLCAxOSwgMTMsIDksIDIxNCwgNiwgMywgOCwgMjgsIDEsIDgzLCAxNiwgMTYsIDksIDgyLCAxMiwgOSwgOSwgODQsIDE0LCA1LCA5LCAyNDMsIDE0LCAxNjYsIDksIDcxLCA1LCAyLCAxLCAzLCAzLCAyLCAwLCAyLCAxLCAxMywgOSwgMTIwLCA2LCAzLCA2LCA0LCAwLCAyOSwgOSwgNDEsIDYsIDIsIDMsIDksIDAsIDEwLCAxMCwgNDcsIDE1LCA0MDYsIDcsIDIsIDcsIDE3LCA5LCA1NywgMjEsIDIsIDEzLCAxMjMsIDUsIDQsIDAsIDIsIDEsIDIsIDYsIDIsIDAsIDksIDksIDQ5LCA0LCAyLCAxLCAyLCA0LCA5LCA5LCAzMzAsIDMsIDEwLCAxLCAyLCAwLCA0OSwgNiwgNCwgNCwgMTQsIDksIDUzNTEsIDAsIDcsIDE0LCAxMzgzNSwgOSwgODcsIDksIDM5LCA0LCA2MCwgNiwgMjYsIDksIDEwMTQsIDAsIDIsIDU0LCA4LCAzLCA4MiwgMCwgMTIsIDEsIDE5NjI4LCAxLCA0NzA2LCA0NSwgMywgMjIsIDU0MywgNCwgNCwgNSwgOSwgNywgMywgNiwgMzEsIDMsIDE0OSwgMiwgMTQxOCwgNDksIDUxMywgNTQsIDUsIDQ5LCA5LCAwLCAxNSwgMCwgMjMsIDQsIDIsIDE0LCAxMzYxLCA2LCAyLCAxNiwgMywgNiwgMiwgMSwgMiwgNCwgMTAxLCAwLCAxNjEsIDYsIDEwLCA5LCAzNTcsIDAsIDYyLCAxMywgNDk5LCAxMywgOTgzLCA2LCAxMTAsIDYsIDYsIDksIDQ3NTksIDksIDc4NzcxOSwgMjM5XTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQuIERvIG5vdCBtb2RpZnkgbWFudWFsbHkhXG52YXIgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMgPSBbMCwgMTEsIDIsIDI1LCAyLCAxOCwgMiwgMSwgMiwgMTQsIDMsIDEzLCAzNSwgMTIyLCA3MCwgNTIsIDI2OCwgMjgsIDQsIDQ4LCA0OCwgMzEsIDE0LCAyOSwgNiwgMzcsIDExLCAyOSwgMywgMzUsIDUsIDcsIDIsIDQsIDQzLCAxNTcsIDE5LCAzNSwgNSwgMzUsIDUsIDM5LCA5LCA1MSwgMTMsIDEwLCAyLCAxNCwgMiwgNiwgMiwgMSwgMiwgMTAsIDIsIDE0LCAyLCA2LCAyLCAxLCA2OCwgMzEwLCAxMCwgMjEsIDExLCA3LCAyNSwgNSwgMiwgNDEsIDIsIDgsIDcwLCA1LCAzLCAwLCAyLCA0MywgMiwgMSwgNCwgMCwgMywgMjIsIDExLCAyMiwgMTAsIDMwLCA2NiwgMTgsIDIsIDEsIDExLCAyMSwgMTEsIDI1LCA3MSwgNTUsIDcsIDEsIDY1LCAwLCAxNiwgMywgMiwgMiwgMiwgMjgsIDQzLCAyOCwgNCwgMjgsIDM2LCA3LCAyLCAyNywgMjgsIDUzLCAxMSwgMjEsIDExLCAxOCwgMTQsIDE3LCAxMTEsIDcyLCA1NiwgNTAsIDE0LCA1MCwgMTQsIDM1LCAzNDksIDQxLCA3LCAxLCA3OSwgMjgsIDExLCAwLCA5LCAyMSwgNDMsIDE3LCA0NywgMjAsIDI4LCAyMiwgMTMsIDUyLCA1OCwgMSwgMywgMCwgMTQsIDQ0LCAzMywgMjQsIDI3LCAzNSwgMzAsIDAsIDMsIDAsIDksIDM0LCA0LCAwLCAxMywgNDcsIDE1LCAzLCAyMiwgMCwgMiwgMCwgMzYsIDE3LCAyLCAyNCwgMjAsIDEsIDY0LCA2LCAyLCAwLCAyLCAzLCAyLCAxNCwgMiwgOSwgOCwgNDYsIDM5LCA3LCAzLCAxLCAzLCAyMSwgMiwgNiwgMiwgMSwgMiwgNCwgNCwgMCwgMTksIDAsIDEzLCA0LCAxNTksIDUyLCAxOSwgMywgMjEsIDIsIDMxLCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDE0LCAwLCA3MiwgMjYsIDM4LCA2LCAxODYsIDQzLCAxMTcsIDYzLCAzMiwgNywgMywgMCwgMywgNywgMiwgMSwgMiwgMjMsIDE2LCAwLCAyLCAwLCA5NSwgNywgMywgMzgsIDE3LCAwLCAyLCAwLCAyOSwgMCwgMTEsIDM5LCA4LCAwLCAyMiwgMCwgMTIsIDQ1LCAyMCwgMCwgMTksIDcyLCAyNjQsIDgsIDIsIDM2LCAxOCwgMCwgNTAsIDI5LCAxMTMsIDYsIDIsIDEsIDIsIDM3LCAyMiwgMCwgMjYsIDUsIDIsIDEsIDIsIDMxLCAxNSwgMCwgMzI4LCAxOCwgMTYsIDAsIDIsIDEyLCAyLCAzMywgMTI1LCAwLCA4MCwgOTIxLCAxMDMsIDExMCwgMTgsIDE5NSwgMjYzNywgOTYsIDE2LCAxMDcxLCAxOCwgNSwgNDAyNiwgNTgyLCA4NjM0LCA1NjgsIDgsIDMwLCAxOCwgNzgsIDE4LCAyOSwgMTksIDQ3LCAxNywgMywgMzIsIDIwLCA2LCAxOCwgNjg5LCA2MywgMTI5LCA3NCwgNiwgMCwgNjcsIDEyLCA2NSwgMSwgMiwgMCwgMjksIDYxMzUsIDksIDEyMzcsIDQzLCA4LCA4OTM2LCAzLCAyLCA2LCAyLCAxLCAyLCAyOTAsIDE2LCAwLCAzMCwgMiwgMywgMCwgMTUsIDMsIDksIDM5NSwgMjMwOSwgMTA2LCA2LCAxMiwgNCwgOCwgOCwgOSwgNTk5MSwgODQsIDIsIDcwLCAyLCAxLCAzLCAwLCAzLCAxLCAzLCAzLCAyLCAxMSwgMiwgMCwgMiwgNiwgMiwgNjQsIDIsIDMsIDMsIDcsIDIsIDYsIDIsIDI3LCAyLCAzLCAyLCA0LCAyLCAwLCA0LCA2LCAyLCAzMzksIDMsIDI0LCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCA3LCAxODQ1LCAzMCwgNywgNSwgMjYyLCA2MSwgMTQ3LCA0NCwgMTEsIDYsIDE3LCAwLCAzMjIsIDI5LCAxOSwgNDMsIDQ4NSwgMjcsIDc1NywgNiwgMiwgMywgMiwgMSwgMiwgMTQsIDIsIDE5NiwgNjAsIDY3LCA4LCAwLCAxMjA1LCAzLCAyLCAyNiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgOSwgMiwgMywgMiwgMCwgMiwgMCwgNywgMCwgNSwgMCwgMiwgMCwgMiwgMCwgMiwgMiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMSwgMiwgMCwgMywgMywgMiwgNiwgMiwgMywgMiwgMywgMiwgMCwgMiwgOSwgMiwgMTYsIDYsIDIsIDIsIDQsIDIsIDE2LCA0NDIxLCA0MjcxOSwgMzMsIDQxNTMsIDcsIDIyMSwgMywgNTc2MSwgMTUsIDc0NzIsIDMxMDQsIDU0MSwgMTUwNywgNDkzOCwgNiwgNDE5MV07XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkLiBEbyBub3QgbW9kaWZ5IG1hbnVhbGx5IVxudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5OC1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjNcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZVxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhY2VcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZC4gRG8gbm90IG1vZGlmeSBtYW51YWxseSFcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4NzAtXFx1MDg4N1xcdTA4ODktXFx1MDg4ZVxcdTA4YTAtXFx1MDhjOVxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzVkXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3Y2FcXHVhN2QwXFx1YTdkMVxcdWE3ZDNcXHVhN2Q1LVxcdWE3ZDlcXHVhN2YyLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5cbi8vIFRoZXNlIGFyZSBhIHJ1bi1sZW5ndGggYW5kIG9mZnNldCBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuLy8gPjB4ZmZmZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBhIHZhbGlkIHBhcnQgb2YgaWRlbnRpZmllcnMuIFRoZVxuLy8gb2Zmc2V0IHN0YXJ0cyBhdCAweDEwMDAwLCBhbmQgZWFjaCBwYWlyIG9mIG51bWJlcnMgcmVwcmVzZW50cyBhblxuLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IHJhbmdlLCBhbmQgdGhlbiBhIHNpemUgb2YgdGhlIHJhbmdlLlxuXG4vLyBSZXNlcnZlZCB3b3JkIGxpc3RzIGZvciB2YXJpb3VzIGRpYWxlY3RzIG9mIHRoZSBsYW5ndWFnZVxuXG52YXIgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gIDU6IFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIixcbiAgNjogXCJlbnVtXCIsXG4gIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gIHN0cmljdEJpbmQ6IFwiZXZhbCBhcmd1bWVudHNcIlxufTtcblxuLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG52YXIgZWNtYTVBbmRMZXNzS2V5d29yZHMgPSBcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiO1xuXG52YXIga2V5d29yZHMkMSA9IHtcbiAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gIFwiNW1vZHVsZVwiOiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGV4cG9ydCBpbXBvcnRcIixcbiAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXJcIlxufTtcblxudmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuLy8gVGhpcyBoYXMgYSBjb21wbGV4aXR5IGxpbmVhciB0byB0aGUgdmFsdWUgb2YgdGhlIGNvZGUuIFRoZVxuLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuLy8gcmFyZS5cbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIHZhciBwb3MgPSAweDEwMDAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHBvcyArPSBzZXRbaV07XG4gICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICBpZiAocG9zID49IGNvZGUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2Rlcylcbn1cblxuLy8gIyMgVG9rZW4gdHlwZXNcblxuLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbi8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuLy8gdG9rZW4gaW4gYSB3YXkgdGhhdCBpcyB2ZXJ5IGNoZWFwIGZvciB0aGUgcGFyc2VyIHRvIGxvb2sgdXAuXG5cbi8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbi8vIFRoZSBgYmVmb3JlRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiByZWd1bGFyXG4vLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4vLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuLy8gcmVndWxhciBleHByZXNzaW9uKS5cbi8vXG4vLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuLy8gYHlpZWxkYCBleHByZXNzaW9uLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgZWl0aGVyIGNhblxuLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbi8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuLy9cbi8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbi8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbnZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxufVxudmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cbi8vIE1hcCBrZXl3b3JkIG5hbWVzIHRvIHRva2VuIHR5cGVzLlxuXG52YXIga2V5d29yZHMgPSB7fTtcblxuLy8gU3VjY2luY3QgZGVmaW5pdGlvbnMgb2Yga2V5d29yZCB0b2tlbiB0eXBlc1xuZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuICByZXR1cm4ga2V5d29yZHNbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG59XG5cbnZhciB0eXBlcyQxID0ge1xuICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHN0YXJ0c0V4cHIpLFxuICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgcHJpdmF0ZUlkOiBuZXcgVG9rZW5UeXBlKFwicHJpdmF0ZUlkXCIsIHN0YXJ0c0V4cHIpLFxuICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gIGJyYWNrZXRMOiBuZXcgVG9rZW5UeXBlKFwiW1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICBjb21tYTogbmV3IFRva2VuVHlwZShcIixcIiwgYmVmb3JlRXhwciksXG4gIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gIGRvdDogbmV3IFRva2VuVHlwZShcIi5cIiksXG4gIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgcXVlc3Rpb25Eb3Q6IG5ldyBUb2tlblR5cGUoXCI/LlwiKSxcbiAgYXJyb3c6IG5ldyBUb2tlblR5cGUoXCI9PlwiLCBiZWZvcmVFeHByKSxcbiAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgaW52YWxpZFRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwiaW52YWxpZFRlbXBsYXRlXCIpLFxuICBlbGxpcHNpczogbmV3IFRva2VuVHlwZShcIi4uLlwiLCBiZWZvcmVFeHByKSxcbiAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcblxuICAvLyBPcGVyYXRvcnMuIFRoZXNlIGNhcnJ5IHNldmVyYWwga2luZHMgb2YgcHJvcGVydGllcyB0byBoZWxwIHRoZVxuICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gIC8vIHdoYXQgY2F0ZWdvcml6ZXMgdGhlbSBhcyBvcGVyYXRvcnMpLlxuICAvL1xuICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgLy8gb3BlcmF0b3IsIGFuZCB3aWxsIHJlZmVyIHRvIGl0cyBwcmVjZWRlbmNlLlxuICAvL1xuICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgLy8gdW5hcnkgb3BlcmF0b3IuXG4gIC8vXG4gIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gIC8vIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCBhIHZlcnkgbG93IHByZWNlZGVuY2UsIHRoYXQgc2hvdWxkIHJlc3VsdFxuICAvLyBpbiBBc3NpZ25tZW50RXhwcmVzc2lvbiBub2Rlcy5cblxuICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICBpbmNEZWM6IG5ldyBUb2tlblR5cGUoXCIrKy8tLVwiLCB7cHJlZml4OiB0cnVlLCBwb3N0Zml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIHByZWZpeDogbmV3IFRva2VuVHlwZShcIiEvflwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGxvZ2ljYWxPUjogYmlub3AoXCJ8fFwiLCAxKSxcbiAgbG9naWNhbEFORDogYmlub3AoXCImJlwiLCAyKSxcbiAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gIGJpdHdpc2VYT1I6IGJpbm9wKFwiXlwiLCA0KSxcbiAgYml0d2lzZUFORDogYmlub3AoXCImXCIsIDUpLFxuICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPS89PT0vIT09XCIsIDYpLFxuICByZWxhdGlvbmFsOiBiaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgYml0U2hpZnQ6IGJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIG1vZHVsbzogYmlub3AoXCIlXCIsIDEwKSxcbiAgc3RhcjogYmlub3AoXCIqXCIsIDEwKSxcbiAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gIHN0YXJzdGFyOiBuZXcgVG9rZW5UeXBlKFwiKipcIiwge2JlZm9yZUV4cHI6IHRydWV9KSxcbiAgY29hbGVzY2U6IGJpbm9wKFwiPz9cIiwgMSksXG5cbiAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgX2JyZWFrOiBrdyhcImJyZWFrXCIpLFxuICBfY2FzZToga3coXCJjYXNlXCIsIGJlZm9yZUV4cHIpLFxuICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gIF9jb250aW51ZToga3coXCJjb250aW51ZVwiKSxcbiAgX2RlYnVnZ2VyOiBrdyhcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICBfZG86IGt3KFwiZG9cIiwge2lzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0pLFxuICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICBfZm9yOiBrdyhcImZvclwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF9mdW5jdGlvbjoga3coXCJmdW5jdGlvblwiLCBzdGFydHNFeHByKSxcbiAgX2lmOiBrdyhcImlmXCIpLFxuICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgX3N3aXRjaDoga3coXCJzd2l0Y2hcIiksXG4gIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgX3RyeToga3coXCJ0cnlcIiksXG4gIF92YXI6IGt3KFwidmFyXCIpLFxuICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gIF93aGlsZToga3coXCJ3aGlsZVwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF93aXRoOiBrdyhcIndpdGhcIiksXG4gIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF90aGlzOiBrdyhcInRoaXNcIiwgc3RhcnRzRXhwciksXG4gIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgX2NsYXNzOiBrdyhcImNsYXNzXCIsIHN0YXJ0c0V4cHIpLFxuICBfZXh0ZW5kczoga3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpLFxuICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiwgc3RhcnRzRXhwciksXG4gIF9udWxsOiBrdyhcIm51bGxcIiwgc3RhcnRzRXhwciksXG4gIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgX2luOiBrdyhcImluXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfaW5zdGFuY2VvZjoga3coXCJpbnN0YW5jZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF92b2lkOiBrdyhcInZvaWRcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfZGVsZXRlOiBrdyhcImRlbGV0ZVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSlcbn07XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG52YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG52YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiBpc05ld0xpbmUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT09IDB4MjAyOVxufVxuXG5mdW5jdGlvbiBuZXh0TGluZUJyZWFrKGNvZGUsIGZyb20sIGVuZCkge1xuICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gY29kZS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IGZyb207IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciBuZXh0ID0gY29kZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpc05ld0xpbmUobmV4dCkpXG4gICAgICB7IHJldHVybiBpIDwgZW5kIC0gMSAmJiBuZXh0ID09PSAxMyAmJiBjb2RlLmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCA/IGkgKyAyIDogaSArIDEgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuXG52YXIgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcblxudmFyIHJlZiA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSByZWYudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBPYmplY3QuaGFzT3duIHx8IChmdW5jdGlvbiAob2JqLCBwcm9wTmFtZSkgeyByZXR1cm4gKFxuICBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcE5hbWUpXG4pOyB9KTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4pOyB9KTtcblxuZnVuY3Rpb24gd29yZHNSZWdleHAod29yZHMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB3b3Jkcy5yZXBsYWNlKC8gL2csIFwifFwiKSArIFwiKSRcIilcbn1cblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmcoY29kZSkge1xuICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgY29kZSAtPSAweDEwMDAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG59XG5cbnZhciBsb25lU3Vycm9nYXRlID0gLyg/OltcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKS87XG5cbi8vIFRoZXNlIGFyZSB1c2VkIHdoZW4gYG9wdGlvbnMubG9jYXRpb25zYCBpcyBvbiwgZm9yIHRoZVxuLy8gYHN0YXJ0TG9jYCBhbmQgYGVuZExvY2AgcHJvcGVydGllcy5cblxudmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gIHRoaXMubGluZSA9IGxpbmU7XG4gIHRoaXMuY29sdW1uID0gY29sO1xufTtcblxuUG9zaXRpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCAobikge1xuICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxufTtcblxudmFyIFNvdXJjZUxvY2F0aW9uID0gZnVuY3Rpb24gU291cmNlTG9jYXRpb24ocCwgc3RhcnQsIGVuZCkge1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuZW5kID0gZW5kO1xuICBpZiAocC5zb3VyY2VGaWxlICE9PSBudWxsKSB7IHRoaXMuc291cmNlID0gcC5zb3VyY2VGaWxlOyB9XG59O1xuXG4vLyBUaGUgYGdldExpbmVJbmZvYCBmdW5jdGlvbiBpcyBtb3N0bHkgdXNlZnVsIHdoZW4gdGhlXG4vLyBgbG9jYXRpb25zYCBvcHRpb24gaXMgb2ZmIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykgYW5kIHlvdVxuLy8gd2FudCB0byBmaW5kIHRoZSBsaW5lL2NvbHVtbiBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbi8vIG9mZnNldC4gYGlucHV0YCBzaG91bGQgYmUgdGhlIGNvZGUgc3RyaW5nIHRoYXQgdGhlIG9mZnNldCByZWZlcnNcbi8vIGludG8uXG5cbmZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgZm9yICh2YXIgbGluZSA9IDEsIGN1ciA9IDA7Oykge1xuICAgIHZhciBuZXh0QnJlYWsgPSBuZXh0TGluZUJyZWFrKGlucHV0LCBjdXIsIG9mZnNldCk7XG4gICAgaWYgKG5leHRCcmVhayA8IDApIHsgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBjdXIpIH1cbiAgICArK2xpbmU7XG4gICAgY3VyID0gbmV4dEJyZWFrO1xuICB9XG59XG5cbi8vIEEgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgZ2l2ZW4gdG8gY29uZmlndXJlIHRoZSBwYXJzZXIgcHJvY2Vzcy5cbi8vIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQgKG9ubHkgYGVjbWFWZXJzaW9uYCBpcyByZXF1aXJlZCk6XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdCBiZVxuICAvLyBlaXRoZXIgMywgNSwgNiAob3IgMjAxNSksIDcgKDIwMTYpLCA4ICgyMDE3KSwgOSAoMjAxOCksIDEwXG4gIC8vICgyMDE5KSwgMTEgKDIwMjApLCAxMiAoMjAyMSksIDEzICgyMDIyKSwgMTQgKDIwMjMpLCBvciBgXCJsYXRlc3RcImBcbiAgLy8gKHRoZSBsYXRlc3QgdmVyc2lvbiB0aGUgbGlicmFyeSBzdXBwb3J0cykuIFRoaXMgaW5mbHVlbmNlc1xuICAvLyBzdXBwb3J0IGZvciBzdHJpY3QgbW9kZSwgdGhlIHNldCBvZiByZXNlcnZlZCB3b3JkcywgYW5kIHN1cHBvcnRcbiAgLy8gZm9yIG5ldyBzeW50YXggZmVhdHVyZXMuXG4gIGVjbWFWZXJzaW9uOiBudWxsLFxuICAvLyBgc291cmNlVHlwZWAgaW5kaWNhdGVzIHRoZSBtb2RlIHRoZSBjb2RlIHNob3VsZCBiZSBwYXJzZWQgaW4uXG4gIC8vIENhbiBiZSBlaXRoZXIgYFwic2NyaXB0XCJgIG9yIGBcIm1vZHVsZVwiYC4gVGhpcyBpbmZsdWVuY2VzIGdsb2JhbFxuICAvLyBzdHJpY3QgbW9kZSBhbmQgcGFyc2luZyBvZiBgaW1wb3J0YCBhbmQgYGV4cG9ydGAgZGVjbGFyYXRpb25zLlxuICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAvLyBgb25JbnNlcnRlZFNlbWljb2xvbmAgY2FuIGJlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZFxuICAvLyB3aGVuIGEgc2VtaWNvbG9uIGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQuIEl0IHdpbGwgYmUgcGFzc2VkXG4gIC8vIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29tbWEgYXMgYW4gb2Zmc2V0LCBhbmQgaWYgYGxvY2F0aW9uc2AgaXNcbiAgLy8gZW5hYmxlZCwgaXQgaXMgZ2l2ZW4gdGhlIGxvY2F0aW9uIGFzIGEgYHtsaW5lLCBjb2x1bW59YCBvYmplY3RcbiAgLy8gYXMgc2Vjb25kIGFyZ3VtZW50LlxuICBvbkluc2VydGVkU2VtaWNvbG9uOiBudWxsLFxuICAvLyBgb25UcmFpbGluZ0NvbW1hYCBpcyBzaW1pbGFyIHRvIGBvbkluc2VydGVkU2VtaWNvbG9uYCwgYnV0IGZvclxuICAvLyB0cmFpbGluZyBjb21tYXMuXG4gIG9uVHJhaWxpbmdDb21tYTogbnVsbCxcbiAgLy8gQnkgZGVmYXVsdCwgcmVzZXJ2ZWQgd29yZHMgYXJlIG9ubHkgZW5mb3JjZWQgaWYgZWNtYVZlcnNpb24gPj0gNS5cbiAgLy8gU2V0IGBhbGxvd1Jlc2VydmVkYCB0byBhIGJvb2xlYW4gdmFsdWUgdG8gZXhwbGljaXRseSB0dXJuIHRoaXMgb25cbiAgLy8gYW4gb2ZmLiBXaGVuIHRoaXMgb3B0aW9uIGhhcyB0aGUgdmFsdWUgXCJuZXZlclwiLCByZXNlcnZlZCB3b3Jkc1xuICAvLyBhbmQga2V5d29yZHMgY2FuIGFsc28gbm90IGJlIHVzZWQgYXMgcHJvcGVydHkgbmFtZXMuXG4gIGFsbG93UmVzZXJ2ZWQ6IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgYSByZXR1cm4gYXQgdGhlIHRvcCBsZXZlbCBpcyBub3QgY29uc2lkZXJlZCBhblxuICAvLyBlcnJvci5cbiAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAvLyBXaGVuIGVuYWJsZWQsIGltcG9ydC9leHBvcnQgc3RhdGVtZW50cyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gIC8vIGFwcGVhcmluZyBhdCB0aGUgdG9wIG9mIHRoZSBwcm9ncmFtLCBhbmQgYW4gaW1wb3J0Lm1ldGEgZXhwcmVzc2lvblxuICAvLyBpbiBhIHNjcmlwdCBpc24ndCBjb25zaWRlcmVkIGFuIGVycm9yLlxuICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IGZhbHNlLFxuICAvLyBCeSBkZWZhdWx0LCBhd2FpdCBpZGVudGlmaWVycyBhcmUgYWxsb3dlZCB0byBhcHBlYXIgYXQgdGhlIHRvcC1sZXZlbCBzY29wZSBvbmx5IGlmIGVjbWFWZXJzaW9uID49IDIwMjIuXG4gIC8vIFdoZW4gZW5hYmxlZCwgYXdhaXQgaWRlbnRpZmllcnMgYXJlIGFsbG93ZWQgdG8gYXBwZWFyIGF0IHRoZSB0b3AtbGV2ZWwgc2NvcGUsXG4gIC8vIGJ1dCB0aGV5IGFyZSBzdGlsbCBub3QgYWxsb3dlZCBpbiBub24tYXN5bmMgZnVuY3Rpb25zLlxuICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIHN1cGVyIGlkZW50aWZpZXJzIGFyZSBub3QgY29uc3RyYWluZWQgdG9cbiAgLy8gYXBwZWFyaW5nIGluIG1ldGhvZHMgYW5kIGRvIG5vdCByYWlzZSBhbiBlcnJvciB3aGVuIHRoZXkgYXBwZWFyIGVsc2V3aGVyZS5cbiAgYWxsb3dTdXBlck91dHNpZGVNZXRob2Q6IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgaGFzaGJhbmcgZGlyZWN0aXZlIGluIHRoZSBiZWdpbm5pbmcgb2YgZmlsZSBpc1xuICAvLyBhbGxvd2VkIGFuZCB0cmVhdGVkIGFzIGEgbGluZSBjb21tZW50LiBFbmFibGVkIGJ5IGRlZmF1bHQgd2hlblxuICAvLyBgZWNtYVZlcnNpb25gID49IDIwMjMuXG4gIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAvLyBCeSBkZWZhdWx0LCB0aGUgcGFyc2VyIHdpbGwgdmVyaWZ5IHRoYXQgcHJpdmF0ZSBwcm9wZXJ0aWVzIGFyZVxuICAvLyBvbmx5IHVzZWQgaW4gcGxhY2VzIHdoZXJlIHRoZXkgYXJlIHZhbGlkIGFuZCBoYXZlIGJlZW4gZGVjbGFyZWQuXG4gIC8vIFNldCB0aGlzIHRvIGZhbHNlIHRvIHR1cm4gc3VjaCBjaGVja3Mgb2ZmLlxuICBjaGVja1ByaXZhdGVGaWVsZHM6IHRydWUsXG4gIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIGBsb2NgIHByb3BlcnRpZXMgaG9sZGluZyBvYmplY3RzIHdpdGhcbiAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyBpbiBge2xpbmUsIGNvbHVtbn1gIGZvcm0gKHdpdGhcbiAgLy8gbGluZSBiZWluZyAxLWJhc2VkIGFuZCBjb2x1bW4gMC1iYXNlZCkgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGVcbiAgLy8gbm9kZXMuXG4gIGxvY2F0aW9uczogZmFsc2UsXG4gIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Ub2tlbmAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIG9iamVjdCBpbiB0aGUgc2FtZVxuICAvLyBmb3JtYXQgYXMgdG9rZW5zIHJldHVybmVkIGZyb20gYHRva2VuaXplcigpLmdldFRva2VuKClgLiBOb3RlXG4gIC8vIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZSBwYXJzZXIgZnJvbSB0aGVcbiAgLy8gY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gIG9uVG9rZW46IG51bGwsXG4gIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Db21tZW50YCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggYChibG9jaywgdGV4dCwgc3RhcnQsXG4gIC8vIGVuZClgIHBhcmFtZXRlcnMgd2hlbmV2ZXIgYSBjb21tZW50IGlzIHNraXBwZWQuIGBibG9ja2AgaXMgYVxuICAvLyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGlzIGEgYmxvY2sgKGAvKiAqL2ApIGNvbW1lbnQsXG4gIC8vIGB0ZXh0YCBpcyB0aGUgY29udGVudCBvZiB0aGUgY29tbWVudCwgYW5kIGBzdGFydGAgYW5kIGBlbmRgIGFyZVxuICAvLyBjaGFyYWN0ZXIgb2Zmc2V0cyB0aGF0IGRlbm90ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgY29tbWVudC5cbiAgLy8gV2hlbiB0aGUgYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9uLCB0d28gbW9yZSBwYXJhbWV0ZXJzIGFyZVxuICAvLyBwYXNzZWQsIHRoZSBmdWxsIGB7bGluZSwgY29sdW1ufWAgbG9jYXRpb25zIG9mIHRoZSBzdGFydCBhbmRcbiAgLy8gZW5kIG9mIHRoZSBjb21tZW50cy4gTm90ZSB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGVcbiAgLy8gcGFyc2VyIGZyb20gdGhlIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvbkNvbW1lbnQ6IG51bGwsXG4gIC8vIE5vZGVzIGhhdmUgdGhlaXIgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXJzIG9mZnNldHMgcmVjb3JkZWQgaW5cbiAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyAoZGlyZWN0bHkgb24gdGhlIG5vZGUsIHJhdGhlciB0aGFuXG4gIC8vIHRoZSBgbG9jYCBvYmplY3QsIHdoaWNoIGhvbGRzIGxpbmUvY29sdW1uIGRhdGEuIFRvIGFsc28gYWRkIGFcbiAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgLy8gZW5kXWAgYXJyYXkgd2l0aCB0aGUgc2FtZSBudW1iZXJzLCBzZXQgdGhlIGByYW5nZXNgIG9wdGlvbiB0b1xuICAvLyBgdHJ1ZWAuXG4gIC8vXG4gIC8vIFtyYW5nZV06IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc0NTY3OFxuICByYW5nZXM6IGZhbHNlLFxuICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAvLyBwYXNzaW5nIHRoZSB0cmVlIHByb2R1Y2VkIGJ5IHBhcnNpbmcgdGhlIGZpcnN0IGZpbGUgYXNcbiAgLy8gYHByb2dyYW1gIG9wdGlvbiBpbiBzdWJzZXF1ZW50IHBhcnNlcy4gVGhpcyB3aWxsIGFkZCB0aGVcbiAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAvLyBvZiBhbiBleGlzdGluZyBwYXJzZSB0cmVlLlxuICBwcm9ncmFtOiBudWxsLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAvLyBmaWxlIGluIGV2ZXJ5IG5vZGUncyBgbG9jYCBvYmplY3QuXG4gIHNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAvLyBgbG9jYXRpb25zYCBpcyBvbiBvciBvZmYuXG4gIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgLy8gKG5vbi1zdGFuZGFyZCkgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gbm9kZXNcbiAgcHJlc2VydmVQYXJlbnM6IGZhbHNlXG59O1xuXG4vLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxudmFyIHdhcm5lZEFib3V0RWNtYVZlcnNpb24gPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gIHZhciBvcHRpb25zID0ge307XG5cbiAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgIHsgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBoYXNPd24ob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF07IH1cblxuICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gXCJsYXRlc3RcIikge1xuICAgIG9wdGlvbnMuZWNtYVZlcnNpb24gPSAxZTg7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA9PSBudWxsKSB7XG4gICAgaWYgKCF3YXJuZWRBYm91dEVjbWFWZXJzaW9uICYmIHR5cGVvZiBjb25zb2xlID09PSBcIm9iamVjdFwiICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgd2FybmVkQWJvdXRFY21hVmVyc2lvbiA9IHRydWU7XG4gICAgICBjb25zb2xlLndhcm4oXCJTaW5jZSBBY29ybiA4LjAuMCwgb3B0aW9ucy5lY21hVmVyc2lvbiBpcyByZXF1aXJlZC5cXG5EZWZhdWx0aW5nIHRvIDIwMjAsIGJ1dCB0aGlzIHdpbGwgc3RvcCB3b3JraW5nIGluIHRoZSBmdXR1cmUuXCIpO1xuICAgIH1cbiAgICBvcHRpb25zLmVjbWFWZXJzaW9uID0gMTE7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSAyMDE1KSB7XG4gICAgb3B0aW9ucy5lY21hVmVyc2lvbiAtPSAyMDA5O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PSBudWxsKVxuICAgIHsgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID0gb3B0aW9ucy5lY21hVmVyc2lvbiA8IDU7IH1cblxuICBpZiAoIW9wdHMgfHwgb3B0cy5hbGxvd0hhc2hCYW5nID09IG51bGwpXG4gICAgeyBvcHRpb25zLmFsbG93SGFzaEJhbmcgPSBvcHRpb25zLmVjbWFWZXJzaW9uID49IDE0OyB9XG5cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gIH1cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICB2YWx1ZTogdGV4dCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgfVxufVxuXG4vLyBFYWNoIHNjb3BlIGdldHMgYSBiaXRzZXQgdGhhdCBtYXkgY29udGFpbiB0aGVzZSBmbGFnc1xudmFyXG4gICAgU0NPUEVfVE9QID0gMSxcbiAgICBTQ09QRV9GVU5DVElPTiA9IDIsXG4gICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgIFNDT1BFX0dFTkVSQVRPUiA9IDgsXG4gICAgU0NPUEVfQVJST1cgPSAxNixcbiAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICBTQ09QRV9TVVBFUiA9IDY0LFxuICAgIFNDT1BFX0RJUkVDVF9TVVBFUiA9IDEyOCxcbiAgICBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgPSAyNTYsXG4gICAgU0NPUEVfVkFSID0gU0NPUEVfVE9QIHwgU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0s7XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoYXN5bmMsIGdlbmVyYXRvcikge1xuICByZXR1cm4gU0NPUEVfRlVOQ1RJT04gfCAoYXN5bmMgPyBTQ09QRV9BU1lOQyA6IDApIHwgKGdlbmVyYXRvciA/IFNDT1BFX0dFTkVSQVRPUiA6IDApXG59XG5cbi8vIFVzZWQgaW4gY2hlY2tMVmFsKiBhbmQgZGVjbGFyZU5hbWUgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgYmluZGluZ1xudmFyXG4gICAgQklORF9OT05FID0gMCwgLy8gTm90IGEgYmluZGluZ1xuICAgIEJJTkRfVkFSID0gMSwgLy8gVmFyLXN0eWxlIGJpbmRpbmdcbiAgICBCSU5EX0xFWElDQUwgPSAyLCAvLyBMZXQtIG9yIGNvbnN0LXN0eWxlIGJpbmRpbmdcbiAgICBCSU5EX0ZVTkNUSU9OID0gMywgLy8gRnVuY3Rpb24gZGVjbGFyYXRpb25cbiAgICBCSU5EX1NJTVBMRV9DQVRDSCA9IDQsIC8vIFNpbXBsZSAoaWRlbnRpZmllciBwYXR0ZXJuKSBjYXRjaCBiaW5kaW5nXG4gICAgQklORF9PVVRTSURFID0gNTsgLy8gU3BlY2lhbCBjYXNlIGZvciBmdW5jdGlvbiBuYW1lcyBhcyBib3VuZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG5cbnZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gIHRoaXMua2V5d29yZHMgPSB3b3Jkc1JlZ2V4cChrZXl3b3JkcyQxW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIgPyBcIjVtb2R1bGVcIiA6IDVdKTtcbiAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gdHJ1ZSkge1xuICAgIHJlc2VydmVkID0gcmVzZXJ2ZWRXb3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogb3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNSA/IDUgOiAzXTtcbiAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgfVxuICB0aGlzLnJlc2VydmVkV29yZHMgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZCk7XG4gIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0O1xuICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCk7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbiAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgLy8gVXNlZCB0byBzaWduYWwgdG8gY2FsbGVycyBvZiBgcmVhZFdvcmQxYCB3aGV0aGVyIHRoZSB3b3JkXG4gIC8vIGNvbnRhaW5lZCBhbnkgZXNjYXBlIHNlcXVlbmNlcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB3b3JkcyB3aXRoXG4gIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgdG9rZW4gc3RhdGVcblxuICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgdG9rZW5pemVyIGluIHRoZSBpbnB1dC5cbiAgaWYgKHN0YXJ0UG9zKSB7XG4gICAgdGhpcy5wb3MgPSBzdGFydFBvcztcbiAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MgLSAxKSArIDE7XG4gICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pbnB1dC5zbGljZSgwLCB0aGlzLmxpbmVTdGFydCkuc3BsaXQobGluZUJyZWFrKS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgdGhpcy5jdXJMaW5lID0gMTtcbiAgfVxuXG4gIC8vIFByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdG9rZW46XG4gIC8vIEl0cyB0eXBlXG4gIHRoaXMudHlwZSA9IHR5cGVzJDEuZW9mO1xuICAvLyBGb3IgdG9rZW5zIHRoYXQgaW5jbHVkZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgdHlwZSwgdGhlIHZhbHVlXG4gIHRoaXMudmFsdWUgPSBudWxsO1xuICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcbiAgdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgPSBmYWxzZTtcblxuICAvLyBQb3NpdGlvbnMgdG8gZGVsYXllZC1jaGVjayB0aGF0IHlpZWxkL2F3YWl0IGRvZXMgbm90IGV4aXN0IGluIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgdGhpcy55aWVsZFBvcyA9IHRoaXMuYXdhaXRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gIHRoaXMubGFiZWxzID0gW107XG4gIC8vIFRodXMtZmFyIHVuZGVmaW5lZCBleHBvcnRzLlxuICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICB7IHRoaXMuc2tpcExpbmVDb21tZW50KDIpOyB9XG5cbiAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgdGhpcy5lbnRlclNjb3BlKFNDT1BFX1RPUCk7XG5cbiAgLy8gRm9yIFJlZ0V4cCB2YWxpZGF0aW9uXG4gIHRoaXMucmVnZXhwU3RhdGUgPSBudWxsO1xuXG4gIC8vIFRoZSBzdGFjayBvZiBwcml2YXRlIG5hbWVzLlxuICAvLyBFYWNoIGVsZW1lbnQgaGFzIHR3byBwcm9wZXJ0aWVzOiAnZGVjbGFyZWQnIGFuZCAndXNlZCcuXG4gIC8vIFdoZW4gaXQgZXhpdGVkIGZyb20gdGhlIG91dGVybW9zdCBjbGFzcyBkZWZpbml0aW9uLCBhbGwgdXNlZCBwcml2YXRlIG5hbWVzIG11c3QgYmUgZGVjbGFyZWQuXG4gIHRoaXMucHJpdmF0ZU5hbWVTdGFjayA9IFtdO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgaW5GdW5jdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkdlbmVyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkFzeW5jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGNhbkF3YWl0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dEaXJlY3RTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cmVhdEZ1bmN0aW9uc0FzVmFyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93TmV3RG90VGFyZ2V0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQ2xhc3NTdGF0aWNCbG9jazogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKCkge1xuICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dFRva2VuKCk7XG4gIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwobm9kZSlcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkZ1bmN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuaW5HZW5lcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9HRU5FUkFUT1IpID4gMCAmJiAhdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCAmJiAhdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5jYW5Bd2FpdC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmluQ2xhc3NGaWVsZEluaXQgfHwgc2NvcGUuZmxhZ3MgJiBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgeyByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9XG4gIH1cbiAgcmV0dXJuICh0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMykgfHwgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb25cbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd1N1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlZiA9IHRoaXMuY3VycmVudFRoaXNTY29wZSgpO1xuICAgIHZhciBmbGFncyA9IHJlZi5mbGFncztcbiAgICB2YXIgaW5DbGFzc0ZpZWxkSW5pdCA9IHJlZi5pbkNsYXNzRmllbGRJbml0O1xuICByZXR1cm4gKGZsYWdzICYgU0NPUEVfU1VQRVIpID4gMCB8fCBpbkNsYXNzRmllbGRJbml0IHx8IHRoaXMub3B0aW9ucy5hbGxvd1N1cGVyT3V0c2lkZU1ldGhvZFxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmFsbG93RGlyZWN0U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDAgfTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnRyZWF0RnVuY3Rpb25zQXNWYXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dOZXdEb3RUYXJnZXQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVmID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlKCk7XG4gICAgdmFyIGZsYWdzID0gcmVmLmZsYWdzO1xuICAgIHZhciBpbkNsYXNzRmllbGRJbml0ID0gcmVmLmluQ2xhc3NGaWVsZEluaXQ7XG4gIHJldHVybiAoZmxhZ3MgJiAoU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spKSA+IDAgfHwgaW5DbGFzc0ZpZWxkSW5pdFxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmluQ2xhc3NTdGF0aWNCbG9jay5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSykgPiAwXG59O1xuXG5QYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICgpIHtcbiAgICB2YXIgcGx1Z2lucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBwbHVnaW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgdmFyIGNscyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykgeyBjbHMgPSBwbHVnaW5zW2ldKGNscyk7IH1cbiAgcmV0dXJuIGNsc1xufTtcblxuUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCkucGFyc2UoKVxufTtcblxuUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0ID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQgKGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICBwYXJzZXIubmV4dFRva2VuKCk7XG4gIHJldHVybiBwYXJzZXIucGFyc2VFeHByZXNzaW9uKClcbn07XG5cblBhcnNlci50b2tlbml6ZXIgPSBmdW5jdGlvbiB0b2tlbml6ZXIgKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dClcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQYXJzZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbnZhciBsaXRlcmFsID0gL14oPzonKCg/OlxcXFwufFteJ1xcXFxdKSo/KSd8XCIoKD86XFxcXC58W15cIlxcXFxdKSo/KVwiKS87XG5wcCQ5LnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA1KSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAoOzspIHtcbiAgICAvLyBUcnkgdG8gZmluZCBzdHJpbmcgbGl0ZXJhbC5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2ggPSBsaXRlcmFsLmV4ZWModGhpcy5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgdmFyIHNwYWNlQWZ0ZXIgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpLCBlbmQgPSBzcGFjZUFmdGVyLmluZGV4ICsgc3BhY2VBZnRlclswXS5sZW5ndGg7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckF0KGVuZCk7XG4gICAgICByZXR1cm4gbmV4dCA9PT0gXCI7XCIgfHwgbmV4dCA9PT0gXCJ9XCIgfHxcbiAgICAgICAgKGxpbmVCcmVhay50ZXN0KHNwYWNlQWZ0ZXJbMF0pICYmXG4gICAgICAgICAhKC9bKGAuWytcXC0vKiU8Pj0sP14mXS8udGVzdChuZXh0KSB8fCBuZXh0ID09PSBcIiFcIiAmJiB0aGlzLmlucHV0LmNoYXJBdChlbmQgKyAxKSA9PT0gXCI9XCIpKVxuICAgIH1cbiAgICBzdGFydCArPSBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAvLyBTa2lwIHNlbWljb2xvbiwgaWYgYW55LlxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmlucHV0W3N0YXJ0XSA9PT0gXCI7XCIpXG4gICAgICB7IHN0YXJ0Kys7IH1cbiAgfVxufTtcblxuLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbi8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbnBwJDkuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwJDkuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xufTtcblxuLy8gQ29uc3VtZXMgY29udGV4dHVhbCBrZXl3b3JkIGlmIHBvc3NpYmxlLlxuXG5wcCQ5LmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5pc0NvbnRleHR1YWwobmFtZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxucHAkOS5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbChuYW1lKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxuLy8gVGVzdCB3aGV0aGVyIGEgc2VtaWNvbG9uIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxucHAkOS5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lb2YgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2VSIHx8XG4gICAgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxufTtcblxucHAkOS5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuLy8gcHJldGVuZCB0aGF0IHRoZXJlIGlzIGEgc2VtaWNvbG9uIGF0IHRoaXMgcG9zaXRpb24uXG5cbnBwJDkuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5lYXQodHlwZXMkMS5zZW1pKSAmJiAhdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxucHAkOS5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSlcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpOyB9XG4gICAgaWYgKCFub3ROZXh0KVxuICAgICAgeyB0aGlzLm5leHQoKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbi8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwJDkuZXhwZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQoKTtcbn07XG5cbi8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwJDkudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xufTtcblxudmFyIERlc3RydWN0dXJpbmdFcnJvcnMgPSBmdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICB0aGlzLnNob3J0aGFuZEFzc2lnbiA9XG4gIHRoaXMudHJhaWxpbmdDb21tYSA9XG4gIHRoaXMucGFyZW50aGVzaXplZEFzc2lnbiA9XG4gIHRoaXMucGFyZW50aGVzaXplZEJpbmQgPVxuICB0aGlzLmRvdWJsZVByb3RvID1cbiAgICAtMTtcbn07XG5cbnBwJDkuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgaXNBc3NpZ24pIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPiAtMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gIGlmIChwYXJlbnMgPiAtMSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocGFyZW5zLCBpc0Fzc2lnbiA/IFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiIDogXCJQYXJlbnRoZXNpemVkIHBhdHRlcm5cIik7IH1cbn07XG5cbnBwJDkuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBzaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgdmFyIGRvdWJsZVByb3RvID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90bztcbiAgaWYgKCFhbmRUaHJvdykgeyByZXR1cm4gc2hvcnRoYW5kQXNzaWduID49IDAgfHwgZG91YmxlUHJvdG8gPj0gMCB9XG4gIGlmIChzaG9ydGhhbmRBc3NpZ24gPj0gMClcbiAgICB7IHRoaXMucmFpc2Uoc2hvcnRoYW5kQXNzaWduLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpOyB9XG4gIGlmIChkb3VibGVQcm90byA+PSAwKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGRvdWJsZVByb3RvLCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbn07XG5cbnBwJDkuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnlpZWxkUG9zICYmICghdGhpcy5hd2FpdFBvcyB8fCB0aGlzLnlpZWxkUG9zIDwgdGhpcy5hd2FpdFBvcykpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMueWllbGRQb3MsIFwiWWllbGQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gIGlmICh0aGlzLmF3YWl0UG9zKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0UG9zLCBcIkF3YWl0IGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxufTtcblxucHAkOS5pc1NpbXBsZUFzc2lnblRhcmdldCA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgaWYgKGV4cHIudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIHsgcmV0dXJuIHRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwci5leHByZXNzaW9uKSB9XG4gIHJldHVybiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGV4cHIudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCJcbn07XG5cbnZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMjIFN0YXRlbWVudCBwYXJzaW5nXG5cbi8vIFBhcnNlIGEgcHJvZ3JhbS4gSW5pdGlhbGl6ZXMgdGhlIHBhcnNlciwgcmVhZHMgYW55IG51bWJlciBvZlxuLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbi8vIGBwcm9ncmFtYCBhcmd1bWVudC4gIElmIHByZXNlbnQsIHRoZSBzdGF0ZW1lbnRzIHdpbGwgYmUgYXBwZW5kZWRcbi8vIHRvIGl0cyBib2R5IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgbm9kZS5cblxucHAkOC5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghbm9kZS5ib2R5KSB7IG5vZGUuYm9keSA9IFtdOyB9XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuZW9mKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwsIHRydWUsIGV4cG9ydHMpO1xuICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICB9XG4gIGlmICh0aGlzLmluTW9kdWxlKVxuICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh0aGlzLnVuZGVmaW5lZEV4cG9ydHMpOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV0uc3RhcnQsIChcIkV4cG9ydCAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgIH0gfVxuICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5KTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxufTtcblxudmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn0sIHN3aXRjaExhYmVsID0ge2tpbmQ6IFwic3dpdGNoXCJ9O1xuXG5wcCQ4LmlzTGV0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gIC8vIEZvciBhbWJpZ3VvdXMgY2FzZXMsIGRldGVybWluZSBpZiBhIExleGljYWxEZWNsYXJhdGlvbiAob3Igb25seSBhXG4gIC8vIFN0YXRlbWVudCkgaXMgYWxsb3dlZCBoZXJlLiBJZiBjb250ZXh0IGlzIG5vdCBlbXB0eSB0aGVuIG9ubHkgYSBTdGF0ZW1lbnRcbiAgLy8gaXMgYWxsb3dlZC4gSG93ZXZlciwgYGxldCBbYCBpcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSBsb29rYWhlYWQgZm9yXG4gIC8vIEV4cHJlc3Npb25TdGF0ZW1lbnQsIHNvIHNwZWNpYWwtY2FzZSBpdCBmaXJzdC5cbiAgaWYgKG5leHRDaCA9PT0gOTEgfHwgbmV4dENoID09PSA5MikgeyByZXR1cm4gdHJ1ZSB9IC8vICdbJywgJy8nXG4gIGlmIChjb250ZXh0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKG5leHRDaCA9PT0gMTIzIHx8IG5leHRDaCA+IDB4ZDdmZiAmJiBuZXh0Q2ggPCAweGRjMDApIHsgcmV0dXJuIHRydWUgfSAvLyAneycsIGFzdHJhbFxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoLCB0cnVlKSkge1xuICAgIHZhciBwb3MgPSBuZXh0ICsgMTtcbiAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcihuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICBpZiAobmV4dENoID09PSA5MiB8fCBuZXh0Q2ggPiAweGQ3ZmYgJiYgbmV4dENoIDwgMHhkYzAwKSB7IHJldHVybiB0cnVlIH1cbiAgICB2YXIgaWRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKG5leHQsIHBvcyk7XG4gICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGNoZWNrICdhc3luYyBbbm8gTGluZVRlcm1pbmF0b3IgaGVyZV0gZnVuY3Rpb24nXG4vLyAtICdhc3luYyAvKmZvbyovIGZ1bmN0aW9uJyBpcyBPSy5cbi8vIC0gJ2FzeW5jIC8qXFxuKi8gZnVuY3Rpb24nIGlzIGludmFsaWQuXG5wcCQ4LmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJhc3luY1wiKSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBhZnRlcjtcbiAgcmV0dXJuICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCBuZXh0KSkgJiZcbiAgICB0aGlzLmlucHV0LnNsaWNlKG5leHQsIG5leHQgKyA4KSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fFxuICAgICAhKGlzSWRlbnRpZmllckNoYXIoYWZ0ZXIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCArIDgpKSB8fCBhZnRlciA+IDB4ZDdmZiAmJiBhZnRlciA8IDB4ZGMwMCkpXG59O1xuXG4vLyBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4vL1xuLy8gSWYgZXhwZWN0aW5nIGEgc3RhdGVtZW50IGFuZCBmaW5kaW5nIGEgc2xhc2ggb3BlcmF0b3IsIHBhcnNlIGFcbi8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsLiBUaGlzIGlzIHRvIGhhbmRsZSBjYXNlcyBsaWtlXG4vLyBgaWYgKGZvbykgL2JsYWgvLmV4ZWMoZm9vKWAsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4vLyBkb2VzIG5vdCBoZWxwLlxuXG5wcCQ4LnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oY29udGV4dCwgdG9wTGV2ZWwsIGV4cG9ydHMpIHtcbiAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgaWYgKHRoaXMuaXNMZXQoY29udGV4dCkpIHtcbiAgICBzdGFydHR5cGUgPSB0eXBlcyQxLl92YXI7XG4gICAga2luZCA9IFwibGV0XCI7XG4gIH1cblxuICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgLy8gY29tcGxleGl0eS5cblxuICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICBjYXNlIHR5cGVzJDEuX2JyZWFrOiBjYXNlIHR5cGVzJDEuX2NvbnRpbnVlOiByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpXG4gIGNhc2UgdHlwZXMkMS5fZGVidWdnZXI6IHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9kbzogcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX2ZvcjogcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9mdW5jdGlvbjpcbiAgICAvLyBGdW5jdGlvbiBhcyBzb2xlIGJvZHkgb2YgZWl0aGVyIGFuIGlmIHN0YXRlbWVudCBvciBhIGxhYmVsZWQgc3RhdGVtZW50XG4gICAgLy8gd29ya3MsIGJ1dCBub3Qgd2hlbiBpdCBpcyBwYXJ0IG9mIGEgbGFiZWxlZCBzdGF0ZW1lbnQgdGhhdCBpcyB0aGUgc29sZVxuICAgIC8vIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50LlxuICAgIGlmICgoY29udGV4dCAmJiAodGhpcy5zdHJpY3QgfHwgY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikpICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gIGNhc2UgdHlwZXMkMS5fY2xhc3M6XG4gICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gIGNhc2UgdHlwZXMkMS5faWY6IHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX3Rocm93OiByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX2NvbnN0OiBjYXNlIHR5cGVzJDEuX3ZhcjpcbiAgICBraW5kID0ga2luZCB8fCB0aGlzLnZhbHVlO1xuICAgIGlmIChjb250ZXh0ICYmIGtpbmQgIT09IFwidmFyXCIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICBjYXNlIHR5cGVzJDEuX3doaWxlOiByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fd2l0aDogcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgbm9kZSlcbiAgY2FzZSB0eXBlcyQxLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9leHBvcnQ6XG4gIGNhc2UgdHlwZXMkMS5faW1wb3J0OlxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiBzdGFydHR5cGUgPT09IHR5cGVzJDEuX2ltcG9ydCkge1xuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIGlmIChuZXh0Q2ggPT09IDQwIHx8IG5leHRDaCA9PT0gNDYpIC8vICcoJyBvciAnLidcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIpOyB9XG4gICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcyQxLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgZGVmYXVsdDpcbiAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVOYW1lID0gdGhpcy52YWx1ZSwgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMkMS5jb2xvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIH1cbiAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgfVxufTtcblxucHAkOC5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmxhYmVsID0gbnVsbDsgfVxuICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzJDEubmFtZSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICBlbHNlIHtcbiAgICBub2RlLmxhYmVsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGFuIGFjdHVhbCBkZXN0aW5hdGlvbiB0byBicmVhayBvclxuICAvLyBjb250aW51ZSB0by5cbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGxhYiA9IHRoaXMubGFiZWxzW2ldO1xuICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgeyBicmVhayB9XG4gICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICB9XG4gIH1cbiAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImRvXCIpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5fd2hpbGUpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICB7IHRoaXMuZWF0KHR5cGVzJDEuc2VtaSk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKVxufTtcblxuLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuLy8gbG9vcCBpcyBub24tdHJpdmlhbC4gQmFzaWNhbGx5LCB3ZSBoYXZlIHRvIHBhcnNlIHRoZSBpbml0IGB2YXJgXG4vLyBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbiwgZGlzYWxsb3dpbmcgdGhlIGBpbmAgb3BlcmF0b3IgKHNlZVxuLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuLy8gd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBgaW5gIG9yIGBvZmAuIFdoZW4gdGhlcmUgaXMgbm8gaW5pdFxuLy8gcGFydCAoc2VtaWNvbG9uIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzKSwgaXRcbi8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG5wcCQ4LnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5jYW5Bd2FpdCAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkgPyB0aGlzLmxhc3RUb2tTdGFydCA6IC0xO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNlbWkpIHtcbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gIH1cbiAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl92YXIgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLl9jb25zdCB8fCBpc0xldCkge1xuICAgIHZhciBpbml0JDEgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kID0gaXNMZXQgPyBcImxldFwiIDogdGhpcy52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKGluaXQkMSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgIGlmICgodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5faW4pIHtcbiAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSlcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0JDEpXG4gIH1cbiAgdmFyIHN0YXJ0c1dpdGhMZXQgPSB0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSwgaXNGb3JPZiA9IGZhbHNlO1xuICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICB2YXIgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGF3YWl0QXQgPiAtMSA/IFwiYXdhaXRcIiA6IHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCAoaXNGb3JPZiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbikge1xuICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgIH1cbiAgICBpZiAoc3RhcnRzV2l0aExldCAmJiBpc0Zvck9mKSB7IHRoaXMucmFpc2UoaW5pdC5zdGFydCwgXCJUaGUgbGVmdC1oYW5kIHNpZGUgb2YgYSBmb3Itb2YgbG9vcCBtYXkgbm90IHN0YXJ0IHdpdGggJ2xldCcuXCIpOyB9XG4gICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihpbml0KTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gIH1cbiAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbn07XG5cbnBwJDgucGFyc2VGdW5jdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMsIGRlY2xhcmF0aW9uUG9zaXRpb24pIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgRlVOQ19TVEFURU1FTlQgfCAoZGVjbGFyYXRpb25Qb3NpdGlvbiA/IDAgOiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSwgZmFsc2UsIGlzQXN5bmMpXG59O1xuXG5wcCQ4LnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIC8vIGFsbG93IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBpbiBicmFuY2hlcywgYnV0IG9ubHkgaW4gbm9uLXN0cmljdCBtb2RlXG4gIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKTtcbiAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcyQxLl9lbHNlKSA/IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKSA6IG51bGw7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKCF0aGlzLmluRnVuY3Rpb24gJiYgIXRoaXMub3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIEluIGByZXR1cm5gIChhbmQgYGJyZWFrYC9gY29udGludWVgKSwgdGhlIGtleXdvcmRzIHdpdGhcbiAgLy8gb3B0aW9uYWwgYXJndW1lbnRzLCB3ZSBlYWdlcmx5IGxvb2sgZm9yIGEgc2VtaWNvbG9uIG9yIHRoZVxuICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgZWxzZSB7IG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpOyB0aGlzLnNlbWljb2xvbigpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5jYXNlcyA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gIHRoaXMubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICB0aGlzLmVudGVyU2NvcGUoMCk7XG5cbiAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gIC8vIGFkZGluZyBzdGF0ZW1lbnRzIHRvLlxuXG4gIHZhciBjdXI7XG4gIGZvciAodmFyIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlUjspIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9jYXNlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fZGVmYXVsdCkge1xuICAgICAgdmFyIGlzQ2FzZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fY2FzZTtcbiAgICAgIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzYXdEZWZhdWx0KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIik7IH1cbiAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29sb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWN1cikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgdGhpcy5uZXh0KCk7IC8vIENsb3NpbmcgYnJhY2VcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmIChsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpOyB9XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFJldXNlZCBlbXB0eSBhcnJheSBhZGRlZCBmb3Igbm9kZSBmaWVsZHMgdGhhdCBhcmUgYWx3YXlzIGVtcHR5LlxuXG52YXIgZW1wdHkkMSA9IFtdO1xuXG5wcCQ4LnBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgdmFyIHNpbXBsZSA9IHBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICB0aGlzLmVudGVyU2NvcGUoc2ltcGxlID8gU0NPUEVfU0lNUExFX0NBVENIIDogMCk7XG4gIHRoaXMuY2hlY2tMVmFsUGF0dGVybihwYXJhbSwgc2ltcGxlID8gQklORF9TSU1QTEVfQ0FUQ0ggOiBCSU5EX0xFWElDQUwpO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG5cbiAgcmV0dXJuIHBhcmFtXG59O1xuXG5wcCQ4LnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5ibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xuICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9jYXRjaCkge1xuICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLnBhcmVuTCkpIHtcbiAgICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VDYXRjaENsYXVzZVBhcmFtKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgY2xhdXNlLnBhcmFtID0gbnVsbDtcbiAgICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICB9XG4gICAgY2xhdXNlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgfVxuICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR5cGVzJDEuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlVmFyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDgucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2hpbGVcIik7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAodGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aXRoXCIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkge1xuICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gdGhpcy5sYWJlbHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICB7XG4gICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSlcbiAgICAgIHsgdGhpcy5yYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICB9IH1cbiAgdmFyIGtpbmQgPSB0aGlzLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICBmb3IgKHZhciBpID0gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFiZWwkMSA9IHRoaXMubGFiZWxzW2ldO1xuICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAvLyBVcGRhdGUgaW5mb3JtYXRpb24gYWJvdXQgcHJldmlvdXMgbGFiZWxzIG9uIHRoaXMgbm9kZVxuICAgICAgbGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgfVxuICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoY29udGV4dCA/IGNvbnRleHQuaW5kZXhPZihcImxhYmVsXCIpID09PSAtMSA/IGNvbnRleHQgKyBcImxhYmVsXCIgOiBjb250ZXh0IDogXCJsYWJlbFwiKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIG5vZGUubGFiZWwgPSBleHByO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHNlbWljb2xvbi1lbmNsb3NlZCBibG9jayBvZiBzdGF0ZW1lbnRzLCBoYW5kbGluZyBgXCJ1c2Vcbi8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4vLyBmdW5jdGlvbiBib2RpZXMpLlxuXG5wcCQ4LnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIG5vZGUsIGV4aXRTdHJpY3QpIHtcbiAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG4gIGlmICggbm9kZSA9PT0gdm9pZCAwICkgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgbm9kZS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmVudGVyU2NvcGUoMCk7IH1cbiAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIpIHtcbiAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgaWYgKGV4aXRTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSBmYWxzZTsgfVxuICB0aGlzLm5leHQoKTtcbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmV4aXRTY29wZSgpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4vLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3Jcbi8vIGV4cHJlc3Npb24uXG5cbnBwJDgucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIG5vZGUuaW5pdCA9IGluaXQ7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuc2VtaSk7XG4gIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zZW1pID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuc2VtaSk7XG4gIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuUiA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIGBmb3JgL2BpbmAgYW5kIGBmb3JgL2BvZmAgbG9vcCwgd2hpY2ggYXJlIGFsbW9zdFxuLy8gc2FtZSBmcm9tIHBhcnNlcidzIHBlcnNwZWN0aXZlLlxuXG5wcCQ4LnBhcnNlRm9ySW4gPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIHZhciBpc0ZvckluID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9pbjtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgaWYgKFxuICAgIGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiZcbiAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0ICE9IG51bGwgJiZcbiAgICAoXG4gICAgICAhaXNGb3JJbiB8fFxuICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fFxuICAgICAgdGhpcy5zdHJpY3QgfHxcbiAgICAgIGluaXQua2luZCAhPT0gXCJ2YXJcIiB8fFxuICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCJcbiAgICApXG4gICkge1xuICAgIHRoaXMucmFpc2UoXG4gICAgICBpbml0LnN0YXJ0LFxuICAgICAgKChpc0ZvckluID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCIpICsgXCIgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXJcIilcbiAgICApO1xuICB9XG4gIG5vZGUubGVmdCA9IGluaXQ7XG4gIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgdmFyaWFibGUgZGVjbGFyYXRpb25zLlxuXG5wcCQ4LnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKSB7XG4gIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gIG5vZGUua2luZCA9IGtpbmQ7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZGVjbCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmVxKSkge1xuICAgICAgZGVjbC5pbml0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICB9IGVsc2UgaWYgKCFhbGxvd01pc3NpbmdJbml0aWFsaXplciAmJiBraW5kID09PSBcImNvbnN0XCIgJiYgISh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH0gZWxzZSBpZiAoIWFsbG93TWlzc2luZ0luaXRpYWxpemVyICYmIGRlY2wuaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgIShpc0ZvciAmJiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbiB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIkNvbXBsZXggYmluZGluZyBwYXR0ZXJucyByZXF1aXJlIGFuIGluaXRpYWxpemF0aW9uIHZhbHVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNsLmluaXQgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSkgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnBwJDgucGFyc2VWYXJJZCA9IGZ1bmN0aW9uKGRlY2wsIGtpbmQpIHtcbiAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZGVjbC5pZCwga2luZCA9PT0gXCJ2YXJcIiA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMLCBmYWxzZSk7XG59O1xuXG52YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cbi8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UYCkuXG5cbi8vIFJlbW92ZSBgYWxsb3dFeHByZXNzaW9uQm9keWAgZm9yIDcuMC4wLCBhcyBpdCBpcyBvbmx5IGNhbGxlZCB3aXRoIGZhbHNlXG5wcCQ4LnBhcnNlRnVuY3Rpb24gPSBmdW5jdGlvbihub2RlLCBzdGF0ZW1lbnQsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzQXN5bmMsIGZvckluaXQpIHtcbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RhciAmJiAoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICBpZiAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpIHtcbiAgICBub2RlLmlkID0gKHN0YXRlbWVudCAmIEZVTkNfTlVMTEFCTEVfSUQpICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5uYW1lID8gbnVsbCA6IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAvLyBJZiBpdCBpcyBhIHJlZ3VsYXIgZnVuY3Rpb24gZGVjbGFyYXRpb24gaW4gc2xvcHB5IG1vZGUsIHRoZW4gaXQgaXNcbiAgICAgIC8vIHN1YmplY3QgdG8gQW5uZXggQiBzZW1hbnRpY3MgKEJJTkRfRlVOQ1RJT04pLiBPdGhlcndpc2UsIHRoZSBiaW5kaW5nXG4gICAgICAvLyBtb2RlIGRlcGVuZHMgb24gcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBzY29wZSAoc2VlXG4gICAgICAvLyB0cmVhdEZ1bmN0aW9uc0FzVmFyKS5cbiAgICAgIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5pZCwgKHRoaXMuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMpID8gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwgOiBCSU5EX0ZVTkNUSU9OKTsgfVxuICB9XG5cbiAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKG5vZGUuYXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSk7XG5cbiAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgIHsgbm9kZS5pZCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiBudWxsOyB9XG5cbiAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGZhbHNlLCBmb3JJbml0KTtcblxuICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxucHAkOC5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuTCk7XG4gIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzJDEucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xufTtcblxuLy8gUGFyc2UgYSBjbGFzcyBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbnBwJDgucGFyc2VDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIGVjbWEtMjYyIDE0LjYgQ2xhc3MgRGVmaW5pdGlvbnNcbiAgLy8gQSBjbGFzcyBkZWZpbml0aW9uIGlzIGFsd2F5cyBzdHJpY3QgbW9kZSBjb2RlLlxuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3Q7XG4gIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICB2YXIgcHJpdmF0ZU5hbWVNYXAgPSB0aGlzLmVudGVyQ2xhc3NCb2R5KCk7XG4gIHZhciBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgaGFkQ29uc3RydWN0b3IgPSBmYWxzZTtcbiAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlUikge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudChub2RlLnN1cGVyQ2xhc3MgIT09IG51bGwpO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGVsZW1lbnQpO1xuICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgZWxlbWVudC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShlbGVtZW50LnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzc1wiKTsgfVxuICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ICYmIGVsZW1lbnQua2V5LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIiAmJiBpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZChwcml2YXRlTmFtZU1hcCwgZWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVsZW1lbnQua2V5LnN0YXJ0LCAoXCJJZGVudGlmaWVyICcjXCIgKyAoZWxlbWVudC5rZXkubmFtZSkgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gIHRoaXMuZXhpdENsYXNzQm9keSgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKVxufTtcblxucHAkOC5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpIHtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkpIHsgcmV0dXJuIG51bGwgfVxuXG4gIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIga2V5TmFtZSA9IFwiXCI7XG4gIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xuICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICB2YXIga2luZCA9IFwibWV0aG9kXCI7XG4gIHZhciBpc1N0YXRpYyA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJzdGF0aWNcIikpIHtcbiAgICAvLyBQYXJzZSBzdGF0aWMgaW5pdCBibG9ja1xuICAgIGlmIChlY21hVmVyc2lvbiA+PSAxMyAmJiB0aGlzLmVhdCh0eXBlcyQxLmJyYWNlTCkpIHtcbiAgICAgIHRoaXMucGFyc2VDbGFzc1N0YXRpY0Jsb2NrKG5vZGUpO1xuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQoKSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3Rhcikge1xuICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlOYW1lID0gXCJzdGF0aWNcIjtcbiAgICB9XG4gIH1cbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgaWYgKCFrZXlOYW1lICYmIGVjbWFWZXJzaW9uID49IDggJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXN5bmNcIikpIHtcbiAgICBpZiAoKHRoaXMuaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQoKSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RhcikgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlOYW1lID0gXCJhc3luY1wiO1xuICAgIH1cbiAgfVxuICBpZiAoIWtleU5hbWUgJiYgKGVjbWFWZXJzaW9uID49IDkgfHwgIWlzQXN5bmMpICYmIHRoaXMuZWF0KHR5cGVzJDEuc3RhcikpIHtcbiAgICBpc0dlbmVyYXRvciA9IHRydWU7XG4gIH1cbiAgaWYgKCFrZXlOYW1lICYmICFpc0FzeW5jICYmICFpc0dlbmVyYXRvcikge1xuICAgIHZhciBsYXN0VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJnZXRcIikgfHwgdGhpcy5lYXRDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICBpZiAodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpKSB7XG4gICAgICAgIGtpbmQgPSBsYXN0VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlOYW1lID0gbGFzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIGVsZW1lbnQgbmFtZVxuICBpZiAoa2V5TmFtZSkge1xuICAgIC8vICdhc3luYycsICdnZXQnLCAnc2V0Jywgb3IgJ3N0YXRpYycgd2VyZSBub3QgYSBrZXl3b3JkIGNvbnRleHR1YWxseS5cbiAgICAvLyBUaGUgbGFzdCB0b2tlbiBpcyBhbnkgb2YgdGhvc2UuIE1ha2UgaXQgdGhlIGVsZW1lbnQgbmFtZS5cbiAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgbm9kZS5rZXkgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7XG4gICAgbm9kZS5rZXkubmFtZSA9IGtleU5hbWU7XG4gICAgdGhpcy5maW5pc2hOb2RlKG5vZGUua2V5LCBcIklkZW50aWZpZXJcIik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wYXJzZUNsYXNzRWxlbWVudE5hbWUobm9kZSk7XG4gIH1cblxuICAvLyBQYXJzZSBlbGVtZW50IHZhbHVlXG4gIGlmIChlY21hVmVyc2lvbiA8IDEzIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wYXJlbkwgfHwga2luZCAhPT0gXCJtZXRob2RcIiB8fCBpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7XG4gICAgdmFyIGlzQ29uc3RydWN0b3IgPSAhbm9kZS5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKG5vZGUsIFwiY29uc3RydWN0b3JcIik7XG4gICAgdmFyIGFsbG93c0RpcmVjdFN1cGVyID0gaXNDb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3RvckFsbG93c1N1cGVyO1xuICAgIC8vIENvdWxkbid0IG1vdmUgdGhpcyBjaGVjayBpbnRvIHRoZSAncGFyc2VDbGFzc01ldGhvZCcgbWV0aG9kIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgIGlmIChpc0NvbnN0cnVjdG9yICYmIGtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICBub2RlLmtpbmQgPSBpc0NvbnN0cnVjdG9yID8gXCJjb25zdHJ1Y3RvclwiIDoga2luZDtcbiAgICB0aGlzLnBhcnNlQ2xhc3NNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhcnNlQ2xhc3NGaWVsZChub2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlXG59O1xuXG5wcCQ4LmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEucHJpdmF0ZUlkIHx8XG4gICAgdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fFxuICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2tldEwgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZFxuICApXG59O1xuXG5wcCQ4LnBhcnNlQ2xhc3NFbGVtZW50TmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wcml2YXRlSWQpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGFuIGVsZW1lbnQgbmFtZWQgJyNjb25zdHJ1Y3RvcidcIik7XG4gICAgfVxuICAgIGVsZW1lbnQuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICBlbGVtZW50LmtleSA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKGVsZW1lbnQpO1xuICB9XG59O1xuXG5wcCQ4LnBhcnNlQ2xhc3NNZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAvLyBDaGVjayBrZXkgYW5kIGZsYWdzXG4gIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICBpZiAobWV0aG9kLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgIGlmIChpc0FzeW5jKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIG1ldGhvZFwiKTsgfVxuICB9IGVsc2UgaWYgKG1ldGhvZC5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKG1ldGhvZCwgXCJwcm90b3R5cGVcIikpIHtcbiAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gIH1cblxuICAvLyBQYXJzZSB2YWx1ZVxuICB2YXIgdmFsdWUgPSBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG5cbiAgLy8gQ2hlY2sgdmFsdWVcbiAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiICYmIHZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDApXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUuc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgdmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh2YWx1ZS5zdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIHZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiTWV0aG9kRGVmaW5pdGlvblwiKVxufTtcblxucHAkOC5wYXJzZUNsYXNzRmllbGQgPSBmdW5jdGlvbihmaWVsZCkge1xuICBpZiAoY2hlY2tLZXlOYW1lKGZpZWxkLCBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgdGhpcy5yYWlzZShmaWVsZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJ1wiKTtcbiAgfSBlbHNlIGlmIChmaWVsZC5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKGZpZWxkLCBcInByb3RvdHlwZVwiKSkge1xuICAgIHRoaXMucmFpc2UoZmllbGQua2V5LnN0YXJ0LCBcIkNsYXNzZXMgY2FuJ3QgaGF2ZSBhIHN0YXRpYyBmaWVsZCBuYW1lZCAncHJvdG90eXBlJ1wiKTtcbiAgfVxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLmVxKSkge1xuICAgIC8vIFRvIHJhaXNlIFN5bnRheEVycm9yIGlmICdhcmd1bWVudHMnIGV4aXN0cyBpbiB0aGUgaW5pdGlhbGl6ZXIuXG4gICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlKCk7XG4gICAgdmFyIGluQ2xhc3NGaWVsZEluaXQgPSBzY29wZS5pbkNsYXNzRmllbGRJbml0O1xuICAgIHNjb3BlLmluQ2xhc3NGaWVsZEluaXQgPSB0cnVlO1xuICAgIGZpZWxkLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgc2NvcGUuaW5DbGFzc0ZpZWxkSW5pdCA9IGluQ2xhc3NGaWVsZEluaXQ7XG4gIH0gZWxzZSB7XG4gICAgZmllbGQudmFsdWUgPSBudWxsO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShmaWVsZCwgXCJQcm9wZXJ0eURlZmluaXRpb25cIilcbn07XG5cbnBwJDgucGFyc2VDbGFzc1N0YXRpY0Jsb2NrID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLmJvZHkgPSBbXTtcblxuICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gIHRoaXMubGFiZWxzID0gW107XG4gIHRoaXMuZW50ZXJTY29wZShTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgfCBTQ09QRV9TVVBFUik7XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmV4aXRTY29wZSgpO1xuICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3RhdGljQmxvY2tcIilcbn07XG5cbnBwJDgucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChpc1N0YXRlbWVudClcbiAgICAgIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5pZCwgQklORF9MRVhJQ0FMLCBmYWxzZSk7IH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gIH1cbn07XG5cbnBwJDgucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcyQxLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhudWxsLCBmYWxzZSkgOiBudWxsO1xufTtcblxucHAkOC5lbnRlckNsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxlbWVudCA9IHtkZWNsYXJlZDogT2JqZWN0LmNyZWF0ZShudWxsKSwgdXNlZDogW119O1xuICB0aGlzLnByaXZhdGVOYW1lU3RhY2sucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQuZGVjbGFyZWRcbn07XG5cbnBwJDguZXhpdENsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVmID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLnBvcCgpO1xuICB2YXIgZGVjbGFyZWQgPSByZWYuZGVjbGFyZWQ7XG4gIHZhciB1c2VkID0gcmVmLnVzZWQ7XG4gIGlmICghdGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcykgeyByZXR1cm4gfVxuICB2YXIgbGVuID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aDtcbiAgdmFyIHBhcmVudCA9IGxlbiA9PT0gMCA/IG51bGwgOiB0aGlzLnByaXZhdGVOYW1lU3RhY2tbbGVuIC0gMV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlZC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpZCA9IHVzZWRbaV07XG4gICAgaWYgKCFoYXNPd24oZGVjbGFyZWQsIGlkLm5hbWUpKSB7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC51c2VkLnB1c2goaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGlkLnN0YXJ0LCAoXCJQcml2YXRlIGZpZWxkICcjXCIgKyAoaWQubmFtZSkgKyBcIicgbXVzdCBiZSBkZWNsYXJlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3NcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQcml2YXRlTmFtZUNvbmZsaWN0ZWQocHJpdmF0ZU5hbWVNYXAsIGVsZW1lbnQpIHtcbiAgdmFyIG5hbWUgPSBlbGVtZW50LmtleS5uYW1lO1xuICB2YXIgY3VyciA9IHByaXZhdGVOYW1lTWFwW25hbWVdO1xuXG4gIHZhciBuZXh0ID0gXCJ0cnVlXCI7XG4gIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIChlbGVtZW50LmtpbmQgPT09IFwiZ2V0XCIgfHwgZWxlbWVudC5raW5kID09PSBcInNldFwiKSkge1xuICAgIG5leHQgPSAoZWxlbWVudC5zdGF0aWMgPyBcInNcIiA6IFwiaVwiKSArIGVsZW1lbnQua2luZDtcbiAgfVxuXG4gIC8vIGBjbGFzcyB7IGdldCAjYSgpe307IHN0YXRpYyBzZXQgI2EoXyl7fSB9YCBpcyBhbHNvIGNvbmZsaWN0LlxuICBpZiAoXG4gICAgY3VyciA9PT0gXCJpZ2V0XCIgJiYgbmV4dCA9PT0gXCJpc2V0XCIgfHxcbiAgICBjdXJyID09PSBcImlzZXRcIiAmJiBuZXh0ID09PSBcImlnZXRcIiB8fFxuICAgIGN1cnIgPT09IFwic2dldFwiICYmIG5leHQgPT09IFwic3NldFwiIHx8XG4gICAgY3VyciA9PT0gXCJzc2V0XCIgJiYgbmV4dCA9PT0gXCJzZ2V0XCJcbiAgKSB7XG4gICAgcHJpdmF0ZU5hbWVNYXBbbmFtZV0gPSBcInRydWVcIjtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghY3Vycikge1xuICAgIHByaXZhdGVOYW1lTWFwW25hbWVdID0gbmV4dDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrS2V5TmFtZShub2RlLCBuYW1lKSB7XG4gIHZhciBjb21wdXRlZCA9IG5vZGUuY29tcHV0ZWQ7XG4gIHZhciBrZXkgPSBub2RlLmtleTtcbiAgcmV0dXJuICFjb21wdXRlZCAmJiAoXG4gICAga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBuYW1lIHx8XG4gICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gbmFtZVxuICApXG59XG5cbi8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQ4LnBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICBpZiAodGhpcy50eXBlICE9PSB0eXBlcyQxLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDgucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gIHRoaXMubmV4dCgpO1xuICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLnN0YXIpKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBleHBvcnRzKVxuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLl9kZWZhdWx0KSkgeyAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgLy8gZXhwb3J0IHZhcnxjb25zdHxsZXR8ZnVuY3Rpb258Y2xhc3MgLi4uXG4gIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uaWQsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICB9IGVsc2UgeyAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhleHBvcnRzKTtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgICB2YXIgc3BlYyA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGV4cG9ydCBpcyBkZWZpbmVkXG4gICAgICAgIHRoaXMuY2hlY2tMb2NhbEV4cG9ydChzcGVjLmxvY2FsKTtcblxuICAgICAgICBpZiAoc3BlYy5sb2NhbC50eXBlID09PSBcIkxpdGVyYWxcIikge1xuICAgICAgICAgIHRoaXMucmFpc2Uoc3BlYy5sb2NhbC5zdGFydCwgXCJBIHN0cmluZyBsaXRlcmFsIGNhbm5vdCBiZSB1c2VkIGFzIGFuIGV4cG9ydGVkIGJpbmRpbmcgd2l0aG91dCBgZnJvbWAuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKVxufTtcblxucHAkOC5wYXJzZUV4cG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKVxufTtcblxucHAkOC5wYXJzZUV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXNBc3luYztcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fZnVuY3Rpb24gfHwgKGlzQXN5bmMgPSB0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSkge1xuICAgIHZhciBmTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5uZXh0KCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKGZOb2RlLCBGVU5DX1NUQVRFTUVOVCB8IEZVTkNfTlVMTEFCTEVfSUQsIGZhbHNlLCBpc0FzeW5jKVxuICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fY2xhc3MpIHtcbiAgICB2YXIgY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MoY05vZGUsIFwibnVsbGFibGVJRFwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uXG4gIH1cbn07XG5cbnBwJDguY2hlY2tFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBwb3MpIHtcbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICB7IG5hbWUgPSBuYW1lLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gbmFtZS5uYW1lIDogbmFtZS52YWx1ZTsgfVxuICBpZiAoaGFzT3duKGV4cG9ydHMsIG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgXCJEdXBsaWNhdGUgZXhwb3J0ICdcIiArIG5hbWUgKyBcIidcIik7IH1cbiAgZXhwb3J0c1tuYW1lXSA9IHRydWU7XG59O1xuXG5wcCQ4LmNoZWNrUGF0dGVybkV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIHBhdCkge1xuICB2YXIgdHlwZSA9IHBhdC50eXBlO1xuICBpZiAodHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIHBhdCwgcGF0LnN0YXJ0KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGF0LnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcCk7XG4gICAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHBhdC5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICBpZiAoZWx0KSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGVsdCk7IH1cbiAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJQcm9wZXJ0eVwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LnZhbHVlKTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQubGVmdCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmFyZ3VtZW50KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuZXhwcmVzc2lvbik7IH1cbn07XG5cbnBwJDguY2hlY2tWYXJpYWJsZUV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlY2xzKSB7XG4gIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGRlY2xzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIGRlY2wgPSBsaXN0W2ldO1xuXG4gICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZGVjbC5pZCk7XG4gIH1cbn07XG5cbnBwJDguc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZS5rZXl3b3JkID09PSBcInZhclwiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY29uc3RcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNsYXNzXCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgdGhpcy5pc0xldCgpIHx8XG4gICAgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGV4cG9ydHMuXG5cbnBwJDgucGFyc2VFeHBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG5cbiAgbm9kZS5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKSA6IG5vZGUubG9jYWw7XG4gIHRoaXMuY2hlY2tFeHBvcnQoXG4gICAgZXhwb3J0cyxcbiAgICBub2RlLmV4cG9ydGVkLFxuICAgIG5vZGUuZXhwb3J0ZWQuc3RhcnRcbiAgKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpXG59O1xuXG5wcCQ4LnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcyQxLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcyQxLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIG5vZGVzLnB1c2godGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcihleHBvcnRzKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzXG59O1xuXG4vLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQ4LnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcblxuICAvLyBpbXBvcnQgJy4uLidcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eSQxO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpXG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgaW1wb3J0cy5cblxucHAkOC5wYXJzZUltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuXG4gIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlLmltcG9ydGVkKTtcbiAgICBub2RlLmxvY2FsID0gbm9kZS5pbXBvcnRlZDtcbiAgfVxuICB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRTcGVjaWZpZXJcIilcbn07XG5cbnBwJDgucGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XG4gIC8vIGltcG9ydCBkZWZhdWx0T2JqLCB7IHgsIHkgYXMgeiB9IGZyb20gJy4uLidcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXG59O1xuXG5wcCQ4LnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIilcbn07XG5cbnBwJDgucGFyc2VJbXBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgIG5vZGVzLnB1c2godGhpcy5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSkgeyByZXR1cm4gbm9kZXMgfVxuICB9XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3Rhcikge1xuICAgIG5vZGVzLnB1c2godGhpcy5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXIoKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzXG59O1xuXG5wcCQ4LnBhcnNlTW9kdWxlRXhwb3J0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEzICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcpIHtcbiAgICB2YXIgc3RyaW5nTGl0ZXJhbCA9IHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpO1xuICAgIGlmIChsb25lU3Vycm9nYXRlLnRlc3Qoc3RyaW5nTGl0ZXJhbC52YWx1ZSkpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RyaW5nTGl0ZXJhbC5zdGFydCwgXCJBbiBleHBvcnQgbmFtZSBjYW5ub3QgaW5jbHVkZSBhIGxvbmUgc3Vycm9nYXRlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxcbiAgfVxuICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KHRydWUpXG59O1xuXG4vLyBTZXQgYEV4cHJlc3Npb25TdGF0ZW1lbnQjZGlyZWN0aXZlYCBwcm9wZXJ0eSBmb3IgZGlyZWN0aXZlIHByb2xvZ3Vlcy5cbnBwJDguYWRhcHREaXJlY3RpdmVQcm9sb2d1ZSA9IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aCAmJiB0aGlzLmlzRGlyZWN0aXZlQ2FuZGlkYXRlKHN0YXRlbWVudHNbaV0pOyArK2kpIHtcbiAgICBzdGF0ZW1lbnRzW2ldLmRpcmVjdGl2ZSA9IHN0YXRlbWVudHNbaV0uZXhwcmVzc2lvbi5yYXcuc2xpY2UoMSwgLTEpO1xuICB9XG59O1xucHAkOC5pc0RpcmVjdGl2ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKHN0YXRlbWVudCkge1xuICByZXR1cm4gKFxuICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmXG4gICAgc3RhdGVtZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG4gICAgc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiZcbiAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAvLyBSZWplY3QgcGFyZW50aGVzaXplZCBzdHJpbmdzLlxuICAgICh0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiXFxcIlwiIHx8IHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCInXCIpXG4gIClcbn07XG5cbnZhciBwcCQ3ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4vLyBpZiBwb3NzaWJsZS5cblxucHAkNy50b0Fzc2lnbmFibGUgPSBmdW5jdGlvbihub2RlLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nKTtcbiAgICAgICAgLy8gRWFybHkgZXJyb3I6XG4gICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgLy8gICAgIGAuLi5gIERlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0W1lpZWxkLCBBd2FpdF1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmXG4gICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHByb3AuYXJndW1lbnQuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICAgIGlmIChub2RlLmtpbmQgIT09IFwiaW5pdFwiKSB7IHRoaXMucmFpc2Uobm9kZS5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpOyB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiUmVzdEVsZW1lbnRcIjtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGlzQmluZGluZyk7XG4gICAgICBpZiAobm9kZS5hcmd1bWVudC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZShub2RlLmFyZ3VtZW50LnN0YXJ0LCBcIlJlc3QgZWxlbWVudHMgY2Fubm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICBpZiAobm9kZS5vcGVyYXRvciAhPT0gXCI9XCIpIHsgdGhpcy5yYWlzZShub2RlLmxlZnQuZW5kLCBcIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuXCIpOyB9XG4gICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQ2hhaW5FeHByZXNzaW9uXCI6XG4gICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIGxlZnQtaGFuZCBzaWRlXCIpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBpZiAoIWlzQmluZGluZykgeyBicmVhayB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbi8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxucHAkNy50b0Fzc2lnbmFibGVMaXN0ID0gZnVuY3Rpb24oZXhwckxpc3QsIGlzQmluZGluZykge1xuICB2YXIgZW5kID0gZXhwckxpc3QubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIGVsdCA9IGV4cHJMaXN0W2ldO1xuICAgIGlmIChlbHQpIHsgdGhpcy50b0Fzc2lnbmFibGUoZWx0LCBpc0JpbmRpbmcpOyB9XG4gIH1cbiAgaWYgKGVuZCkge1xuICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQobGFzdC5hcmd1bWVudC5zdGFydCk7IH1cbiAgfVxuICByZXR1cm4gZXhwckxpc3Rcbn07XG5cbi8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxucHAkNy5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTcHJlYWRFbGVtZW50XCIpXG59O1xuXG5wcCQ3LnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcblxuICAvLyBSZXN0RWxlbWVudCBpbnNpZGUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpZGVudGlmaWVyXG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLm5hbWUpXG4gICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbnBwJDcucGFyc2VCaW5kaW5nQXRvbSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMkMS5icmFja2V0TDpcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcyQxLmJyYWNrZXRSLCB0cnVlLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIilcblxuICAgIGNhc2UgdHlwZXMkMS5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0cnVlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KClcbn07XG5cbnBwJDcucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93TW9kaWZpZXJzKSB7XG4gIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgIGVsc2UgeyB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTsgfVxuICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgIH0gZWxzZSBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkge1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgdmFyIHJlc3QgPSB0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKTtcbiAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0ocmVzdCk7XG4gICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgdGhpcy5leHBlY3QoY2xvc2UpO1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgZWx0cy5wdXNoKHRoaXMucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW0oYWxsb3dNb2RpZmllcnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsdHNcbn07XG5cbnBwJDcucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW0gPSBmdW5jdGlvbihhbGxvd01vZGlmaWVycykge1xuICB2YXIgZWxlbSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYyk7XG4gIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gIHJldHVybiBlbGVtXG59O1xuXG5wcCQ3LnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgcmV0dXJuIHBhcmFtXG59O1xuXG4vLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG5wcCQ3LnBhcnNlTWF5YmVEZWZhdWx0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KSB7XG4gIGxlZnQgPSBsZWZ0IHx8IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMkMS5lcSkpIHsgcmV0dXJuIGxlZnQgfVxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIilcbn07XG5cbi8vIFRoZSBmb2xsb3dpbmcgdGhyZWUgZnVuY3Rpb25zIGFsbCB2ZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbHVlIOKAlFxuLy8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGJvdW5kLCBvciBhc3NpZ25lZCB0by4gSW4gb3JkZXIgdG8gZG8gc28sIHRoZXkgcGVyZm9ybVxuLy8gYSB2YXJpZXR5IG9mIGNoZWNrczpcbi8vXG4vLyAtIENoZWNrIHRoYXQgbm9uZSBvZiB0aGUgYm91bmQvYXNzaWduZWQtdG8gaWRlbnRpZmllcnMgYXJlIHJlc2VydmVkIHdvcmRzLlxuLy8gLSBSZWNvcmQgbmFtZSBkZWNsYXJhdGlvbnMgZm9yIGJpbmRpbmdzIGluIHRoZSBhcHByb3ByaWF0ZSBzY29wZS5cbi8vIC0gQ2hlY2sgZHVwbGljYXRlIGFyZ3VtZW50IG5hbWVzLCBpZiBjaGVja0NsYXNoZXMgaXMgc2V0LlxuLy9cbi8vIElmIGEgY29tcGxleCBiaW5kaW5nIHBhdHRlcm4gaXMgZW5jb3VudGVyZWQgKGUuZy4sIG9iamVjdCBhbmQgYXJyYXlcbi8vIGRlc3RydWN0dXJpbmcpLCB0aGUgZW50aXJlIHBhdHRlcm4gaXMgcmVjdXJzaXZlbHkgY2hlY2tlZC5cbi8vXG4vLyBUaGVyZSBhcmUgdGhyZWUgdmVyc2lvbnMgb2YgY2hlY2tMVmFsKigpIGFwcHJvcHJpYXRlIGZvciBkaWZmZXJlbnRcbi8vIGNpcmN1bXN0YW5jZXM6XG4vL1xuLy8gLSBjaGVja0xWYWxTaW1wbGUoKSBzaGFsbCBiZSB1c2VkIGlmIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHN1cHBvcnRzXG4vLyAgIG5vdGhpbmcgb3RoZXIgdGhhbiBpZGVudGlmaWVycyBhbmQgbWVtYmVyIGV4cHJlc3Npb25zLiBQYXJlbnRoZXNpemVkXG4vLyAgIGV4cHJlc3Npb25zIGFyZSBhbHNvIGNvcnJlY3RseSBoYW5kbGVkLiBUaGlzIGlzIGdlbmVyYWxseSBhcHByb3ByaWF0ZSBmb3Jcbi8vICAgY29uc3RydWN0cyBmb3Igd2hpY2ggdGhlIHNwZWMgc2F5c1xuLy9cbi8vICAgPiBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiBBc3NpZ25tZW50VGFyZ2V0VHlwZSBvZiBbdGhlIHByb2R1Y3Rpb25dIGlzIG5vdFxuLy8gICA+IHNpbXBsZS5cbi8vXG4vLyAgIEl0IGlzIGFsc28gYXBwcm9wcmlhdGUgZm9yIGNoZWNraW5nIGlmIGFuIGlkZW50aWZpZXIgaXMgdmFsaWQgYW5kIG5vdFxuLy8gICBkZWZpbmVkIGVsc2V3aGVyZSwgbGlrZSBpbXBvcnQgZGVjbGFyYXRpb25zIG9yIGZ1bmN0aW9uL2NsYXNzIGlkZW50aWZpZXJzLlxuLy9cbi8vICAgRXhhbXBsZXMgd2hlcmUgdGhpcyBpcyB1c2VkIGluY2x1ZGU6XG4vLyAgICAgYSArPSDigKY7XG4vLyAgICAgaW1wb3J0IGEgZnJvbSAn4oCmJztcbi8vICAgd2hlcmUgYSBpcyB0aGUgbm9kZSB0byBiZSBjaGVja2VkLlxuLy9cbi8vIC0gY2hlY2tMVmFsUGF0dGVybigpIHNoYWxsIGJlIHVzZWQgaWYgdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3Qgc3VwcG9ydHNcbi8vICAgYW55dGhpbmcgY2hlY2tMVmFsU2ltcGxlKCkgc3VwcG9ydHMsIGFzIHdlbGwgYXMgb2JqZWN0IGFuZCBhcnJheVxuLy8gICBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zLiBUaGlzIGlzIGdlbmVyYWxseSBhcHByb3ByaWF0ZSBmb3IgY29uc3RydWN0cyBmb3Jcbi8vICAgd2hpY2ggdGhlIHNwZWMgc2F5c1xuLy9cbi8vICAgPiBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiBbdGhlIHByb2R1Y3Rpb25dIGlzIG5laXRoZXIgYW4gT2JqZWN0TGl0ZXJhbCBub3Jcbi8vICAgPiBhbiBBcnJheUxpdGVyYWwgYW5kIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4vLyAgID4gc2ltcGxlLlxuLy9cbi8vICAgRXhhbXBsZXMgd2hlcmUgdGhpcyBpcyB1c2VkIGluY2x1ZGU6XG4vLyAgICAgKGEgPSDigKYpO1xuLy8gICAgIGNvbnN0IGEgPSDigKY7XG4vLyAgICAgdHJ5IHsg4oCmIH0gY2F0Y2ggKGEpIHsg4oCmIH1cbi8vICAgd2hlcmUgYSBpcyB0aGUgbm9kZSB0byBiZSBjaGVja2VkLlxuLy9cbi8vIC0gY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuLy8gICBhbnl0aGluZyBjaGVja0xWYWxQYXR0ZXJuKCkgc3VwcG9ydHMsIGFzIHdlbGwgYXMgZGVmYXVsdCBhc3NpZ25tZW50XG4vLyAgIHBhdHRlcm5zLCByZXN0IGVsZW1lbnRzLCBhbmQgb3RoZXIgY29uc3RydWN0cyB0aGF0IG1heSBhcHBlYXIgd2l0aGluIGFuXG4vLyAgIG9iamVjdCBvciBhcnJheSBkZXN0cnVjdHVyaW5nIHBhdHRlcm4uXG4vL1xuLy8gICBBcyBhIHNwZWNpYWwgY2FzZSwgZnVuY3Rpb24gcGFyYW1ldGVycyBhbHNvIHVzZSBjaGVja0xWYWxJbm5lclBhdHRlcm4oKSxcbi8vICAgYXMgdGhleSBhbHNvIHN1cHBvcnQgZGVmYXVsdHMgYW5kIHJlc3QgY29uc3RydWN0cy5cbi8vXG4vLyBUaGVzZSBmdW5jdGlvbnMgZGVsaWJlcmF0ZWx5IHN1cHBvcnQgYm90aCBhc3NpZ25tZW50IGFuZCBiaW5kaW5nIGNvbnN0cnVjdHMsXG4vLyBhcyB0aGUgbG9naWMgZm9yIGJvdGggaXMgZXhjZWVkaW5nbHkgc2ltaWxhci4gSWYgdGhlIG5vZGUgaXMgdGhlIHRhcmdldCBvZlxuLy8gYW4gYXNzaWdubWVudCwgdGhlbiBiaW5kaW5nVHlwZSBzaG91bGQgYmUgc2V0IHRvIEJJTkRfTk9ORS4gT3RoZXJ3aXNlLCBpdFxuLy8gc2hvdWxkIGJlIHNldCB0byB0aGUgYXBwcm9wcmlhdGUgQklORF8qIGNvbnN0YW50LCBsaWtlIEJJTkRfVkFSIG9yXG4vLyBCSU5EX0xFWElDQUwuXG4vL1xuLy8gSWYgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGEgbm9uLUJJTkRfTk9ORSBiaW5kaW5nVHlwZSwgdGhlblxuLy8gYWRkaXRpb25hbGx5IGEgY2hlY2tDbGFzaGVzIG9iamVjdCBtYXkgYmUgc3BlY2lmaWVkIHRvIGFsbG93IGNoZWNraW5nIGZvclxuLy8gZHVwbGljYXRlIGFyZ3VtZW50IG5hbWVzLiBjaGVja0NsYXNoZXMgaXMgaWdub3JlZCBpZiB0aGUgcHJvdmlkZWQgY29uc3RydWN0XG4vLyBpcyBhbiBhc3NpZ25tZW50IChpLmUuLCBiaW5kaW5nVHlwZSBpcyBCSU5EX05PTkUpLlxuXG5wcCQ3LmNoZWNrTFZhbFNpbXBsZSA9IGZ1bmN0aW9uKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpIHtcbiAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgdmFyIGlzQmluZCA9IGJpbmRpbmdUeXBlICE9PSBCSU5EX05PTkU7XG5cbiAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICBpZiAodGhpcy5zdHJpY3QgJiYgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZC50ZXN0KGV4cHIubmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoaXNCaW5kID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICBpZiAoaXNCaW5kKSB7XG4gICAgICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCAmJiBleHByLm5hbWUgPT09IFwibGV0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgICBpZiAoaGFzT3duKGNoZWNrQ2xhc2hlcywgZXhwci5uYW1lKSlcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgICAgY2hlY2tDbGFzaGVzW2V4cHIubmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX09VVFNJREUpIHsgdGhpcy5kZWNsYXJlTmFtZShleHByLm5hbWUsIGJpbmRpbmdUeXBlLCBleHByLnN0YXJ0KTsgfVxuICAgIH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIGxlZnQtaGFuZCBzaWRlXCIpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICBpZiAoaXNCaW5kKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb25cIik7IH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgIGlmIChpc0JpbmQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25cIik7IH1cbiAgICByZXR1cm4gdGhpcy5jaGVja0xWYWxTaW1wbGUoZXhwci5leHByZXNzaW9uLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKVxuXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5yYWlzZShleHByLnN0YXJ0LCAoaXNCaW5kID8gXCJCaW5kaW5nXCIgOiBcIkFzc2lnbmluZyB0b1wiKSArIFwiIHJ2YWx1ZVwiKTtcbiAgfVxufTtcblxucHAkNy5jaGVja0xWYWxQYXR0ZXJuID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZXhwci5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgdGhpcy5jaGVja0xWYWxJbm5lclBhdHRlcm4ocHJvcCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGV4cHIuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICB2YXIgZWxlbSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgaWYgKGVsZW0pIHsgdGhpcy5jaGVja0xWYWxJbm5lclBhdHRlcm4oZWxlbSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7IH1cbiAgICB9XG4gICAgYnJlYWtcblxuICBkZWZhdWx0OlxuICAgIHRoaXMuY2hlY2tMVmFsU2ltcGxlKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICB9XG59O1xuXG5wcCQ3LmNoZWNrTFZhbElubmVyUGF0dGVybiA9IGZ1bmN0aW9uKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpIHtcbiAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihleHByLnZhbHVlLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihleHByLmxlZnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGV4cHIuYXJndW1lbnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gIH1cbn07XG5cbi8vIFRoZSBhbGdvcml0aG0gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHJlZ2V4cCBjYW4gYXBwZWFyIGF0IGFcbi8vIGdpdmVuIHBvaW50IGluIHRoZSBwcm9ncmFtIGlzIGxvb3NlbHkgYmFzZWQgb24gc3dlZXQuanMnIGFwcHJvYWNoLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG5cblxudmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlLCBnZW5lcmF0b3IpIHtcbiAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICB0aGlzLnByZXNlcnZlU3BhY2UgPSAhIXByZXNlcnZlU3BhY2U7XG4gIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgdGhpcy5nZW5lcmF0b3IgPSAhIWdlbmVyYXRvcjtcbn07XG5cbnZhciB0eXBlcyA9IHtcbiAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICBiX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwie1wiLCB0cnVlKSxcbiAgYl90bXBsOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIGZhbHNlKSxcbiAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICBwX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCB0cnVlKSxcbiAgcV90bXBsOiBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudHJ5UmVhZFRlbXBsYXRlVG9rZW4oKTsgfSksXG4gIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gIGZfZXhwcjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlKSxcbiAgZl9leHByX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlLCBmYWxzZSwgbnVsbCwgdHJ1ZSksXG4gIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbn07XG5cbnZhciBwcCQ2ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkNi5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW3R5cGVzLmJfc3RhdF1cbn07XG5cbnBwJDYuY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb250ZXh0W3RoaXMuY29udGV4dC5sZW5ndGggLSAxXVxufTtcblxucHAkNi5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gIGlmIChwYXJlbnQgPT09IHR5cGVzLmZfZXhwciB8fCBwYXJlbnQgPT09IHR5cGVzLmZfc3RhdClcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLmNvbG9uICYmIChwYXJlbnQgPT09IHR5cGVzLmJfc3RhdCB8fCBwYXJlbnQgPT09IHR5cGVzLmJfZXhwcikpXG4gICAgeyByZXR1cm4gIXBhcmVudC5pc0V4cHIgfVxuXG4gIC8vIFRoZSBjaGVjayBmb3IgYHR0Lm5hbWUgJiYgZXhwckFsbG93ZWRgIGRldGVjdHMgd2hldGhlciB3ZSBhcmVcbiAgLy8gYWZ0ZXIgYSBgeWllbGRgIG9yIGBvZmAgY29uc3RydWN0LiBTZWUgdGhlIGB1cGRhdGVDb250ZXh0YCBmb3JcbiAgLy8gYHR0Lm5hbWVgLlxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX3JldHVybiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgeyByZXR1cm4gbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMkMS5fZWxzZSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5zZW1pIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLmVvZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5wYXJlblIgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuYXJyb3cpXG4gICAgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMkMS5icmFjZUwpXG4gICAgeyByZXR1cm4gcGFyZW50ID09PSB0eXBlcy5iX3N0YXQgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEubmFtZSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiAhdGhpcy5leHByQWxsb3dlZFxufTtcblxucHAkNi5pbkdlbmVyYXRvckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0W2ldO1xuICAgIGlmIChjb250ZXh0LnRva2VuID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICB7IHJldHVybiBjb250ZXh0LmdlbmVyYXRvciB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG5wcCQ2LnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgdXBkYXRlLCB0eXBlID0gdGhpcy50eXBlO1xuICBpZiAodHlwZS5rZXl3b3JkICYmIHByZXZUeXBlID09PSB0eXBlcyQxLmRvdClcbiAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICBlbHNlIGlmICh1cGRhdGUgPSB0eXBlLnVwZGF0ZUNvbnRleHQpXG4gICAgeyB1cGRhdGUuY2FsbCh0aGlzLCBwcmV2VHlwZSk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjsgfVxufTtcblxuLy8gVXNlZCB0byBoYW5kbGUgZWdkZSBjYXNlcyB3aGVuIHRva2VuIGNvbnRleHQgY291bGQgbm90IGJlIGluZmVycmVkIGNvcnJlY3RseSBkdXJpbmcgdG9rZW5pemF0aW9uIHBoYXNlXG5cbnBwJDYub3ZlcnJpZGVDb250ZXh0ID0gZnVuY3Rpb24odG9rZW5DdHgpIHtcbiAgaWYgKHRoaXMuY3VyQ29udGV4dCgpICE9PSB0b2tlbkN0eCkge1xuICAgIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV0gPSB0b2tlbkN0eDtcbiAgfVxufTtcblxuLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG50eXBlcyQxLnBhcmVuUi51cGRhdGVDb250ZXh0ID0gdHlwZXMkMS5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gIGlmIChvdXQgPT09IHR5cGVzLmJfc3RhdCAmJiB0aGlzLmN1ckNvbnRleHQoKS50b2tlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSAhb3V0LmlzRXhwcjtcbn07XG5cbnR5cGVzJDEuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0aGlzLmJyYWNlSXNCbG9jayhwcmV2VHlwZSkgPyB0eXBlcy5iX3N0YXQgOiB0eXBlcy5iX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzJDEuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb250ZXh0LnB1c2godHlwZXMuYl90bXBsKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcyQxLnBhcmVuTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcyQxLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aGlsZTtcbiAgdGhpcy5jb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gdHlwZXMucF9zdGF0IDogdHlwZXMucF9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcyQxLmluY0RlYy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHRva0V4cHJBbGxvd2VkIHN0YXlzIHVuY2hhbmdlZFxufTtcblxudHlwZXMkMS5fZnVuY3Rpb24udXBkYXRlQ29udGV4dCA9IHR5cGVzJDEuX2NsYXNzLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHlwZXMkMS5fZWxzZSAmJlxuICAgICAgIShwcmV2VHlwZSA9PT0gdHlwZXMkMS5zZW1pICYmIHRoaXMuY3VyQ29udGV4dCgpICE9PSB0eXBlcy5wX3N0YXQpICYmXG4gICAgICAhKHByZXZUeXBlID09PSB0eXBlcyQxLl9yZXR1cm4gJiYgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSkgJiZcbiAgICAgICEoKHByZXZUeXBlID09PSB0eXBlcyQxLmNvbG9uIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLmJyYWNlTCkgJiYgdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLmJfc3RhdCkpXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX2V4cHIpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzLmZfc3RhdCk7IH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxudHlwZXMkMS5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbClcbiAgICB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5xX3RtcGwpOyB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzJDEuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLl9mdW5jdGlvbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxO1xuICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcy5mX2V4cHIpXG4gICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcy5mX2V4cHJfZ2VuOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMuZl9nZW47IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzJDEubmFtZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcyQxLmRvdCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBcIm9mXCIgJiYgIXRoaXMuZXhwckFsbG93ZWQgfHxcbiAgICAgICAgdGhpcy52YWx1ZSA9PT0gXCJ5aWVsZFwiICYmIHRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpXG4gICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGFsbG93ZWQ7XG59O1xuXG4vLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuLy8gc3ludGFjdGljIGVsZW1lbnRzLCBhbmQgcmVjdXJzaXZlbHkgY2FsbGluZyB0aG9zZSwgZWFjaCBmdW5jdGlvblxuLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuLy8gb2YgY29uc3RydWN0cyAoZm9yIGV4YW1wbGUsIHRoZSBmYWN0IHRoYXQgYCF4WzFdYCBtZWFucyBgISh4WzFdKWBcbi8vIGluc3RlYWQgb2YgYCgheClbMV1gIGlzIGhhbmRsZWQgYnkgdGhlIGZhY3QgdGhhdCB0aGUgcGFyc2VyXG4vLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4vLyBpbiB0dXJuIGNhbGxzIHRoZSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBgW11gIHN1YnNjcmlwdHMg4oCUIHRoYXRcbi8vIHdheSwgaXQnbGwgcmVjZWl2ZSB0aGUgbm9kZSBmb3IgYHhbMV1gIGFscmVhZHkgcGFyc2VkLCBhbmQgd3JhcHNcbi8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbi8vXG4vLyBBY29ybiB1c2VzIGFuIFtvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNlcl1bb3BwXSB0byBoYW5kbGUgYmluYXJ5XG4vLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbi8vIHRoZSB0ZWNobmlxdWUgb3V0bGluZWQgYWJvdmUsIHdoaWNoIHVzZXMgZGlmZmVyZW50LCBuZXN0aW5nXG4vLyBmdW5jdGlvbnMgdG8gc3BlY2lmeSBwcmVjZWRlbmNlLCBmb3IgYWxsIG9mIHRoZSB0ZW4gYmluYXJ5XG4vLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbi8vXG4vLyBbb3BwXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRvci1wcmVjZWRlbmNlX3BhcnNlclxuXG5cbnZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ2hlY2sgaWYgcHJvcGVydHkgbmFtZSBjbGFzaGVzIHdpdGggYWxyZWFkeSBhZGRlZC5cbi8vIE9iamVjdC9jbGFzcyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGFyZSBub3QgYWxsb3dlZCB0byBjbGFzaCDigJRcbi8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbi8vIHN0cmljdCBtb2RlLCBpbml0IHByb3BlcnRpZXMgYXJlIGFsc28gbm90IGFsbG93ZWQgdG8gYmUgcmVwZWF0ZWQuXG5cbnBwJDUuY2hlY2tQcm9wQ2xhc2ggPSBmdW5jdGlvbihwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICB7IHJldHVybiB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAocHJvcC5jb21wdXRlZCB8fCBwcm9wLm1ldGhvZCB8fCBwcm9wLnNob3J0aGFuZCkpXG4gICAgeyByZXR1cm4gfVxuICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gIHZhciBuYW1lO1xuICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgY2FzZSBcIkxpdGVyYWxcIjogbmFtZSA9IFN0cmluZyhrZXkudmFsdWUpOyBicmVha1xuICBkZWZhdWx0OiByZXR1cm5cbiAgfVxuICB2YXIga2luZCA9IHByb3Aua2luZDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIGlmIChwcm9wSGFzaC5wcm90bykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvIDwgMCkge1xuICAgICAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IGtleS5zdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gIHZhciBvdGhlciA9IHByb3BIYXNoW25hbWVdO1xuICBpZiAob3RoZXIpIHtcbiAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgIGlmIChraW5kID09PSBcImluaXRcIikge1xuICAgICAgcmVkZWZpbml0aW9uID0gdGhpcy5zdHJpY3QgJiYgb3RoZXIuaW5pdCB8fCBvdGhlci5nZXQgfHwgb3RoZXIuc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRlZmluaXRpb24gPSBvdGhlci5pbml0IHx8IG90aGVyW2tpbmRdO1xuICAgIH1cbiAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKTsgfVxuICB9IGVsc2Uge1xuICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICBpbml0OiBmYWxzZSxcbiAgICAgIGdldDogZmFsc2UsXG4gICAgICBzZXQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBvdGhlcltraW5kXSA9IHRydWU7XG59O1xuXG4vLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbi8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2Zcbi8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbihzKSBiZWxvdyB0aGVtIHBhcnNlLFxuLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbi8vIHRoZSBBU1Qgbm9kZSB0aGF0IHRoZSBpbm5lciBwYXJzZXIgZ2F2ZSB0aGVtIGluIGFub3RoZXIgbm9kZS5cblxuLy8gUGFyc2UgYSBmdWxsIGV4cHJlc3Npb24uIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgdG9cbi8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4vLyBhbmQgcHJvdmlkZSByZWZlcmVuY2UgZm9yIHN0b3JpbmcgJz0nIG9wZXJhdG9yIGluc2lkZSBzaG9ydGhhbmRcbi8vIHByb3BlcnR5IGFzc2lnbm1lbnQgaW4gY29udGV4dHMgd2hlcmUgYm90aCBvYmplY3QgZXhwcmVzc2lvblxuLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuLy8gZGVsYXllZCBzeW50YXggZXJyb3IgYXQgY29ycmVjdCBwb3NpdGlvbikuXG5cbnBwJDUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMkMS5jb21tYSkpIHsgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gIH1cbiAgcmV0dXJuIGV4cHJcbn07XG5cbi8vIFBhcnNlIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi4gVGhpcyBpbmNsdWRlcyBhcHBsaWNhdGlvbnMgb2Zcbi8vIG9wZXJhdG9ycyBsaWtlIGArPWAuXG5cbnBwJDUucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7XG4gICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IpIHsgcmV0dXJuIHRoaXMucGFyc2VZaWVsZChmb3JJbml0KSB9XG4gICAgLy8gVGhlIHRva2VuaXplciB3aWxsIGFzc3VtZSBhbiBleHByZXNzaW9uIGlzIGFsbG93ZWQgYWZ0ZXJcbiAgICAvLyBgeWllbGRgLCBidXQgdGhpcyBpc24ndCB0aGF0IGtpbmQgb2YgeWllbGRcbiAgICBlbHNlIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gIH1cblxuICB2YXIgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZhbHNlLCBvbGRQYXJlbkFzc2lnbiA9IC0xLCBvbGRUcmFpbGluZ0NvbW1hID0gLTEsIG9sZERvdWJsZVByb3RvID0gLTE7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgb2xkVHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgICBvbGREb3VibGVQcm90byA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG87XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgPSBmb3JJbml0ID09PSBcImF3YWl0XCI7XG4gIH1cbiAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7IGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7IH1cbiAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEpXG4gICAgICB7IGxlZnQgPSB0aGlzLnRvQXNzaWduYWJsZShsZWZ0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICBpZiAoIW93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSAtMTtcbiAgICB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID49IGxlZnQuc3RhcnQpXG4gICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IH0gLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVxKVxuICAgICAgeyB0aGlzLmNoZWNrTFZhbFBhdHRlcm4obGVmdCk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKGxlZnQpOyB9XG4gICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgIGlmIChvbGREb3VibGVQcm90byA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBvbGREb3VibGVQcm90bzsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIGlmIChvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gIH1cbiAgaWYgKG9sZFBhcmVuQXNzaWduID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gb2xkUGFyZW5Bc3NpZ247IH1cbiAgaWYgKG9sZFRyYWlsaW5nQ29tbWEgPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSBvbGRUcmFpbGluZ0NvbW1hOyB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG4vLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG5wcCQ1LnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICBpZiAodGhpcy5lYXQodHlwZXMkMS5xdWVzdGlvbikpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLnRlc3QgPSBleHByO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29sb24pO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIilcbiAgfVxuICByZXR1cm4gZXhwclxufTtcblxuLy8gU3RhcnQgdGhlIHByZWNlZGVuY2UgcGFyc2VyLlxuXG5wcCQ1LnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlLCBmYWxzZSwgZm9ySW5pdCk7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gIHJldHVybiBleHByLnN0YXJ0ID09PSBzdGFydFBvcyAmJiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGV4cHIgOiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIGZvckluaXQpXG59O1xuXG4vLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbi8vIGBtaW5QcmVjYCBwcm92aWRlcyBjb250ZXh0IHRoYXQgYWxsb3dzIHRoZSBmdW5jdGlvbiB0byBzdG9wIGFuZFxuLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuXG5wcCQ1LnBhcnNlRXhwck9wID0gZnVuY3Rpb24obGVmdCwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIGZvckluaXQpIHtcbiAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gIGlmIChwcmVjICE9IG51bGwgJiYgKCFmb3JJbml0IHx8IHRoaXMudHlwZSAhPT0gdHlwZXMkMS5faW4pKSB7XG4gICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICB2YXIgbG9naWNhbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQ7XG4gICAgICB2YXIgY29hbGVzY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29hbGVzY2U7XG4gICAgICBpZiAoY29hbGVzY2UpIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBwcmVjZWRlbmNlIG9mIGB0dC5jb2FsZXNjZWAgYXMgZXF1YWwgdG8gdGhlIHJhbmdlIG9mIGxvZ2ljYWwgZXhwcmVzc2lvbnMuXG4gICAgICAgIC8vIEluIG90aGVyIHdvcmRzLCBgbm9kZS5yaWdodGAgc2hvdWxkbid0IGNvbnRhaW4gbG9naWNhbCBleHByZXNzaW9ucyBpbiBvcmRlciB0byBjaGVjayB0aGUgbWl4ZWQgZXJyb3IuXG4gICAgICAgIHByZWMgPSB0eXBlcyQxLmxvZ2ljYWxBTkQuYmlub3A7XG4gICAgICB9XG4gICAgICB2YXIgb3AgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlLCBmYWxzZSwgZm9ySW5pdCksIHN0YXJ0UG9zLCBzdGFydExvYywgcHJlYywgZm9ySW5pdCk7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYnVpbGRCaW5hcnkobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCB8fCBjb2FsZXNjZSk7XG4gICAgICBpZiAoKGxvZ2ljYWwgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvYWxlc2NlKSB8fCAoY29hbGVzY2UgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmxvZ2ljYWxBTkQpKSkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJMb2dpY2FsIGV4cHJlc3Npb25zIGFuZCBjb2FsZXNjZSBleHByZXNzaW9ucyBjYW5ub3QgYmUgbWl4ZWQuIFdyYXAgZWl0aGVyIGJ5IHBhcmVudGhlc2VzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIGZvckluaXQpXG4gICAgfVxuICB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG5wcCQ1LmJ1aWxkQmluYXJ5ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpIHtcbiAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIikgeyB0aGlzLnJhaXNlKHJpZ2h0LnN0YXJ0LCBcIlByaXZhdGUgaWRlbnRpZmllciBjYW4gb25seSBiZSBsZWZ0IHNpZGUgb2YgYmluYXJ5IGV4cHJlc3Npb25cIik7IH1cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgbm9kZS5yaWdodCA9IHJpZ2h0O1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGxvZ2ljYWwgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIHVuYXJ5IG9wZXJhdG9ycywgYm90aCBwcmVmaXggYW5kIHBvc3RmaXguXG5cbnBwJDUucGFyc2VNYXliZVVuYXJ5ID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgc2F3VW5hcnksIGluY0RlYywgZm9ySW5pdCkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmIHRoaXMuY2FuQXdhaXQpIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0KGZvckluaXQpO1xuICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUucHJlZml4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuaW5jRGVjO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSwgdXBkYXRlLCBmb3JJbml0KTtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICBpZiAodXBkYXRlKSB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuYXJndW1lbnQpOyB9XG4gICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJlxuICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgZWxzZSBpZiAobm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJiBpc1ByaXZhdGVGaWVsZEFjY2Vzcyhub2RlLmFyZ3VtZW50KSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiUHJpdmF0ZSBmaWVsZHMgY2FuIG5vdCBiZSBkZWxldGVkXCIpOyB9XG4gICAgZWxzZSB7IHNhd1VuYXJ5ID0gdHJ1ZTsgfVxuICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIGlmICghc2F3VW5hcnkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCkge1xuICAgIGlmICgoZm9ySW5pdCB8fCB0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoID09PSAwKSAmJiB0aGlzLm9wdGlvbnMuY2hlY2tQcml2YXRlRmllbGRzKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgZXhwciA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICAvLyBvbmx5IGNvdWxkIGJlIHByaXZhdGUgZmllbGRzIGluICdpbicsIHN1Y2ggYXMgI3ggaW4gb2JqXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5faW4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfSBlbHNlIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZvckluaXQpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWluY0RlYyAmJiB0aGlzLmVhdCh0eXBlcyQxLnN0YXJzdGFyKSkge1xuICAgIGlmIChzYXdVbmFyeSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIHRoaXMuYnVpbGRCaW5hcnkoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByLCB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSwgZmFsc2UsIGZvckluaXQpLCBcIioqXCIsIGZhbHNlKSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cHJcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQcml2YXRlRmllbGRBY2Nlc3Mobm9kZSkge1xuICByZXR1cm4gKFxuICAgIG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgbm9kZS5wcm9wZXJ0eS50eXBlID09PSBcIlByaXZhdGVJZGVudGlmaWVyXCIgfHxcbiAgICBub2RlLnR5cGUgPT09IFwiQ2hhaW5FeHByZXNzaW9uXCIgJiYgaXNQcml2YXRlRmllbGRBY2Nlc3Mobm9kZS5leHByZXNzaW9uKVxuICApXG59XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcCQ1LnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0KSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCk7XG4gIGlmIChleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tFbmQpICE9PSBcIilcIilcbiAgICB7IHJldHVybiBleHByIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgZmFsc2UsIGZvckluaXQpO1xuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZXN1bHQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gLTE7IH1cbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSAtMTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbnBwJDUucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBmb3JJbml0KSB7XG4gIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICB0aGlzLmxhc3RUb2tFbmQgPT09IGJhc2UuZW5kICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIGJhc2UuZW5kIC0gYmFzZS5zdGFydCA9PT0gNSAmJlxuICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0O1xuICB2YXIgb3B0aW9uYWxDaGFpbmVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCk7XG5cbiAgICBpZiAoZWxlbWVudC5vcHRpb25hbCkgeyBvcHRpb25hbENoYWluZWQgPSB0cnVlOyB9XG4gICAgaWYgKGVsZW1lbnQgPT09IGJhc2UgfHwgZWxlbWVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgIGlmIChvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgdmFyIGNoYWluTm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgY2hhaW5Ob2RlLmV4cHJlc3Npb24gPSBlbGVtZW50O1xuICAgICAgICBlbGVtZW50ID0gdGhpcy5maW5pc2hOb2RlKGNoYWluTm9kZSwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cblxuICAgIGJhc2UgPSBlbGVtZW50O1xuICB9XG59O1xuXG5wcCQ1LnNob3VsZFBhcnNlQXN5bmNBcnJvdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5hcnJvdylcbn07XG5cbnBwJDUucGFyc2VTdWJzY3JpcHRBc3luY0Fycm93ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdCkge1xuICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlLCBmb3JJbml0KVxufTtcblxucHAkNS5wYXJzZVN1YnNjcmlwdCA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93LCBvcHRpb25hbENoYWluZWQsIGZvckluaXQpIHtcbiAgdmFyIG9wdGlvbmFsU3VwcG9ydGVkID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICB2YXIgb3B0aW9uYWwgPSBvcHRpb25hbFN1cHBvcnRlZCAmJiB0aGlzLmVhdCh0eXBlcyQxLnF1ZXN0aW9uRG90KTtcbiAgaWYgKG5vQ2FsbHMgJiYgb3B0aW9uYWwpIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSBjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb25zXCIpOyB9XG5cbiAgdmFyIGNvbXB1dGVkID0gdGhpcy5lYXQodHlwZXMkMS5icmFja2V0TCk7XG4gIGlmIChjb21wdXRlZCB8fCAob3B0aW9uYWwgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuTCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYmFja1F1b3RlKSB8fCB0aGlzLmVhdCh0eXBlcyQxLmRvdCkpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2tldFIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnByaXZhdGVJZCAmJiBiYXNlLnR5cGUgIT09IFwiU3VwZXJcIikge1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICB9XG4gICAgbm9kZS5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgfVxuICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkge1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzJDEucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChtYXliZUFzeW5jQXJyb3cgJiYgIW9wdGlvbmFsICYmIHRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICBpZiAodGhpcy5hd2FpdElkZW50UG9zID4gMClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRJZGVudFBvcywgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdEFzeW5jQXJyb3coc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdClcbiAgICB9XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcyB8fCB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlJDEuY2FsbGVlID0gYmFzZTtcbiAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgaWYgKG9wdGlvbmFsU3VwcG9ydGVkKSB7XG4gICAgICBub2RlJDEub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICB9XG4gICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmJhY2tRdW90ZSkge1xuICAgIGlmIChvcHRpb25hbCB8fCBvcHRpb25hbENoYWluZWQpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSB0YWcgb2YgdGFnZ2VkIHRlbXBsYXRlIGV4cHJlc3Npb25zXCIpO1xuICAgIH1cbiAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgIG5vZGUkMi5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh7aXNUYWdnZWQ6IHRydWV9KTtcbiAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIGJhc2Vcbn07XG5cbi8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuLy8gZXhwcmVzc2lvbiwgYW4gZXhwcmVzc2lvbiBzdGFydGVkIGJ5IGEga2V5d29yZCBsaWtlIGBmdW5jdGlvbmAgb3Jcbi8vIGBuZXdgLCBvciBhbiBleHByZXNzaW9uIHdyYXBwZWQgaW4gcHVuY3R1YXRpb24gbGlrZSBgKClgLCBgW11gLFxuLy8gb3IgYHt9YC5cblxucHAkNS5wYXJzZUV4cHJBdG9tID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCwgZm9yTmV3KSB7XG4gIC8vIElmIGEgZGl2aXNpb24gb3BlcmF0b3IgYXBwZWFycyBpbiBhbiBleHByZXNzaW9uIHBvc2l0aW9uLCB0aGVcbiAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zbGFzaCkgeyB0aGlzLnJlYWRSZWdleHAoKTsgfVxuXG4gIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXJ0O1xuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICBjYXNlIHR5cGVzJDEuX3N1cGVyOlxuICAgIGlmICghdGhpcy5hbGxvd1N1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwic3VwZXIoKSBjYWxsIG91dHNpZGUgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzc1wiKTsgfVxuICAgIC8vIFRoZSBgc3VwZXJgIGtleXdvcmQgY2FuIGFwcGVhciBhdCBiZWxvdzpcbiAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgIC8vICAgICBzdXBlciBbIEV4cHJlc3Npb24gXVxuICAgIC8vICAgICBzdXBlciAuIElkZW50aWZpZXJOYW1lXG4gICAgLy8gU3VwZXJDYWxsOlxuICAgIC8vICAgICBzdXBlciAoIEFyZ3VtZW50cyApXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5kb3QgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNrZXRMICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5wYXJlbkwpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN1cGVyXCIpXG5cbiAgY2FzZSB0eXBlcyQxLl90aGlzOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMkMS5uYW1lOlxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5fZnVuY3Rpb24pKSB7XG4gICAgICB0aGlzLm92ZXJyaWRlQ29udGV4dCh0eXBlcy5mX2V4cHIpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIDAsIGZhbHNlLCB0cnVlLCBmb3JJbml0KVxuICAgIH1cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuYXJyb3cpKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UsIGZvckluaXQpIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgKCF0aGlzLnBvdGVudGlhbEFycm93SW5Gb3JBd2FpdCB8fCB0aGlzLnZhbHVlICE9PSBcIm9mXCIgfHwgdGhpcy5jb250YWluc0VzYykpIHtcbiAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAhdGhpcy5lYXQodHlwZXMkMS5hcnJvdykpXG4gICAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUsIGZvckluaXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZFxuXG4gIGNhc2UgdHlwZXMkMS5yZWdleHA6XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgIG5vZGUucmVnZXggPSB7cGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzfTtcbiAgICByZXR1cm4gbm9kZVxuXG4gIGNhc2UgdHlwZXMkMS5udW06IGNhc2UgdHlwZXMkMS5zdHJpbmc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgY2FzZSB0eXBlcyQxLl9udWxsOiBjYXNlIHR5cGVzJDEuX3RydWU6IGNhc2UgdHlwZXMkMS5fZmFsc2U6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX3RydWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuXG4gIGNhc2UgdHlwZXMkMS5wYXJlbkw6XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93LCBmb3JJbml0KTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDAgJiYgIXRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwcikpXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcblxuICBjYXNlIHR5cGVzJDEuYnJhY2tldEw6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcyQxLmJyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgY2FzZSB0eXBlcyQxLmJyYWNlTDpcbiAgICB0aGlzLm92ZXJyaWRlQ29udGV4dCh0eXBlcy5iX2V4cHIpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gIGNhc2UgdHlwZXMkMS5fZnVuY3Rpb246XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAwKVxuXG4gIGNhc2UgdHlwZXMkMS5fY2xhc3M6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICBjYXNlIHR5cGVzJDEuX25ldzpcbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldygpXG5cbiAgY2FzZSB0eXBlcyQxLmJhY2tRdW90ZTpcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICBjYXNlIHR5cGVzJDEuX2ltcG9ydDpcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJJbXBvcnQoZm9yTmV3KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICB9XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tRGVmYXVsdCgpXG4gIH1cbn07XG5cbnBwJDUucGFyc2VFeHByQXRvbURlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy51bmV4cGVjdGVkKCk7XG59O1xuXG5wcCQ1LnBhcnNlRXhwckltcG9ydCA9IGZ1bmN0aW9uKGZvck5ldykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgLy8gQ29uc3VtZSBgaW1wb3J0YCBhcyBhbiBpZGVudGlmaWVyIGZvciBgaW1wb3J0Lm1ldGFgLlxuICAvLyBCZWNhdXNlIGB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlgIGRvZXNuJ3QgY2hlY2sgZXNjYXBlIHNlcXVlbmNlcywgaXQgbmVlZHMgdGhlIGNoZWNrIG9mIGB0aGlzLmNvbnRhaW5zRXNjYC5cbiAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgaW1wb3J0XCIpOyB9XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuXG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MICYmICFmb3JOZXcpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUR5bmFtaWNJbXBvcnQobm9kZSlcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZG90KSB7XG4gICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydE1ldGEobm9kZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxufTtcblxucHAkNS5wYXJzZUR5bmFtaWNJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpOyAvLyBza2lwIGAoYFxuXG4gIC8vIFBhcnNlIG5vZGUuc291cmNlLlxuICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuXG4gIC8vIFZlcmlmeSBlbmRpbmcuXG4gIGlmICghdGhpcy5lYXQodHlwZXMkMS5wYXJlblIpKSB7XG4gICAgdmFyIGVycm9yUG9zID0gdGhpcy5zdGFydDtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMkMS5jb21tYSkgJiYgdGhpcy5lYXQodHlwZXMkMS5wYXJlblIpKSB7XG4gICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXJyb3JQb3MsIFwiVHJhaWxpbmcgY29tbWEgaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KClcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChlcnJvclBvcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDUucGFyc2VJbXBvcnRNZXRhID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTsgLy8gc2tpcCBgLmBcblxuICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuXG4gIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwibWV0YVwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgaW1wb3J0IGlzICdpbXBvcnQubWV0YSdcIik7IH1cbiAgaWYgKGNvbnRhaW5zRXNjKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ2ltcG9ydC5tZXRhJyBtdXN0IG5vdCBjb250YWluIGVzY2FwZWQgY2hhcmFjdGVyc1wiKTsgfVxuICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgIT09IFwibW9kdWxlXCIgJiYgIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdpbXBvcnQubWV0YScgb3V0c2lkZSBhIG1vZHVsZVwiKTsgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbn07XG5cbnBwJDUucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLnZhbHVlID0gdmFsdWU7XG4gIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gIGlmIChub2RlLnJhdy5jaGFyQ29kZUF0KG5vZGUucmF3Lmxlbmd0aCAtIDEpID09PSAxMTApIHsgbm9kZS5iaWdpbnQgPSBub2RlLnJhdy5zbGljZSgwLCAtMSkucmVwbGFjZSgvXy9nLCBcIlwiKTsgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbn07XG5cbnBwJDUucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICB2YXIgdmFsID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuICByZXR1cm4gdmFsXG59O1xuXG5wcCQ1LnNob3VsZFBhcnNlQXJyb3cgPSBmdW5jdGlvbihleHByTGlzdCkge1xuICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKClcbn07XG5cbnBwJDUucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNhbkJlQXJyb3csIGZvckluaXQpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHJMaXN0ID0gW10sIGZpcnN0ID0gdHJ1ZSwgbGFzdElzQ29tbWEgPSBmYWxzZTtcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgc3ByZWFkU3RhcnQ7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgLy8gRG8gbm90IHNhdmUgYXdhaXRJZGVudFBvcyB0byBhbGxvdyBjaGVja2luZyBhd2FpdHMgbmVzdGVkIGluIHBhcmFtZXRlcnNcbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcyQxLnBhcmVuUikge1xuICAgICAgZmlyc3QgPyBmaXJzdCA9IGZhbHNlIDogdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEucGFyZW5SLCB0cnVlKSkge1xuICAgICAgICBsYXN0SXNDb21tYSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lbGxpcHNpcykge1xuICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZVBhcmVuSXRlbSh0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKSkpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKFxuICAgICAgICAgICAgdGhpcy5zdGFydCxcbiAgICAgICAgICAgIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLmxhc3RUb2tFbmQsIGlubmVyRW5kTG9jID0gdGhpcy5sYXN0VG9rRW5kTG9jO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcblxuICAgIGlmIChjYW5CZUFycm93ICYmIHRoaXMuc2hvdWxkUGFyc2VBcnJvdyhleHByTGlzdCkgJiYgdGhpcy5lYXQodHlwZXMkMS5hcnJvdykpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVBhcmVuQXJyb3dMaXN0KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QsIGZvckluaXQpXG4gICAgfVxuXG4gICAgaWYgKCFleHByTGlzdC5sZW5ndGggfHwgbGFzdElzQ29tbWEpIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgIGlmIChzcHJlYWRTdGFydCkgeyB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnQpOyB9XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG5cbiAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgdmFsID0gdGhpcy5zdGFydE5vZGVBdChpbm5lclN0YXJ0UG9zLCBpbm5lclN0YXJ0TG9jKTtcbiAgICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0O1xuICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBleHByTGlzdFswXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVBhcmVucykge1xuICAgIHZhciBwYXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXIsIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsXG4gIH1cbn07XG5cbnBwJDUucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIHJldHVybiBpdGVtXG59O1xuXG5wcCQ1LnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0LCBmb3JJbml0KSB7XG4gIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QsIGZhbHNlLCBmb3JJbml0KVxufTtcblxuLy8gTmV3J3MgcHJlY2VkZW5jZSBpcyBzbGlnaHRseSB0cmlja3kuIEl0IG11c3QgYWxsb3cgaXRzIGFyZ3VtZW50IHRvXG4vLyBiZSBhIGBbXWAgb3IgZG90IHN1YnNjcmlwdCBleHByZXNzaW9uLCBidXQgbm90IGEgY2FsbCDigJQgYXQgbGVhc3QsXG4vLyBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGUgbm9DYWxsc1xuLy8gYXJndW1lbnQgdG8gcGFyc2VTdWJzY3JpcHRzIHRvIHByZXZlbnQgaXQgZnJvbSBjb25zdW1pbmcgdGhlXG4vLyBhcmd1bWVudCBsaXN0LlxuXG52YXIgZW1wdHkgPSBbXTtcblxucHAkNS5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBuZXdcIik7IH1cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuZWF0KHR5cGVzJDEuZG90KSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyAnbmV3LnRhcmdldCdcIik7IH1cbiAgICBpZiAoY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIiduZXcudGFyZ2V0JyBtdXN0IG5vdCBjb250YWluIGVzY2FwZWQgY2hhcmFjdGVyc1wiKTsgfVxuICAgIGlmICghdGhpcy5hbGxvd05ld0RvdFRhcmdldClcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ25ldy50YXJnZXQnIGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zIGFuZCBjbGFzcyBzdGF0aWMgYmxvY2tcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gIH1cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbShudWxsLCBmYWxzZSwgdHJ1ZSksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSwgZmFsc2UpO1xuICBpZiAodGhpcy5lYXQodHlwZXMkMS5wYXJlbkwpKSB7IG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzJDEucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UpOyB9XG4gIGVsc2UgeyBub2RlLmFyZ3VtZW50cyA9IGVtcHR5OyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSB0ZW1wbGF0ZSBleHByZXNzaW9uLlxuXG5wcCQ1LnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24ocmVmKSB7XG4gIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDtcblxuICB2YXIgZWxlbSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuaW52YWxpZFRlbXBsYXRlKSB7XG4gICAgaWYgKCFpc1RhZ2dlZCkge1xuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQmFkIGVzY2FwZSBzZXF1ZW5jZSBpbiB1bnRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgIH1cbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLnZhbHVlLFxuICAgICAgY29va2VkOiBudWxsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgfTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgZWxlbS50YWlsID0gdGhpcy50eXBlID09PSB0eXBlcyQxLmJhY2tRdW90ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKVxufTtcblxucHAkNS5wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkOyBpZiAoIGlzVGFnZ2VkID09PSB2b2lkIDAgKSBpc1RhZ2dlZCA9IGZhbHNlO1xuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgdmFyIGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pO1xuICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lb2YpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTsgfVxuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuZG9sbGFyQnJhY2VMKTtcbiAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZVIpO1xuICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSkpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpXG59O1xuXG5wcCQ1LmlzQXN5bmNQcm9wID0gZnVuY3Rpb24ocHJvcCkge1xuICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2tldEwgfHwgdGhpcy50eXBlLmtleXdvcmQgfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyKSkgJiZcbiAgICAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxufTtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYmluZGluZyBwYXR0ZXJuLlxuXG5wcCQ1LnBhcnNlT2JqID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBwcm9wSGFzaCA9IHt9O1xuICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgdGhpcy5uZXh0KCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2VQcm9wZXJ0eShpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICghaXNQYXR0ZXJuKSB7IHRoaXMuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1BhdHRlcm4gPyBcIk9iamVjdFBhdHRlcm5cIiA6IFwiT2JqZWN0RXhwcmVzc2lvblwiKVxufTtcblxucHAkNS5wYXJzZVByb3BlcnR5ID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBwcm9wID0gdGhpcy5zdGFydE5vZGUoKSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYztcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzJDEuZWxsaXBzaXMpKSB7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJSZXN0RWxlbWVudFwiKVxuICAgIH1cbiAgICAvLyBQYXJzZSBhcmd1bWVudC5cbiAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAvLyBUbyBkaXNhbGxvdyB0cmFpbGluZyBjb21tYSB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKSB7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICAvLyBGaW5pc2hcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgcHJvcC5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB9XG4gICAgaWYgKCFpc1BhdHRlcm4pXG4gICAgICB7IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMkMS5zdGFyKTsgfVxuICB9XG4gIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5pc0FzeW5jUHJvcChwcm9wKSkge1xuICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMkMS5zdGFyKTtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICB9IGVsc2Uge1xuICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlByb3BlcnR5XCIpXG59O1xuXG5wcCQ1LnBhcnNlR2V0dGVyU2V0dGVyID0gZnVuY3Rpb24ocHJvcCkge1xuICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChmYWxzZSk7XG4gIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICB2YXIgc3RhcnQgPSBwcm9wLnZhbHVlLnN0YXJ0O1xuICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb3Aua2luZCA9PT0gXCJzZXRcIiAmJiBwcm9wLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwcm9wLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICB9XG59O1xuXG5wcCQ1LnBhcnNlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpIHtcbiAgaWYgKChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29sb24pXG4gICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLmNvbG9uKSkge1xuICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MKSB7XG4gICAgaWYgKGlzUGF0dGVybikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIH0gZWxzZSBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgICAgIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmXG4gICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5jb21tYSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5lcSkpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHRoaXMucGFyc2VHZXR0ZXJTZXR0ZXIocHJvcCk7XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICBpZiAocHJvcC5rZXkubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IHN0YXJ0UG9zOyB9XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCB0aGlzLmNvcHlOb2RlKHByb3Aua2V5KSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgdGhpcy5jb3B5Tm9kZShwcm9wLmtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5jb3B5Tm9kZShwcm9wLmtleSk7XG4gICAgfVxuICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbnBwJDUucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmJyYWNrZXRMKSkge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFja2V0Uik7XG4gICAgICByZXR1cm4gcHJvcC5rZXlcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcC5rZXkgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKVxufTtcblxuLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG5wcCQ1LmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZS5pZCA9IG51bGw7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyBub2RlLmdlbmVyYXRvciA9IG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gZmFsc2U7IH1cbn07XG5cbi8vIFBhcnNlIG9iamVjdCBvciBjbGFzcyBtZXRob2QuXG5cbnBwJDUucGFyc2VNZXRob2QgPSBmdW5jdGlvbihpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dEaXJlY3RTdXBlcikge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgeyBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSB8IFNDT1BFX1NVUEVSIHwgKGFsbG93RGlyZWN0U3VwZXIgPyBTQ09QRV9ESVJFQ1RfU1VQRVIgOiAwKSk7XG5cbiAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcyQxLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuXG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy5cblxucHAkNS5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYywgZm9ySW5pdCkge1xuICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgZmFsc2UpIHwgU0NPUEVfQVJST1cpO1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG5cbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cnVlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBmYWxzZSwgZm9ySW5pdCk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cblxucHAkNS5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbiwgaXNNZXRob2QsIGZvckluaXQpIHtcbiAgdmFyIGlzRXhwcmVzc2lvbiA9IGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VMO1xuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3QsIHVzZVN0cmljdCA9IGZhbHNlO1xuXG4gIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9uU2ltcGxlID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgIGlmICghb2xkU3RyaWN0IHx8IG5vblNpbXBsZSkge1xuICAgICAgdXNlU3RyaWN0ID0gdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5lbmQpO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmljdCBtb2RlIGZ1bmN0aW9uLCB2ZXJpZnkgdGhhdCBhcmd1bWVudCBuYW1lc1xuICAgICAgLy8gYXJlIG5vdCByZXBlYXRlZCwgYW5kIGl0IGRvZXMgbm90IHRyeSB0byBiaW5kIHRoZSB3b3JkcyBgZXZhbGBcbiAgICAgIC8vIG9yIGBhcmd1bWVudHNgLlxuICAgICAgaWYgKHVzZVN0cmljdCAmJiBub25TaW1wbGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdFwiKTsgfVxuICAgIH1cbiAgICAvLyBTdGFydCBhIG5ldyBzY29wZSB3aXRoIHJlZ2FyZCB0byBsYWJlbHMgYW5kIHRoZSBgaW5GdW5jdGlvbmBcbiAgICAvLyBmbGFnIChyZXN0b3JlIHRoZW0gdG8gdGhlaXIgb2xkIHZhbHVlIGFmdGVyd2FyZHMpLlxuICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIGlmICh1c2VTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSB0cnVlOyB9XG5cbiAgICAvLyBBZGQgdGhlIHBhcmFtcyB0byB2YXJEZWNsYXJlZE5hbWVzIHRvIGVuc3VyZSB0aGF0IGFuIGVycm9yIGlzIHRocm93blxuICAgIC8vIGlmIGEgbGV0L2NvbnN0IGRlY2xhcmF0aW9uIGluIHRoZSBmdW5jdGlvbiBjbGFzaGVzIHdpdGggb25lIG9mIHRoZSBwYXJhbXMuXG4gICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhb2xkU3RyaWN0ICYmICF1c2VTdHJpY3QgJiYgIWlzQXJyb3dGdW5jdGlvbiAmJiAhaXNNZXRob2QgJiYgdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcykpO1xuICAgIC8vIEVuc3VyZSB0aGUgZnVuY3Rpb24gbmFtZSBpc24ndCBhIGZvcmJpZGRlbiBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLCBlLmcuICdldmFsJ1xuICAgIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLmlkKSB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuaWQsIEJJTkRfT1VUU0lERSk7IH1cbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UsIHVuZGVmaW5lZCwgdXNlU3RyaWN0ICYmICFvbGRTdHJpY3QpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkuYm9keSk7XG4gICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gIH1cbiAgdGhpcy5leGl0U2NvcGUoKTtcbn07XG5cbnBwJDUuaXNTaW1wbGVQYXJhbUxpc3QgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7IHJldHVybiBmYWxzZVxuICB9IH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIENoZWNrcyBmdW5jdGlvbiBwYXJhbXMgZm9yIHZhcmlvdXMgZGlzYWxsb3dlZCBwYXR0ZXJucyBzdWNoIGFzIHVzaW5nIFwiZXZhbFwiXG4vLyBvciBcImFyZ3VtZW50c1wiIGFuZCBkdXBsaWNhdGUgcGFyYW1ldGVycy5cblxucHAkNS5jaGVja1BhcmFtcyA9IGZ1bmN0aW9uKG5vZGUsIGFsbG93RHVwbGljYXRlcykge1xuICB2YXIgbmFtZUhhc2ggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIHRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKHBhcmFtLCBCSU5EX1ZBUiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoKTtcbiAgfVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhwcmVzc2lvbnMsIGFuZCByZXR1cm5zIHRoZW0gYXNcbi8vIGFuIGFycmF5LiBgY2xvc2VgIGlzIHRoZSB0b2tlbiB0eXBlIHRoYXQgZW5kcyB0aGUgbGlzdCwgYW5kXG4vLyBgYWxsb3dFbXB0eWAgY2FuIGJlIHR1cm5lZCBvbiB0byBhbGxvdyBzdWJzZXF1ZW50IGNvbW1hcyB3aXRoXG4vLyBub3RoaW5nIGluIGJldHdlZW4gdGhlbSB0byBiZSBwYXJzZWQgYXMgYG51bGxgICh3aGljaCBpcyBuZWVkZWRcbi8vIGZvciBhcnJheSBsaXRlcmFscykuXG5cbnBwJDUucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpXG4gICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZWxsaXBzaXMpIHtcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VTcHJlYWQocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0OyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgfVxuICAgIGVsdHMucHVzaChlbHQpO1xuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQ1LmNoZWNrVW5yZXNlcnZlZCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gIHZhciBlbmQgPSByZWYuZW5kO1xuICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7IH1cbiAgaWYgKHRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gIGlmICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0ICYmIG5hbWUgPT09IFwiYXJndW1lbnRzXCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXJndW1lbnRzJyBpbiBjbGFzcyBmaWVsZCBpbml0aWFsaXplclwiKTsgfVxuICBpZiAodGhpcy5pbkNsYXNzU3RhdGljQmxvY2sgJiYgKG5hbWUgPT09IFwiYXJndW1lbnRzXCIgfHwgbmFtZSA9PT0gXCJhd2FpdFwiKSlcbiAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIkNhbm5vdCB1c2UgXCIgKyBuYW1lICsgXCIgaW4gY2xhc3Mgc3RhdGljIGluaXRpYWxpemF0aW9uIGJsb2NrXCIpKTsgfVxuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShzdGFydCwgZW5kKS5pbmRleE9mKFwiXFxcXFwiKSAhPT0gLTEpIHsgcmV0dXJuIH1cbiAgdmFyIHJlID0gdGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgOiB0aGlzLnJlc2VydmVkV29yZHM7XG4gIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgaWYgKCF0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gIH1cbn07XG5cbi8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4vLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbi8vIGlkZW50aWZpZXJzLlxuXG5wcCQ1LnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsKSB7XG4gIHZhciBub2RlID0gdGhpcy5wYXJzZUlkZW50Tm9kZSgpO1xuICB0aGlzLm5leHQoISFsaWJlcmFsKTtcbiAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgaWYgKCFsaWJlcmFsKSB7XG4gICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSk7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IG5vZGUuc3RhcnQ7IH1cbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxucHAkNS5wYXJzZUlkZW50Tm9kZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMudmFsdWU7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlLmtleXdvcmQpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnR5cGUua2V5d29yZDtcblxuICAgIC8vIFRvIGZpeCBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi9pc3N1ZXMvNTc1XG4gICAgLy8gYGNsYXNzYCBhbmQgYGZ1bmN0aW9uYCBrZXl3b3JkcyBwdXNoIG5ldyBjb250ZXh0IGludG8gdGhpcy5jb250ZXh0LlxuICAgIC8vIEJ1dCB0aGVyZSBpcyBubyBjaGFuY2UgdG8gcG9wIHRoZSBjb250ZXh0IGlmIHRoZSBrZXl3b3JkIGlzIGNvbnN1bWVkIGFzIGFuIGlkZW50aWZpZXIgc3VjaCBhcyBhIHByb3BlcnR5IG5hbWUuXG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIHRva2VuIGlzIGEgZG90LCB0aGlzIGRvZXMgbm90IGFwcGx5IGJlY2F1c2UgdGhlIGNvbnRleHQtbWFuYWdpbmcgY29kZSBhbHJlYWR5IGlnbm9yZWQgdGhlIGtleXdvcmRcbiAgICBpZiAoKG5vZGUubmFtZSA9PT0gXCJjbGFzc1wiIHx8IG5vZGUubmFtZSA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxucHAkNS5wYXJzZVByaXZhdGVJZGVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucHJpdmF0ZUlkKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJpdmF0ZUlkZW50aWZpZXJcIik7XG5cbiAgLy8gRm9yIHZhbGlkYXRpbmcgZXhpc3RlbmNlXG4gIGlmICh0aGlzLm9wdGlvbnMuY2hlY2tQcml2YXRlRmllbGRzKSB7XG4gICAgaWYgKHRoaXMucHJpdmF0ZU5hbWVTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgKFwiUHJpdmF0ZSBmaWVsZCAnI1wiICsgKG5vZGUubmFtZSkgKyBcIicgbXVzdCBiZSBkZWNsYXJlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3NcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByaXZhdGVOYW1lU3RhY2tbdGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aCAtIDFdLnVzZWQucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gUGFyc2VzIHlpZWxkIGV4cHJlc3Npb24gaW5zaWRlIGdlbmVyYXRvci5cblxucHAkNS5wYXJzZVlpZWxkID0gZnVuY3Rpb24oZm9ySW5pdCkge1xuICBpZiAoIXRoaXMueWllbGRQb3MpIHsgdGhpcy55aWVsZFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNlbWkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAodGhpcy50eXBlICE9PSB0eXBlcyQxLnN0YXIgJiYgIXRoaXMudHlwZS5zdGFydHNFeHByKSkge1xuICAgIG5vZGUuZGVsZWdhdGUgPSBmYWxzZTtcbiAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRlbGVnYXRlID0gdGhpcy5lYXQodHlwZXMkMS5zdGFyKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJZaWVsZEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDUucGFyc2VBd2FpdCA9IGZ1bmN0aW9uKGZvckluaXQpIHtcbiAgaWYgKCF0aGlzLmF3YWl0UG9zKSB7IHRoaXMuYXdhaXRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUsIGZhbHNlLCBmb3JJbml0KTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkF3YWl0RXhwcmVzc2lvblwiKVxufTtcblxudmFyIHBwJDQgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmFpc2UgZXhjZXB0aW9ucyBvbiBwYXJzZSBlcnJvcnMuIEl0XG4vLyB0YWtlcyBhbiBvZmZzZXQgaW50ZWdlciAoaW50byB0aGUgY3VycmVudCBgaW5wdXRgKSB0byBpbmRpY2F0ZVxuLy8gdGhlIGxvY2F0aW9uIG9mIHRoZSBlcnJvciwgYXR0YWNoZXMgdGhlIHBvc2l0aW9uIHRvIHRoZSBlbmRcbi8vIG9mIHRoZSBlcnJvciBtZXNzYWdlLCBhbmQgdGhlbiByYWlzZXMgYSBgU3ludGF4RXJyb3JgIHdpdGggdGhhdFxuLy8gbWVzc2FnZS5cblxucHAkNC5yYWlzZSA9IGZ1bmN0aW9uKHBvcywgbWVzc2FnZSkge1xuICB2YXIgbG9jID0gZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcG9zKTtcbiAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICBlcnIucG9zID0gcG9zOyBlcnIubG9jID0gbG9jOyBlcnIucmFpc2VkQXQgPSB0aGlzLnBvcztcbiAgdGhyb3cgZXJyXG59O1xuXG5wcCQ0LnJhaXNlUmVjb3ZlcmFibGUgPSBwcCQ0LnJhaXNlO1xuXG5wcCQ0LmN1clBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpXG4gIH1cbn07XG5cbnZhciBwcCQzID0gUGFyc2VyLnByb3RvdHlwZTtcblxudmFyIFNjb3BlID0gZnVuY3Rpb24gU2NvcGUoZmxhZ3MpIHtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAvLyBBIGxpc3Qgb2YgdmFyLWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgdGhpcy52YXIgPSBbXTtcbiAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIHRoaXMubGV4aWNhbCA9IFtdO1xuICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIEZ1bmN0aW9uRGVjbGFyYXRpb24gbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAvLyBBIHN3aXRjaCB0byBkaXNhbGxvdyB0aGUgaWRlbnRpZmllciByZWZlcmVuY2UgJ2FyZ3VtZW50cydcbiAgdGhpcy5pbkNsYXNzRmllbGRJbml0ID0gZmFsc2U7XG59O1xuXG4vLyBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGtlZXAgdHJhY2sgb2YgZGVjbGFyZWQgdmFyaWFibGVzIGluIHRoZSBjdXJyZW50IHNjb3BlIGluIG9yZGVyIHRvIGRldGVjdCBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMuXG5cbnBwJDMuZW50ZXJTY29wZSA9IGZ1bmN0aW9uKGZsYWdzKSB7XG4gIHRoaXMuc2NvcGVTdGFjay5wdXNoKG5ldyBTY29wZShmbGFncykpO1xufTtcblxucHAkMy5leGl0U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xufTtcblxuLy8gVGhlIHNwZWMgc2F5czpcbi8vID4gQXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZ1bmN0aW9uLCBvciBzY3JpcHQsIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmVcbi8vID4gdHJlYXRlZCBsaWtlIHZhciBkZWNsYXJhdGlvbnMgcmF0aGVyIHRoYW4gbGlrZSBsZXhpY2FsIGRlY2xhcmF0aW9ucy5cbnBwJDMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUgPSBmdW5jdGlvbihzY29wZSkge1xuICByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHx8ICF0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUClcbn07XG5cbnBwJDMuZGVjbGFyZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKSB7XG4gIHZhciByZWRlY2xhcmVkID0gZmFsc2U7XG4gIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICByZWRlY2xhcmVkID0gc2NvcGUubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS52YXIuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgIHNjb3BlLmxleGljYWwucHVzaChuYW1lKTtcbiAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfU0lNUExFX0NBVENIKSB7XG4gICAgdmFyIHNjb3BlJDEgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIHNjb3BlJDEubGV4aWNhbC5wdXNoKG5hbWUpO1xuICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0ZVTkNUSU9OKSB7XG4gICAgdmFyIHNjb3BlJDIgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGlmICh0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIpXG4gICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgZWxzZVxuICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZSQyLnZhci5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICBzY29wZSQyLmZ1bmN0aW9ucy5wdXNoKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBzY29wZSQzID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlJDMubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgJiYgISgoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1NJTVBMRV9DQVRDSCkgJiYgc2NvcGUkMy5sZXhpY2FsWzBdID09PSBuYW1lKSB8fFxuICAgICAgICAgICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlJDMpICYmIHNjb3BlJDMuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICByZWRlY2xhcmVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHNjb3BlJDMudmFyLnB1c2gobmFtZSk7XG4gICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgICAgaWYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9WQVIpIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuICBpZiAocmVkZWNsYXJlZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCAoXCJJZGVudGlmaWVyICdcIiArIG5hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7IH1cbn07XG5cbnBwJDMuY2hlY2tMb2NhbEV4cG9ydCA9IGZ1bmN0aW9uKGlkKSB7XG4gIC8vIHNjb3BlLmZ1bmN0aW9ucyBtdXN0IGJlIGVtcHR5IGFzIE1vZHVsZSBjb2RlIGlzIGFsd2F5cyBzdHJpY3QuXG4gIGlmICh0aGlzLnNjb3BlU3RhY2tbMF0ubGV4aWNhbC5pbmRleE9mKGlkLm5hbWUpID09PSAtMSAmJlxuICAgICAgdGhpcy5zY29wZVN0YWNrWzBdLnZhci5pbmRleE9mKGlkLm5hbWUpID09PSAtMSkge1xuICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tpZC5uYW1lXSA9IGlkO1xuICB9XG59O1xuXG5wcCQzLmN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXVxufTtcblxucHAkMy5jdXJyZW50VmFyU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUikgeyByZXR1cm4gc2NvcGUgfVxuICB9XG59O1xuXG4vLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGB0aGlzYCwgYG5ldy50YXJnZXRgLCBgc3VwZXIoKWAsIGBzdXBlci5wcm9wZXJ0eWAsIGFuZCBgc3VwZXJbcHJvcGVydHldYC5cbnBwJDMuY3VycmVudFRoaXNTY29wZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSICYmICEoc2NvcGUuZmxhZ3MgJiBTQ09QRV9BUlJPVykpIHsgcmV0dXJuIHNjb3BlIH1cbiAgfVxufTtcblxudmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgdGhpcy50eXBlID0gXCJcIjtcbiAgdGhpcy5zdGFydCA9IHBvcztcbiAgdGhpcy5lbmQgPSAwO1xuICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocGFyc2VyLCBsb2MpOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICBpZiAocGFyc2VyLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwb3MsIDBdOyB9XG59O1xuXG4vLyBTdGFydCBhbiBBU1Qgbm9kZSwgYXR0YWNoaW5nIGEgc3RhcnQgb2Zmc2V0LlxuXG52YXIgcHAkMiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnBwJDIuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKVxufTtcblxucHAkMi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbn07XG5cbi8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIG5vZGUudHlwZSA9IHR5cGU7XG4gIG5vZGUuZW5kID0gcG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IG5vZGUubG9jLmVuZCA9IGxvYzsgfVxuICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgcmV0dXJuIG5vZGVcbn1cblxucHAkMi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgdGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpXG59O1xuXG4vLyBGaW5pc2ggbm9kZSBhdCBnaXZlbiBwb3NpdGlvblxuXG5wcCQyLmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbn07XG5cbnBwJDIuY29weU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBuZXdOb2RlID0gbmV3IE5vZGUodGhpcywgbm9kZS5zdGFydCwgdGhpcy5zdGFydExvYyk7XG4gIGZvciAodmFyIHByb3AgaW4gbm9kZSkgeyBuZXdOb2RlW3Byb3BdID0gbm9kZVtwcm9wXTsgfVxuICByZXR1cm4gbmV3Tm9kZVxufTtcblxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIFVuaWNvZGUgcHJvcGVydGllcyBleHRyYWN0ZWQgZnJvbSB0aGUgRUNNQVNjcmlwdCBzcGVjaWZpY2F0aW9uLlxuLy8gVGhlIGxpc3RzIGFyZSBleHRyYWN0ZWQgbGlrZSBzbzpcbi8vICQkKCcjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllcyA+IGZpZ3VyZSA+IHRhYmxlID4gdGJvZHkgPiB0ciA+IHRkOm50aC1jaGlsZCgxKSBjb2RlJykubWFwKGVsID0+IGVsLmlubmVyVGV4dClcblxuLy8gI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXNcbnZhciBlY21hOUJpbmFyeVByb3BlcnRpZXMgPSBcIkFTQ0lJIEFTQ0lJX0hleF9EaWdpdCBBSGV4IEFscGhhYmV0aWMgQWxwaGEgQW55IEFzc2lnbmVkIEJpZGlfQ29udHJvbCBCaWRpX0MgQmlkaV9NaXJyb3JlZCBCaWRpX00gQ2FzZV9JZ25vcmFibGUgQ0kgQ2FzZWQgQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQgQ1dDRiBDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNIENoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkIENXTCBDaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkIENXS0NGIENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVCBDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZCBDV1UgRGFzaCBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJIERlcHJlY2F0ZWQgRGVwIERpYWNyaXRpYyBEaWEgRW1vamkgRW1vamlfQ29tcG9uZW50IEVtb2ppX01vZGlmaWVyIEVtb2ppX01vZGlmaWVyX0Jhc2UgRW1vamlfUHJlc2VudGF0aW9uIEV4dGVuZGVyIEV4dCBHcmFwaGVtZV9CYXNlIEdyX0Jhc2UgR3JhcGhlbWVfRXh0ZW5kIEdyX0V4dCBIZXhfRGlnaXQgSGV4IElEU19CaW5hcnlfT3BlcmF0b3IgSURTQiBJRFNfVHJpbmFyeV9PcGVyYXRvciBJRFNUIElEX0NvbnRpbnVlIElEQyBJRF9TdGFydCBJRFMgSWRlb2dyYXBoaWMgSWRlbyBKb2luX0NvbnRyb2wgSm9pbl9DIExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRSBMb3dlcmNhc2UgTG93ZXIgTWF0aCBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhciBQYXR0ZXJuX1N5bnRheCBQYXRfU3luIFBhdHRlcm5fV2hpdGVfU3BhY2UgUGF0X1dTIFF1b3RhdGlvbl9NYXJrIFFNYXJrIFJhZGljYWwgUmVnaW9uYWxfSW5kaWNhdG9yIFJJIFNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtIFNvZnRfRG90dGVkIFNEIFRlcm1pbmFsX1B1bmN0dWF0aW9uIFRlcm0gVW5pZmllZF9JZGVvZ3JhcGggVUlkZW8gVXBwZXJjYXNlIFVwcGVyIFZhcmlhdGlvbl9TZWxlY3RvciBWUyBXaGl0ZV9TcGFjZSBzcGFjZSBYSURfQ29udGludWUgWElEQyBYSURfU3RhcnQgWElEU1wiO1xudmFyIGVjbWExMEJpbmFyeVByb3BlcnRpZXMgPSBlY21hOUJpbmFyeVByb3BlcnRpZXMgKyBcIiBFeHRlbmRlZF9QaWN0b2dyYXBoaWNcIjtcbnZhciBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTEwQmluYXJ5UHJvcGVydGllcztcbnZhciBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTExQmluYXJ5UHJvcGVydGllcyArIFwiIEVCYXNlIEVDb21wIEVNb2QgRVByZXMgRXh0UGljdFwiO1xudmFyIGVjbWExM0JpbmFyeVByb3BlcnRpZXMgPSBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzO1xudmFyIGVjbWExNEJpbmFyeVByb3BlcnRpZXMgPSBlY21hMTNCaW5hcnlQcm9wZXJ0aWVzO1xuXG52YXIgdW5pY29kZUJpbmFyeVByb3BlcnRpZXMgPSB7XG4gIDk6IGVjbWE5QmluYXJ5UHJvcGVydGllcyxcbiAgMTA6IGVjbWExMEJpbmFyeVByb3BlcnRpZXMsXG4gIDExOiBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzLFxuICAxMjogZWNtYTEyQmluYXJ5UHJvcGVydGllcyxcbiAgMTM6IGVjbWExM0JpbmFyeVByb3BlcnRpZXMsXG4gIDE0OiBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzXG59O1xuXG4vLyAjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllcy1vZi1zdHJpbmdzXG52YXIgZWNtYTE0QmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyA9IFwiQmFzaWNfRW1vamkgRW1vamlfS2V5Y2FwX1NlcXVlbmNlIFJHSV9FbW9qaV9Nb2RpZmllcl9TZXF1ZW5jZSBSR0lfRW1vamlfRmxhZ19TZXF1ZW5jZSBSR0lfRW1vamlfVGFnX1NlcXVlbmNlIFJHSV9FbW9qaV9aV0pfU2VxdWVuY2UgUkdJX0Vtb2ppXCI7XG5cbnZhciB1bmljb2RlQmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyA9IHtcbiAgOTogXCJcIixcbiAgMTA6IFwiXCIsXG4gIDExOiBcIlwiLFxuICAxMjogXCJcIixcbiAgMTM6IFwiXCIsXG4gIDE0OiBlY21hMTRCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzXG59O1xuXG4vLyAjdGFibGUtdW5pY29kZS1nZW5lcmFsLWNhdGVnb3J5LXZhbHVlc1xudmFyIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMgPSBcIkNhc2VkX0xldHRlciBMQyBDbG9zZV9QdW5jdHVhdGlvbiBQZSBDb25uZWN0b3JfUHVuY3R1YXRpb24gUGMgQ29udHJvbCBDYyBjbnRybCBDdXJyZW5jeV9TeW1ib2wgU2MgRGFzaF9QdW5jdHVhdGlvbiBQZCBEZWNpbWFsX051bWJlciBOZCBkaWdpdCBFbmNsb3NpbmdfTWFyayBNZSBGaW5hbF9QdW5jdHVhdGlvbiBQZiBGb3JtYXQgQ2YgSW5pdGlhbF9QdW5jdHVhdGlvbiBQaSBMZXR0ZXIgTCBMZXR0ZXJfTnVtYmVyIE5sIExpbmVfU2VwYXJhdG9yIFpsIExvd2VyY2FzZV9MZXR0ZXIgTGwgTWFyayBNIENvbWJpbmluZ19NYXJrIE1hdGhfU3ltYm9sIFNtIE1vZGlmaWVyX0xldHRlciBMbSBNb2RpZmllcl9TeW1ib2wgU2sgTm9uc3BhY2luZ19NYXJrIE1uIE51bWJlciBOIE9wZW5fUHVuY3R1YXRpb24gUHMgT3RoZXIgQyBPdGhlcl9MZXR0ZXIgTG8gT3RoZXJfTnVtYmVyIE5vIE90aGVyX1B1bmN0dWF0aW9uIFBvIE90aGVyX1N5bWJvbCBTbyBQYXJhZ3JhcGhfU2VwYXJhdG9yIFpwIFByaXZhdGVfVXNlIENvIFB1bmN0dWF0aW9uIFAgcHVuY3QgU2VwYXJhdG9yIFogU3BhY2VfU2VwYXJhdG9yIFpzIFNwYWNpbmdfTWFyayBNYyBTdXJyb2dhdGUgQ3MgU3ltYm9sIFMgVGl0bGVjYXNlX0xldHRlciBMdCBVbmFzc2lnbmVkIENuIFVwcGVyY2FzZV9MZXR0ZXIgTHVcIjtcblxuLy8gI3RhYmxlLXVuaWNvZGUtc2NyaXB0LXZhbHVlc1xudmFyIGVjbWE5U2NyaXB0VmFsdWVzID0gXCJBZGxhbSBBZGxtIEFob20gQW5hdG9saWFuX0hpZXJvZ2x5cGhzIEhsdXcgQXJhYmljIEFyYWIgQXJtZW5pYW4gQXJtbiBBdmVzdGFuIEF2c3QgQmFsaW5lc2UgQmFsaSBCYW11bSBCYW11IEJhc3NhX1ZhaCBCYXNzIEJhdGFrIEJhdGsgQmVuZ2FsaSBCZW5nIEJoYWlrc3VraSBCaGtzIEJvcG9tb2ZvIEJvcG8gQnJhaG1pIEJyYWggQnJhaWxsZSBCcmFpIEJ1Z2luZXNlIEJ1Z2kgQnVoaWQgQnVoZCBDYW5hZGlhbl9BYm9yaWdpbmFsIENhbnMgQ2FyaWFuIENhcmkgQ2F1Y2FzaWFuX0FsYmFuaWFuIEFnaGIgQ2hha21hIENha20gQ2hhbSBDaGFtIENoZXJva2VlIENoZXIgQ29tbW9uIFp5eXkgQ29wdGljIENvcHQgUWFhYyBDdW5laWZvcm0gWHN1eCBDeXByaW90IENwcnQgQ3lyaWxsaWMgQ3lybCBEZXNlcmV0IERzcnQgRGV2YW5hZ2FyaSBEZXZhIER1cGxveWFuIER1cGwgRWd5cHRpYW5fSGllcm9nbHlwaHMgRWd5cCBFbGJhc2FuIEVsYmEgRXRoaW9waWMgRXRoaSBHZW9yZ2lhbiBHZW9yIEdsYWdvbGl0aWMgR2xhZyBHb3RoaWMgR290aCBHcmFudGhhIEdyYW4gR3JlZWsgR3JlayBHdWphcmF0aSBHdWpyIEd1cm11a2hpIEd1cnUgSGFuIEhhbmkgSGFuZ3VsIEhhbmcgSGFudW5vbyBIYW5vIEhhdHJhbiBIYXRyIEhlYnJldyBIZWJyIEhpcmFnYW5hIEhpcmEgSW1wZXJpYWxfQXJhbWFpYyBBcm1pIEluaGVyaXRlZCBaaW5oIFFhYWkgSW5zY3JpcHRpb25hbF9QYWhsYXZpIFBobGkgSW5zY3JpcHRpb25hbF9QYXJ0aGlhbiBQcnRpIEphdmFuZXNlIEphdmEgS2FpdGhpIEt0aGkgS2FubmFkYSBLbmRhIEthdGFrYW5hIEthbmEgS2F5YWhfTGkgS2FsaSBLaGFyb3NodGhpIEtoYXIgS2htZXIgS2htciBLaG9qa2kgS2hvaiBLaHVkYXdhZGkgU2luZCBMYW8gTGFvbyBMYXRpbiBMYXRuIExlcGNoYSBMZXBjIExpbWJ1IExpbWIgTGluZWFyX0EgTGluYSBMaW5lYXJfQiBMaW5iIExpc3UgTGlzdSBMeWNpYW4gTHljaSBMeWRpYW4gTHlkaSBNYWhhamFuaSBNYWhqIE1hbGF5YWxhbSBNbHltIE1hbmRhaWMgTWFuZCBNYW5pY2hhZWFuIE1hbmkgTWFyY2hlbiBNYXJjIE1hc2FyYW1fR29uZGkgR29ubSBNZWV0ZWlfTWF5ZWsgTXRlaSBNZW5kZV9LaWtha3VpIE1lbmQgTWVyb2l0aWNfQ3Vyc2l2ZSBNZXJjIE1lcm9pdGljX0hpZXJvZ2x5cGhzIE1lcm8gTWlhbyBQbHJkIE1vZGkgTW9uZ29saWFuIE1vbmcgTXJvIE1yb28gTXVsdGFuaSBNdWx0IE15YW5tYXIgTXltciBOYWJhdGFlYW4gTmJhdCBOZXdfVGFpX0x1ZSBUYWx1IE5ld2EgTmV3YSBOa28gTmtvbyBOdXNodSBOc2h1IE9naGFtIE9nYW0gT2xfQ2hpa2kgT2xjayBPbGRfSHVuZ2FyaWFuIEh1bmcgT2xkX0l0YWxpYyBJdGFsIE9sZF9Ob3J0aF9BcmFiaWFuIE5hcmIgT2xkX1Blcm1pYyBQZXJtIE9sZF9QZXJzaWFuIFhwZW8gT2xkX1NvdXRoX0FyYWJpYW4gU2FyYiBPbGRfVHVya2ljIE9ya2ggT3JpeWEgT3J5YSBPc2FnZSBPc2dlIE9zbWFueWEgT3NtYSBQYWhhd2hfSG1vbmcgSG1uZyBQYWxteXJlbmUgUGFsbSBQYXVfQ2luX0hhdSBQYXVjIFBoYWdzX1BhIFBoYWcgUGhvZW5pY2lhbiBQaG54IFBzYWx0ZXJfUGFobGF2aSBQaGxwIFJlamFuZyBSam5nIFJ1bmljIFJ1bnIgU2FtYXJpdGFuIFNhbXIgU2F1cmFzaHRyYSBTYXVyIFNoYXJhZGEgU2hyZCBTaGF2aWFuIFNoYXcgU2lkZGhhbSBTaWRkIFNpZ25Xcml0aW5nIFNnbncgU2luaGFsYSBTaW5oIFNvcmFfU29tcGVuZyBTb3JhIFNveW9tYm8gU295byBTdW5kYW5lc2UgU3VuZCBTeWxvdGlfTmFncmkgU3lsbyBTeXJpYWMgU3lyYyBUYWdhbG9nIFRnbGcgVGFnYmFud2EgVGFnYiBUYWlfTGUgVGFsZSBUYWlfVGhhbSBMYW5hIFRhaV9WaWV0IFRhdnQgVGFrcmkgVGFrciBUYW1pbCBUYW1sIFRhbmd1dCBUYW5nIFRlbHVndSBUZWx1IFRoYWFuYSBUaGFhIFRoYWkgVGhhaSBUaWJldGFuIFRpYnQgVGlmaW5hZ2ggVGZuZyBUaXJodXRhIFRpcmggVWdhcml0aWMgVWdhciBWYWkgVmFpaSBXYXJhbmdfQ2l0aSBXYXJhIFlpIFlpaWkgWmFuYWJhemFyX1NxdWFyZSBaYW5iXCI7XG52YXIgZWNtYTEwU2NyaXB0VmFsdWVzID0gZWNtYTlTY3JpcHRWYWx1ZXMgKyBcIiBEb2dyYSBEb2dyIEd1bmphbGFfR29uZGkgR29uZyBIYW5pZmlfUm9oaW5neWEgUm9oZyBNYWthc2FyIE1ha2EgTWVkZWZhaWRyaW4gTWVkZiBPbGRfU29nZGlhbiBTb2dvIFNvZ2RpYW4gU29nZFwiO1xudmFyIGVjbWExMVNjcmlwdFZhbHVlcyA9IGVjbWExMFNjcmlwdFZhbHVlcyArIFwiIEVseW1haWMgRWx5bSBOYW5kaW5hZ2FyaSBOYW5kIE55aWFrZW5nX1B1YWNodWVfSG1vbmcgSG1ucCBXYW5jaG8gV2Nob1wiO1xudmFyIGVjbWExMlNjcmlwdFZhbHVlcyA9IGVjbWExMVNjcmlwdFZhbHVlcyArIFwiIENob3Jhc21pYW4gQ2hycyBEaWFrIERpdmVzX0FrdXJ1IEtoaXRhbl9TbWFsbF9TY3JpcHQgS2l0cyBZZXppIFllemlkaVwiO1xudmFyIGVjbWExM1NjcmlwdFZhbHVlcyA9IGVjbWExMlNjcmlwdFZhbHVlcyArIFwiIEN5cHJvX01pbm9hbiBDcG1uIE9sZF9VeWdodXIgT3VnciBUYW5nc2EgVG5zYSBUb3RvIFZpdGhrdXFpIFZpdGhcIjtcbnZhciBlY21hMTRTY3JpcHRWYWx1ZXMgPSBlY21hMTNTY3JpcHRWYWx1ZXMgKyBcIiBIcmt0IEthdGFrYW5hX09yX0hpcmFnYW5hIEthd2kgTmFnX011bmRhcmkgTmFnbSBVbmtub3duIFp6enpcIjtcblxudmFyIHVuaWNvZGVTY3JpcHRWYWx1ZXMgPSB7XG4gIDk6IGVjbWE5U2NyaXB0VmFsdWVzLFxuICAxMDogZWNtYTEwU2NyaXB0VmFsdWVzLFxuICAxMTogZWNtYTExU2NyaXB0VmFsdWVzLFxuICAxMjogZWNtYTEyU2NyaXB0VmFsdWVzLFxuICAxMzogZWNtYTEzU2NyaXB0VmFsdWVzLFxuICAxNDogZWNtYTE0U2NyaXB0VmFsdWVzXG59O1xuXG52YXIgZGF0YSA9IHt9O1xuZnVuY3Rpb24gYnVpbGRVbmljb2RlRGF0YShlY21hVmVyc2lvbikge1xuICB2YXIgZCA9IGRhdGFbZWNtYVZlcnNpb25dID0ge1xuICAgIGJpbmFyeTogd29yZHNSZWdleHAodW5pY29kZUJpbmFyeVByb3BlcnRpZXNbZWNtYVZlcnNpb25dICsgXCIgXCIgKyB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICBiaW5hcnlPZlN0cmluZ3M6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzW2VjbWFWZXJzaW9uXSksXG4gICAgbm9uQmluYXJ5OiB7XG4gICAgICBHZW5lcmFsX0NhdGVnb3J5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICAgIFNjcmlwdDogd29yZHNSZWdleHAodW5pY29kZVNjcmlwdFZhbHVlc1tlY21hVmVyc2lvbl0pXG4gICAgfVxuICB9O1xuICBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcblxuICBkLm5vbkJpbmFyeS5nYyA9IGQubm9uQmluYXJ5LkdlbmVyYWxfQ2F0ZWdvcnk7XG4gIGQubm9uQmluYXJ5LnNjID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuICBkLm5vbkJpbmFyeS5zY3ggPSBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucztcbn1cblxuZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBbOSwgMTAsIDExLCAxMiwgMTMsIDE0XTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgdmFyIGVjbWFWZXJzaW9uID0gbGlzdFtpXTtcblxuICBidWlsZFVuaWNvZGVEYXRhKGVjbWFWZXJzaW9uKTtcbn1cblxudmFyIHBwJDEgPSBQYXJzZXIucHJvdG90eXBlO1xuXG52YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgPyBcImRcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE1ID8gXCJ2XCIgOiBcIlwiKTtcbiAgdGhpcy51bmljb2RlUHJvcGVydGllcyA9IGRhdGFbcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTQgPyAxNCA6IHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uXTtcbiAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICB0aGlzLmZsYWdzID0gXCJcIjtcbiAgdGhpcy5zdGFydCA9IDA7XG4gIHRoaXMuc3dpdGNoVSA9IGZhbHNlO1xuICB0aGlzLnN3aXRjaFYgPSBmYWxzZTtcbiAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgdGhpcy5ncm91cE5hbWVzID0gW107XG4gIHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzID0gW107XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICB2YXIgdW5pY29kZVNldHMgPSBmbGFncy5pbmRleE9mKFwidlwiKSAhPT0gLTE7XG4gIHZhciB1bmljb2RlID0gZmxhZ3MuaW5kZXhPZihcInVcIikgIT09IC0xO1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQgfCAwO1xuICB0aGlzLnNvdXJjZSA9IHBhdHRlcm4gKyBcIlwiO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIGlmICh1bmljb2RlU2V0cyAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDE1KSB7XG4gICAgdGhpcy5zd2l0Y2hVID0gdHJ1ZTtcbiAgICB0aGlzLnN3aXRjaFYgPSB0cnVlO1xuICAgIHRoaXMuc3dpdGNoTiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zd2l0Y2hVID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgdGhpcy5zd2l0Y2hWID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG4gIH1cbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmFpc2UgPSBmdW5jdGlvbiByYWlzZSAobWVzc2FnZSkge1xuICB0aGlzLnBhcnNlci5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIChcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvXCIgKyAodGhpcy5zb3VyY2UpICsgXCIvOiBcIiArIG1lc3NhZ2UpKTtcbn07XG5cbi8vIElmIHUgZmxhZyBpcyBnaXZlbiwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBpbmRleCAoaXQgY29tYmluZXMgYSBzdXJyb2dhdGUgcGFpcikuXG4vLyBPdGhlcndpc2UsIHRoaXMgcmV0dXJucyB0aGUgY29kZSB1bml0IG9mIHRoZSBpbmRleCAoY2FuIGJlIGEgcGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyKS5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaSwgZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gIHZhciBsID0gcy5sZW5ndGg7XG4gIGlmIChpID49IGwpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgaWYgKCEoZm9yY2VVIHx8IHRoaXMuc3dpdGNoVSkgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCkge1xuICAgIHJldHVybiBjXG4gIH1cbiAgdmFyIG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICByZXR1cm4gbmV4dCA+PSAweERDMDAgJiYgbmV4dCA8PSAweERGRkYgPyAoYyA8PCAxMCkgKyBuZXh0IC0gMHgzNUZEQzAwIDogY1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5uZXh0SW5kZXggPSBmdW5jdGlvbiBuZXh0SW5kZXggKGksIGZvcmNlVSkge1xuICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICB2YXIgbCA9IHMubGVuZ3RoO1xuICBpZiAoaSA+PSBsKSB7XG4gICAgcmV0dXJuIGxcbiAgfVxuICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKSwgbmV4dDtcbiAgaWYgKCEoZm9yY2VVIHx8IHRoaXMuc3dpdGNoVSkgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCB8fFxuICAgICAgKG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4REMwMCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgcmV0dXJuIGkgKyAxXG4gIH1cbiAgcmV0dXJuIGkgKyAyXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50IChmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5wb3MsIGZvcmNlVSlcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkIChmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5uZXh0SW5kZXgodGhpcy5wb3MsIGZvcmNlVSksIGZvcmNlVSlcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2UgKGZvcmNlVSkge1xuICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICB0aGlzLnBvcyA9IHRoaXMubmV4dEluZGV4KHRoaXMucG9zLCBmb3JjZVUpO1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKGNoLCBmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuY3VycmVudChmb3JjZVUpID09PSBjaCkge1xuICAgIHRoaXMuYWR2YW5jZShmb3JjZVUpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmVhdENoYXJzID0gZnVuY3Rpb24gZWF0Q2hhcnMgKGNocywgZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBjaHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGNoID0gbGlzdFtpXTtcblxuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmF0KHBvcywgZm9yY2VVKTtcbiAgICBpZiAoY3VycmVudCA9PT0gLTEgfHwgY3VycmVudCAhPT0gY2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBwb3MgPSB0aGlzLm5leHRJbmRleChwb3MsIGZvcmNlVSk7XG4gIH1cbiAgdGhpcy5wb3MgPSBwb3M7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBmbGFncyBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5wcCQxLnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgdmFsaWRGbGFncyA9IHN0YXRlLnZhbGlkRmxhZ3M7XG4gIHZhciBmbGFncyA9IHN0YXRlLmZsYWdzO1xuXG4gIHZhciB1ID0gZmFsc2U7XG4gIHZhciB2ID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgIGlmICh2YWxpZEZsYWdzLmluZGV4T2YoZmxhZykgPT09IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgfVxuICAgIGlmIChmbGFncy5pbmRleE9mKGZsYWcsIGkgKyAxKSA+IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gICAgaWYgKGZsYWcgPT09IFwidVwiKSB7IHUgPSB0cnVlOyB9XG4gICAgaWYgKGZsYWcgPT09IFwidlwiKSB7IHYgPSB0cnVlOyB9XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxNSAmJiB1ICYmIHYpIHtcbiAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHBhdHRlcm4gcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gKlxuICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xucHAkMS52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcblxuICAvLyBUaGUgZ29hbCBzeW1ib2wgZm9yIHRoZSBwYXJzZSBpcyB8UGF0dGVyblt+VSwgfk5dfC4gSWYgdGhlIHJlc3VsdCBvZlxuICAvLyBwYXJzaW5nIGNvbnRhaW5zIGEgfEdyb3VwTmFtZXwsIHJlcGFyc2Ugd2l0aCB0aGUgZ29hbCBzeW1ib2xcbiAgLy8gfFBhdHRlcm5bflUsICtOXXwgYW5kIHVzZSB0aGlzIHJlc3VsdCBpbnN0ZWFkLiBUaHJvdyBhICpTeW50YXhFcnJvcipcbiAgLy8gZXhjZXB0aW9uIGlmIF9QXyBkaWQgbm90IGNvbmZvcm0gdG8gdGhlIGdyYW1tYXIsIGlmIGFueSBlbGVtZW50cyBvZiBfUF9cbiAgLy8gd2VyZSBub3QgbWF0Y2hlZCBieSB0aGUgcGFyc2UsIG9yIGlmIGFueSBFYXJseSBFcnJvciBjb25kaXRpb25zIGV4aXN0LlxuICBpZiAoIXN0YXRlLnN3aXRjaE4gJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgc3RhdGUuc3dpdGNoTiA9IHRydWU7XG4gICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5cbnBwJDEucmVnZXhwX3BhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5wb3MgPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID0gMDtcbiAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG5cbiAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuXG4gIGlmIChzdGF0ZS5wb3MgIT09IHN0YXRlLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2VzIGFzIFY4LlxuICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJVbm1hdGNoZWQgJyknXCIpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogXSAqLykgfHwgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGUubWF4QmFja1JlZmVyZW5jZSA+IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCBjYXB0dXJlIHJlZmVyZW5jZWRcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EaXNqdW5jdGlvblxucHAkMS5yZWdleHBfZGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgfVxuXG4gIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgfVxuICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQWx0ZXJuYXRpdmVcbnBwJDEucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXRlLnNvdXJjZS5sZW5ndGggJiYgdGhpcy5yZWdleHBfZWF0VGVybShzdGF0ZSkpXG4gICAgeyB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItVGVybVxucHAkMS5yZWdleHBfZWF0VGVybSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oc3RhdGUpKSB7XG4gICAgLy8gSGFuZGxlIGBRdWFudGlmaWFibGVBc3NlcnRpb24gUXVhbnRpZmllcmAgYWx0ZXJuYXRpdmUuXG4gICAgLy8gYHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZWAgaXMgdHJ1ZSBpZiB0aGUgbGFzdCBlYXRlbiBBc3NlcnRpb25cbiAgICAvLyBpcyBhIFF1YW50aWZpYWJsZUFzc2VydGlvbi5cbiAgICBpZiAoc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlICYmIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcXVhbnRpZmllclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdGF0ZS5zd2l0Y2hVID8gdGhpcy5yZWdleHBfZWF0QXRvbShzdGF0ZSkgOiB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20oc3RhdGUpKSB7XG4gICAgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUFzc2VydGlvblxucHAkMS5yZWdleHBfZWF0QXNzZXJ0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcblxuICAvLyBeLCAkXG4gIGlmIChzdGF0ZS5lYXQoMHg1RSAvKiBeICovKSB8fCBzdGF0ZS5lYXQoMHgyNCAvKiAkICovKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBcXGIgXFxCXG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NDIgLyogQiAqLykgfHwgc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgLy8gTG9va2FoZWFkIC8gTG9va2JlaGluZFxuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykgJiYgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICB2YXIgbG9va2JlaGluZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgbG9va2JlaGluZCA9IHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4M0QgLyogPSAqLykgfHwgc3RhdGUuZWF0KDB4MjEgLyogISAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmICghc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSAhbG9va2JlaGluZDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclxucHAkMS5yZWdleHBfZWF0UXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIGlmICggbm9FcnJvciA9PT0gdm9pZCAwICkgbm9FcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4KHN0YXRlLCBub0Vycm9yKSkge1xuICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyUHJlZml4XG5wcCQxLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4ID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyQSAvKiAqICovKSB8fFxuICAgIHN0YXRlLmVhdCgweDJCIC8qICsgKi8pIHx8XG4gICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCBub0Vycm9yKVxuICApXG59O1xucHAkMS5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgdmFyIG1pbiA9IDAsIG1heCA9IC0xO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgbWluID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDJDIC8qICwgKi8pICYmIHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgIG1heCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICAvLyBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLXRlcm1cbiAgICAgICAgaWYgKG1heCAhPT0gLTEgJiYgbWF4IDwgbWluICYmICFub0Vycm9yKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmICFub0Vycm9yKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkluY29tcGxldGUgcXVhbnRpZmllclwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BdG9tXG5wcCQxLnJlZ2V4cF9lYXRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyhzdGF0ZSkgfHxcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKVxuICApXG59O1xucHAkMS5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEF0b21Fc2NhcGUoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQxLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgJiYgc3RhdGUuZWF0KDB4M0EgLyogOiAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDEucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICB0aGlzLnJlZ2V4cF9ncm91cFNwZWNpZmllcihzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgLyogPyAqLykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgIH1cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgKz0gMTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkQXRvbVxucHAkMS5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUludmFsaWRCcmFjZWRRdWFudGlmaWVyXG5wcCQxLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1TeW50YXhDaGFyYWN0ZXJcbnBwJDEucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzU3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4MjQgLyogJCAqLyB8fFxuICAgIGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8gfHxcbiAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgY2ggPT09IDB4M0YgLyogPyAqLyB8fFxuICAgIGNoID49IDB4NUIgLyogWyAqLyAmJiBjaCA8PSAweDVFIC8qIF4gKi8gfHxcbiAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVybkNoYXJhY3RlclxuLy8gQnV0IGVhdCBlYWdlci5cbnBwJDEucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgIWlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkUGF0dGVybkNoYXJhY3RlclxucHAkMS5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoXG4gICAgY2ggIT09IC0xICYmXG4gICAgY2ggIT09IDB4MjQgLyogJCAqLyAmJlxuICAgICEoY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLykgJiZcbiAgICBjaCAhPT0gMHgyRSAvKiAuICovICYmXG4gICAgY2ggIT09IDB4M0YgLyogPyAqLyAmJlxuICAgIGNoICE9PSAweDVCIC8qIFsgKi8gJiZcbiAgICBjaCAhPT0gMHg1RSAvKiBeICovICYmXG4gICAgY2ggIT09IDB4N0MgLyogfCAqL1xuICApIHtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIEdyb3VwU3BlY2lmaWVyIDo6XG4vLyAgIFtlbXB0eV1cbi8vICAgYD9gIEdyb3VwTmFtZVxucHAkMS5yZWdleHBfZ3JvdXBTcGVjaWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpICE9PSAtMSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5ncm91cE5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gIH1cbn07XG5cbi8vIEdyb3VwTmFtZSA6OlxuLy8gICBgPGAgUmVnRXhwSWRlbnRpZmllck5hbWUgYD5gXG4vLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbnBwJDEucmVnZXhwX2VhdEdyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIGlmIChzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0UgLyogPiAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZWdFeHBJZGVudGlmaWVyTmFtZSA6OlxuLy8gICBSZWdFeHBJZGVudGlmaWVyU3RhcnRcbi8vICAgUmVnRXhwSWRlbnRpZmllck5hbWUgUmVnRXhwSWRlbnRpZmllclBhcnRcbi8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxucHAkMS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0KHN0YXRlKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydChzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gUmVnRXhwSWRlbnRpZmllclN0YXJ0IDo6XG4vLyAgIFVuaWNvZGVJRFN0YXJ0XG4vLyAgIGAkYFxuLy8gICBgX2Bcbi8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbK1VdXG5wcCQxLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoZm9yY2VVKTtcbiAgc3RhdGUuYWR2YW5jZShmb3JjZVUpO1xuXG4gIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZvcmNlVSkpIHtcbiAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgfVxuICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkge1xuICByZXR1cm4gaXNJZGVudGlmaWVyU3RhcnQoY2gsIHRydWUpIHx8IGNoID09PSAweDI0IC8qICQgKi8gfHwgY2ggPT09IDB4NUYgLyogXyAqL1xufVxuXG4vLyBSZWdFeHBJZGVudGlmaWVyUGFydCA6OlxuLy8gICBVbmljb2RlSURDb250aW51ZVxuLy8gICBgJGBcbi8vICAgYF9gXG4vLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWytVXVxuLy8gICA8WldOSj5cbi8vICAgPFpXSj5cbnBwJDEucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgZm9yY2VVID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KGZvcmNlVSk7XG4gIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmb3JjZVUpKSB7XG4gICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gIH1cbiAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi8gfHwgY2ggPT09IDB4MjAwQyAvKiA8WldOSj4gKi8gfHwgY2ggPT09IDB4MjAwRCAvKiA8WldKPiAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXRvbUVzY2FwZVxucHAkMS5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSkgfHxcbiAgICAoc3RhdGUuc3dpdGNoTiAmJiB0aGlzLnJlZ2V4cF9lYXRLR3JvdXBOYW1lKHN0YXRlKSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDYzIC8qIGMgKi8pIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQxLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZShzdGF0ZSkpIHtcbiAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gRm9yIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtYXRvbWVzY2FwZVxuICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKG4gPD0gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQxLnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDZCIC8qIGsgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNoYXJhY3RlckVzY2FwZVxucHAkMS5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENDb250cm9sTGV0dGVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmYWxzZSkgfHxcbiAgICAoIXN0YXRlLnN3aXRjaFUgJiYgdGhpcy5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUoc3RhdGUpXG4gIClcbn07XG5wcCQxLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQxLnJlZ2V4cF9lYXRaZXJvID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzMCAvKiAwICovICYmICFpc0RlY2ltYWxEaWdpdChzdGF0ZS5sb29rYWhlYWQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbEVzY2FwZVxucHAkMS5yZWdleHBfZWF0Q29udHJvbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoID09PSAweDc0IC8qIHQgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA5OyAvKiBcXHQgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NkUgLyogbiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEE7IC8qIFxcbiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg3NiAvKiB2ICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQjsgLyogXFx2ICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDY2IC8qIGYgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBDOyAvKiBcXGYgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NzIgLyogciAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEQ7IC8qIFxcciAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbExldHRlclxucHAkMS5yZWdleHBfZWF0Q29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzQ29udHJvbExldHRlcihjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNDb250cm9sTGV0dGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDVBIC8qIFogKi8pIHx8XG4gICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDdBIC8qIHogKi8pXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlXG5wcCQxLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSwgZm9yY2VVKSB7XG4gIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBzd2l0Y2hVID0gZm9yY2VVIHx8IHN0YXRlLnN3aXRjaFU7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgdmFyIGxlYWQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3dpdGNoVSAmJiBsZWFkID49IDB4RDgwMCAmJiBsZWFkIDw9IDB4REJGRikge1xuICAgICAgICB2YXIgbGVhZFN1cnJvZ2F0ZUVuZCA9IHN0YXRlLnBvcztcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSAmJiBzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgICB2YXIgdHJhaWwgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgICAgaWYgKHRyYWlsID49IDB4REMwMCAmJiB0cmFpbCA8PSAweERGRkYpIHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgPSBsZWFkU3Vycm9nYXRlRW5kO1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBsZWFkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKFxuICAgICAgc3dpdGNoVSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgIHRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhzdGF0ZSkgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pICYmXG4gICAgICBpc1ZhbGlkVW5pY29kZShzdGF0ZS5sYXN0SW50VmFsdWUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3dpdGNoVSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzVmFsaWRVbmljb2RlKGNoKSB7XG4gIHJldHVybiBjaCA+PSAwICYmIGNoIDw9IDB4MTBGRkZGXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JZGVudGl0eUVzY2FwZVxucHAkMS5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4MkYgLyogLyAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkY7IC8qIC8gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggIT09IDB4NjMgLyogYyAqLyAmJiAoIXN0YXRlLnN3aXRjaE4gfHwgY2ggIT09IDB4NkIgLyogayAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbEVzY2FwZVxucHAkMS5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoID49IDB4MzEgLyogMSAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICBkbyB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfSB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZXR1cm4gdmFsdWVzIHVzZWQgYnkgY2hhcmFjdGVyIHNldCBwYXJzaW5nIG1ldGhvZHMsIG5lZWRlZCB0b1xuLy8gZm9yYmlkIG5lZ2F0aW9uIG9mIHNldHMgdGhhdCBjYW4gbWF0Y2ggc3RyaW5ncy5cbnZhciBDaGFyU2V0Tm9uZSA9IDA7IC8vIE5vdGhpbmcgcGFyc2VkXG52YXIgQ2hhclNldE9rID0gMTsgLy8gQ29uc3RydWN0IHBhcnNlZCwgY2Fubm90IGNvbnRhaW4gc3RyaW5nc1xudmFyIENoYXJTZXRTdHJpbmcgPSAyOyAvLyBDb25zdHJ1Y3QgcGFyc2VkLCBjYW4gY29udGFpbiBzdHJpbmdzXG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzRXNjYXBlXG5wcCQxLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcblxuICBpZiAoaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIENoYXJTZXRPa1xuICB9XG5cbiAgdmFyIG5lZ2F0ZSA9IGZhbHNlO1xuICBpZiAoXG4gICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmXG4gICAgKChuZWdhdGUgPSBjaCA9PT0gMHg1MCAvKiBQICovKSB8fCBjaCA9PT0gMHg3MCAvKiBwICovKVxuICApIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgKHJlc3VsdCA9IHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihzdGF0ZSkpICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKVxuICAgICkge1xuICAgICAgaWYgKG5lZ2F0ZSAmJiByZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gIH1cblxuICByZXR1cm4gQ2hhclNldE5vbmVcbn07XG5cbmZ1bmN0aW9uIGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpIHtcbiAgcmV0dXJuIChcbiAgICBjaCA9PT0gMHg2NCAvKiBkICovIHx8XG4gICAgY2ggPT09IDB4NDQgLyogRCAqLyB8fFxuICAgIGNoID09PSAweDczIC8qIHMgKi8gfHxcbiAgICBjaCA9PT0gMHg1MyAvKiBTICovIHx8XG4gICAgY2ggPT09IDB4NzcgLyogdyAqLyB8fFxuICAgIGNoID09PSAweDU3IC8qIFcgKi9cbiAgKVxufVxuXG4vLyBVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gOjpcbi8vICAgVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbi8vICAgTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG5wcCQxLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbiAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNEIC8qID0gKi8pKSB7XG4gICAgdmFyIG5hbWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoc3RhdGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybiBDaGFyU2V0T2tcbiAgICB9XG4gIH1cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG5cbiAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUpKSB7XG4gICAgdmFyIG5hbWVPclZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgIHJldHVybiB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlLCBuYW1lT3JWYWx1ZSlcbiAgfVxuICByZXR1cm4gQ2hhclNldE5vbmVcbn07XG5cbnBwJDEucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaGFzT3duKHN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeSwgbmFtZSkpXG4gICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeVtuYW1lXS50ZXN0KHZhbHVlKSlcbiAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZVwiKTsgfVxufTtcblxucHAkMS5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lT3JWYWx1ZSkge1xuICBpZiAoc3RhdGUudW5pY29kZVByb3BlcnRpZXMuYmluYXJ5LnRlc3QobmFtZU9yVmFsdWUpKSB7IHJldHVybiBDaGFyU2V0T2sgfVxuICBpZiAoc3RhdGUuc3dpdGNoViAmJiBzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnlPZlN0cmluZ3MudGVzdChuYW1lT3JWYWx1ZSkpIHsgcmV0dXJuIENoYXJTZXRTdHJpbmcgfVxuICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbn07XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcnNcbnBwJDEucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbn07XG5cbmZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkge1xuICByZXR1cm4gaXNDb250cm9sTGV0dGVyKGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG59XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eVZhbHVlIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xucHAkMS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG59O1xuZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCkge1xuICByZXR1cm4gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB8fCBpc0RlY2ltYWxEaWdpdChjaClcbn1cblxuLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xucHAkMS5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NcbnBwJDEucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDVCIC8qIFsgKi8pKSB7XG4gICAgdmFyIG5lZ2F0ZSA9IHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc0NvbnRlbnRzKHN0YXRlKTtcbiAgICBpZiAoIXN0YXRlLmVhdCgweDVEIC8qIF0gKi8pKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3NcIik7IH1cbiAgICBpZiAobmVnYXRlICYmIHJlc3VsdCA9PT0gQ2hhclNldFN0cmluZylcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJOZWdhdGVkIGNoYXJhY3RlciBjbGFzcyBtYXkgY29udGFpbiBzdHJpbmdzXCIpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzQ29udGVudHNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzUmFuZ2VzXG5wcCQxLnJlZ2V4cF9jbGFzc0NvbnRlbnRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg1RCAvKiBdICovKSB7IHJldHVybiBDaGFyU2V0T2sgfVxuICBpZiAoc3RhdGUuc3dpdGNoVikgeyByZXR1cm4gdGhpcy5yZWdleHBfY2xhc3NTZXRFeHByZXNzaW9uKHN0YXRlKSB9XG4gIHRoaXMucmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXMoc3RhdGUpO1xuICByZXR1cm4gQ2hhclNldE9rXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXG5wcCQxLnJlZ2V4cF9ub25FbXB0eUNsYXNzUmFuZ2VzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MkQgLyogLSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgKGxlZnQgPT09IC0xIHx8IHJpZ2h0ID09PSAtMSkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICE9PSAtMSAmJiByaWdodCAhPT0gLTEgJiYgbGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbVxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tTm9EYXNoXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc0F0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICB2YXIgY2gkMSA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgIGlmIChjaCQxID09PSAweDYzIC8qIGMgKi8gfHwgaXNPY3RhbERpZ2l0KGNoJDEpKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjbGFzcyBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoICE9PSAweDVEIC8qIF0gKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzRXNjYXBlXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyAvKiA8QlM+ICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRDsgLyogLSAqL1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoIXN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTZXRFeHByZXNzaW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1VuaW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc0ludGVyc2VjdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdWJ0cmFjdGlvblxucHAkMS5yZWdleHBfY2xhc3NTZXRFeHByZXNzaW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IENoYXJTZXRPaywgc3ViUmVzdWx0O1xuICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRSYW5nZShzdGF0ZSkpIDsgZWxzZSBpZiAoc3ViUmVzdWx0ID0gdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKHN0YXRlKSkge1xuICAgIGlmIChzdWJSZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldFN0cmluZzsgfVxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzSW50ZXJzZWN0aW9uXG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHdoaWxlIChzdGF0ZS5lYXRDaGFycyhbMHgyNiwgMHgyNl0gLyogJiYgKi8pKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLmN1cnJlbnQoKSAhPT0gMHgyNiAvKiAmICovICYmXG4gICAgICAgIChzdWJSZXN1bHQgPSB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoc3RhdGUpKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChzdWJSZXN1bHQgIT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldE9rOyB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICE9PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdWJ0cmFjdGlvblxuICAgIHdoaWxlIChzdGF0ZS5lYXRDaGFycyhbMHgyRCwgMHgyRF0gLyogLS0gKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKHN0YXRlKSkgeyBjb250aW51ZSB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICE9PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIHJlc3VsdCB9XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gIH1cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NVbmlvblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzU2V0UmFuZ2Uoc3RhdGUpKSB7IGNvbnRpbnVlIH1cbiAgICBzdWJSZXN1bHQgPSB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoc3RhdGUpO1xuICAgIGlmICghc3ViUmVzdWx0KSB7IHJldHVybiByZXN1bHQgfVxuICAgIGlmIChzdWJSZXN1bHQgPT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldFN0cmluZzsgfVxuICB9XG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldFJhbmdlXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc1NldFJhbmdlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgdmFyIGxlZnQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pICYmIHRoaXMucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyKHN0YXRlKSkge1xuICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldE9wZXJhbmRcbnBwJDEucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHsgcmV0dXJuIENoYXJTZXRPayB9XG4gIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRDbGFzc1N0cmluZ0Rpc2p1bmN0aW9uKHN0YXRlKSB8fCB0aGlzLnJlZ2V4cF9lYXROZXN0ZWRDbGFzcyhzdGF0ZSlcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLU5lc3RlZENsYXNzXG5wcCQxLnJlZ2V4cF9lYXROZXN0ZWRDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDVCIC8qIFsgKi8pKSB7XG4gICAgdmFyIG5lZ2F0ZSA9IHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc0NvbnRlbnRzKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogXSAqLykpIHtcbiAgICAgIGlmIChuZWdhdGUgJiYgcmVzdWx0ID09PSBDaGFyU2V0U3RyaW5nKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiTmVnYXRlZCBjaGFyYWN0ZXIgY2xhc3MgbWF5IGNvbnRhaW4gc3RyaW5nc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIHZhciByZXN1bHQkMSA9IHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKTtcbiAgICBpZiAocmVzdWx0JDEpIHtcbiAgICAgIHJldHVybiByZXN1bHQkMVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3Byb2QtQ2xhc3NTdHJpbmdEaXNqdW5jdGlvblxucHAkMS5yZWdleHBfZWF0Q2xhc3NTdHJpbmdEaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdENoYXJzKFsweDVDLCAweDcxXSAvKiBcXHEgKi8pKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWdleHBfY2xhc3NTdHJpbmdEaXNqdW5jdGlvbkNvbnRlbnRzKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBudWxsXG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHNcbnBwJDEucmVnZXhwX2NsYXNzU3RyaW5nRGlzanVuY3Rpb25Db250ZW50cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4cF9jbGFzc1N0cmluZyhzdGF0ZSk7XG4gIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9jbGFzc1N0cmluZyhzdGF0ZSkgPT09IENoYXJTZXRTdHJpbmcpIHsgcmVzdWx0ID0gQ2hhclNldFN0cmluZzsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU3RyaW5nXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1Ob25FbXB0eUNsYXNzU3RyaW5nXG5wcCQxLnJlZ2V4cF9jbGFzc1N0cmluZyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihzdGF0ZSkpIHsgY291bnQrKzsgfVxuICByZXR1cm4gY291bnQgPT09IDEgPyBDaGFyU2V0T2sgOiBDaGFyU2V0U3RyaW5nXG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldENoYXJhY3RlclxucHAkMS5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihzdGF0ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwODsgLyogPEJTPiAqL1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggPCAwIHx8IGNoID09PSBzdGF0ZS5sb29rYWhlYWQoKSAmJiBpc0NsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yQ2hhcmFjdGVyKGNoKSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoaXNDbGFzc1NldFN5bnRheENoYXJhY3RlcihjaCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgc3RhdGUuYWR2YW5jZSgpO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yXG5mdW5jdGlvbiBpc0NsYXNzU2V0UmVzZXJ2ZWREb3VibGVQdW5jdHVhdG9yQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4MjEgLyogISAqLyB8fFxuICAgIGNoID49IDB4MjMgLyogIyAqLyAmJiBjaCA8PSAweDI2IC8qICYgKi8gfHxcbiAgICBjaCA+PSAweDJBIC8qICogKi8gJiYgY2ggPD0gMHgyQyAvKiAsICovIHx8XG4gICAgY2ggPT09IDB4MkUgLyogLiAqLyB8fFxuICAgIGNoID49IDB4M0EgLyogOiAqLyAmJiBjaCA8PSAweDQwIC8qIEAgKi8gfHxcbiAgICBjaCA9PT0gMHg1RSAvKiBeICovIHx8XG4gICAgY2ggPT09IDB4NjAgLyogYCAqLyB8fFxuICAgIGNoID09PSAweDdFIC8qIH4gKi9cbiAgKVxufVxuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldFN5bnRheENoYXJhY3RlclxuZnVuY3Rpb24gaXNDbGFzc1NldFN5bnRheENoYXJhY3RlcihjaCkge1xuICByZXR1cm4gKFxuICAgIGNoID09PSAweDI4IC8qICggKi8gfHxcbiAgICBjaCA9PT0gMHgyOSAvKiApICovIHx8XG4gICAgY2ggPT09IDB4MkQgLyogLSAqLyB8fFxuICAgIGNoID09PSAweDJGIC8qIC8gKi8gfHxcbiAgICBjaCA+PSAweDVCIC8qIFsgKi8gJiYgY2ggPD0gMHg1RCAvKiBdICovIHx8XG4gICAgY2ggPj0gMHg3QiAvKiB7ICovICYmIGNoIDw9IDB4N0QgLyogfSAqL1xuICApXG59XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNwcm9kLUNsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzQ2xhc3NTZXRSZXNlcnZlZFB1bmN0dWF0b3IoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jcHJvZC1DbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvclxuZnVuY3Rpb24gaXNDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihjaCkge1xuICByZXR1cm4gKFxuICAgIGNoID09PSAweDIxIC8qICEgKi8gfHxcbiAgICBjaCA9PT0gMHgyMyAvKiAjICovIHx8XG4gICAgY2ggPT09IDB4MjUgLyogJSAqLyB8fFxuICAgIGNoID09PSAweDI2IC8qICYgKi8gfHxcbiAgICBjaCA9PT0gMHgyQyAvKiAsICovIHx8XG4gICAgY2ggPT09IDB4MkQgLyogLSAqLyB8fFxuICAgIGNoID49IDB4M0EgLyogOiAqLyAmJiBjaCA8PSAweDNFIC8qID4gKi8gfHxcbiAgICBjaCA9PT0gMHg0MCAvKiBAICovIHx8XG4gICAgY2ggPT09IDB4NjAgLyogYCAqLyB8fFxuICAgIGNoID09PSAweDdFIC8qIH4gKi9cbiAgKVxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NDb250cm9sTGV0dGVyXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc0RlY2ltYWxEaWdpdChjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQxLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDc4IC8qIHggKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbERpZ2l0c1xucHAkMS5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5mdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdHNcbnBwJDEucmVnZXhwX2VhdEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzSGV4RGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICByZXR1cm4gKFxuICAgIChjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB8fFxuICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB8fFxuICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKVxuICApXG59XG5mdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICBpZiAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgLyogQSAqLylcbiAgfVxuICBpZiAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgLyogYSAqLylcbiAgfVxuICByZXR1cm4gY2ggLSAweDMwIC8qIDAgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUxlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Vcbi8vIEFsbG93cyBvbmx5IDAtMzc3KG9jdGFsKSBpLmUuIDAtMjU1KGRlY2ltYWwpLlxucHAkMS5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgIHZhciBuMSA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgIHZhciBuMiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChuMSA8PSAzICYmIHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDggKyBuMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1PY3RhbERpZ2l0XG5wcCQxLnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgLyogMCAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzcgLyogNyAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXg0RGlnaXRzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdFxuLy8gQW5kIEhleERpZ2l0IEhleERpZ2l0IGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQxLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuLy8gdXNlZCBmb3IgdGhlIG9uVG9rZW4gY2FsbGJhY2sgYW5kIHRoZSBleHRlcm5hbCB0b2tlbml6ZXIuXG5cbnZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgdGhpcy50eXBlID0gcC50eXBlO1xuICB0aGlzLnZhbHVlID0gcC52YWx1ZTtcbiAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gIHRoaXMuZW5kID0gcC5lbmQ7XG4gIGlmIChwLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpOyB9XG4gIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwLnN0YXJ0LCBwLmVuZF07IH1cbn07XG5cbi8vICMjIFRva2VuaXplclxuXG52YXIgcHAgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBNb3ZlIHRvIHRoZSBuZXh0IHRva2VuXG5cbnBwLm5leHQgPSBmdW5jdGlvbihpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCkge1xuICBpZiAoIWlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkICYmIHRoaXMudHlwZS5rZXl3b3JkICYmIHRoaXMuY29udGFpbnNFc2MpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBcIiArIHRoaXMudHlwZS5rZXl3b3JkKTsgfVxuICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgeyB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpOyB9XG5cbiAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5lbmRMb2M7XG4gIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbn07XG5cbnBwLmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gbmV3IFRva2VuKHRoaXMpXG59O1xuXG4vLyBJZiB3ZSdyZSBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIG1ha2UgcGFyc2VycyBpdGVyYWJsZVxuaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpXG4gIHsgcHBbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzJDEkMS5nZXRUb2tlbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzJDEuZW9mLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyB9XG5cbi8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2Vcbi8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxuLy8gUmVhZCBhIHNpbmdsZSB0b2tlbiwgdXBkYXRpbmcgdGhlIHBhcnNlciBvYmplY3QncyB0b2tlbi1yZWxhdGVkXG4vLyBwcm9wZXJ0aWVzLlxuXG5wcC5uZXh0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHsgdGhpcy5za2lwU3BhY2UoKTsgfVxuXG4gIHRoaXMuc3RhcnQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5zdGFydExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5lb2YpIH1cblxuICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gIGVsc2UgeyB0aGlzLnJlYWRUb2tlbih0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpOyB9XG59O1xuXG5wcC5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSB7XG4gIC8vIElkZW50aWZpZXIgb3Iga2V5d29yZC4gJ1xcdVhYWFgnIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCBpblxuICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKVxuICAgIHsgcmV0dXJuIHRoaXMucmVhZFdvcmQoKSB9XG5cbiAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKVxufTtcblxucHAuZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGRjMDApIHsgcmV0dXJuIGNvZGUgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICByZXR1cm4gbmV4dCA8PSAweGRiZmYgfHwgbmV4dCA+PSAweGUwMDAgPyBjb2RlIDogKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxufTtcblxucHAuc2tpcEJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICBpZiAoZW5kID09PSAtMSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTsgfVxuICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgZm9yICh2YXIgbmV4dEJyZWFrID0gKHZvaWQgMCksIHBvcyA9IHN0YXJ0OyAobmV4dEJyZWFrID0gbmV4dExpbmVCcmVhayh0aGlzLmlucHV0LCBwb3MsIHRoaXMucG9zKSkgPiAtMTspIHtcbiAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgcG9zID0gdGhpcy5saW5lU3RhcnQgPSBuZXh0QnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudCh0cnVlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbn07XG5cbnBwLnNraXBMaW5lQ29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0U2tpcCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArPSBzdGFydFNraXApO1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuLy8gd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGFuZC5cblxucHAuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAzMjogY2FzZSAxNjA6IC8vICcgJ1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxMzpcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICBjYXNlIDEwOiBjYXNlIDgyMzI6IGNhc2UgODIzMzpcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpKSB7XG4gICAgICBjYXNlIDQyOiAvLyAnKidcbiAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrIGxvb3BcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbi8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbi8vIHRoZSB0b2tlbiwgc28gdGhhdCB0aGUgbmV4dCBvbmUncyBgc3RhcnRgIHdpbGwgcG9pbnQgYXQgdGhlXG4vLyByaWdodCBwb3NpdGlvbi5cblxucHAuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIHtcbiAgdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG59O1xuXG4vLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4vLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbi8vIGlzIHNvbWV3aGF0IG9ic2N1cmUsIGJlY2F1c2UgaXQgd29ya3MgaW4gY2hhcmFjdGVyIGNvZGVzIHJhdGhlclxuLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbi8vIGludG8gaXQuXG4vL1xuLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuLy9cbnBwLnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgdGhpcy5wb3MgKz0gMztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmVsbGlwc2lzKVxuICB9IGVsc2Uge1xuICAgICsrdGhpcy5wb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5kb3QpXG4gIH1cbn07XG5cbnBwLnJlYWRUb2tlbl9zbGFzaCA9IGZ1bmN0aW9uKCkgeyAvLyAnLydcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuc2xhc2gsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnJSonXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHZhciBzaXplID0gMTtcbiAgdmFyIHRva2VudHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMkMS5zdGFyIDogdHlwZXMkMS5tb2R1bG87XG5cbiAgLy8gZXhwb25lbnRpYXRpb24gb3BlcmF0b3IgKiogYW5kICoqPVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICArK3NpemU7XG4gICAgdG9rZW50eXBlID0gdHlwZXMkMS5zdGFyc3RhcjtcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIHNpemUgKyAxKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbn07XG5cbnBwLnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJ3wmJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgaWYgKG5leHQyID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMykgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcyQxLmxvZ2ljYWxPUiA6IHR5cGVzJDEubG9naWNhbEFORCwgMilcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMkMS5iaXR3aXNlT1IgOiB0eXBlcyQxLmJpdHdpc2VBTkQsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbigpIHsgLy8gJ14nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmJpdHdpc2VYT1IsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbihjb2RlKSB7IC8vICcrLSdcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICBpZiAobmV4dCA9PT0gNDUgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyICYmXG4gICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5pbmNEZWMsIDIpXG4gIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucGx1c01pbiwgMSlcbn07XG5cbnBwLnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJzw+J1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5iaXRTaGlmdCwgc2l6ZSlcbiAgfVxuICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAvLyBgPCEtLWAsIGFuIFhNTC1zdHlsZSBjb21tZW50IHRoYXQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgbGluZSBjb21tZW50XG4gICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyBzaXplID0gMjsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnJlbGF0aW9uYWwsIHNpemUpXG59O1xuXG5wcC5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJz0hJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IC8vICc9PidcbiAgICB0aGlzLnBvcyArPSAyO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYXJyb3cpXG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcyQxLmVxIDogdHlwZXMkMS5wcmVmaXgsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fcXVlc3Rpb24gPSBmdW5jdGlvbigpIHsgLy8gJz8nXG4gIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgaWYgKGVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNDYpIHtcbiAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgaWYgKG5leHQyIDwgNDggfHwgbmV4dDIgPiA1NykgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnF1ZXN0aW9uRG90LCAyKSB9XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2Mykge1xuICAgICAgaWYgKGVjbWFWZXJzaW9uID49IDEyKSB7XG4gICAgICAgIHZhciBuZXh0MiQxID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiQxID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMykgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5jb2FsZXNjZSwgMilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5xdWVzdGlvbiwgMSlcbn07XG5cbnBwLnJlYWRUb2tlbl9udW1iZXJTaWduID0gZnVuY3Rpb24oKSB7IC8vICcjJ1xuICB2YXIgZWNtYVZlcnNpb24gPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb247XG4gIHZhciBjb2RlID0gMzU7IC8vICcjJ1xuICBpZiAoZWNtYVZlcnNpb24gPj0gMTMpIHtcbiAgICArK3RoaXMucG9zO1xuICAgIGNvZGUgPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRydWUpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucHJpdmF0ZUlkLCB0aGlzLnJlYWRXb3JkMSgpKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG59O1xuXG5wcC5nZXRUb2tlbkZyb21Db2RlID0gZnVuY3Rpb24oY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAvLyBieSBhIGRpZ2l0IG9yIGFub3RoZXIgdHdvIGRvdHMuXG4gIGNhc2UgNDY6IC8vICcuJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKVxuXG4gIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgY2FzZSA0MDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5wYXJlbkwpXG4gIGNhc2UgNDE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucGFyZW5SKVxuICBjYXNlIDU5OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnNlbWkpXG4gIGNhc2UgNDQ6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuY29tbWEpXG4gIGNhc2UgOTE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2tldEwpXG4gIGNhc2UgOTM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2tldFIpXG4gIGNhc2UgMTIzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJyYWNlTClcbiAgY2FzZSAxMjU6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2VSKVxuICBjYXNlIDU4OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmNvbG9uKVxuXG4gIGNhc2UgOTY6IC8vICdgJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYmFja1F1b3RlKVxuXG4gIGNhc2UgNDg6IC8vICcwJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpIH0gLy8gJzBvJywgJzBPJyAtIG9jdGFsIG51bWJlclxuICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgfVxuXG4gIC8vIEFueXRoaW5nIGVsc2UgYmVnaW5uaW5nIHdpdGggYSBkaWdpdCBpcyBhbiBpbnRlZ2VyLCBvY3RhbFxuICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiAvLyAxLTlcbiAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKVxuXG4gIC8vIFF1b3RlcyBwcm9kdWNlIHN0cmluZ3MuXG4gIGNhc2UgMzQ6IGNhc2UgMzk6IC8vICdcIicsIFwiJ1wiXG4gICAgcmV0dXJuIHRoaXMucmVhZFN0cmluZyhjb2RlKVxuXG4gIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAvLyBjaGFyYWN0ZXJzIGl0IGlzIGdpdmVuIGFzIHNlY29uZCBhcmd1bWVudCwgYW5kIHJldHVybnMgYSB0b2tlblxuICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG4gIGNhc2UgNDc6IC8vICcvJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpXG5cbiAgY2FzZSAzNzogY2FzZSA0MjogLy8gJyUqJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSlcblxuICBjYXNlIDEyNDogY2FzZSAzODogLy8gJ3wmJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKVxuXG4gIGNhc2UgOTQ6IC8vICdeJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpXG5cbiAgY2FzZSA0MzogY2FzZSA0NTogLy8gJystJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gIGNhc2UgNjA6IGNhc2UgNjI6IC8vICc8PidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICBjYXNlIDYxOiBjYXNlIDMzOiAvLyAnPSEnXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSlcblxuICBjYXNlIDYzOiAvLyAnPydcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcXVlc3Rpb24oKVxuXG4gIGNhc2UgMTI2OiAvLyAnfidcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnByZWZpeCwgMSlcblxuICBjYXNlIDM1OiAvLyAnIydcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbnVtYmVyU2lnbigpXG4gIH1cblxuICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xufTtcblxucHAuZmluaXNoT3AgPSBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG4gIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpO1xuICB0aGlzLnBvcyArPSBzaXplO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpXG59O1xuXG5wcC5yZWFkUmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICArK3RoaXMucG9zO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICArK3RoaXMucG9zO1xuICB2YXIgZmxhZ3NTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgZmxhZ3MgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnVuZXhwZWN0ZWQoZmxhZ3NTdGFydCk7IH1cblxuICAvLyBWYWxpZGF0ZSBwYXR0ZXJuXG4gIHZhciBzdGF0ZSA9IHRoaXMucmVnZXhwU3RhdGUgfHwgKHRoaXMucmVnZXhwU3RhdGUgPSBuZXcgUmVnRXhwVmFsaWRhdGlvblN0YXRlKHRoaXMpKTtcbiAgc3RhdGUucmVzZXQoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKTtcbiAgdGhpcy52YWxpZGF0ZVJlZ0V4cEZsYWdzKHN0YXRlKTtcbiAgdGhpcy52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4oc3RhdGUpO1xuXG4gIC8vIENyZWF0ZSBMaXRlcmFsI3ZhbHVlIHByb3BlcnR5IHZhbHVlLlxuICB2YXIgdmFsdWUgPSBudWxsO1xuICB0cnkge1xuICAgIHZhbHVlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFU1RyZWUgcmVxdWlyZXMgbnVsbCBpZiBpdCBmYWlsZWQgdG8gaW5zdGFudGlhdGUgUmVnRXhwIG9iamVjdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXN0cmVlL2VzdHJlZS9ibG9iL2EyNzAwM2FkZjRmZDdiZmFkNDRkZTljZWYzNzJhMmVhY2Q1MjdiMWMvZXM1Lm1kI3JlZ2V4cGxpdGVyYWxcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucmVnZXhwLCB7cGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzLCB2YWx1ZTogdmFsdWV9KVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyIGluIHRoZSBnaXZlbiByYWRpeC4gUmV0dXJuIG51bGwgaWYgemVybyBkaWdpdHNcbi8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4vLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxucHAucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4sIG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAvLyBgbGVuYCBpcyB1c2VkIGZvciBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcy4gSW4gdGhhdCBjYXNlLCBkaXNhbGxvdyBzZXBhcmF0b3JzLlxuICB2YXIgYWxsb3dTZXBhcmF0b3JzID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEyICYmIGxlbiA9PT0gdW5kZWZpbmVkO1xuXG4gIC8vIGBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWxgIGlzIHRydWUgaWYgaXQgZG9lc24ndCBoYXZlIHByZWZpeCAoMHgsMG8sMGIpXG4gIC8vIGFuZCBpc24ndCBmcmFjdGlvbiBwYXJ0IG5vciBleHBvbmVudCBwYXJ0LiBJbiB0aGF0IGNhc2UsIGlmIHRoZSBmaXJzdCBkaWdpdFxuICAvLyBpcyB6ZXJvIHRoZW4gZGlzYWxsb3cgc2VwYXJhdG9ycy5cbiAgdmFyIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCA9IG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSA0ODtcblxuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwLCBsYXN0Q29kZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSwgKyt0aGlzLnBvcykge1xuICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgdmFsID0gKHZvaWQgMCk7XG5cbiAgICBpZiAoYWxsb3dTZXBhcmF0b3JzICYmIGNvZGUgPT09IDk1KSB7XG4gICAgICBpZiAoaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBpbiBsZWdhY3kgb2N0YWwgbnVtZXJpYyBsaXRlcmFsc1wiKTsgfVxuICAgICAgaWYgKGxhc3RDb2RlID09PSA5NSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgbXVzdCBiZSBleGFjdGx5IG9uZSB1bmRlcnNjb3JlXCIpOyB9XG4gICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgYXQgdGhlIGZpcnN0IG9mIGRpZ2l0c1wiKTsgfVxuICAgICAgbGFzdENvZGUgPSBjb2RlO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSA5NykgeyB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgfSAvLyBhXG4gICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgeyB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgfSAvLyBBXG4gICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICBlbHNlIHsgdmFsID0gSW5maW5pdHk7IH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICB9XG5cbiAgaWYgKGFsbG93U2VwYXJhdG9ycyAmJiBsYXN0Q29kZSA9PT0gOTUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zIC0gMSwgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgbGFzdCBvZiBkaWdpdHNcIik7IH1cbiAgaWYgKHRoaXMucG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0aGlzLnBvcyAtIHN0YXJ0ICE9PSBsZW4pIHsgcmV0dXJuIG51bGwgfVxuXG4gIHJldHVybiB0b3RhbFxufTtcblxuZnVuY3Rpb24gc3RyaW5nVG9OdW1iZXIoc3RyLCBpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgaWYgKGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgIHJldHVybiBwYXJzZUludChzdHIsIDgpXG4gIH1cblxuICAvLyBgcGFyc2VGbG9hdCh2YWx1ZSlgIHN0b3BzIHBhcnNpbmcgYXQgdGhlIGZpcnN0IG51bWVyaWMgc2VwYXJhdG9yIHRoZW4gcmV0dXJucyBhIHdyb25nIHZhbHVlLlxuICByZXR1cm4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9CaWdJbnQoc3RyKSB7XG4gIGlmICh0eXBlb2YgQmlnSW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gYEJpZ0ludCh2YWx1ZSlgIHRocm93cyBzeW50YXggZXJyb3IgaWYgdGhlIHN0cmluZyBjb250YWlucyBudW1lcmljIHNlcGFyYXRvcnMuXG4gIHJldHVybiBCaWdJbnQoc3RyLnJlcGxhY2UoL18vZywgXCJcIikpXG59XG5cbnBwLnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICB0aGlzLnBvcyArPSAyOyAvLyAweFxuICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgaWYgKHZhbCA9PSBudWxsKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCArIDIsIFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4IFwiICsgcmFkaXgpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTEwKSB7XG4gICAgdmFsID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICArK3RoaXMucG9zO1xuICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLm51bSwgdmFsKVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbnBwLnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwLCB1bmRlZmluZWQsIHRydWUpID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICBpZiAob2N0YWwgJiYgdGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIGlmICghb2N0YWwgJiYgIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIG5leHQgPT09IDExMCkge1xuICAgIHZhciB2YWwkMSA9IHN0cmluZ1RvQmlnSW50KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5udW0sIHZhbCQxKVxuICB9XG4gIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyAvLyAnLidcbiAgICArK3RoaXMucG9zO1xuICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSAvLyAnKy0nXG4gICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICB2YXIgdmFsID0gc3RyaW5nVG9OdW1iZXIodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpLCBvY3RhbCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEubnVtLCB2YWwpXG59O1xuXG4vLyBSZWFkIGEgc3RyaW5nIHZhbHVlLCBpbnRlcnByZXRpbmcgYmFja3NsYXNoLWVzY2FwZXMuXG5cbnBwLnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZTtcblxuICBpZiAoY2ggPT09IDEyMykgeyAvLyAneydcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7IH1cbiAgfSBlbHNlIHtcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcig0KTtcbiAgfVxuICByZXR1cm4gY29kZVxufTtcblxucHAucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGNoID09PSBxdW90ZSkgeyBicmVhayB9XG4gICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIoZmFsc2UpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MjAyOCB8fCBjaCA9PT0gMHgyMDI5KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgMTApIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICB0aGlzLmN1ckxpbmUrKztcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICB9XG4gIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnN0cmluZywgb3V0KVxufTtcblxuLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxudmFyIElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SID0ge307XG5cbnBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSB0cnVlO1xuICB0cnkge1xuICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyID09PSBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUikge1xuICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IGZhbHNlO1xufTtcblxucHAuaW52YWxpZFN0cmluZ1Rva2VuID0gZnVuY3Rpb24ocG9zaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICB0aHJvdyBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUlxuICB9IGVsc2Uge1xuICAgIHRoaXMucmFpc2UocG9zaXRpb24sIG1lc3NhZ2UpO1xuICB9XG59O1xuXG5wcC5yZWFkVG1wbFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEyMykgeyAvLyAnYCcsICckeydcbiAgICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5zdGFydCAmJiAodGhpcy50eXBlID09PSB0eXBlcyQxLnRlbXBsYXRlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5pbnZhbGlkVGVtcGxhdGUpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuZG9sbGFyQnJhY2VMKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5iYWNrUXVvdGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEudGVtcGxhdGUsIG91dClcbiAgICB9XG4gICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIodHJ1ZSk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH1cbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICB9XG59O1xuXG4vLyBSZWFkcyBhIHRlbXBsYXRlIHRva2VuIHRvIHNlYXJjaCBmb3IgdGhlIGVuZCwgd2l0aG91dCB2YWxpZGF0aW5nIGFueSBlc2NhcGUgc2VxdWVuY2VzXG5wcC5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgZm9yICg7IHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHRoaXMucG9zKyspIHtcbiAgICBzd2l0Y2ggKHRoaXMuaW5wdXRbdGhpcy5wb3NdKSB7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIiRcIjpcbiAgICAgIGlmICh0aGlzLmlucHV0W3RoaXMucG9zICsgMV0gIT09IFwie1wiKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgY2FzZSBcImBcIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuaW52YWxpZFRlbXBsYXRlLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKSlcblxuICAgIC8vIG5vIGRlZmF1bHRcbiAgICB9XG4gIH1cbiAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBlc2NhcGVkIGNoYXJhY3RlcnNcblxucHAucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24oaW5UZW1wbGF0ZSkge1xuICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICsrdGhpcy5wb3M7XG4gIHN3aXRjaCAoY2gpIHtcbiAgY2FzZSAxMTA6IHJldHVybiBcIlxcblwiIC8vICduJyAtPiAnXFxuJ1xuICBjYXNlIDExNDogcmV0dXJuIFwiXFxyXCIgLy8gJ3InIC0+ICdcXHInXG4gIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSAvLyAneCdcbiAgY2FzZSAxMTc6IHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyh0aGlzLnJlYWRDb2RlUG9pbnQoKSkgLy8gJ3UnXG4gIGNhc2UgMTE2OiByZXR1cm4gXCJcXHRcIiAvLyAndCcgLT4gJ1xcdCdcbiAgY2FzZSA5ODogcmV0dXJuIFwiXFxiXCIgLy8gJ2InIC0+ICdcXGInXG4gIGNhc2UgMTE4OiByZXR1cm4gXCJcXHUwMDBiXCIgLy8gJ3YnIC0+ICdcXHUwMDBiJ1xuICBjYXNlIDEwMjogcmV0dXJuIFwiXFxmXCIgLy8gJ2YnIC0+ICdcXGYnXG4gIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9IC8vICdcXHJcXG4nXG4gIGNhc2UgMTA6IC8vICcgXFxuJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7ICsrdGhpcy5jdXJMaW5lOyB9XG4gICAgcmV0dXJuIFwiXCJcbiAgY2FzZSA1NjpcbiAgY2FzZSA1NzpcbiAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICB0aGlzLnBvcyAtIDEsXG4gICAgICAgIFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2VcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgIHZhciBjb2RlUG9zID0gdGhpcy5wb3MgLSAxO1xuXG4gICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgY29kZVBvcyxcbiAgICAgICAgXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgKTtcbiAgICB9XG4gIGRlZmF1bHQ6XG4gICAgaWYgKGNoID49IDQ4ICYmIGNoIDw9IDU1KSB7XG4gICAgICB2YXIgb2N0YWxTdHIgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcyAtIDEsIDMpLm1hdGNoKC9eWzAtN10rLylbMF07XG4gICAgICB2YXIgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICBpZiAob2N0YWwgPiAyNTUpIHtcbiAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmICgob2N0YWxTdHIgIT09IFwiMFwiIHx8IGNoID09PSA1NiB8fCBjaCA9PT0gNTcpICYmICh0aGlzLnN0cmljdCB8fCBpblRlbXBsYXRlKSkge1xuICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICB0aGlzLnBvcyAtIDEgLSBvY3RhbFN0ci5sZW5ndGgsXG4gICAgICAgICAgaW5UZW1wbGF0ZVxuICAgICAgICAgICAgPyBcIk9jdGFsIGxpdGVyYWwgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgICAgIDogXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdGFsKVxuICAgIH1cbiAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgLy8gVW5pY29kZSBuZXcgbGluZSBjaGFyYWN0ZXJzIGFmdGVyIFxcIGdldCByZW1vdmVkIGZyb20gb3V0cHV0IGluIGJvdGhcbiAgICAgIC8vIHRlbXBsYXRlIGxpdGVyYWxzIGFuZCBzdHJpbmdzXG4gICAgICByZXR1cm4gXCJcIlxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaClcbiAgfVxufTtcblxuLy8gVXNlZCB0byByZWFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VzICgnXFx4JywgJ1xcdScsICdcXFUnKS5cblxucHAucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbik7XG4gIGlmIChuID09PSBudWxsKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7IH1cbiAgcmV0dXJuIG5cbn07XG5cbi8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2Bcbi8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuLy9cbi8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbi8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG5wcC5yZWFkV29yZDEgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuICB2YXIgd29yZCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZSwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpO1xuICAgIGlmIChpc0lkZW50aWZpZXJDaGFyKGNoLCBhc3RyYWwpKSB7XG4gICAgICB0aGlzLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICB9IGVsc2UgaWYgKGNoID09PSA5MikgeyAvLyBcIlxcXCJcbiAgICAgIHRoaXMuY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIHZhciBlc2NTdGFydCA9IHRoaXMucG9zO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKSAhPT0gMTE3KSAvLyBcInVcIlxuICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHRoaXMucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICB2YXIgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KCk7XG4gICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCBhc3RyYWwpKVxuICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGVzY1N0YXJ0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7IH1cbiAgICAgIHdvcmQgKz0gY29kZVBvaW50VG9TdHJpbmcoZXNjKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZmlyc3QgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG59O1xuXG4vLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbi8vIHdvcmRzIHdoZW4gbmVjZXNzYXJ5LlxuXG5wcC5yZWFkV29yZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd29yZCA9IHRoaXMucmVhZFdvcmQxKCk7XG4gIHZhciB0eXBlID0gdHlwZXMkMS5uYW1lO1xuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgdHlwZSA9IGtleXdvcmRzW3dvcmRdO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpXG59O1xuXG4vLyBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UsIEluZ3ZhciBTdGVwYW55YW4sIGFuZFxuLy8gdmFyaW91cyBjb250cmlidXRvcnMgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi5naXRcbi8vXG4vLyBQbGVhc2UgdXNlIHRoZSBbZ2l0aHViIGJ1ZyB0cmFja2VyXVtnaGJ0XSB0byByZXBvcnQgaXNzdWVzLlxuLy9cbi8vIFtnaGJ0XTogaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzXG4vL1xuLy8gW3dhbGtdOiB1dGlsL3dhbGsuanNcblxuXG52YXIgdmVyc2lvbiA9IFwiOC4xMC4wXCI7XG5cblBhcnNlci5hY29ybiA9IHtcbiAgUGFyc2VyOiBQYXJzZXIsXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcbiAgUG9zaXRpb246IFBvc2l0aW9uLFxuICBTb3VyY2VMb2NhdGlvbjogU291cmNlTG9jYXRpb24sXG4gIGdldExpbmVJbmZvOiBnZXRMaW5lSW5mbyxcbiAgTm9kZTogTm9kZSxcbiAgVG9rZW5UeXBlOiBUb2tlblR5cGUsXG4gIHRva1R5cGVzOiB0eXBlcyQxLFxuICBrZXl3b3JkVHlwZXM6IGtleXdvcmRzLFxuICBUb2tDb250ZXh0OiBUb2tDb250ZXh0LFxuICB0b2tDb250ZXh0czogdHlwZXMsXG4gIGlzSWRlbnRpZmllckNoYXI6IGlzSWRlbnRpZmllckNoYXIsXG4gIGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgVG9rZW46IFRva2VuLFxuICBpc05ld0xpbmU6IGlzTmV3TGluZSxcbiAgbGluZUJyZWFrOiBsaW5lQnJlYWssXG4gIGxpbmVCcmVha0c6IGxpbmVCcmVha0csXG4gIG5vbkFTQ0lJd2hpdGVzcGFjZTogbm9uQVNDSUl3aGl0ZXNwYWNlXG59O1xuXG4vLyBUaGUgbWFpbiBleHBvcnRlZCBpbnRlcmZhY2UgKHVuZGVyIGBzZWxmLmFjb3JuYCB3aGVuIGluIHRoZVxuLy8gYnJvd3NlcikgaXMgYSBgcGFyc2VgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjb2RlIHN0cmluZyBhbmRcbi8vIHJldHVybnMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgYXMgc3BlY2lmaWVkIGJ5IFtNb3ppbGxhIHBhcnNlclxuLy8gQVBJXVthcGldLlxuLy9cbi8vIFthcGldOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJXG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBQYXJzZXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4vLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4vLyB0aGF0IGVtYmVkIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMuXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKVxufVxuXG4vLyBBY29ybiBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuLy8gVGhlIGB0b2tlbml6ZXJgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cblxuZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBQYXJzZXIudG9rZW5pemVyKGlucHV0LCBvcHRpb25zKVxufVxuXG5leHBvcnQgeyBOb2RlLCBQYXJzZXIsIFBvc2l0aW9uLCBTb3VyY2VMb2NhdGlvbiwgVG9rQ29udGV4dCwgVG9rZW4sIFRva2VuVHlwZSwgZGVmYXVsdE9wdGlvbnMsIGdldExpbmVJbmZvLCBpc0lkZW50aWZpZXJDaGFyLCBpc0lkZW50aWZpZXJTdGFydCwgaXNOZXdMaW5lLCBrZXl3b3JkcyBhcyBrZXl3b3JkVHlwZXMsIGxpbmVCcmVhaywgbGluZUJyZWFrRywgbm9uQVNDSUl3aGl0ZXNwYWNlLCBwYXJzZSwgcGFyc2VFeHByZXNzaW9uQXQsIHR5cGVzIGFzIHRva0NvbnRleHRzLCB0eXBlcyQxIGFzIHRva1R5cGVzLCB0b2tlbml6ZXIsIHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6WyJhc3RyYWxJZGVudGlmaWVyQ29kZXMiLCJhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyIsIm5vbkFTQ0lJaWRlbnRpZmllckNoYXJzIiwibm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyIsInJlc2VydmVkV29yZHMiLCJzdHJpY3QiLCJzdHJpY3RCaW5kIiwiZWNtYTVBbmRMZXNzS2V5d29yZHMiLCJrZXl3b3JkcyQxIiwia2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciIsIm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0IiwiUmVnRXhwIiwibm9uQVNDSUlpZGVudGlmaWVyIiwiaXNJbkFzdHJhbFNldCIsImNvZGUiLCJzZXQiLCJwb3MiLCJpIiwibGVuZ3RoIiwiaXNJZGVudGlmaWVyU3RhcnQiLCJhc3RyYWwiLCJ0ZXN0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiaXNJZGVudGlmaWVyQ2hhciIsIlRva2VuVHlwZSIsImxhYmVsIiwiY29uZiIsImtleXdvcmQiLCJiZWZvcmVFeHByIiwic3RhcnRzRXhwciIsImlzTG9vcCIsImlzQXNzaWduIiwicHJlZml4IiwicG9zdGZpeCIsImJpbm9wIiwidXBkYXRlQ29udGV4dCIsIm5hbWUiLCJwcmVjIiwia2V5d29yZHMiLCJrdyIsIm9wdGlvbnMiLCJ0eXBlcyQxIiwibnVtIiwicmVnZXhwIiwic3RyaW5nIiwicHJpdmF0ZUlkIiwiZW9mIiwiYnJhY2tldEwiLCJicmFja2V0UiIsImJyYWNlTCIsImJyYWNlUiIsInBhcmVuTCIsInBhcmVuUiIsImNvbW1hIiwic2VtaSIsImNvbG9uIiwiZG90IiwicXVlc3Rpb24iLCJxdWVzdGlvbkRvdCIsImFycm93IiwidGVtcGxhdGUiLCJpbnZhbGlkVGVtcGxhdGUiLCJlbGxpcHNpcyIsImJhY2tRdW90ZSIsImRvbGxhckJyYWNlTCIsImVxIiwiYXNzaWduIiwiaW5jRGVjIiwibG9naWNhbE9SIiwibG9naWNhbEFORCIsImJpdHdpc2VPUiIsImJpdHdpc2VYT1IiLCJiaXR3aXNlQU5EIiwiZXF1YWxpdHkiLCJyZWxhdGlvbmFsIiwiYml0U2hpZnQiLCJwbHVzTWluIiwibW9kdWxvIiwic3RhciIsInNsYXNoIiwic3RhcnN0YXIiLCJjb2FsZXNjZSIsIl9icmVhayIsIl9jYXNlIiwiX2NhdGNoIiwiX2NvbnRpbnVlIiwiX2RlYnVnZ2VyIiwiX2RlZmF1bHQiLCJfZG8iLCJfZWxzZSIsIl9maW5hbGx5IiwiX2ZvciIsIl9mdW5jdGlvbiIsIl9pZiIsIl9yZXR1cm4iLCJfc3dpdGNoIiwiX3Rocm93IiwiX3RyeSIsIl92YXIiLCJfY29uc3QiLCJfd2hpbGUiLCJfd2l0aCIsIl9uZXciLCJfdGhpcyIsIl9zdXBlciIsIl9jbGFzcyIsIl9leHRlbmRzIiwiX2V4cG9ydCIsIl9pbXBvcnQiLCJfbnVsbCIsIl90cnVlIiwiX2ZhbHNlIiwiX2luIiwiX2luc3RhbmNlb2YiLCJfdHlwZW9mIiwiX3ZvaWQiLCJfZGVsZXRlIiwibGluZUJyZWFrIiwibGluZUJyZWFrRyIsInNvdXJjZSIsImlzTmV3TGluZSIsIm5leHRMaW5lQnJlYWsiLCJmcm9tIiwiZW5kIiwibmV4dCIsImNoYXJDb2RlQXQiLCJub25BU0NJSXdoaXRlc3BhY2UiLCJza2lwV2hpdGVTcGFjZSIsInJlZiIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwidG9TdHJpbmciLCJoYXNPd24iLCJvYmoiLCJwcm9wTmFtZSIsImNhbGwiLCJpc0FycmF5IiwiQXJyYXkiLCJ3b3Jkc1JlZ2V4cCIsIndvcmRzIiwicmVwbGFjZSIsImNvZGVQb2ludFRvU3RyaW5nIiwibG9uZVN1cnJvZ2F0ZSIsIlBvc2l0aW9uIiwibGluZSIsImNvbCIsImNvbHVtbiIsIm9mZnNldCIsIm4iLCJTb3VyY2VMb2NhdGlvbiIsInAiLCJzdGFydCIsInNvdXJjZUZpbGUiLCJnZXRMaW5lSW5mbyIsImlucHV0IiwiY3VyIiwibmV4dEJyZWFrIiwiZGVmYXVsdE9wdGlvbnMiLCJlY21hVmVyc2lvbiIsInNvdXJjZVR5cGUiLCJvbkluc2VydGVkU2VtaWNvbG9uIiwib25UcmFpbGluZ0NvbW1hIiwiYWxsb3dSZXNlcnZlZCIsImFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uIiwiYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlIiwiYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbiIsImFsbG93U3VwZXJPdXRzaWRlTWV0aG9kIiwiYWxsb3dIYXNoQmFuZyIsImNoZWNrUHJpdmF0ZUZpZWxkcyIsImxvY2F0aW9ucyIsIm9uVG9rZW4iLCJvbkNvbW1lbnQiLCJyYW5nZXMiLCJwcm9ncmFtIiwiZGlyZWN0U291cmNlRmlsZSIsInByZXNlcnZlUGFyZW5zIiwid2FybmVkQWJvdXRFY21hVmVyc2lvbiIsImdldE9wdGlvbnMiLCJvcHRzIiwib3B0IiwiY29uc29sZSIsIndhcm4iLCJ0b2tlbnMiLCJ0b2tlbiIsInB1c2giLCJwdXNoQ29tbWVudCIsImFycmF5IiwiYmxvY2siLCJ0ZXh0Iiwic3RhcnRMb2MiLCJlbmRMb2MiLCJjb21tZW50IiwidHlwZSIsInZhbHVlIiwibG9jIiwicmFuZ2UiLCJTQ09QRV9UT1AiLCJTQ09QRV9GVU5DVElPTiIsIlNDT1BFX0FTWU5DIiwiU0NPUEVfR0VORVJBVE9SIiwiU0NPUEVfQVJST1ciLCJTQ09QRV9TSU1QTEVfQ0FUQ0giLCJTQ09QRV9TVVBFUiIsIlNDT1BFX0RJUkVDVF9TVVBFUiIsIlNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSyIsIlNDT1BFX1ZBUiIsImZ1bmN0aW9uRmxhZ3MiLCJhc3luYyIsImdlbmVyYXRvciIsIkJJTkRfTk9ORSIsIkJJTkRfVkFSIiwiQklORF9MRVhJQ0FMIiwiQklORF9GVU5DVElPTiIsIkJJTkRfU0lNUExFX0NBVENIIiwiQklORF9PVVRTSURFIiwiUGFyc2VyIiwic3RhcnRQb3MiLCJyZXNlcnZlZCIsInJlc2VydmVkU3RyaWN0IiwicmVzZXJ2ZWRXb3Jkc1N0cmljdCIsInJlc2VydmVkV29yZHNTdHJpY3RCaW5kIiwiY29udGFpbnNFc2MiLCJsaW5lU3RhcnQiLCJsYXN0SW5kZXhPZiIsImN1ckxpbmUiLCJzbGljZSIsInNwbGl0IiwiY3VyUG9zaXRpb24iLCJsYXN0VG9rRW5kTG9jIiwibGFzdFRva1N0YXJ0TG9jIiwibGFzdFRva1N0YXJ0IiwibGFzdFRva0VuZCIsImNvbnRleHQiLCJpbml0aWFsQ29udGV4dCIsImV4cHJBbGxvd2VkIiwiaW5Nb2R1bGUiLCJzdHJpY3REaXJlY3RpdmUiLCJwb3RlbnRpYWxBcnJvd0F0IiwicG90ZW50aWFsQXJyb3dJbkZvckF3YWl0IiwieWllbGRQb3MiLCJhd2FpdFBvcyIsImF3YWl0SWRlbnRQb3MiLCJsYWJlbHMiLCJ1bmRlZmluZWRFeHBvcnRzIiwiY3JlYXRlIiwic2tpcExpbmVDb21tZW50Iiwic2NvcGVTdGFjayIsImVudGVyU2NvcGUiLCJyZWdleHBTdGF0ZSIsInByaXZhdGVOYW1lU3RhY2siLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJpbkZ1bmN0aW9uIiwiY29uZmlndXJhYmxlIiwiaW5HZW5lcmF0b3IiLCJpbkFzeW5jIiwiY2FuQXdhaXQiLCJhbGxvd1N1cGVyIiwiYWxsb3dEaXJlY3RTdXBlciIsInRyZWF0RnVuY3Rpb25zQXNWYXIiLCJhbGxvd05ld0RvdFRhcmdldCIsImluQ2xhc3NTdGF0aWNCbG9jayIsInBhcnNlIiwibm9kZSIsInN0YXJ0Tm9kZSIsIm5leHRUb2tlbiIsInBhcnNlVG9wTGV2ZWwiLCJnZXQiLCJjdXJyZW50VmFyU2NvcGUiLCJmbGFncyIsImluQ2xhc3NGaWVsZEluaXQiLCJzY29wZSIsImN1cnJlbnRUaGlzU2NvcGUiLCJ0cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSIsImN1cnJlbnRTY29wZSIsImV4dGVuZCIsInBsdWdpbnMiLCJsZW4iLCJhcmd1bWVudHMiLCJjbHMiLCJwYXJzZUV4cHJlc3Npb25BdCIsInBhcnNlciIsInBhcnNlRXhwcmVzc2lvbiIsInRva2VuaXplciIsImRlZmluZVByb3BlcnRpZXMiLCJwcCQ5IiwibGl0ZXJhbCIsImxhc3RJbmRleCIsImV4ZWMiLCJtYXRjaCIsInNwYWNlQWZ0ZXIiLCJpbmRleCIsImNoYXJBdCIsImVhdCIsImlzQ29udGV4dHVhbCIsImVhdENvbnRleHR1YWwiLCJleHBlY3RDb250ZXh0dWFsIiwidW5leHBlY3RlZCIsImNhbkluc2VydFNlbWljb2xvbiIsImluc2VydFNlbWljb2xvbiIsInNlbWljb2xvbiIsImFmdGVyVHJhaWxpbmdDb21tYSIsInRva1R5cGUiLCJub3ROZXh0IiwiZXhwZWN0IiwicmFpc2UiLCJEZXN0cnVjdHVyaW5nRXJyb3JzIiwic2hvcnRoYW5kQXNzaWduIiwidHJhaWxpbmdDb21tYSIsInBhcmVudGhlc2l6ZWRBc3NpZ24iLCJwYXJlbnRoZXNpemVkQmluZCIsImRvdWJsZVByb3RvIiwiY2hlY2tQYXR0ZXJuRXJyb3JzIiwicmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyIsInJhaXNlUmVjb3ZlcmFibGUiLCJwYXJlbnMiLCJjaGVja0V4cHJlc3Npb25FcnJvcnMiLCJhbmRUaHJvdyIsImNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyIsImlzU2ltcGxlQXNzaWduVGFyZ2V0IiwiZXhwciIsImV4cHJlc3Npb24iLCJwcCQ4IiwiZXhwb3J0cyIsImJvZHkiLCJzdG10IiwicGFyc2VTdGF0ZW1lbnQiLCJsaXN0Iiwia2V5cyIsImFkYXB0RGlyZWN0aXZlUHJvbG9ndWUiLCJmaW5pc2hOb2RlIiwibG9vcExhYmVsIiwia2luZCIsInN3aXRjaExhYmVsIiwiaXNMZXQiLCJza2lwIiwibmV4dENoIiwiaWRlbnQiLCJpc0FzeW5jRnVuY3Rpb24iLCJhZnRlciIsInRvcExldmVsIiwic3RhcnR0eXBlIiwicGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50IiwicGFyc2VEZWJ1Z2dlclN0YXRlbWVudCIsInBhcnNlRG9TdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsInBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQiLCJwYXJzZUNsYXNzIiwicGFyc2VJZlN0YXRlbWVudCIsInBhcnNlUmV0dXJuU3RhdGVtZW50IiwicGFyc2VTd2l0Y2hTdGF0ZW1lbnQiLCJwYXJzZVRocm93U3RhdGVtZW50IiwicGFyc2VUcnlTdGF0ZW1lbnQiLCJwYXJzZVZhclN0YXRlbWVudCIsInBhcnNlV2hpbGVTdGF0ZW1lbnQiLCJwYXJzZVdpdGhTdGF0ZW1lbnQiLCJwYXJzZUJsb2NrIiwicGFyc2VFbXB0eVN0YXRlbWVudCIsInBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCIsInBhcnNlSW1wb3J0IiwicGFyc2VFeHBvcnQiLCJtYXliZU5hbWUiLCJwYXJzZUxhYmVsZWRTdGF0ZW1lbnQiLCJpc0JyZWFrIiwicGFyc2VJZGVudCIsImxhYiIsInBvcCIsInBhcnNlUGFyZW5FeHByZXNzaW9uIiwiYXdhaXRBdCIsInBhcnNlRm9yIiwiaW5pdCQxIiwicGFyc2VWYXIiLCJkZWNsYXJhdGlvbnMiLCJhd2FpdCIsInBhcnNlRm9ySW4iLCJzdGFydHNXaXRoTGV0IiwiaXNGb3JPZiIsImluaXQiLCJ0b0Fzc2lnbmFibGUiLCJjaGVja0xWYWxQYXR0ZXJuIiwiaXNBc3luYyIsImRlY2xhcmF0aW9uUG9zaXRpb24iLCJwYXJzZUZ1bmN0aW9uIiwiRlVOQ19TVEFURU1FTlQiLCJGVU5DX0hBTkdJTkdfU1RBVEVNRU5UIiwiY29uc2VxdWVudCIsImFsdGVybmF0ZSIsImFyZ3VtZW50IiwiZGlzY3JpbWluYW50IiwiY2FzZXMiLCJzYXdEZWZhdWx0IiwiaXNDYXNlIiwiZXhpdFNjb3BlIiwiZW1wdHkkMSIsInBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSIsInBhcmFtIiwicGFyc2VCaW5kaW5nQXRvbSIsInNpbXBsZSIsImhhbmRsZXIiLCJjbGF1c2UiLCJmaW5hbGl6ZXIiLCJhbGxvd01pc3NpbmdJbml0aWFsaXplciIsIm9iamVjdCIsImkkMSIsImxhYmVsJDEiLCJzdGF0ZW1lbnRTdGFydCIsImluZGV4T2YiLCJjcmVhdGVOZXdMZXhpY2FsU2NvcGUiLCJleGl0U3RyaWN0IiwidXBkYXRlIiwiaXNGb3JJbiIsImlkIiwibGVmdCIsInJpZ2h0IiwicGFyc2VNYXliZUFzc2lnbiIsImlzRm9yIiwiZGVjbCIsInBhcnNlVmFySWQiLCJGVU5DX05VTExBQkxFX0lEIiwic3RhdGVtZW50IiwiYWxsb3dFeHByZXNzaW9uQm9keSIsImZvckluaXQiLCJpbml0RnVuY3Rpb24iLCJjaGVja0xWYWxTaW1wbGUiLCJvbGRZaWVsZFBvcyIsIm9sZEF3YWl0UG9zIiwib2xkQXdhaXRJZGVudFBvcyIsInBhcnNlRnVuY3Rpb25QYXJhbXMiLCJwYXJzZUZ1bmN0aW9uQm9keSIsInBhcmFtcyIsInBhcnNlQmluZGluZ0xpc3QiLCJpc1N0YXRlbWVudCIsIm9sZFN0cmljdCIsInBhcnNlQ2xhc3NJZCIsInBhcnNlQ2xhc3NTdXBlciIsInByaXZhdGVOYW1lTWFwIiwiZW50ZXJDbGFzc0JvZHkiLCJjbGFzc0JvZHkiLCJoYWRDb25zdHJ1Y3RvciIsImVsZW1lbnQiLCJwYXJzZUNsYXNzRWxlbWVudCIsInN1cGVyQ2xhc3MiLCJrZXkiLCJpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZCIsImV4aXRDbGFzc0JvZHkiLCJjb25zdHJ1Y3RvckFsbG93c1N1cGVyIiwia2V5TmFtZSIsImlzR2VuZXJhdG9yIiwiaXNTdGF0aWMiLCJwYXJzZUNsYXNzU3RhdGljQmxvY2siLCJpc0NsYXNzRWxlbWVudE5hbWVTdGFydCIsInN0YXRpYyIsImxhc3RWYWx1ZSIsImNvbXB1dGVkIiwic3RhcnROb2RlQXQiLCJwYXJzZUNsYXNzRWxlbWVudE5hbWUiLCJpc0NvbnN0cnVjdG9yIiwiY2hlY2tLZXlOYW1lIiwiYWxsb3dzRGlyZWN0U3VwZXIiLCJwYXJzZUNsYXNzTWV0aG9kIiwicGFyc2VDbGFzc0ZpZWxkIiwicGFyc2VQcml2YXRlSWRlbnQiLCJwYXJzZVByb3BlcnR5TmFtZSIsIm1ldGhvZCIsInBhcnNlTWV0aG9kIiwiZmllbGQiLCJvbGRMYWJlbHMiLCJwYXJzZUV4cHJTdWJzY3JpcHRzIiwiZGVjbGFyZWQiLCJ1c2VkIiwicGFyZW50IiwiY3VyciIsInBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24iLCJleHBvcnRlZCIsInBhcnNlTW9kdWxlRXhwb3J0TmFtZSIsImNoZWNrRXhwb3J0IiwicGFyc2VFeHByQXRvbSIsImRlY2xhcmF0aW9uIiwicGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24iLCJzaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCIsInBhcnNlRXhwb3J0RGVjbGFyYXRpb24iLCJjaGVja1ZhcmlhYmxlRXhwb3J0Iiwic3BlY2lmaWVycyIsInBhcnNlRXhwb3J0U3BlY2lmaWVycyIsInNwZWMiLCJjaGVja1VucmVzZXJ2ZWQiLCJsb2NhbCIsImNoZWNrTG9jYWxFeHBvcnQiLCJmTm9kZSIsImNOb2RlIiwiY2hlY2tQYXR0ZXJuRXhwb3J0IiwicGF0IiwicHJvcGVydGllcyIsInByb3AiLCJsaXN0JDEiLCJlbGVtZW50cyIsImVsdCIsImRlY2xzIiwicGFyc2VFeHBvcnRTcGVjaWZpZXIiLCJub2RlcyIsImZpcnN0IiwicGFyc2VJbXBvcnRTcGVjaWZpZXJzIiwicGFyc2VJbXBvcnRTcGVjaWZpZXIiLCJpbXBvcnRlZCIsInBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllciIsInBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyIiwic3RyaW5nTGl0ZXJhbCIsInBhcnNlTGl0ZXJhbCIsInN0YXRlbWVudHMiLCJpc0RpcmVjdGl2ZUNhbmRpZGF0ZSIsImRpcmVjdGl2ZSIsInJhdyIsInBwJDciLCJpc0JpbmRpbmciLCJ0b0Fzc2lnbmFibGVMaXN0Iiwib3BlcmF0b3IiLCJleHByTGlzdCIsImxhc3QiLCJwYXJzZVNwcmVhZCIsInBhcnNlUmVzdEJpbmRpbmciLCJwYXJzZU9iaiIsImNsb3NlIiwiYWxsb3dFbXB0eSIsImFsbG93VHJhaWxpbmdDb21tYSIsImFsbG93TW9kaWZpZXJzIiwiZWx0cyIsInJlc3QiLCJwYXJzZUJpbmRpbmdMaXN0SXRlbSIsInBhcnNlQXNzaWduYWJsZUxpc3RJdGVtIiwiZWxlbSIsInBhcnNlTWF5YmVEZWZhdWx0IiwiYmluZGluZ1R5cGUiLCJjaGVja0NsYXNoZXMiLCJpc0JpbmQiLCJkZWNsYXJlTmFtZSIsImNoZWNrTFZhbElubmVyUGF0dGVybiIsIlRva0NvbnRleHQiLCJpc0V4cHIiLCJwcmVzZXJ2ZVNwYWNlIiwib3ZlcnJpZGUiLCJ0eXBlcyIsImJfc3RhdCIsImJfZXhwciIsImJfdG1wbCIsInBfc3RhdCIsInBfZXhwciIsInFfdG1wbCIsInRyeVJlYWRUZW1wbGF0ZVRva2VuIiwiZl9zdGF0IiwiZl9leHByIiwiZl9leHByX2dlbiIsImZfZ2VuIiwicHAkNiIsImN1ckNvbnRleHQiLCJicmFjZUlzQmxvY2siLCJwcmV2VHlwZSIsImluR2VuZXJhdG9yQ29udGV4dCIsIm92ZXJyaWRlQ29udGV4dCIsInRva2VuQ3R4Iiwib3V0Iiwic3RhdGVtZW50UGFyZW5zIiwiYWxsb3dlZCIsInBwJDUiLCJjaGVja1Byb3BDbGFzaCIsInByb3BIYXNoIiwic2hvcnRoYW5kIiwicHJvdG8iLCJvdGhlciIsInJlZGVmaW5pdGlvbiIsImV4cHJlc3Npb25zIiwiYWZ0ZXJMZWZ0UGFyc2UiLCJwYXJzZVlpZWxkIiwib3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyIsIm9sZFBhcmVuQXNzaWduIiwib2xkVHJhaWxpbmdDb21tYSIsIm9sZERvdWJsZVByb3RvIiwicGFyc2VNYXliZUNvbmRpdGlvbmFsIiwicGFyc2VFeHByT3BzIiwicGFyc2VNYXliZVVuYXJ5IiwicGFyc2VFeHByT3AiLCJsZWZ0U3RhcnRQb3MiLCJsZWZ0U3RhcnRMb2MiLCJtaW5QcmVjIiwibG9naWNhbCIsIm9wIiwiYnVpbGRCaW5hcnkiLCJzYXdVbmFyeSIsInBhcnNlQXdhaXQiLCJpc1ByaXZhdGVGaWVsZEFjY2VzcyIsIm5vZGUkMSIsInByb3BlcnR5IiwicmVzdWx0IiwicGFyc2VTdWJzY3JpcHRzIiwiYmFzZSIsIm5vQ2FsbHMiLCJtYXliZUFzeW5jQXJyb3ciLCJvcHRpb25hbENoYWluZWQiLCJwYXJzZVN1YnNjcmlwdCIsIm9wdGlvbmFsIiwiY2hhaW5Ob2RlIiwic2hvdWxkUGFyc2VBc3luY0Fycm93IiwicGFyc2VTdWJzY3JpcHRBc3luY0Fycm93IiwicGFyc2VBcnJvd0V4cHJlc3Npb24iLCJvcHRpb25hbFN1cHBvcnRlZCIsInBhcnNlRXhwckxpc3QiLCJjYWxsZWUiLCJub2RlJDIiLCJ0YWciLCJxdWFzaSIsInBhcnNlVGVtcGxhdGUiLCJpc1RhZ2dlZCIsImZvck5ldyIsInJlYWRSZWdleHAiLCJjYW5CZUFycm93IiwicmVnZXgiLCJwYXR0ZXJuIiwicGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiIsInBhcnNlTmV3IiwicGFyc2VFeHBySW1wb3J0IiwicGFyc2VFeHByQXRvbURlZmF1bHQiLCJtZXRhIiwicGFyc2VEeW5hbWljSW1wb3J0IiwicGFyc2VJbXBvcnRNZXRhIiwiZXJyb3JQb3MiLCJiaWdpbnQiLCJ2YWwiLCJzaG91bGRQYXJzZUFycm93IiwiaW5uZXJTdGFydFBvcyIsImlubmVyU3RhcnRMb2MiLCJsYXN0SXNDb21tYSIsInNwcmVhZFN0YXJ0IiwicGFyc2VQYXJlbkl0ZW0iLCJpbm5lckVuZFBvcyIsImlubmVyRW5kTG9jIiwicGFyc2VQYXJlbkFycm93TGlzdCIsImZpbmlzaE5vZGVBdCIsInBhciIsIml0ZW0iLCJlbXB0eSIsInBhcnNlVGVtcGxhdGVFbGVtZW50IiwiY29va2VkIiwidGFpbCIsImN1ckVsdCIsInF1YXNpcyIsImlzQXN5bmNQcm9wIiwiaXNQYXR0ZXJuIiwicGFyc2VQcm9wZXJ0eSIsInBhcnNlUHJvcGVydHlWYWx1ZSIsInBhcnNlR2V0dGVyU2V0dGVyIiwicGFyYW1Db3VudCIsImNvcHlOb2RlIiwiaXNBcnJvd0Z1bmN0aW9uIiwiaXNNZXRob2QiLCJpc0V4cHJlc3Npb24iLCJ1c2VTdHJpY3QiLCJjaGVja1BhcmFtcyIsIm5vblNpbXBsZSIsImlzU2ltcGxlUGFyYW1MaXN0IiwidW5kZWZpbmVkIiwiYWxsb3dEdXBsaWNhdGVzIiwibmFtZUhhc2giLCJyZSIsImxpYmVyYWwiLCJwYXJzZUlkZW50Tm9kZSIsImRlbGVnYXRlIiwicHAkNCIsIm1lc3NhZ2UiLCJlcnIiLCJTeW50YXhFcnJvciIsInJhaXNlZEF0IiwicHAkMyIsIlNjb3BlIiwidmFyIiwibGV4aWNhbCIsImZ1bmN0aW9ucyIsInJlZGVjbGFyZWQiLCJzY29wZSQxIiwic2NvcGUkMiIsInNjb3BlJDMiLCJOb2RlIiwicHAkMiIsIm5ld05vZGUiLCJlY21hOUJpbmFyeVByb3BlcnRpZXMiLCJlY21hMTBCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTExQmluYXJ5UHJvcGVydGllcyIsImVjbWExMkJpbmFyeVByb3BlcnRpZXMiLCJlY21hMTNCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTE0QmluYXJ5UHJvcGVydGllcyIsInVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzIiwiZWNtYTE0QmluYXJ5UHJvcGVydGllc09mU3RyaW5ncyIsInVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzT2ZTdHJpbmdzIiwidW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyIsImVjbWE5U2NyaXB0VmFsdWVzIiwiZWNtYTEwU2NyaXB0VmFsdWVzIiwiZWNtYTExU2NyaXB0VmFsdWVzIiwiZWNtYTEyU2NyaXB0VmFsdWVzIiwiZWNtYTEzU2NyaXB0VmFsdWVzIiwiZWNtYTE0U2NyaXB0VmFsdWVzIiwidW5pY29kZVNjcmlwdFZhbHVlcyIsImRhdGEiLCJidWlsZFVuaWNvZGVEYXRhIiwiZCIsImJpbmFyeSIsImJpbmFyeU9mU3RyaW5ncyIsIm5vbkJpbmFyeSIsIkdlbmVyYWxfQ2F0ZWdvcnkiLCJTY3JpcHQiLCJTY3JpcHRfRXh0ZW5zaW9ucyIsImdjIiwic2MiLCJzY3giLCJwcCQxIiwiUmVnRXhwVmFsaWRhdGlvblN0YXRlIiwidmFsaWRGbGFncyIsInVuaWNvZGVQcm9wZXJ0aWVzIiwic3dpdGNoVSIsInN3aXRjaFYiLCJzd2l0Y2hOIiwibGFzdEludFZhbHVlIiwibGFzdFN0cmluZ1ZhbHVlIiwibGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlIiwibnVtQ2FwdHVyaW5nUGFyZW5zIiwibWF4QmFja1JlZmVyZW5jZSIsImdyb3VwTmFtZXMiLCJiYWNrUmVmZXJlbmNlTmFtZXMiLCJyZXNldCIsInVuaWNvZGVTZXRzIiwidW5pY29kZSIsImF0IiwiZm9yY2VVIiwicyIsImwiLCJjIiwibmV4dEluZGV4IiwiY3VycmVudCIsImxvb2thaGVhZCIsImFkdmFuY2UiLCJjaCIsImVhdENoYXJzIiwiY2hzIiwidmFsaWRhdGVSZWdFeHBGbGFncyIsInN0YXRlIiwidSIsInYiLCJmbGFnIiwidmFsaWRhdGVSZWdFeHBQYXR0ZXJuIiwicmVnZXhwX3BhdHRlcm4iLCJyZWdleHBfZGlzanVuY3Rpb24iLCJyZWdleHBfYWx0ZXJuYXRpdmUiLCJyZWdleHBfZWF0UXVhbnRpZmllciIsInJlZ2V4cF9lYXRUZXJtIiwicmVnZXhwX2VhdEFzc2VydGlvbiIsInJlZ2V4cF9lYXRBdG9tIiwicmVnZXhwX2VhdEV4dGVuZGVkQXRvbSIsImxvb2tiZWhpbmQiLCJub0Vycm9yIiwicmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgiLCJyZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciIsIm1pbiIsIm1heCIsInJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzIiwicmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzIiwicmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSIsInJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyIsInJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwIiwicmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwIiwicmVnZXhwX2VhdEF0b21Fc2NhcGUiLCJyZWdleHBfZ3JvdXBTcGVjaWZpZXIiLCJyZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIiLCJyZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyIiwicmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciIsImlzU3ludGF4Q2hhcmFjdGVyIiwicmVnZXhwX2VhdEdyb3VwTmFtZSIsInJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSIsInJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQiLCJyZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQiLCJyZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlIiwiaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQiLCJpc1JlZ0V4cElkZW50aWZpZXJQYXJ0IiwicmVnZXhwX2VhdEJhY2tSZWZlcmVuY2UiLCJyZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUiLCJyZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlIiwicmVnZXhwX2VhdEtHcm91cE5hbWUiLCJyZWdleHBfZWF0RGVjaW1hbEVzY2FwZSIsInJlZ2V4cF9lYXRDb250cm9sRXNjYXBlIiwicmVnZXhwX2VhdENDb250cm9sTGV0dGVyIiwicmVnZXhwX2VhdFplcm8iLCJyZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2UiLCJyZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSIsInJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSIsInJlZ2V4cF9lYXRDb250cm9sTGV0dGVyIiwiaXNEZWNpbWFsRGlnaXQiLCJpc0NvbnRyb2xMZXR0ZXIiLCJyZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMiLCJsZWFkIiwibGVhZFN1cnJvZ2F0ZUVuZCIsInRyYWlsIiwicmVnZXhwX2VhdEhleERpZ2l0cyIsImlzVmFsaWRVbmljb2RlIiwiQ2hhclNldE5vbmUiLCJDaGFyU2V0T2siLCJDaGFyU2V0U3RyaW5nIiwiaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZSIsIm5lZ2F0ZSIsInJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24iLCJyZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSIsInJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSIsInJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZSIsInJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUiLCJuYW1lT3JWYWx1ZSIsInJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIiwiaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyIiwiaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlciIsInJlZ2V4cF9jbGFzc0NvbnRlbnRzIiwicmVnZXhwX2NsYXNzU2V0RXhwcmVzc2lvbiIsInJlZ2V4cF9ub25FbXB0eUNsYXNzUmFuZ2VzIiwicmVnZXhwX2VhdENsYXNzQXRvbSIsInJlZ2V4cF9lYXRDbGFzc0VzY2FwZSIsImNoJDEiLCJpc09jdGFsRGlnaXQiLCJyZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyIiwic3ViUmVzdWx0IiwicmVnZXhwX2VhdENsYXNzU2V0UmFuZ2UiLCJyZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kIiwicmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyIiwicmVnZXhwX2VhdENsYXNzU3RyaW5nRGlzanVuY3Rpb24iLCJyZWdleHBfZWF0TmVzdGVkQ2xhc3MiLCJyZXN1bHQkMSIsInJlZ2V4cF9jbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHMiLCJyZWdleHBfY2xhc3NTdHJpbmciLCJjb3VudCIsInJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvciIsImlzQ2xhc3NTZXRSZXNlcnZlZERvdWJsZVB1bmN0dWF0b3JDaGFyYWN0ZXIiLCJpc0NsYXNzU2V0U3ludGF4Q2hhcmFjdGVyIiwiaXNDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvciIsImlzSGV4RGlnaXQiLCJoZXhUb0ludCIsInJlZ2V4cF9lYXRPY3RhbERpZ2l0IiwibjEiLCJuMiIsIlRva2VuIiwicHAiLCJpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCIsImdldFRva2VuIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ0aGlzJDEkMSIsImRvbmUiLCJza2lwU3BhY2UiLCJmaW5pc2hUb2tlbiIsInJlYWRUb2tlbiIsImZ1bGxDaGFyQ29kZUF0UG9zIiwicmVhZFdvcmQiLCJnZXRUb2tlbkZyb21Db2RlIiwic2tpcEJsb2NrQ29tbWVudCIsInN0YXJ0U2tpcCIsImxvb3AiLCJyZWFkVG9rZW5fZG90IiwicmVhZE51bWJlciIsIm5leHQyIiwicmVhZFRva2VuX3NsYXNoIiwiZmluaXNoT3AiLCJyZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwIiwic2l6ZSIsInRva2VudHlwZSIsInJlYWRUb2tlbl9waXBlX2FtcCIsInJlYWRUb2tlbl9jYXJldCIsInJlYWRUb2tlbl9wbHVzX21pbiIsInJlYWRUb2tlbl9sdF9ndCIsInJlYWRUb2tlbl9lcV9leGNsIiwicmVhZFRva2VuX3F1ZXN0aW9uIiwibmV4dDIkMSIsInJlYWRUb2tlbl9udW1iZXJTaWduIiwicmVhZFdvcmQxIiwicmVhZFJhZGl4TnVtYmVyIiwicmVhZFN0cmluZyIsInN0ciIsImVzY2FwZWQiLCJpbkNsYXNzIiwiZmxhZ3NTdGFydCIsImUiLCJyZWFkSW50IiwicmFkaXgiLCJtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwiLCJhbGxvd1NlcGFyYXRvcnMiLCJpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwiLCJ0b3RhbCIsImxhc3RDb2RlIiwiSW5maW5pdHkiLCJzdHJpbmdUb051bWJlciIsInBhcnNlSW50IiwicGFyc2VGbG9hdCIsInN0cmluZ1RvQmlnSW50IiwiQmlnSW50Iiwic3RhcnRzV2l0aERvdCIsIm9jdGFsIiwidmFsJDEiLCJyZWFkQ29kZVBvaW50IiwiY29kZVBvcyIsInJlYWRIZXhDaGFyIiwiaW52YWxpZFN0cmluZ1Rva2VuIiwicXVvdGUiLCJjaHVua1N0YXJ0IiwicmVhZEVzY2FwZWRDaGFyIiwiSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IiLCJpblRlbXBsYXRlRWxlbWVudCIsInJlYWRUbXBsVG9rZW4iLCJyZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4iLCJwb3NpdGlvbiIsImluVGVtcGxhdGUiLCJvY3RhbFN0ciIsInN1YnN0ciIsIndvcmQiLCJlc2NTdGFydCIsImVzYyIsInZlcnNpb24iLCJhY29ybiIsInRva1R5cGVzIiwia2V5d29yZFR5cGVzIiwidG9rQ29udGV4dHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/acorn/dist/acorn.mjs\n");

/***/ })

};
;