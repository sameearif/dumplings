"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/retext-smartypants";
exports.ids = ["vendor-chunks/retext-smartypants"];
exports.modules = {

/***/ "(rsc)/./node_modules/retext-smartypants/index.js":
/*!**************************************************!*\
  !*** ./node_modules/retext-smartypants/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ retextSmartypants)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var nlcst_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nlcst-to-string */ \"(rsc)/./node_modules/nlcst-to-string/lib/index.js\");\n/**\n * @typedef {import('nlcst').Root} Root\n * @typedef {import('nlcst').Sentence} Sentence\n * @typedef {import('nlcst').Word} Word\n * @typedef {import('nlcst').Symbol} Symbol\n * @typedef {import('nlcst').Punctuation} Punctuation\n * @typedef {import('nlcst').SentenceContent} SentenceContent\n *\n * @typedef QuoteCharacterMap\n *   Quote characters.\n * @property {string} double\n *   Character to use for double quotes.\n * @property {string} single\n *   Character to use for single quotes.\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean} [quotes=true]\n *   Create smart quotes.\n *\n *   Converts straight double and single quotes to smart double or single\n *   quotes.\n * @property {QuoteCharacterMap} [openingQuotes]\n *   Characters to use for opening double and single quotes.\n * @property {QuoteCharacterMap} [closingQuotes]\n *   Characters to use for closing double and single quotes.\n * @property {boolean} [ellipses=true]\n *   Create smart ellipses.\n *\n *   Converts triple dot characters (with or without spaces between) into a\n *   single Unicode ellipsis character.\n * @property {boolean|'all'} [backticks=true]\n *   Create smart quotes from backticks.\n *\n *   When `true`, converts double back-ticks into an opening double quote, and\n *   double straight single quotes into a closing double quote.\n *\n *   When `'all'`: does the preceding and converts single back-ticks into an\n *   opening single quote, and a straight single quote into a closing single\n *   smart quote.\n *\n *   Note: Quotes can not be `true` when `backticks` is `'all'`;\n * @property {boolean|'oldschool'|'inverted'} [dashes=true]\n *   Create smart dashes.\n *\n *   When `true`, converts two dashes into an em-dash character.\n *\n *   When `'oldschool'`, converts two dashes into an en-dash, and three dashes\n *   into an em-dash.\n *\n *   When `'inverted'`, converts two dashes into an em-dash, and three dashes\n *   into an en-dash.\n *\n * @callback Method\n * @param {Punctuation|Symbol} node\n * @param {number} index\n * @param {Word|Sentence} parent\n * @returns {void}\n */ \n\nconst defaultClosingQuotes = {\n    '\"': \"”\",\n    \"'\": \"’\"\n};\nconst defaultOpeningQuotes = {\n    '\"': \"“\",\n    \"'\": \"‘\"\n};\n/**\n * @param {Options} options\n */ function createEducators(options) {\n    const closingQuotes = options.closingQuotes ? {\n        '\"': options.closingQuotes.double,\n        \"'\": options.closingQuotes.single\n    } : defaultClosingQuotes;\n    const openingQuotes = options.openingQuotes ? {\n        '\"': options.openingQuotes.double,\n        \"'\": options.openingQuotes.single\n    } : defaultOpeningQuotes;\n    const educators = {\n        dashes: {\n            /**\n       * Transform two dahes into an em-dash.\n       *\n       * @type {Method}\n       */ true (node) {\n                if (node.value === \"--\") {\n                    node.value = \"—\";\n                }\n            },\n            /**\n       * Transform three dahes into an em-dash, and two into an en-dash.\n       *\n       * @type {Method}\n       */ oldschool (node) {\n                if (node.value === \"---\") {\n                    node.value = \"—\";\n                } else if (node.value === \"--\") {\n                    node.value = \"–\";\n                }\n            },\n            /**\n       * Transform three dahes into an en-dash, and two into an em-dash.\n       *\n       * @type {Method}\n       */ inverted (node) {\n                if (node.value === \"---\") {\n                    node.value = \"–\";\n                } else if (node.value === \"--\") {\n                    node.value = \"—\";\n                }\n            }\n        },\n        backticks: {\n            /**\n       * Transform double backticks and single quotes into smart quotes.\n       *\n       * @type {Method}\n       */ true (node) {\n                if (node.value === \"``\") {\n                    node.value = \"“\";\n                } else if (node.value === \"''\") {\n                    node.value = \"”\";\n                }\n            },\n            /**\n       * Transform single and double backticks and single quotes into smart quotes.\n       *\n       * @type {Method}\n       */ all (node, index, parent) {\n                educators.backticks.true(node, index, parent);\n                if (node.value === \"`\") {\n                    node.value = \"‘\";\n                } else if (node.value === \"'\") {\n                    node.value = \"’\";\n                }\n            }\n        },\n        ellipses: {\n            /**\n       * Transform multiple dots into unicode ellipses.\n       *\n       * @type {Method}\n       */ true (node, index, parent) {\n                const value = node.value;\n                const siblings = parent.children;\n                // Simple node with three dots and without white-space.\n                if (/^\\.{3,}$/.test(node.value)) {\n                    node.value = \"…\";\n                    return;\n                }\n                if (!/^\\.+$/.test(value)) {\n                    return;\n                }\n                // Search for dot-nodes with white-space between.\n                /** @type {Array<SentenceContent>} */ const nodes = [];\n                let position = index;\n                let count = 1;\n                // It’s possible that the node is merged with an adjacent word-node.  In that\n                // code, we cannot transform it because there’s no reference to the\n                // grandparent.\n                while(--position > 0){\n                    let sibling = siblings[position];\n                    if (sibling.type !== \"WhiteSpaceNode\") {\n                        break;\n                    }\n                    const queue = sibling;\n                    sibling = siblings[--position];\n                    if (sibling && (sibling.type === \"PunctuationNode\" || sibling.type === \"SymbolNode\") && /^\\.+$/.test(sibling.value)) {\n                        nodes.push(queue, sibling);\n                        count++;\n                        continue;\n                    }\n                    break;\n                }\n                if (count < 3) {\n                    return;\n                }\n                siblings.splice(index - nodes.length, nodes.length);\n                node.value = \"…\";\n            }\n        },\n        quotes: {\n            /**\n       * Transform straight single- and double quotes into smart quotes.\n       *\n       * @type {Method}\n       */ // eslint-disable-next-line complexity\n            true (node, index, parent) {\n                const siblings = parent.children;\n                const value = node.value;\n                if (value !== '\"' && value !== \"'\") {\n                    return;\n                }\n                const previous = siblings[index - 1];\n                const next = siblings[index + 1];\n                const nextNext = siblings[index + 2];\n                const nextValue = next && (0,nlcst_to_string__WEBPACK_IMPORTED_MODULE_0__.toString)(next);\n                if (next && nextNext && (next.type === \"PunctuationNode\" || next.type === \"SymbolNode\") && nextNext.type !== \"WordNode\") {\n                    // Special case if the very first character is a quote followed by\n                    // punctuation at a non-word-break. Close the quotes by brute force.\n                    node.value = closingQuotes[value];\n                } else if (nextNext && (nextValue === '\"' || nextValue === \"'\") && nextNext.type === \"WordNode\") {\n                    // Special case for double sets of quotes:\n                    // `He said, \"'Quoted' words in a larger quote.\"`\n                    node.value = openingQuotes[value];\n                    // @ts-expect-error: it’s a literal.\n                    next.value = openingQuotes[nextValue];\n                } else if (next && /^\\d\\ds$/.test(nextValue)) {\n                    // Special case for decade abbreviations: `the '80s`\n                    node.value = closingQuotes[value];\n                } else if (previous && next && (previous.type === \"WhiteSpaceNode\" || previous.type === \"PunctuationNode\" || previous.type === \"SymbolNode\") && next.type === \"WordNode\") {\n                    // Get most opening single quotes.\n                    node.value = openingQuotes[value];\n                } else if (previous && previous.type !== \"WhiteSpaceNode\" && previous.type !== \"SymbolNode\" && previous.type !== \"PunctuationNode\") {\n                    // Closing quotes.\n                    node.value = closingQuotes[value];\n                } else if (!next || next.type === \"WhiteSpaceNode\" || value === \"'\" && nextValue === \"s\") {\n                    node.value = closingQuotes[value];\n                } else {\n                    node.value = openingQuotes[value];\n                }\n            }\n        }\n    };\n    return educators;\n}\n/**\n * Plugin to replace dumb/straight/typewriter punctuation marks with smart/curly\n * punctuation marks.\n *\n * @type {import('unified').Plugin<[Options?]|[], Root>}\n */ function retextSmartypants(options = {}) {\n    /** @type {Array<Method>} */ const methods = [];\n    /** @type {Options['quotes']} */ let quotes;\n    /** @type {Options['ellipses']} */ let ellipses;\n    /** @type {Options['backticks']} */ let backticks;\n    /** @type {Options['dashes']} */ let dashes;\n    if (\"quotes\" in options) {\n        quotes = options.quotes;\n        if (quotes !== Boolean(quotes)) {\n            throw new TypeError(\"Illegal invocation: `\" + quotes + \"` \" + \"is not a valid value for `quotes` in \" + \"`smartypants`\");\n        }\n    } else {\n        quotes = true;\n    }\n    if (\"ellipses\" in options) {\n        ellipses = options.ellipses;\n        if (ellipses !== Boolean(ellipses)) {\n            throw new TypeError(\"Illegal invocation: `\" + ellipses + \"` \" + \"is not a valid value for `ellipses` in \" + \"`smartypants`\");\n        }\n    } else {\n        ellipses = true;\n    }\n    if (\"backticks\" in options) {\n        backticks = options.backticks;\n        if (backticks !== Boolean(backticks) && backticks !== \"all\") {\n            throw new TypeError(\"Illegal invocation: `\" + backticks + \"` \" + \"is not a valid value for `backticks` in \" + \"`smartypants`\");\n        }\n        if (backticks === \"all\" && quotes === true) {\n            throw new TypeError(\"Illegal invocation: `backticks: \" + backticks + \"` is not a valid value \" + \"when `quotes: \" + quotes + \"` in \" + \"`smartypants`\");\n        }\n    } else {\n        backticks = true;\n    }\n    if (\"dashes\" in options) {\n        dashes = options.dashes;\n        if (dashes !== Boolean(dashes) && dashes !== \"oldschool\" && dashes !== \"inverted\") {\n            throw new TypeError(\"Illegal invocation: `\" + dashes + \"` \" + \"is not a valid value for `dahes` in \" + \"`smartypants`\");\n        }\n    } else {\n        dashes = true;\n    }\n    const educators = createEducators(options);\n    if (quotes !== false) {\n        methods.push(educators.quotes.true);\n    }\n    if (ellipses !== false) {\n        methods.push(educators.ellipses.true);\n    }\n    if (backticks !== false) {\n        methods.push(educators.backticks[backticks === true ? \"true\" : backticks]);\n    }\n    if (dashes !== false) {\n        methods.push(educators.dashes[dashes === true ? \"true\" : dashes]);\n    }\n    return (tree)=>{\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.visit)(tree, (node, position, parent)=>{\n            let index = -1;\n            if (node.type === \"PunctuationNode\" || node.type === \"SymbolNode\") {\n                while(++index < methods.length){\n                    // @ts-expect-error: they’re literals.\n                    methods[index](node, position, parent);\n                }\n            }\n        });\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmV0ZXh0LXNtYXJ0eXBhbnRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMERDLEdBRXFDO0FBQ0U7QUFFeEMsTUFBTUUsdUJBQXVCO0lBQUMsS0FBSztJQUFLLEtBQUs7QUFBRztBQUNoRCxNQUFNQyx1QkFBdUI7SUFBQyxLQUFLO0lBQUssS0FBSztBQUFHO0FBRWhEOztDQUVDLEdBQ0QsU0FBU0MsZ0JBQWdCQyxPQUFPO0lBQzlCLE1BQU1DLGdCQUFnQkQsUUFBUUMsYUFBYSxHQUN2QztRQUFDLEtBQUtELFFBQVFDLGFBQWEsQ0FBQ0MsTUFBTTtRQUFFLEtBQUtGLFFBQVFDLGFBQWEsQ0FBQ0UsTUFBTTtJQUFBLElBQ3JFTjtJQUNKLE1BQU1PLGdCQUFnQkosUUFBUUksYUFBYSxHQUN2QztRQUFDLEtBQUtKLFFBQVFJLGFBQWEsQ0FBQ0YsTUFBTTtRQUFFLEtBQUtGLFFBQVFJLGFBQWEsQ0FBQ0QsTUFBTTtJQUFBLElBQ3JFTDtJQUVKLE1BQU1PLFlBQVk7UUFDaEJDLFFBQVE7WUFDTjs7OztPQUlDLEdBQ0RDLE1BQUtDLElBQUk7Z0JBQ1AsSUFBSUEsS0FBS0MsS0FBSyxLQUFLLE1BQU07b0JBQ3ZCRCxLQUFLQyxLQUFLLEdBQUc7Z0JBQ2Y7WUFDRjtZQUNBOzs7O09BSUMsR0FDREMsV0FBVUYsSUFBSTtnQkFDWixJQUFJQSxLQUFLQyxLQUFLLEtBQUssT0FBTztvQkFDeEJELEtBQUtDLEtBQUssR0FBRztnQkFDZixPQUFPLElBQUlELEtBQUtDLEtBQUssS0FBSyxNQUFNO29CQUM5QkQsS0FBS0MsS0FBSyxHQUFHO2dCQUNmO1lBQ0Y7WUFDQTs7OztPQUlDLEdBQ0RFLFVBQVNILElBQUk7Z0JBQ1gsSUFBSUEsS0FBS0MsS0FBSyxLQUFLLE9BQU87b0JBQ3hCRCxLQUFLQyxLQUFLLEdBQUc7Z0JBQ2Ys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QUNBLE9BQ0EseUNBQ0E7UUFFTjtJQUNGLE9BQU87UUFDTEEsU0FBUztJQUNYO0lBRUEsTUFBTUQsWUFBWU4sZ0JBQWdCQztJQUVsQyxJQUFJNkIsV0FBVyxPQUFPO1FBQ3BCTSxRQUFRVCxJQUFJLENBQUNyQixVQUFVd0IsTUFBTSxDQUFDdEIsSUFBSTtJQUNwQztJQUVBLElBQUlTLGFBQWEsT0FBTztRQUN0Qm1CLFFBQVFULElBQUksQ0FBQ3JCLFVBQVVXLFFBQVEsQ0FBQ1QsSUFBSTtJQUN0QztJQUVBLElBQUlLLGNBQWMsT0FBTztRQUN2QnVCLFFBQVFULElBQUksQ0FBQ3JCLFVBQVVPLFNBQVMsQ0FBQ0EsY0FBYyxPQUFPLFNBQVNBLFVBQVU7SUFDM0U7SUFFQSxJQUFJTixXQUFXLE9BQU87UUFDcEI2QixRQUFRVCxJQUFJLENBQUNyQixVQUFVQyxNQUFNLENBQUNBLFdBQVcsT0FBTyxTQUFTQSxPQUFPO0lBQ2xFO0lBRUEsT0FBTyxDQUFDZ0M7UUFDTjNDLHVEQUFLQSxDQUFDMkMsTUFBTSxDQUFDOUIsTUFBTWEsVUFBVU47WUFDM0IsSUFBSUQsUUFBUSxDQUFDO1lBRWIsSUFBSU4sS0FBS2dCLElBQUksS0FBSyxxQkFBcUJoQixLQUFLZ0IsSUFBSSxLQUFLLGNBQWM7Z0JBQ2pFLE1BQU8sRUFBRVYsUUFBUXFCLFFBQVFQLE1BQU0sQ0FBRTtvQkFDL0Isc0NBQXNDO29CQUN0Q08sT0FBTyxDQUFDckIsTUFBTSxDQUFDTixNQUFNYSxVQUFVTjtnQkFDakM7WUFDRjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL292ZXJyZWFjdGVkLy4vbm9kZV9tb2R1bGVzL3JldGV4dC1zbWFydHlwYW50cy9pbmRleC5qcz8zYjAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbmxjc3QnKS5Sb290fSBSb290XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdubGNzdCcpLlNlbnRlbmNlfSBTZW50ZW5jZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbmxjc3QnKS5Xb3JkfSBXb3JkXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdubGNzdCcpLlN5bWJvbH0gU3ltYm9sXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdubGNzdCcpLlB1bmN0dWF0aW9ufSBQdW5jdHVhdGlvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbmxjc3QnKS5TZW50ZW5jZUNvbnRlbnR9IFNlbnRlbmNlQ29udGVudFxuICpcbiAqIEB0eXBlZGVmIFF1b3RlQ2hhcmFjdGVyTWFwXG4gKiAgIFF1b3RlIGNoYXJhY3RlcnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZG91YmxlXG4gKiAgIENoYXJhY3RlciB0byB1c2UgZm9yIGRvdWJsZSBxdW90ZXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2luZ2xlXG4gKiAgIENoYXJhY3RlciB0byB1c2UgZm9yIHNpbmdsZSBxdW90ZXMuXG4gKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcXVvdGVzPXRydWVdXG4gKiAgIENyZWF0ZSBzbWFydCBxdW90ZXMuXG4gKlxuICogICBDb252ZXJ0cyBzdHJhaWdodCBkb3VibGUgYW5kIHNpbmdsZSBxdW90ZXMgdG8gc21hcnQgZG91YmxlIG9yIHNpbmdsZVxuICogICBxdW90ZXMuXG4gKiBAcHJvcGVydHkge1F1b3RlQ2hhcmFjdGVyTWFwfSBbb3BlbmluZ1F1b3Rlc11cbiAqICAgQ2hhcmFjdGVycyB0byB1c2UgZm9yIG9wZW5pbmcgZG91YmxlIGFuZCBzaW5nbGUgcXVvdGVzLlxuICogQHByb3BlcnR5IHtRdW90ZUNoYXJhY3Rlck1hcH0gW2Nsb3NpbmdRdW90ZXNdXG4gKiAgIENoYXJhY3RlcnMgdG8gdXNlIGZvciBjbG9zaW5nIGRvdWJsZSBhbmQgc2luZ2xlIHF1b3Rlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VsbGlwc2VzPXRydWVdXG4gKiAgIENyZWF0ZSBzbWFydCBlbGxpcHNlcy5cbiAqXG4gKiAgIENvbnZlcnRzIHRyaXBsZSBkb3QgY2hhcmFjdGVycyAod2l0aCBvciB3aXRob3V0IHNwYWNlcyBiZXR3ZWVuKSBpbnRvIGFcbiAqICAgc2luZ2xlIFVuaWNvZGUgZWxsaXBzaXMgY2hhcmFjdGVyLlxuICogQHByb3BlcnR5IHtib29sZWFufCdhbGwnfSBbYmFja3RpY2tzPXRydWVdXG4gKiAgIENyZWF0ZSBzbWFydCBxdW90ZXMgZnJvbSBiYWNrdGlja3MuXG4gKlxuICogICBXaGVuIGB0cnVlYCwgY29udmVydHMgZG91YmxlIGJhY2stdGlja3MgaW50byBhbiBvcGVuaW5nIGRvdWJsZSBxdW90ZSwgYW5kXG4gKiAgIGRvdWJsZSBzdHJhaWdodCBzaW5nbGUgcXVvdGVzIGludG8gYSBjbG9zaW5nIGRvdWJsZSBxdW90ZS5cbiAqXG4gKiAgIFdoZW4gYCdhbGwnYDogZG9lcyB0aGUgcHJlY2VkaW5nIGFuZCBjb252ZXJ0cyBzaW5nbGUgYmFjay10aWNrcyBpbnRvIGFuXG4gKiAgIG9wZW5pbmcgc2luZ2xlIHF1b3RlLCBhbmQgYSBzdHJhaWdodCBzaW5nbGUgcXVvdGUgaW50byBhIGNsb3Npbmcgc2luZ2xlXG4gKiAgIHNtYXJ0IHF1b3RlLlxuICpcbiAqICAgTm90ZTogUXVvdGVzIGNhbiBub3QgYmUgYHRydWVgIHdoZW4gYGJhY2t0aWNrc2AgaXMgYCdhbGwnYDtcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnwnb2xkc2Nob29sJ3wnaW52ZXJ0ZWQnfSBbZGFzaGVzPXRydWVdXG4gKiAgIENyZWF0ZSBzbWFydCBkYXNoZXMuXG4gKlxuICogICBXaGVuIGB0cnVlYCwgY29udmVydHMgdHdvIGRhc2hlcyBpbnRvIGFuIGVtLWRhc2ggY2hhcmFjdGVyLlxuICpcbiAqICAgV2hlbiBgJ29sZHNjaG9vbCdgLCBjb252ZXJ0cyB0d28gZGFzaGVzIGludG8gYW4gZW4tZGFzaCwgYW5kIHRocmVlIGRhc2hlc1xuICogICBpbnRvIGFuIGVtLWRhc2guXG4gKlxuICogICBXaGVuIGAnaW52ZXJ0ZWQnYCwgY29udmVydHMgdHdvIGRhc2hlcyBpbnRvIGFuIGVtLWRhc2gsIGFuZCB0aHJlZSBkYXNoZXNcbiAqICAgaW50byBhbiBlbi1kYXNoLlxuICpcbiAqIEBjYWxsYmFjayBNZXRob2RcbiAqIEBwYXJhbSB7UHVuY3R1YXRpb258U3ltYm9sfSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7V29yZHxTZW50ZW5jZX0gcGFyZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG5pbXBvcnQge3Zpc2l0fSBmcm9tICd1bmlzdC11dGlsLXZpc2l0J1xuaW1wb3J0IHt0b1N0cmluZ30gZnJvbSAnbmxjc3QtdG8tc3RyaW5nJ1xuXG5jb25zdCBkZWZhdWx0Q2xvc2luZ1F1b3RlcyA9IHsnXCInOiAn4oCdJywgXCInXCI6ICfigJknfVxuY29uc3QgZGVmYXVsdE9wZW5pbmdRdW90ZXMgPSB7J1wiJzogJ+KAnCcsIFwiJ1wiOiAn4oCYJ31cblxuLyoqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWR1Y2F0b3JzKG9wdGlvbnMpIHtcbiAgY29uc3QgY2xvc2luZ1F1b3RlcyA9IG9wdGlvbnMuY2xvc2luZ1F1b3Rlc1xuICAgID8geydcIic6IG9wdGlvbnMuY2xvc2luZ1F1b3Rlcy5kb3VibGUsIFwiJ1wiOiBvcHRpb25zLmNsb3NpbmdRdW90ZXMuc2luZ2xlfVxuICAgIDogZGVmYXVsdENsb3NpbmdRdW90ZXNcbiAgY29uc3Qgb3BlbmluZ1F1b3RlcyA9IG9wdGlvbnMub3BlbmluZ1F1b3Rlc1xuICAgID8geydcIic6IG9wdGlvbnMub3BlbmluZ1F1b3Rlcy5kb3VibGUsIFwiJ1wiOiBvcHRpb25zLm9wZW5pbmdRdW90ZXMuc2luZ2xlfVxuICAgIDogZGVmYXVsdE9wZW5pbmdRdW90ZXNcblxuICBjb25zdCBlZHVjYXRvcnMgPSB7XG4gICAgZGFzaGVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0d28gZGFoZXMgaW50byBhbiBlbS1kYXNoLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtNZXRob2R9XG4gICAgICAgKi9cbiAgICAgIHRydWUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS52YWx1ZSA9PT0gJy0tJykge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSAn4oCUJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gdGhyZWUgZGFoZXMgaW50byBhbiBlbS1kYXNoLCBhbmQgdHdvIGludG8gYW4gZW4tZGFzaC5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7TWV0aG9kfVxuICAgICAgICovXG4gICAgICBvbGRzY2hvb2wobm9kZSkge1xuICAgICAgICBpZiAobm9kZS52YWx1ZSA9PT0gJy0tLScpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gJ+KAlCdcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnZhbHVlID09PSAnLS0nKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9ICfigJMnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aHJlZSBkYWhlcyBpbnRvIGFuIGVuLWRhc2gsIGFuZCB0d28gaW50byBhbiBlbS1kYXNoLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtNZXRob2R9XG4gICAgICAgKi9cbiAgICAgIGludmVydGVkKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUudmFsdWUgPT09ICctLS0nKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9ICfigJMnXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSA9PT0gJy0tJykge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSAn4oCUJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBiYWNrdGlja3M6IHtcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIGRvdWJsZSBiYWNrdGlja3MgYW5kIHNpbmdsZSBxdW90ZXMgaW50byBzbWFydCBxdW90ZXMuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge01ldGhvZH1cbiAgICAgICAqL1xuICAgICAgdHJ1ZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnZhbHVlID09PSAnYGAnKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9ICfigJwnXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSA9PT0gXCInJ1wiKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9ICfigJ0nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSBzaW5nbGUgYW5kIGRvdWJsZSBiYWNrdGlja3MgYW5kIHNpbmdsZSBxdW90ZXMgaW50byBzbWFydCBxdW90ZXMuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge01ldGhvZH1cbiAgICAgICAqL1xuICAgICAgYWxsKG5vZGUsIGluZGV4LCBwYXJlbnQpIHtcbiAgICAgICAgZWR1Y2F0b3JzLmJhY2t0aWNrcy50cnVlKG5vZGUsIGluZGV4LCBwYXJlbnQpXG5cbiAgICAgICAgaWYgKG5vZGUudmFsdWUgPT09ICdgJykge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSAn4oCYJ1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9ICfigJknXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGVsbGlwc2VzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSBtdWx0aXBsZSBkb3RzIGludG8gdW5pY29kZSBlbGxpcHNlcy5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7TWV0aG9kfVxuICAgICAgICovXG4gICAgICB0cnVlKG5vZGUsIGluZGV4LCBwYXJlbnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlLnZhbHVlXG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuXG5cbiAgICAgICAgLy8gU2ltcGxlIG5vZGUgd2l0aCB0aHJlZSBkb3RzIGFuZCB3aXRob3V0IHdoaXRlLXNwYWNlLlxuICAgICAgICBpZiAoL15cXC57Myx9JC8udGVzdChub2RlLnZhbHVlKSkge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSAn4oCmJ1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEvXlxcLiskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VhcmNoIGZvciBkb3Qtbm9kZXMgd2l0aCB3aGl0ZS1zcGFjZSBiZXR3ZWVuLlxuICAgICAgICAvKiogQHR5cGUge0FycmF5PFNlbnRlbmNlQ29udGVudD59ICovXG4gICAgICAgIGNvbnN0IG5vZGVzID0gW11cbiAgICAgICAgbGV0IHBvc2l0aW9uID0gaW5kZXhcbiAgICAgICAgbGV0IGNvdW50ID0gMVxuXG4gICAgICAgIC8vIEl04oCZcyBwb3NzaWJsZSB0aGF0IHRoZSBub2RlIGlzIG1lcmdlZCB3aXRoIGFuIGFkamFjZW50IHdvcmQtbm9kZS4gIEluIHRoYXRcbiAgICAgICAgLy8gY29kZSwgd2UgY2Fubm90IHRyYW5zZm9ybSBpdCBiZWNhdXNlIHRoZXJl4oCZcyBubyByZWZlcmVuY2UgdG8gdGhlXG4gICAgICAgIC8vIGdyYW5kcGFyZW50LlxuICAgICAgICB3aGlsZSAoLS1wb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICBsZXQgc2libGluZyA9IHNpYmxpbmdzW3Bvc2l0aW9uXVxuXG4gICAgICAgICAgaWYgKHNpYmxpbmcudHlwZSAhPT0gJ1doaXRlU3BhY2VOb2RlJykge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBxdWV1ZSA9IHNpYmxpbmdcbiAgICAgICAgICBzaWJsaW5nID0gc2libGluZ3NbLS1wb3NpdGlvbl1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHNpYmxpbmcgJiZcbiAgICAgICAgICAgIChzaWJsaW5nLnR5cGUgPT09ICdQdW5jdHVhdGlvbk5vZGUnIHx8XG4gICAgICAgICAgICAgIHNpYmxpbmcudHlwZSA9PT0gJ1N5bWJvbE5vZGUnKSAmJlxuICAgICAgICAgICAgL15cXC4rJC8udGVzdChzaWJsaW5nLnZhbHVlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChxdWV1ZSwgc2libGluZylcblxuICAgICAgICAgICAgY291bnQrK1xuXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY291bnQgPCAzKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBzaWJsaW5ncy5zcGxpY2UoaW5kZXggLSBub2Rlcy5sZW5ndGgsIG5vZGVzLmxlbmd0aClcblxuICAgICAgICBub2RlLnZhbHVlID0gJ+KApidcbiAgICAgIH1cbiAgICB9LFxuICAgIHF1b3Rlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gc3RyYWlnaHQgc2luZ2xlLSBhbmQgZG91YmxlIHF1b3RlcyBpbnRvIHNtYXJ0IHF1b3Rlcy5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7TWV0aG9kfVxuICAgICAgICovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgICAgdHJ1ZShub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZS52YWx1ZVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gJ1wiJyAmJiB2YWx1ZSAhPT0gXCInXCIpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzID0gc2libGluZ3NbaW5kZXggLSAxXVxuICAgICAgICBjb25zdCBuZXh0ID0gc2libGluZ3NbaW5kZXggKyAxXVxuICAgICAgICBjb25zdCBuZXh0TmV4dCA9IHNpYmxpbmdzW2luZGV4ICsgMl1cbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gbmV4dCAmJiB0b1N0cmluZyhuZXh0KVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXh0ICYmXG4gICAgICAgICAgbmV4dE5leHQgJiZcbiAgICAgICAgICAobmV4dC50eXBlID09PSAnUHVuY3R1YXRpb25Ob2RlJyB8fCBuZXh0LnR5cGUgPT09ICdTeW1ib2xOb2RlJykgJiZcbiAgICAgICAgICBuZXh0TmV4dC50eXBlICE9PSAnV29yZE5vZGUnXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBpZiB0aGUgdmVyeSBmaXJzdCBjaGFyYWN0ZXIgaXMgYSBxdW90ZSBmb2xsb3dlZCBieVxuICAgICAgICAgIC8vIHB1bmN0dWF0aW9uIGF0IGEgbm9uLXdvcmQtYnJlYWsuIENsb3NlIHRoZSBxdW90ZXMgYnkgYnJ1dGUgZm9yY2UuXG4gICAgICAgICAgbm9kZS52YWx1ZSA9IGNsb3NpbmdRdW90ZXNbdmFsdWVdXG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgbmV4dE5leHQgJiZcbiAgICAgICAgICAobmV4dFZhbHVlID09PSAnXCInIHx8IG5leHRWYWx1ZSA9PT0gXCInXCIpICYmXG4gICAgICAgICAgbmV4dE5leHQudHlwZSA9PT0gJ1dvcmROb2RlJ1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGRvdWJsZSBzZXRzIG9mIHF1b3RlczpcbiAgICAgICAgICAvLyBgSGUgc2FpZCwgXCInUXVvdGVkJyB3b3JkcyBpbiBhIGxhcmdlciBxdW90ZS5cImBcbiAgICAgICAgICBub2RlLnZhbHVlID0gb3BlbmluZ1F1b3Rlc1t2YWx1ZV1cbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpdOKAmXMgYSBsaXRlcmFsLlxuICAgICAgICAgIG5leHQudmFsdWUgPSBvcGVuaW5nUXVvdGVzW25leHRWYWx1ZV1cbiAgICAgICAgfSBlbHNlIGlmIChuZXh0ICYmIC9eXFxkXFxkcyQvLnRlc3QobmV4dFZhbHVlKSkge1xuICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgZGVjYWRlIGFiYnJldmlhdGlvbnM6IGB0aGUgJzgwc2BcbiAgICAgICAgICBub2RlLnZhbHVlID0gY2xvc2luZ1F1b3Rlc1t2YWx1ZV1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBwcmV2aW91cyAmJlxuICAgICAgICAgIG5leHQgJiZcbiAgICAgICAgICAocHJldmlvdXMudHlwZSA9PT0gJ1doaXRlU3BhY2VOb2RlJyB8fFxuICAgICAgICAgICAgcHJldmlvdXMudHlwZSA9PT0gJ1B1bmN0dWF0aW9uTm9kZScgfHxcbiAgICAgICAgICAgIHByZXZpb3VzLnR5cGUgPT09ICdTeW1ib2xOb2RlJykgJiZcbiAgICAgICAgICBuZXh0LnR5cGUgPT09ICdXb3JkTm9kZSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gR2V0IG1vc3Qgb3BlbmluZyBzaW5nbGUgcXVvdGVzLlxuICAgICAgICAgIG5vZGUudmFsdWUgPSBvcGVuaW5nUXVvdGVzW3ZhbHVlXVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHByZXZpb3VzICYmXG4gICAgICAgICAgcHJldmlvdXMudHlwZSAhPT0gJ1doaXRlU3BhY2VOb2RlJyAmJlxuICAgICAgICAgIHByZXZpb3VzLnR5cGUgIT09ICdTeW1ib2xOb2RlJyAmJlxuICAgICAgICAgIHByZXZpb3VzLnR5cGUgIT09ICdQdW5jdHVhdGlvbk5vZGUnXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIENsb3NpbmcgcXVvdGVzLlxuICAgICAgICAgIG5vZGUudmFsdWUgPSBjbG9zaW5nUXVvdGVzW3ZhbHVlXVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICFuZXh0IHx8XG4gICAgICAgICAgbmV4dC50eXBlID09PSAnV2hpdGVTcGFjZU5vZGUnIHx8XG4gICAgICAgICAgKHZhbHVlID09PSBcIidcIiAmJiBuZXh0VmFsdWUgPT09ICdzJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IGNsb3NpbmdRdW90ZXNbdmFsdWVdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IG9wZW5pbmdRdW90ZXNbdmFsdWVdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWR1Y2F0b3JzXG59XG5cbi8qKlxuICogUGx1Z2luIHRvIHJlcGxhY2UgZHVtYi9zdHJhaWdodC90eXBld3JpdGVyIHB1bmN0dWF0aW9uIG1hcmtzIHdpdGggc21hcnQvY3VybHlcbiAqIHB1bmN0dWF0aW9uIG1hcmtzLlxuICpcbiAqIEB0eXBlIHtpbXBvcnQoJ3VuaWZpZWQnKS5QbHVnaW48W09wdGlvbnM/XXxbXSwgUm9vdD59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJldGV4dFNtYXJ0eXBhbnRzKG9wdGlvbnMgPSB7fSkge1xuICAvKiogQHR5cGUge0FycmF5PE1ldGhvZD59ICovXG4gIGNvbnN0IG1ldGhvZHMgPSBbXVxuICAvKiogQHR5cGUge09wdGlvbnNbJ3F1b3RlcyddfSAqL1xuICBsZXQgcXVvdGVzXG4gIC8qKiBAdHlwZSB7T3B0aW9uc1snZWxsaXBzZXMnXX0gKi9cbiAgbGV0IGVsbGlwc2VzXG4gIC8qKiBAdHlwZSB7T3B0aW9uc1snYmFja3RpY2tzJ119ICovXG4gIGxldCBiYWNrdGlja3NcbiAgLyoqIEB0eXBlIHtPcHRpb25zWydkYXNoZXMnXX0gKi9cbiAgbGV0IGRhc2hlc1xuXG4gIGlmICgncXVvdGVzJyBpbiBvcHRpb25zKSB7XG4gICAgcXVvdGVzID0gb3B0aW9ucy5xdW90ZXNcblxuICAgIGlmIChxdW90ZXMgIT09IEJvb2xlYW4ocXVvdGVzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0lsbGVnYWwgaW52b2NhdGlvbjogYCcgK1xuICAgICAgICAgIHF1b3RlcyArXG4gICAgICAgICAgJ2AgJyArXG4gICAgICAgICAgJ2lzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciBgcXVvdGVzYCBpbiAnICtcbiAgICAgICAgICAnYHNtYXJ0eXBhbnRzYCdcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVvdGVzID0gdHJ1ZVxuICB9XG5cbiAgaWYgKCdlbGxpcHNlcycgaW4gb3B0aW9ucykge1xuICAgIGVsbGlwc2VzID0gb3B0aW9ucy5lbGxpcHNlc1xuXG4gICAgaWYgKGVsbGlwc2VzICE9PSBCb29sZWFuKGVsbGlwc2VzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0lsbGVnYWwgaW52b2NhdGlvbjogYCcgK1xuICAgICAgICAgIGVsbGlwc2VzICtcbiAgICAgICAgICAnYCAnICtcbiAgICAgICAgICAnaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIGBlbGxpcHNlc2AgaW4gJyArXG4gICAgICAgICAgJ2BzbWFydHlwYW50c2AnXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVsbGlwc2VzID0gdHJ1ZVxuICB9XG5cbiAgaWYgKCdiYWNrdGlja3MnIGluIG9wdGlvbnMpIHtcbiAgICBiYWNrdGlja3MgPSBvcHRpb25zLmJhY2t0aWNrc1xuXG4gICAgaWYgKGJhY2t0aWNrcyAhPT0gQm9vbGVhbihiYWNrdGlja3MpICYmIGJhY2t0aWNrcyAhPT0gJ2FsbCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdJbGxlZ2FsIGludm9jYXRpb246IGAnICtcbiAgICAgICAgICBiYWNrdGlja3MgK1xuICAgICAgICAgICdgICcgK1xuICAgICAgICAgICdpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgYGJhY2t0aWNrc2AgaW4gJyArXG4gICAgICAgICAgJ2BzbWFydHlwYW50c2AnXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGJhY2t0aWNrcyA9PT0gJ2FsbCcgJiYgcXVvdGVzID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnSWxsZWdhbCBpbnZvY2F0aW9uOiBgYmFja3RpY2tzOiAnICtcbiAgICAgICAgICBiYWNrdGlja3MgK1xuICAgICAgICAgICdgIGlzIG5vdCBhIHZhbGlkIHZhbHVlICcgK1xuICAgICAgICAgICd3aGVuIGBxdW90ZXM6ICcgK1xuICAgICAgICAgIHF1b3RlcyArXG4gICAgICAgICAgJ2AgaW4gJyArXG4gICAgICAgICAgJ2BzbWFydHlwYW50c2AnXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhY2t0aWNrcyA9IHRydWVcbiAgfVxuXG4gIGlmICgnZGFzaGVzJyBpbiBvcHRpb25zKSB7XG4gICAgZGFzaGVzID0gb3B0aW9ucy5kYXNoZXNcblxuICAgIGlmIChcbiAgICAgIGRhc2hlcyAhPT0gQm9vbGVhbihkYXNoZXMpICYmXG4gICAgICBkYXNoZXMgIT09ICdvbGRzY2hvb2wnICYmXG4gICAgICBkYXNoZXMgIT09ICdpbnZlcnRlZCdcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdJbGxlZ2FsIGludm9jYXRpb246IGAnICtcbiAgICAgICAgICBkYXNoZXMgK1xuICAgICAgICAgICdgICcgK1xuICAgICAgICAgICdpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgYGRhaGVzYCBpbiAnICtcbiAgICAgICAgICAnYHNtYXJ0eXBhbnRzYCdcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGFzaGVzID0gdHJ1ZVxuICB9XG5cbiAgY29uc3QgZWR1Y2F0b3JzID0gY3JlYXRlRWR1Y2F0b3JzKG9wdGlvbnMpXG5cbiAgaWYgKHF1b3RlcyAhPT0gZmFsc2UpIHtcbiAgICBtZXRob2RzLnB1c2goZWR1Y2F0b3JzLnF1b3Rlcy50cnVlKVxuICB9XG5cbiAgaWYgKGVsbGlwc2VzICE9PSBmYWxzZSkge1xuICAgIG1ldGhvZHMucHVzaChlZHVjYXRvcnMuZWxsaXBzZXMudHJ1ZSlcbiAgfVxuXG4gIGlmIChiYWNrdGlja3MgIT09IGZhbHNlKSB7XG4gICAgbWV0aG9kcy5wdXNoKGVkdWNhdG9ycy5iYWNrdGlja3NbYmFja3RpY2tzID09PSB0cnVlID8gJ3RydWUnIDogYmFja3RpY2tzXSlcbiAgfVxuXG4gIGlmIChkYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgbWV0aG9kcy5wdXNoKGVkdWNhdG9ycy5kYXNoZXNbZGFzaGVzID09PSB0cnVlID8gJ3RydWUnIDogZGFzaGVzXSlcbiAgfVxuXG4gIHJldHVybiAodHJlZSkgPT4ge1xuICAgIHZpc2l0KHRyZWUsIChub2RlLCBwb3NpdGlvbiwgcGFyZW50KSA9PiB7XG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICBpZiAobm9kZS50eXBlID09PSAnUHVuY3R1YXRpb25Ob2RlJyB8fCBub2RlLnR5cGUgPT09ICdTeW1ib2xOb2RlJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IG1ldGhvZHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogdGhleeKAmXJlIGxpdGVyYWxzLlxuICAgICAgICAgIG1ldGhvZHNbaW5kZXhdKG5vZGUsIHBvc2l0aW9uLCBwYXJlbnQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG4iXSwibmFtZXMiOlsidmlzaXQiLCJ0b1N0cmluZyIsImRlZmF1bHRDbG9zaW5nUXVvdGVzIiwiZGVmYXVsdE9wZW5pbmdRdW90ZXMiLCJjcmVhdGVFZHVjYXRvcnMiLCJvcHRpb25zIiwiY2xvc2luZ1F1b3RlcyIsImRvdWJsZSIsInNpbmdsZSIsIm9wZW5pbmdRdW90ZXMiLCJlZHVjYXRvcnMiLCJkYXNoZXMiLCJ0cnVlIiwibm9kZSIsInZhbHVlIiwib2xkc2Nob29sIiwiaW52ZXJ0ZWQiLCJiYWNrdGlja3MiLCJhbGwiLCJpbmRleCIsInBhcmVudCIsImVsbGlwc2VzIiwic2libGluZ3MiLCJjaGlsZHJlbiIsInRlc3QiLCJub2RlcyIsInBvc2l0aW9uIiwiY291bnQiLCJzaWJsaW5nIiwidHlwZSIsInF1ZXVlIiwicHVzaCIsInNwbGljZSIsImxlbmd0aCIsInF1b3RlcyIsInByZXZpb3VzIiwibmV4dCIsIm5leHROZXh0IiwibmV4dFZhbHVlIiwicmV0ZXh0U21hcnR5cGFudHMiLCJtZXRob2RzIiwiQm9vbGVhbiIsIlR5cGVFcnJvciIsInRyZWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/retext-smartypants/index.js\n");

/***/ })

};
;