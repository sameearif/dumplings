"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rehype-pretty-code";
exports.ids = ["vendor-chunks/rehype-pretty-code"];
exports.modules = {

/***/ "(rsc)/./node_modules/rehype-pretty-code/dist/rehype-pretty-code.js":
/*!********************************************************************!*\
  !*** ./node_modules/rehype-pretty-code/dist/rehype-pretty-code.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rehypePrettyCode)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var parse_numeric_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parse-numeric-range */ \"(rsc)/./node_modules/parse-numeric-range/index.js\");\n/* harmony import */ var shiki__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shiki */ \"shiki\");\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unified */ \"(rsc)/./node_modules/unified/lib/index.js\");\n/* harmony import */ var rehype_parse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rehype-parse */ \"(rsc)/./node_modules/rehype-parse/lib/index.js\");\n/* harmony import */ var hash_obj__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hash-obj */ \"(rsc)/./node_modules/hash-obj/index.js\");\n/* harmony import */ var hast_util_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hast-util-to-string */ \"(rsc)/./node_modules/hast-util-to-string/index.js\");\n\n\n\n\n\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isShikiTheme(value) {\n    return value ? hasOwnProperty(value, \"tokenColors\") : false;\n}\nfunction isElement(value) {\n    return value ? value.type === \"element\" : false;\n}\nfunction isText(value) {\n    return value ? value.type === \"text\" : false;\n}\nfunction hasOwnProperty(object, string) {\n    return ({}).hasOwnProperty.call(object, string);\n}\nfunction splitElement({ elements, elementToWrap, innerString, rightString, leftString, rest, nextElementContinues, index, ignoreChars }) {\n    if (isElement(elementToWrap) && elementToWrap.children?.[0]?.type !== \"text\" || ignoreChars) {\n        return [\n            elementToWrap,\n            index\n        ];\n    }\n    let newIndex = index;\n    // assign the matched value to the current element\n    const textElement = elementToWrap.children[0];\n    if (isText(textElement)) {\n        textElement.value = innerString;\n    }\n    let rightStr = rightString;\n    const leftStr = leftString;\n    // append any repetitions to the right if necessary\n    if (rest.length > 0) {\n        rightStr += rest.map((s)=>s === \"\" ? innerString : innerString + s).join(\"\");\n    }\n    if (leftStr.length > 0) {\n        elements.splice(newIndex, 0, {\n            ...elementToWrap,\n            properties: {\n                ...elementToWrap.properties\n            },\n            children: [\n                {\n                    type: \"text\",\n                    value: leftStr\n                }\n            ]\n        });\n    }\n    if (rightStr.length > 0 && !nextElementContinues) {\n        newIndex = leftStr.length > 0 ? newIndex + 2 : newIndex + 1;\n        elements.splice(newIndex, 0, {\n            ...elementToWrap,\n            properties: {\n                ...elementToWrap.properties\n            },\n            children: [\n                {\n                    type: \"text\",\n                    value: rightStr\n                }\n            ]\n        });\n    }\n    return [\n        elementToWrap,\n        index + 1\n    ];\n}\n/**\n * Look ahead to determine if further, sibling nodes continue the string.\n */ function nextElementMaybeContinuesChars({ elements, nextIndex, remainingPart }) {\n    if (remainingPart === \"\") {\n        return false;\n    }\n    const nextNode = elements[nextIndex];\n    const content = getContent(nextNode);\n    if (!content) {\n        return false;\n    }\n    const includesNext = content.startsWith(remainingPart) || remainingPart.startsWith(content);\n    const overlap = findOverlap(content, remainingPart);\n    if (overlap === remainingPart && content.startsWith(remainingPart)) {\n        return true;\n    }\n    if (includesNext) {\n        return nextElementMaybeContinuesChars({\n            elements,\n            nextIndex: nextIndex + 1,\n            remainingPart: remainingPart.replace(content, \"\")\n        });\n    }\n    return false;\n}\nfunction getContent(node) {\n    if (!node) return;\n    return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_3__.toString)(node);\n}\nfunction findOverlap(a, b) {\n    if (b.length === 0) {\n        return \"\";\n    }\n    if (a.endsWith(b)) {\n        return b;\n    }\n    if (a.indexOf(b) >= 0) {\n        return b;\n    }\n    return findOverlap(a, b.substring(0, b.length - 1));\n}\nfunction reverseString(s) {\n    return s.split(\"\").reverse().join(\"\");\n}\nfunction getElementsToHighlight(element, chars, startIndex = 0, ignoreChars = false) {\n    const toWrap = [];\n    let charsSoFar = \"\";\n    if (element.children) {\n        const elements = element.children;\n        for(let i = startIndex; i < elements.length; i++){\n            const remaining = charsSoFar ? chars.replace(charsSoFar, \"\") : chars;\n            if (remaining === \"\") {\n                return toWrap;\n            }\n            const maybeElement = elements[i];\n            if (!maybeElement || maybeElement.type !== \"element\" || // ignore any previously matched chars within\n            hasOwnProperty(maybeElement.properties ?? {}, \"rehype-pretty-code-visited\")) {\n                continue;\n            }\n            const content = getContent(maybeElement) || \"\";\n            // node is the chars, or it finishes the chars\n            if (content === chars || charsSoFar + content === chars) {\n                toWrap.push({\n                    element: maybeElement,\n                    index: i\n                });\n                return toWrap;\n            }\n            // check if the whole node is a continuation of the chars\n            if (chars.startsWith(charsSoFar + content)) {\n                // make sure we continue here only if further siblings\n                // complete the chars. Otherwise an earlier repetition\n                // of a section of the chars will lead us down the wrong path\n                if (nextElementMaybeContinuesChars({\n                    elements,\n                    nextIndex: i + 1,\n                    remainingPart: remaining.replace(content, \"\")\n                })) {\n                    toWrap.push({\n                        element: elements[i],\n                        index: i\n                    });\n                    charsSoFar += content;\n                    continue;\n                }\n            }\n            const overlap = findOverlap(content, remaining);\n            const partialMatch = overlap && remaining.startsWith(overlap);\n            if (partialMatch) {\n                const nextPart = remaining.replace(overlap, \"\");\n                // this is the wrong node, continue\n                if (nextPart !== \"\" && getContent(elements[i + 1]) && !nextElementMaybeContinuesChars({\n                    elements,\n                    nextIndex: i + 1,\n                    remainingPart: nextPart\n                })) {\n                    continue;\n                }\n                const splitParts = content.split(overlap);\n                const [leftPart, rightPart, ...rest] = splitParts;\n                if (rightPart || leftPart || rest.length > 0) {\n                    // One of the below scenarios should be true\n                    // 1. the whole set of chars are inside the string (at least once) ca[rro]t\n                    // 2. the chars finish or start & end on the beginning of the string ...[carr]ot\n                    // 3. the chars start or start & end from the end of the string carr[ot]...\n                    const withNextNode = content + (getContent(elements[i + 1]) ? getContent(elements[i + 1]) : \"\");\n                    const nextNodeOverlap = findOverlap(withNextNode, remaining);\n                    const splitIndex = withNextNode.indexOf(nextNodeOverlap);\n                    if (chars.endsWith(overlap) || chars.startsWith(overlap)) {\n                        const rightString = rightPart.replace(overlap, \"\");\n                        const innerString = overlap;\n                        const leftString = content.substring(0, splitIndex);\n                        // need to check this to avoid edge case where the right\n                        // side will be duplicated when the matched part repeats within the\n                        // current node\n                        const nextElementContinues = nextElementMaybeContinuesChars({\n                            elements,\n                            nextIndex: i + 1,\n                            remainingPart: nextPart\n                        });\n                        const [newElement, updatedIndex] = splitElement({\n                            elements,\n                            elementToWrap: elements[i],\n                            innerString,\n                            rightString,\n                            leftString,\n                            rest,\n                            nextElementContinues,\n                            index: i,\n                            ignoreChars\n                        });\n                        charsSoFar += overlap;\n                        toWrap.push({\n                            element: newElement,\n                            index: updatedIndex\n                        });\n                    }\n                }\n            }\n        }\n    }\n    return toWrap;\n}\nfunction wrapHighlightedChars(parentElement, elementsToWrap, options, ignoreWord, onVisitHighlightedChars) {\n    if (!elementsToWrap || elementsToWrap.length === 0) {\n        return;\n    }\n    const [{ element }] = elementsToWrap;\n    if (ignoreWord) {\n        if (element.properties) {\n            element.properties[\"rehype-pretty-code-visited\"] = \"\";\n        }\n        return;\n    }\n    if (elementsToWrap.length > 1) {\n        parentElement.children.splice(elementsToWrap[0].index, elementsToWrap.length, {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {\n                \"data-highlighted-chars-wrapper\": \"\"\n            },\n            children: elementsToWrap.map(({ element })=>element)\n        });\n        const element = parentElement.children[elementsToWrap[0].index];\n        if (!isElement(element)) {\n            return;\n        }\n        const wordStr = element.children.reduce((acc, node)=>{\n            const textElement = isElement(node) ? node.children[0] : null;\n            if (isText(textElement)) {\n                return acc + textElement.value;\n            }\n            return acc;\n        }, \"\");\n        const id = options.idsMap.get(wordStr);\n        element.properties = element.properties || {};\n        element.properties[\"data-highlighted-chars\"] = \"\";\n        element.properties[\"data-chars-id\"] = id;\n        onVisitHighlightedChars?.(element, id);\n    } else {\n        const [{ element }] = elementsToWrap;\n        const textElement = element.children[0];\n        if (!isText(textElement)) {\n            return;\n        }\n        const id = options.idsMap.get(textElement.value);\n        element.properties = element.properties || {};\n        // used to skip already parsed chars\n        element.properties[\"rehype-pretty-code-visited\"] = \"\";\n        element.properties[\"data-highlighted-chars\"] = \"\";\n        element.properties[\"data-chars-id\"] = id;\n        onVisitHighlightedChars?.(element, id);\n    }\n}\n/**\n * Loops through the child nodes and finds the nodes that make up the chars.\n * If the chars cross node boundaries, those nodes are wrapped with\n * <span data-highlighted-chars-wrapper>, and that node is passed to\n * onVisitHighlightedChars.\n *\n * If a node partially matches the chars, its content is replaced with the\n * matched part, and the left and/or right parts are cloned to sibling nodes.\n */ function charsHighlighter(element, charsList, options, onVisitHighlightedChars) {\n    const { ranges = [] } = options;\n    const textContent = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_3__.toString)(element);\n    charsList.forEach((chars, index)=>{\n        if (chars && textContent?.includes(chars)) {\n            let textContent = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_3__.toString)(element);\n            let startIndex = 0;\n            while(textContent.includes(chars)){\n                const currentCharsRange = ranges[index] || [];\n                const id = `${chars}-${index}`;\n                options.counterMap.set(id, (options.counterMap.get(id) || 0) + 1);\n                const ignoreChars = currentCharsRange.length > 0 && !currentCharsRange.includes(options.counterMap.get(id) ?? -1);\n                const elementsToWrap = getElementsToHighlight(element, chars, startIndex, ignoreChars);\n                // maybe throw / notify due to failure here\n                if (elementsToWrap.length === 0) break;\n                wrapHighlightedChars(element, elementsToWrap, options, ignoreChars, onVisitHighlightedChars);\n                // re-start from the 'last' node (the chars or part of them may exist\n                // multiple times in the same node)\n                // account for possible extra nodes added from split with - 2\n                startIndex = Math.max(elementsToWrap[elementsToWrap.length - 1].index - 2, 0);\n                textContent = element.children.map((childNode)=>{\n                    const props = isElement(childNode) ? childNode.properties : {};\n                    if (props && !hasOwnProperty(props, \"rehype-pretty-code-visited\") && !hasOwnProperty(props, \"data-highlighted-chars-wrapper\")) {\n                        return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_3__.toString)(childNode);\n                    }\n                }).join(\"\");\n            }\n        }\n        element.children.forEach((childNode)=>{\n            if (!isElement(childNode)) {\n                return;\n            }\n            if (hasOwnProperty(childNode.properties ?? {}, \"rehype-pretty-code-visited\")) {\n                if (childNode.properties) {\n                    delete childNode.properties[\"rehype-pretty-code-visited\"];\n                }\n            }\n        });\n    });\n}\nfunction toFragment(element, { trees, lang, title, caption, inline = false, keepBackground = true, grid = true, lineNumbersMaxDigits = 1, onVisitTitle, onVisitCaption }) {\n    element.tagName = inline ? \"span\" : \"div\";\n    // User can replace this with a real Fragment at runtime\n    element.properties = {\n        \"data-rehype-pretty-code-fragment\": \"\"\n    };\n    element.children = Object.entries(trees).map(([mode, tree])=>{\n        const pre = tree.children[0];\n        if (!isElement(pre) || !pre.properties) {\n            return [];\n        }\n        const code = pre.children[0];\n        // Remove class=\"shiki\"\n        if (Array.isArray(pre.properties?.className) && pre.properties?.className.includes(\"shiki\")) {\n            const className = pre.properties.className.filter((c)=>c !== \"shiki\");\n            pre.properties.className = className.length > 0 ? className : undefined;\n        }\n        if (!keepBackground) {\n            pre.properties.style = undefined;\n        }\n        pre.properties[\"data-language\"] = lang;\n        pre.properties[\"data-theme\"] = mode;\n        if (!isElement(code) || !code.properties) {\n            return [];\n        }\n        code.properties[\"data-language\"] = lang;\n        code.properties[\"data-theme\"] = mode;\n        if (inline) {\n            if (keepBackground) {\n                code.properties.style = pre.properties.style;\n            }\n            return code;\n        }\n        if (grid) {\n            if (code.properties.style) {\n                code.properties.style += \"display: grid;\";\n            } else {\n                code.properties.style = \"display: grid;\";\n            }\n        }\n        if (\"data-line-numbers\" in code.properties) {\n            code.properties[\"data-line-numbers-max-digits\"] = lineNumbersMaxDigits.toString().length;\n        }\n        const fragments = [];\n        if (title) {\n            const elementContent = {\n                type: \"element\",\n                tagName: \"div\",\n                properties: {\n                    \"data-rehype-pretty-code-title\": \"\",\n                    \"data-language\": lang,\n                    \"data-theme\": mode\n                },\n                children: [\n                    {\n                        type: \"text\",\n                        value: title\n                    }\n                ]\n            };\n            onVisitTitle?.(elementContent);\n            fragments.push(elementContent);\n        }\n        fragments.push(pre);\n        if (caption) {\n            const elementContent = {\n                type: \"element\",\n                tagName: \"div\",\n                properties: {\n                    \"data-rehype-pretty-code-caption\": \"\",\n                    \"data-language\": lang,\n                    \"data-theme\": mode\n                },\n                children: [\n                    {\n                        type: \"text\",\n                        value: caption\n                    }\n                ]\n            };\n            onVisitCaption?.(elementContent);\n            fragments.push(elementContent);\n        }\n        return fragments;\n    }).flatMap((c)=>c);\n}\nconst globalHighlighterCache = new Map();\nconst hastParser = (0,unified__WEBPACK_IMPORTED_MODULE_4__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n    fragment: true\n});\nfunction rehypePrettyCode(options = {}) {\n    const { grid = true, theme = \"github-dark-dimmed\", keepBackground = true, defaultLang = \"\", tokensMap = {}, filterMetaString = (v)=>v, getHighlighter: getHighlighter$1 = shiki__WEBPACK_IMPORTED_MODULE_1__.getHighlighter, onVisitLine, onVisitHighlightedLine, onVisitHighlightedChars, onVisitTitle, onVisitCaption } = options;\n    const optionsHash = (0,hash_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        theme,\n        tokensMap,\n        onVisitLine,\n        onVisitHighlightedLine,\n        onVisitHighlightedChars,\n        getHighlighter: getHighlighter$1\n    }, {\n        algorithm: \"sha1\"\n    });\n    let highlighterCache = globalHighlighterCache.get(optionsHash);\n    if (!highlighterCache) {\n        highlighterCache = new Map();\n        globalHighlighterCache.set(optionsHash, highlighterCache);\n    }\n    const highlighters = new Map();\n    const defaultCodeBlockLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.block || \"\";\n    const defaultInlineCodeLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.inline || \"\";\n    if (theme == null || typeof theme === \"string\" || isShikiTheme(theme)) {\n        if (!highlighterCache.has(\"default\")) {\n            highlighterCache.set(\"default\", getHighlighter$1({\n                theme\n            }));\n        }\n    } else if (typeof theme === \"object\") {\n        // color mode object\n        for (const [mode, value] of Object.entries(theme)){\n            if (!highlighterCache.has(mode)) {\n                highlighterCache.set(mode, getHighlighter$1({\n                    theme: value\n                }));\n            }\n        }\n    }\n    return async (tree)=>{\n        if (!highlighterCache) return;\n        for (const [mode, loadHighlighter] of highlighterCache.entries()){\n            if (!highlighters.get(mode)) {\n                highlighters.set(mode, await loadHighlighter);\n            }\n        }\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_6__.visit)(tree, \"element\", (element, index, parent)=>{\n            // Inline code\n            if (element.tagName === \"code\" && isElement(parent) && parent.tagName !== \"pre\" || element.tagName === \"inlineCode\") {\n                const textElement = element.children[0];\n                if (!isText(textElement)) {\n                    return;\n                }\n                const value = textElement.value;\n                if (!value) {\n                    return;\n                }\n                // TODO: allow escape characters to break out of highlighting\n                const strippedValue = value.replace(/{:[a-zA-Z.-]+}/, \"\");\n                const meta = value.match(/{:([a-zA-Z.-]+)}$/)?.[1] || defaultInlineCodeLang;\n                if (!meta) {\n                    return;\n                }\n                const isLang = meta[0] !== \".\";\n                const trees = {};\n                for (const [mode, highlighter] of highlighters.entries()){\n                    if (!isLang || meta === \"ansi\" && !highlighter.ansiToHtml) {\n                        const color = highlighter.getTheme().settings.find(({ scope })=>scope?.includes(tokensMap[meta.slice(1)] ?? meta.slice(1)))?.settings.foreground ?? \"inherit\";\n                        trees[mode] = hastParser.parse(`<pre><code><span style=\"color:${color}\">${strippedValue}</span></code></pre>`);\n                    } else {\n                        let html;\n                        if (meta === \"ansi\") {\n                            html = highlighter.ansiToHtml(strippedValue);\n                        } else {\n                            html = highlighter.codeToHtml(strippedValue, meta);\n                        }\n                        trees[mode] = hastParser.parse(html);\n                    }\n                }\n                toFragment(element, {\n                    trees,\n                    lang: isLang ? meta : \".token\",\n                    inline: true,\n                    keepBackground\n                });\n            }\n            if (// Block code\n            // Check from https://github.com/leafac/rehype-shiki\n            element.tagName === \"pre\" && Array.isArray(element.children) && element.children.length === 1 && isElement(element.children[0]) && element.children[0].tagName === \"code\") {\n                const codeElement = element.children[0];\n                const textElement = codeElement.children[0];\n                if (!isElement(codeElement)) {\n                    return;\n                }\n                let lang = defaultCodeBlockLang;\n                if (codeElement.properties && Array.isArray(codeElement.properties.className) && typeof codeElement.properties.className[0] === \"string\" && codeElement.properties.className[0].startsWith(\"language-\")) {\n                    lang = codeElement.properties.className[0].replace(\"language-\", \"\");\n                }\n                const metastring = codeElement.data?.meta ?? codeElement.properties?.metastring ?? \"\";\n                let meta = filterMetaString(metastring);\n                const titleMatch = meta.match(/title=\"([^\"]*)\"/);\n                const title = titleMatch?.[1] ?? null;\n                meta = meta.replace(titleMatch?.[0] ?? \"\", \"\");\n                const captionMatch = meta.match(/caption=\"([^\"]*)\"/);\n                const caption = captionMatch?.[1] ?? null;\n                meta = meta.replace(captionMatch?.[0] ?? \"\", \"\");\n                const lineNumbers = meta ? parse_numeric_range__WEBPACK_IMPORTED_MODULE_0__(meta.match(/(?:^|\\s){(.*?)}/)?.[1] ?? \"\") : [];\n                let lineNumbersMaxDigits = 0;\n                const words = [];\n                const wordNumbers = [];\n                const wordIdsMap = new Map();\n                const wordMatches = meta ? [\n                    ...meta.matchAll(/\\/(.*?)\\/(\\S*)/g)\n                ] : undefined;\n                if (Array.isArray(wordMatches)) {\n                    wordMatches.forEach((_, index)=>{\n                        const word = wordMatches[index][1];\n                        const wordIdAndOrRange = wordMatches[index][2];\n                        words.push(word);\n                        const [range, id] = wordIdAndOrRange.split(\"#\");\n                        if (range) {\n                            wordNumbers.push(parse_numeric_range__WEBPACK_IMPORTED_MODULE_0__(range));\n                        }\n                        if (id) {\n                            wordIdsMap.set(word, id);\n                        }\n                    });\n                }\n                if (!isText(textElement)) {\n                    return;\n                }\n                const strippedValue = textElement.value.replace(/\\n$/, \"\");\n                const trees = {};\n                for (const [mode, highlighter] of highlighters.entries()){\n                    try {\n                        let html;\n                        if (lang === \"ansi\" && highlighter.ansiToHtml) {\n                            html = highlighter.ansiToHtml(strippedValue);\n                        } else {\n                            html = highlighter.codeToHtml(strippedValue, lang);\n                        }\n                        trees[mode] = hastParser.parse(html);\n                    } catch (e) {\n                        // Fallback to plain text if a language has not been registered\n                        trees[mode] = hastParser.parse(highlighter.codeToHtml(strippedValue, \"txt\"));\n                    }\n                }\n                Object.entries(trees).forEach(([, tree])=>{\n                    let lineCounter = 0;\n                    const wordOptions = {\n                        ranges: wordNumbers,\n                        idsMap: wordIdsMap,\n                        counterMap: new Map()\n                    };\n                    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_6__.visit)(tree, \"element\", (element)=>{\n                        if (element.tagName === \"code\" && /srebmuNeniLwohs(?!(.*)(\\/))/.test(reverseString(meta))) {\n                            if (element.properties) {\n                                element.properties[\"data-line-numbers\"] = \"\";\n                            }\n                            const lineNumbersStartAtMatch = reverseString(meta).match(/(?:\\}(\\d+){)?srebmuNeniLwohs(?!(.*)(\\/))/);\n                            const startNumberString = lineNumbersStartAtMatch?.[1];\n                            if (startNumberString) {\n                                const startAt = startNumberString ? Number(reverseString(startNumberString)) - 1 : 0;\n                                lineNumbersMaxDigits = startAt;\n                                if (element.properties) {\n                                    element.properties.style = `counter-set: line ${startAt};`;\n                                }\n                            }\n                        }\n                        if (Array.isArray(element.properties?.className) && element.properties?.className?.[0] === \"line\") {\n                            if (grid && element.children.length === 0) {\n                                element.children = [\n                                    {\n                                        type: \"text\",\n                                        value: \" \"\n                                    }\n                                ];\n                            }\n                            const className = element.properties.className.filter((c)=>c !== \"line\");\n                            element.properties.className = className.length > 0 ? className : undefined;\n                            element.properties[\"data-line\"] = \"\";\n                            onVisitLine?.(element);\n                            if (lineNumbers.length !== 0 && lineNumbers.includes(++lineCounter)) {\n                                element.properties[\"data-highlighted-line\"] = \"\";\n                                onVisitHighlightedLine?.(element);\n                            }\n                            charsHighlighter(element, words, wordOptions, onVisitHighlightedChars);\n                            lineNumbersMaxDigits++;\n                        }\n                    });\n                });\n                toFragment(element, {\n                    trees,\n                    lang,\n                    title,\n                    caption,\n                    keepBackground,\n                    grid,\n                    lineNumbersMaxDigits,\n                    onVisitTitle,\n                    onVisitCaption\n                });\n            }\n        });\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL2Rpc3QvcmVoeXBlLXByZXR0eS1jb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ0s7QUFDUDtBQUNMO0FBQ0s7QUFDUjtBQUNnQjtBQUUvQyw4REFBOEQ7QUFDOUQsU0FBU08sYUFBYUMsS0FBSztJQUN6QixPQUFPQSxRQUFRQyxlQUFlRCxPQUFPLGlCQUFpQjtBQUN4RDtBQUNBLFNBQVNFLFVBQVVGLEtBQUs7SUFDdEIsT0FBT0EsUUFBUUEsTUFBTUcsSUFBSSxLQUFLLFlBQVk7QUFDNUM7QUFDQSxTQUFTQyxPQUFPSixLQUFLO0lBQ25CLE9BQU9BLFFBQVFBLE1BQU1HLElBQUksS0FBSyxTQUFTO0FBQ3pDO0FBQ0EsU0FBU0YsZUFBZUksTUFBTSxFQUFFQyxNQUFNO0lBQ3BDLE9BQU8sRUFBQyxHQUFFTCxjQUFjLENBQUNNLElBQUksQ0FBQ0YsUUFBUUM7QUFDeEM7QUFFQSxTQUFTRSxhQUFhLEVBQ3BCQyxRQUFRLEVBQ1JDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsSUFBSSxFQUNKQyxvQkFBb0IsRUFDcEJDLEtBQUssRUFDTEMsV0FBVyxFQUNaO0lBQ0MsSUFBSWYsVUFBVVEsa0JBQWtCQSxjQUFjUSxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUVmLFNBQVMsVUFBVWMsYUFBYTtRQUMzRixPQUFPO1lBQUNQO1lBQWVNO1NBQU07SUFDL0I7SUFDQSxJQUFJRyxXQUFXSDtJQUVmLGtEQUFrRDtJQUNsRCxNQUFNSSxjQUFjVixjQUFjUSxRQUFRLENBQUMsRUFBRTtJQUM3QyxJQUFJZCxPQUFPZ0IsY0FBYztRQUN2QkEsWUFBWXBCLEtBQUssR0FBR1c7SUFDdEI7SUFDQSxJQUFJVSxXQUFXVDtJQUNmLE1BQU1VLFVBQVVUO0lBRWhCLG1EQUFtRDtJQUNuRCxJQUFJQyxLQUFLUyxNQUFNLEdBQUcsR0FBRztRQUNuQkYsWUFBWVAsS0FB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Q0Y7SUFDRjtBQUNGO0FBRXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3ZlcnJlYWN0ZWQvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL2Rpc3QvcmVoeXBlLXByZXR0eS1jb2RlLmpzPzgyZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmlzaXQgfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0JztcbmltcG9ydCByYW5nZVBhcnNlciBmcm9tICdwYXJzZS1udW1lcmljLXJhbmdlJztcbmltcG9ydCB7IGdldEhpZ2hsaWdodGVyIH0gZnJvbSAnc2hpa2knO1xuaW1wb3J0IHsgdW5pZmllZCB9IGZyb20gJ3VuaWZpZWQnO1xuaW1wb3J0IHJlaHlwZVBhcnNlIGZyb20gJ3JlaHlwZS1wYXJzZSc7XG5pbXBvcnQgaGFzaE9iaiBmcm9tICdoYXNoLW9iaic7XG5pbXBvcnQgeyB0b1N0cmluZyB9IGZyb20gJ2hhc3QtdXRpbC10by1zdHJpbmcnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gaXNTaGlraVRoZW1lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IGhhc093blByb3BlcnR5KHZhbHVlLCAndG9rZW5Db2xvcnMnKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLnR5cGUgPT09ICdlbGVtZW50JyA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNUZXh0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLnR5cGUgPT09ICd0ZXh0JyA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqZWN0LCBzdHJpbmcpIHtcbiAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBzdHJpbmcpO1xufVxuXG5mdW5jdGlvbiBzcGxpdEVsZW1lbnQoe1xuICBlbGVtZW50cyxcbiAgZWxlbWVudFRvV3JhcCxcbiAgaW5uZXJTdHJpbmcsXG4gIHJpZ2h0U3RyaW5nLFxuICBsZWZ0U3RyaW5nLFxuICByZXN0LFxuICBuZXh0RWxlbWVudENvbnRpbnVlcyxcbiAgaW5kZXgsXG4gIGlnbm9yZUNoYXJzXG59KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudFRvV3JhcCkgJiYgZWxlbWVudFRvV3JhcC5jaGlsZHJlbj8uWzBdPy50eXBlICE9PSAndGV4dCcgfHwgaWdub3JlQ2hhcnMpIHtcbiAgICByZXR1cm4gW2VsZW1lbnRUb1dyYXAsIGluZGV4XTtcbiAgfVxuICBsZXQgbmV3SW5kZXggPSBpbmRleDtcblxuICAvLyBhc3NpZ24gdGhlIG1hdGNoZWQgdmFsdWUgdG8gdGhlIGN1cnJlbnQgZWxlbWVudFxuICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnRUb1dyYXAuY2hpbGRyZW5bMF07XG4gIGlmIChpc1RleHQodGV4dEVsZW1lbnQpKSB7XG4gICAgdGV4dEVsZW1lbnQudmFsdWUgPSBpbm5lclN0cmluZztcbiAgfVxuICBsZXQgcmlnaHRTdHIgPSByaWdodFN0cmluZztcbiAgY29uc3QgbGVmdFN0ciA9IGxlZnRTdHJpbmc7XG5cbiAgLy8gYXBwZW5kIGFueSByZXBldGl0aW9ucyB0byB0aGUgcmlnaHQgaWYgbmVjZXNzYXJ5XG4gIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICByaWdodFN0ciArPSByZXN0Lm1hcChzID0+IHMgPT09ICcnID8gaW5uZXJTdHJpbmcgOiBpbm5lclN0cmluZyArIHMpLmpvaW4oJycpO1xuICB9XG4gIGlmIChsZWZ0U3RyLmxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50cy5zcGxpY2UobmV3SW5kZXgsIDAsIHtcbiAgICAgIC4uLmVsZW1lbnRUb1dyYXAsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC4uLmVsZW1lbnRUb1dyYXAucHJvcGVydGllc1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHZhbHVlOiBsZWZ0U3RyXG4gICAgICB9XVxuICAgIH0pO1xuICB9XG4gIGlmIChyaWdodFN0ci5sZW5ndGggPiAwICYmICFuZXh0RWxlbWVudENvbnRpbnVlcykge1xuICAgIG5ld0luZGV4ID0gbGVmdFN0ci5sZW5ndGggPiAwID8gbmV3SW5kZXggKyAyIDogbmV3SW5kZXggKyAxO1xuICAgIGVsZW1lbnRzLnNwbGljZShuZXdJbmRleCwgMCwge1xuICAgICAgLi4uZWxlbWVudFRvV3JhcCxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLi4uZWxlbWVudFRvV3JhcC5wcm9wZXJ0aWVzXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdmFsdWU6IHJpZ2h0U3RyXG4gICAgICB9XVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBbZWxlbWVudFRvV3JhcCwgaW5kZXggKyAxXTtcbn1cblxuLyoqXG4gKiBMb29rIGFoZWFkIHRvIGRldGVybWluZSBpZiBmdXJ0aGVyLCBzaWJsaW5nIG5vZGVzIGNvbnRpbnVlIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gIGVsZW1lbnRzLFxuICBuZXh0SW5kZXgsXG4gIHJlbWFpbmluZ1BhcnRcbn0pIHtcbiAgaWYgKHJlbWFpbmluZ1BhcnQgPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5leHROb2RlID0gZWxlbWVudHNbbmV4dEluZGV4XTtcbiAgY29uc3QgY29udGVudCA9IGdldENvbnRlbnQobmV4dE5vZGUpO1xuICBpZiAoIWNvbnRlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaW5jbHVkZXNOZXh0ID0gY29udGVudC5zdGFydHNXaXRoKHJlbWFpbmluZ1BhcnQpIHx8IHJlbWFpbmluZ1BhcnQuc3RhcnRzV2l0aChjb250ZW50KTtcbiAgY29uc3Qgb3ZlcmxhcCA9IGZpbmRPdmVybGFwKGNvbnRlbnQsIHJlbWFpbmluZ1BhcnQpO1xuICBpZiAob3ZlcmxhcCA9PT0gcmVtYWluaW5nUGFydCAmJiBjb250ZW50LnN0YXJ0c1dpdGgocmVtYWluaW5nUGFydCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5jbHVkZXNOZXh0KSB7XG4gICAgcmV0dXJuIG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICBlbGVtZW50cyxcbiAgICAgIG5leHRJbmRleDogbmV4dEluZGV4ICsgMSxcbiAgICAgIHJlbWFpbmluZ1BhcnQ6IHJlbWFpbmluZ1BhcnQucmVwbGFjZShjb250ZW50LCAnJylcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRDb250ZW50KG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm47XG4gIHJldHVybiB0b1N0cmluZyhub2RlKTtcbn1cbmZ1bmN0aW9uIGZpbmRPdmVybGFwKGEsIGIpIHtcbiAgaWYgKGIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChhLmVuZHNXaXRoKGIpKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgaWYgKGEuaW5kZXhPZihiKSA+PSAwKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgcmV0dXJuIGZpbmRPdmVybGFwKGEsIGIuc3Vic3RyaW5nKDAsIGIubGVuZ3RoIC0gMSkpO1xufVxuZnVuY3Rpb24gcmV2ZXJzZVN0cmluZyhzKSB7XG4gIHJldHVybiBzLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRzVG9IaWdobGlnaHQoZWxlbWVudCwgY2hhcnMsIHN0YXJ0SW5kZXggPSAwLCBpZ25vcmVDaGFycyA9IGZhbHNlKSB7XG4gIGNvbnN0IHRvV3JhcCA9IFtdO1xuICBsZXQgY2hhcnNTb0ZhciA9ICcnO1xuICBpZiAoZWxlbWVudC5jaGlsZHJlbikge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZW1haW5pbmcgPSBjaGFyc1NvRmFyID8gY2hhcnMucmVwbGFjZShjaGFyc1NvRmFyLCAnJykgOiBjaGFycztcbiAgICAgIGlmIChyZW1haW5pbmcgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0b1dyYXA7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXliZUVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmICghbWF5YmVFbGVtZW50IHx8IG1heWJlRWxlbWVudC50eXBlICE9PSAnZWxlbWVudCcgfHxcbiAgICAgIC8vIGlnbm9yZSBhbnkgcHJldmlvdXNseSBtYXRjaGVkIGNoYXJzIHdpdGhpblxuICAgICAgaGFzT3duUHJvcGVydHkobWF5YmVFbGVtZW50LnByb3BlcnRpZXMgPz8ge30sICdyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZCcpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudCA9IGdldENvbnRlbnQobWF5YmVFbGVtZW50KSB8fCAnJztcblxuICAgICAgLy8gbm9kZSBpcyB0aGUgY2hhcnMsIG9yIGl0IGZpbmlzaGVzIHRoZSBjaGFyc1xuICAgICAgaWYgKGNvbnRlbnQgPT09IGNoYXJzIHx8IGNoYXJzU29GYXIgKyBjb250ZW50ID09PSBjaGFycykge1xuICAgICAgICB0b1dyYXAucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogbWF5YmVFbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9XcmFwO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiB0aGUgd2hvbGUgbm9kZSBpcyBhIGNvbnRpbnVhdGlvbiBvZiB0aGUgY2hhcnNcbiAgICAgIGlmIChjaGFycy5zdGFydHNXaXRoKGNoYXJzU29GYXIgKyBjb250ZW50KSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgY29udGludWUgaGVyZSBvbmx5IGlmIGZ1cnRoZXIgc2libGluZ3NcbiAgICAgICAgLy8gY29tcGxldGUgdGhlIGNoYXJzLiBPdGhlcndpc2UgYW4gZWFybGllciByZXBldGl0aW9uXG4gICAgICAgIC8vIG9mIGEgc2VjdGlvbiBvZiB0aGUgY2hhcnMgd2lsbCBsZWFkIHVzIGRvd24gdGhlIHdyb25nIHBhdGhcbiAgICAgICAgaWYgKG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgbmV4dEluZGV4OiBpICsgMSxcbiAgICAgICAgICByZW1haW5pbmdQYXJ0OiByZW1haW5pbmcucmVwbGFjZShjb250ZW50LCAnJylcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB0b1dyYXAucHVzaCh7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50c1tpXSxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2hhcnNTb0ZhciArPSBjb250ZW50O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVybGFwID0gZmluZE92ZXJsYXAoY29udGVudCwgcmVtYWluaW5nKTtcbiAgICAgIGNvbnN0IHBhcnRpYWxNYXRjaCA9IG92ZXJsYXAgJiYgcmVtYWluaW5nLnN0YXJ0c1dpdGgob3ZlcmxhcCk7XG4gICAgICBpZiAocGFydGlhbE1hdGNoKSB7XG4gICAgICAgIGNvbnN0IG5leHRQYXJ0ID0gcmVtYWluaW5nLnJlcGxhY2Uob3ZlcmxhcCwgJycpO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIHdyb25nIG5vZGUsIGNvbnRpbnVlXG4gICAgICAgIGlmIChuZXh0UGFydCAhPT0gJycgJiYgZ2V0Q29udGVudChlbGVtZW50c1tpICsgMV0pICYmICFuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgIG5leHRJbmRleDogaSArIDEsXG4gICAgICAgICAgcmVtYWluaW5nUGFydDogbmV4dFBhcnRcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGxpdFBhcnRzID0gY29udGVudC5zcGxpdChvdmVybGFwKTtcbiAgICAgICAgY29uc3QgW2xlZnRQYXJ0LCByaWdodFBhcnQsIC4uLnJlc3RdID0gc3BsaXRQYXJ0cztcbiAgICAgICAgaWYgKHJpZ2h0UGFydCB8fCBsZWZ0UGFydCB8fCByZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBPbmUgb2YgdGhlIGJlbG93IHNjZW5hcmlvcyBzaG91bGQgYmUgdHJ1ZVxuICAgICAgICAgIC8vIDEuIHRoZSB3aG9sZSBzZXQgb2YgY2hhcnMgYXJlIGluc2lkZSB0aGUgc3RyaW5nIChhdCBsZWFzdCBvbmNlKSBjYVtycm9ddFxuICAgICAgICAgIC8vIDIuIHRoZSBjaGFycyBmaW5pc2ggb3Igc3RhcnQgJiBlbmQgb24gdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nIC4uLltjYXJyXW90XG4gICAgICAgICAgLy8gMy4gdGhlIGNoYXJzIHN0YXJ0IG9yIHN0YXJ0ICYgZW5kIGZyb20gdGhlIGVuZCBvZiB0aGUgc3RyaW5nIGNhcnJbb3RdLi4uXG5cbiAgICAgICAgICBjb25zdCB3aXRoTmV4dE5vZGUgPSBjb250ZW50ICsgKGdldENvbnRlbnQoZWxlbWVudHNbaSArIDFdKSA/IGdldENvbnRlbnQoZWxlbWVudHNbaSArIDFdKSA6ICcnKTtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZU92ZXJsYXAgPSBmaW5kT3ZlcmxhcCh3aXRoTmV4dE5vZGUsIHJlbWFpbmluZyk7XG4gICAgICAgICAgY29uc3Qgc3BsaXRJbmRleCA9IHdpdGhOZXh0Tm9kZS5pbmRleE9mKG5leHROb2RlT3ZlcmxhcCk7XG4gICAgICAgICAgaWYgKGNoYXJzLmVuZHNXaXRoKG92ZXJsYXApIHx8IGNoYXJzLnN0YXJ0c1dpdGgob3ZlcmxhcCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0U3RyaW5nID0gcmlnaHRQYXJ0LnJlcGxhY2Uob3ZlcmxhcCwgJycpO1xuICAgICAgICAgICAgY29uc3QgaW5uZXJTdHJpbmcgPSBvdmVybGFwO1xuICAgICAgICAgICAgY29uc3QgbGVmdFN0cmluZyA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIHNwbGl0SW5kZXgpO1xuXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNoZWNrIHRoaXMgdG8gYXZvaWQgZWRnZSBjYXNlIHdoZXJlIHRoZSByaWdodFxuICAgICAgICAgICAgLy8gc2lkZSB3aWxsIGJlIGR1cGxpY2F0ZWQgd2hlbiB0aGUgbWF0Y2hlZCBwYXJ0IHJlcGVhdHMgd2l0aGluIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBub2RlXG4gICAgICAgICAgICBjb25zdCBuZXh0RWxlbWVudENvbnRpbnVlcyA9IG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgICAgICBuZXh0SW5kZXg6IGkgKyAxLFxuICAgICAgICAgICAgICByZW1haW5pbmdQYXJ0OiBuZXh0UGFydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBbbmV3RWxlbWVudCwgdXBkYXRlZEluZGV4XSA9IHNwbGl0RWxlbWVudCh7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgICAgICBlbGVtZW50VG9XcmFwOiBlbGVtZW50c1tpXSxcbiAgICAgICAgICAgICAgaW5uZXJTdHJpbmcsXG4gICAgICAgICAgICAgIHJpZ2h0U3RyaW5nLFxuICAgICAgICAgICAgICBsZWZ0U3RyaW5nLFxuICAgICAgICAgICAgICByZXN0LFxuICAgICAgICAgICAgICBuZXh0RWxlbWVudENvbnRpbnVlcyxcbiAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgIGlnbm9yZUNoYXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoYXJzU29GYXIgKz0gb3ZlcmxhcDtcbiAgICAgICAgICAgIHRvV3JhcC5wdXNoKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogbmV3RWxlbWVudCxcbiAgICAgICAgICAgICAgaW5kZXg6IHVwZGF0ZWRJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1dyYXA7XG59XG5cbmZ1bmN0aW9uIHdyYXBIaWdobGlnaHRlZENoYXJzKHBhcmVudEVsZW1lbnQsIGVsZW1lbnRzVG9XcmFwLCBvcHRpb25zLCBpZ25vcmVXb3JkLCBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycykge1xuICBpZiAoIWVsZW1lbnRzVG9XcmFwIHx8IGVsZW1lbnRzVG9XcmFwLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbe1xuICAgIGVsZW1lbnRcbiAgfV0gPSBlbGVtZW50c1RvV3JhcDtcbiAgaWYgKGlnbm9yZVdvcmQpIHtcbiAgICBpZiAoZWxlbWVudC5wcm9wZXJ0aWVzKSB7XG4gICAgICBlbGVtZW50LnByb3BlcnRpZXNbJ3JlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkJ10gPSAnJztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50c1RvV3JhcC5sZW5ndGggPiAxKSB7XG4gICAgcGFyZW50RWxlbWVudC5jaGlsZHJlbi5zcGxpY2UoZWxlbWVudHNUb1dyYXBbMF0uaW5kZXgsIGVsZW1lbnRzVG9XcmFwLmxlbmd0aCwge1xuICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgICAgdGFnTmFtZTogJ3NwYW4nLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAnZGF0YS1oaWdobGlnaHRlZC1jaGFycy13cmFwcGVyJzogJydcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogZWxlbWVudHNUb1dyYXAubWFwKCh7XG4gICAgICAgIGVsZW1lbnRcbiAgICAgIH0pID0+IGVsZW1lbnQpXG4gICAgfSk7XG4gICAgY29uc3QgZWxlbWVudCA9IHBhcmVudEVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudHNUb1dyYXBbMF0uaW5kZXhdO1xuICAgIGlmICghaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdvcmRTdHIgPSBlbGVtZW50LmNoaWxkcmVuLnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGlzRWxlbWVudChub2RlKSA/IG5vZGUuY2hpbGRyZW5bMF0gOiBudWxsO1xuICAgICAgaWYgKGlzVGV4dCh0ZXh0RWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGFjYyArIHRleHRFbGVtZW50LnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCAnJyk7XG4gICAgY29uc3QgaWQgPSBvcHRpb25zLmlkc01hcC5nZXQod29yZFN0cik7XG4gICAgZWxlbWVudC5wcm9wZXJ0aWVzID0gZWxlbWVudC5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIGVsZW1lbnQucHJvcGVydGllc1snZGF0YS1oaWdobGlnaHRlZC1jaGFycyddID0gJyc7XG4gICAgZWxlbWVudC5wcm9wZXJ0aWVzWydkYXRhLWNoYXJzLWlkJ10gPSBpZDtcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycz8uKGVsZW1lbnQsIGlkKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbe1xuICAgICAgZWxlbWVudFxuICAgIH1dID0gZWxlbWVudHNUb1dyYXA7XG4gICAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IG9wdGlvbnMuaWRzTWFwLmdldCh0ZXh0RWxlbWVudC52YWx1ZSk7XG4gICAgZWxlbWVudC5wcm9wZXJ0aWVzID0gZWxlbWVudC5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIC8vIHVzZWQgdG8gc2tpcCBhbHJlYWR5IHBhcnNlZCBjaGFyc1xuICAgIGVsZW1lbnQucHJvcGVydGllc1sncmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWQnXSA9ICcnO1xuICAgIGVsZW1lbnQucHJvcGVydGllc1snZGF0YS1oaWdobGlnaHRlZC1jaGFycyddID0gJyc7XG4gICAgZWxlbWVudC5wcm9wZXJ0aWVzWydkYXRhLWNoYXJzLWlkJ10gPSBpZDtcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycz8uKGVsZW1lbnQsIGlkKTtcbiAgfVxufVxuXG4vKipcbiAqIExvb3BzIHRocm91Z2ggdGhlIGNoaWxkIG5vZGVzIGFuZCBmaW5kcyB0aGUgbm9kZXMgdGhhdCBtYWtlIHVwIHRoZSBjaGFycy5cbiAqIElmIHRoZSBjaGFycyBjcm9zcyBub2RlIGJvdW5kYXJpZXMsIHRob3NlIG5vZGVzIGFyZSB3cmFwcGVkIHdpdGhcbiAqIDxzcGFuIGRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnMtd3JhcHBlcj4sIGFuZCB0aGF0IG5vZGUgaXMgcGFzc2VkIHRvXG4gKiBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycy5cbiAqXG4gKiBJZiBhIG5vZGUgcGFydGlhbGx5IG1hdGNoZXMgdGhlIGNoYXJzLCBpdHMgY29udGVudCBpcyByZXBsYWNlZCB3aXRoIHRoZVxuICogbWF0Y2hlZCBwYXJ0LCBhbmQgdGhlIGxlZnQgYW5kL29yIHJpZ2h0IHBhcnRzIGFyZSBjbG9uZWQgdG8gc2libGluZyBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY2hhcnNIaWdobGlnaHRlcihlbGVtZW50LCBjaGFyc0xpc3QsIG9wdGlvbnMsIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzKSB7XG4gIGNvbnN0IHtcbiAgICByYW5nZXMgPSBbXVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGV4dENvbnRlbnQgPSB0b1N0cmluZyhlbGVtZW50KTtcbiAgY2hhcnNMaXN0LmZvckVhY2goKGNoYXJzLCBpbmRleCkgPT4ge1xuICAgIGlmIChjaGFycyAmJiB0ZXh0Q29udGVudD8uaW5jbHVkZXMoY2hhcnMpKSB7XG4gICAgICBsZXQgdGV4dENvbnRlbnQgPSB0b1N0cmluZyhlbGVtZW50KTtcbiAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICAgIHdoaWxlICh0ZXh0Q29udGVudC5pbmNsdWRlcyhjaGFycykpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYXJzUmFuZ2UgPSByYW5nZXNbaW5kZXhdIHx8IFtdO1xuICAgICAgICBjb25zdCBpZCA9IGAke2NoYXJzfS0ke2luZGV4fWA7XG4gICAgICAgIG9wdGlvbnMuY291bnRlck1hcC5zZXQoaWQsIChvcHRpb25zLmNvdW50ZXJNYXAuZ2V0KGlkKSB8fCAwKSArIDEpO1xuICAgICAgICBjb25zdCBpZ25vcmVDaGFycyA9IGN1cnJlbnRDaGFyc1JhbmdlLmxlbmd0aCA+IDAgJiYgIWN1cnJlbnRDaGFyc1JhbmdlLmluY2x1ZGVzKG9wdGlvbnMuY291bnRlck1hcC5nZXQoaWQpID8/IC0xKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHNUb1dyYXAgPSBnZXRFbGVtZW50c1RvSGlnaGxpZ2h0KGVsZW1lbnQsIGNoYXJzLCBzdGFydEluZGV4LCBpZ25vcmVDaGFycyk7XG5cbiAgICAgICAgLy8gbWF5YmUgdGhyb3cgLyBub3RpZnkgZHVlIHRvIGZhaWx1cmUgaGVyZVxuICAgICAgICBpZiAoZWxlbWVudHNUb1dyYXAubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgICAgd3JhcEhpZ2hsaWdodGVkQ2hhcnMoZWxlbWVudCwgZWxlbWVudHNUb1dyYXAsIG9wdGlvbnMsIGlnbm9yZUNoYXJzLCBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycyk7XG5cbiAgICAgICAgLy8gcmUtc3RhcnQgZnJvbSB0aGUgJ2xhc3QnIG5vZGUgKHRoZSBjaGFycyBvciBwYXJ0IG9mIHRoZW0gbWF5IGV4aXN0XG4gICAgICAgIC8vIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIG5vZGUpXG4gICAgICAgIC8vIGFjY291bnQgZm9yIHBvc3NpYmxlIGV4dHJhIG5vZGVzIGFkZGVkIGZyb20gc3BsaXQgd2l0aCAtIDJcbiAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWF4KGVsZW1lbnRzVG9XcmFwW2VsZW1lbnRzVG9XcmFwLmxlbmd0aCAtIDFdLmluZGV4IC0gMiwgMCk7XG4gICAgICAgIHRleHRDb250ZW50ID0gZWxlbWVudC5jaGlsZHJlbi5tYXAoY2hpbGROb2RlID0+IHtcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IGlzRWxlbWVudChjaGlsZE5vZGUpID8gY2hpbGROb2RlLnByb3BlcnRpZXMgOiB7fTtcbiAgICAgICAgICBpZiAocHJvcHMgJiYgIWhhc093blByb3BlcnR5KHByb3BzLCAncmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWQnKSAmJiAhaGFzT3duUHJvcGVydHkocHJvcHMsICdkYXRhLWhpZ2hsaWdodGVkLWNoYXJzLXdyYXBwZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKGNoaWxkTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudC5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICBpZiAoIWlzRWxlbWVudChjaGlsZE5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShjaGlsZE5vZGUucHJvcGVydGllcyA/PyB7fSwgJ3JlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkJykpIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgZGVsZXRlIGNoaWxkTm9kZS5wcm9wZXJ0aWVzWydyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZCddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0b0ZyYWdtZW50KGVsZW1lbnQsIHtcbiAgdHJlZXMsXG4gIGxhbmcsXG4gIHRpdGxlLFxuICBjYXB0aW9uLFxuICBpbmxpbmUgPSBmYWxzZSxcbiAga2VlcEJhY2tncm91bmQgPSB0cnVlLFxuICBncmlkID0gdHJ1ZSxcbiAgbGluZU51bWJlcnNNYXhEaWdpdHMgPSAxLFxuICBvblZpc2l0VGl0bGUsXG4gIG9uVmlzaXRDYXB0aW9uXG59KSB7XG4gIGVsZW1lbnQudGFnTmFtZSA9IGlubGluZSA/ICdzcGFuJyA6ICdkaXYnO1xuICAvLyBVc2VyIGNhbiByZXBsYWNlIHRoaXMgd2l0aCBhIHJlYWwgRnJhZ21lbnQgYXQgcnVudGltZVxuICBlbGVtZW50LnByb3BlcnRpZXMgPSB7XG4gICAgJ2RhdGEtcmVoeXBlLXByZXR0eS1jb2RlLWZyYWdtZW50JzogJydcbiAgfTtcbiAgZWxlbWVudC5jaGlsZHJlbiA9IE9iamVjdC5lbnRyaWVzKHRyZWVzKS5tYXAoKFttb2RlLCB0cmVlXSkgPT4ge1xuICAgIGNvbnN0IHByZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgaWYgKCFpc0VsZW1lbnQocHJlKSB8fCAhcHJlLnByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IHByZS5jaGlsZHJlblswXTtcblxuICAgIC8vIFJlbW92ZSBjbGFzcz1cInNoaWtpXCJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcmUucHJvcGVydGllcz8uY2xhc3NOYW1lKSAmJiBwcmUucHJvcGVydGllcz8uY2xhc3NOYW1lLmluY2x1ZGVzKCdzaGlraScpKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBwcmUucHJvcGVydGllcy5jbGFzc05hbWUuZmlsdGVyKGMgPT4gYyAhPT0gJ3NoaWtpJyk7XG4gICAgICBwcmUucHJvcGVydGllcy5jbGFzc05hbWUgPSBjbGFzc05hbWUubGVuZ3RoID4gMCA/IGNsYXNzTmFtZSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFrZWVwQmFja2dyb3VuZCkge1xuICAgICAgcHJlLnByb3BlcnRpZXMuc3R5bGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHByZS5wcm9wZXJ0aWVzWydkYXRhLWxhbmd1YWdlJ10gPSBsYW5nO1xuICAgIHByZS5wcm9wZXJ0aWVzWydkYXRhLXRoZW1lJ10gPSBtb2RlO1xuICAgIGlmICghaXNFbGVtZW50KGNvZGUpIHx8ICFjb2RlLnByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29kZS5wcm9wZXJ0aWVzWydkYXRhLWxhbmd1YWdlJ10gPSBsYW5nO1xuICAgIGNvZGUucHJvcGVydGllc1snZGF0YS10aGVtZSddID0gbW9kZTtcbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICBpZiAoa2VlcEJhY2tncm91bmQpIHtcbiAgICAgICAgY29kZS5wcm9wZXJ0aWVzLnN0eWxlID0gcHJlLnByb3BlcnRpZXMuc3R5bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgaWYgKGdyaWQpIHtcbiAgICAgIGlmIChjb2RlLnByb3BlcnRpZXMuc3R5bGUpIHtcbiAgICAgICAgY29kZS5wcm9wZXJ0aWVzLnN0eWxlICs9ICdkaXNwbGF5OiBncmlkOyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlLnByb3BlcnRpZXMuc3R5bGUgPSAnZGlzcGxheTogZ3JpZDsnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ2RhdGEtbGluZS1udW1iZXJzJyBpbiBjb2RlLnByb3BlcnRpZXMpIHtcbiAgICAgIGNvZGUucHJvcGVydGllc1snZGF0YS1saW5lLW51bWJlcnMtbWF4LWRpZ2l0cyddID0gbGluZU51bWJlcnNNYXhEaWdpdHMudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdtZW50cyA9IFtdO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgY29uc3QgZWxlbWVudENvbnRlbnQgPSB7XG4gICAgICAgIHR5cGU6ICdlbGVtZW50JyxcbiAgICAgICAgdGFnTmFtZTogJ2RpdicsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAnZGF0YS1yZWh5cGUtcHJldHR5LWNvZGUtdGl0bGUnOiAnJyxcbiAgICAgICAgICAnZGF0YS1sYW5ndWFnZSc6IGxhbmcsXG4gICAgICAgICAgJ2RhdGEtdGhlbWUnOiBtb2RlXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB2YWx1ZTogdGl0bGVcbiAgICAgICAgfV1cbiAgICAgIH07XG4gICAgICBvblZpc2l0VGl0bGU/LihlbGVtZW50Q29udGVudCk7XG4gICAgICBmcmFnbWVudHMucHVzaChlbGVtZW50Q29udGVudCk7XG4gICAgfVxuICAgIGZyYWdtZW50cy5wdXNoKHByZSk7XG4gICAgaWYgKGNhcHRpb24pIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRDb250ZW50ID0ge1xuICAgICAgICB0eXBlOiAnZWxlbWVudCcsXG4gICAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgJ2RhdGEtcmVoeXBlLXByZXR0eS1jb2RlLWNhcHRpb24nOiAnJyxcbiAgICAgICAgICAnZGF0YS1sYW5ndWFnZSc6IGxhbmcsXG4gICAgICAgICAgJ2RhdGEtdGhlbWUnOiBtb2RlXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB2YWx1ZTogY2FwdGlvblxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICAgIG9uVmlzaXRDYXB0aW9uPy4oZWxlbWVudENvbnRlbnQpO1xuICAgICAgZnJhZ21lbnRzLnB1c2goZWxlbWVudENvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnRzO1xuICB9KS5mbGF0TWFwKGMgPT4gYyk7XG59XG5jb25zdCBnbG9iYWxIaWdobGlnaHRlckNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3QgaGFzdFBhcnNlciA9IHVuaWZpZWQoKS51c2UocmVoeXBlUGFyc2UsIHtcbiAgZnJhZ21lbnQ6IHRydWVcbn0pO1xuZnVuY3Rpb24gcmVoeXBlUHJldHR5Q29kZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGdyaWQgPSB0cnVlLFxuICAgIHRoZW1lID0gJ2dpdGh1Yi1kYXJrLWRpbW1lZCcsXG4gICAga2VlcEJhY2tncm91bmQgPSB0cnVlLFxuICAgIGRlZmF1bHRMYW5nID0gJycsXG4gICAgdG9rZW5zTWFwID0ge30sXG4gICAgZmlsdGVyTWV0YVN0cmluZyA9IHYgPT4gdixcbiAgICBnZXRIaWdobGlnaHRlcjogZ2V0SGlnaGxpZ2h0ZXIkMSA9IGdldEhpZ2hsaWdodGVyLFxuICAgIG9uVmlzaXRMaW5lLFxuICAgIG9uVmlzaXRIaWdobGlnaHRlZExpbmUsXG4gICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnMsXG4gICAgb25WaXNpdFRpdGxlLFxuICAgIG9uVmlzaXRDYXB0aW9uXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBvcHRpb25zSGFzaCA9IGhhc2hPYmooe1xuICAgIHRoZW1lLFxuICAgIHRva2Vuc01hcCxcbiAgICBvblZpc2l0TGluZSxcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRMaW5lLFxuICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzLFxuICAgIGdldEhpZ2hsaWdodGVyOiBnZXRIaWdobGlnaHRlciQxXG4gIH0sIHtcbiAgICBhbGdvcml0aG06ICdzaGExJ1xuICB9KTtcbiAgbGV0IGhpZ2hsaWdodGVyQ2FjaGUgPSBnbG9iYWxIaWdobGlnaHRlckNhY2hlLmdldChvcHRpb25zSGFzaCk7XG4gIGlmICghaGlnaGxpZ2h0ZXJDYWNoZSkge1xuICAgIGhpZ2hsaWdodGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgZ2xvYmFsSGlnaGxpZ2h0ZXJDYWNoZS5zZXQob3B0aW9uc0hhc2gsIGhpZ2hsaWdodGVyQ2FjaGUpO1xuICB9XG4gIGNvbnN0IGhpZ2hsaWdodGVycyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZGVmYXVsdENvZGVCbG9ja0xhbmcgPSB0eXBlb2YgZGVmYXVsdExhbmcgPT09ICdzdHJpbmcnID8gZGVmYXVsdExhbmcgOiBkZWZhdWx0TGFuZy5ibG9jayB8fCAnJztcbiAgY29uc3QgZGVmYXVsdElubGluZUNvZGVMYW5nID0gdHlwZW9mIGRlZmF1bHRMYW5nID09PSAnc3RyaW5nJyA/IGRlZmF1bHRMYW5nIDogZGVmYXVsdExhbmcuaW5saW5lIHx8ICcnO1xuICBpZiAodGhlbWUgPT0gbnVsbCB8fCB0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnIHx8IGlzU2hpa2lUaGVtZSh0aGVtZSkpIHtcbiAgICBpZiAoIWhpZ2hsaWdodGVyQ2FjaGUuaGFzKCdkZWZhdWx0JykpIHtcbiAgICAgIGhpZ2hsaWdodGVyQ2FjaGUuc2V0KCdkZWZhdWx0JywgZ2V0SGlnaGxpZ2h0ZXIkMSh7XG4gICAgICAgIHRoZW1lXG4gICAgICB9KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBjb2xvciBtb2RlIG9iamVjdFxuICAgIGZvciAoY29uc3QgW21vZGUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGVtZSkpIHtcbiAgICAgIGlmICghaGlnaGxpZ2h0ZXJDYWNoZS5oYXMobW9kZSkpIHtcbiAgICAgICAgaGlnaGxpZ2h0ZXJDYWNoZS5zZXQobW9kZSwgZ2V0SGlnaGxpZ2h0ZXIkMSh7XG4gICAgICAgICAgdGhlbWU6IHZhbHVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFzeW5jIHRyZWUgPT4ge1xuICAgIGlmICghaGlnaGxpZ2h0ZXJDYWNoZSkgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgW21vZGUsIGxvYWRIaWdobGlnaHRlcl0gb2YgaGlnaGxpZ2h0ZXJDYWNoZS5lbnRyaWVzKCkpIHtcbiAgICAgIGlmICghaGlnaGxpZ2h0ZXJzLmdldChtb2RlKSkge1xuICAgICAgICBoaWdobGlnaHRlcnMuc2V0KG1vZGUsIGF3YWl0IGxvYWRIaWdobGlnaHRlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHZpc2l0KHRyZWUsICdlbGVtZW50JywgKGVsZW1lbnQsIGluZGV4LCBwYXJlbnQpID0+IHtcbiAgICAgIC8vIElubGluZSBjb2RlXG4gICAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnY29kZScgJiYgaXNFbGVtZW50KHBhcmVudCkgJiYgcGFyZW50LnRhZ05hbWUgIT09ICdwcmUnIHx8IGVsZW1lbnQudGFnTmFtZSA9PT0gJ2lubGluZUNvZGUnKSB7XG4gICAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc1RleHQodGV4dEVsZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dEVsZW1lbnQudmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhbGxvdyBlc2NhcGUgY2hhcmFjdGVycyB0byBicmVhayBvdXQgb2YgaGlnaGxpZ2h0aW5nXG4gICAgICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC97OlthLXpBLVouLV0rfS8sICcnKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IHZhbHVlLm1hdGNoKC97OihbYS16QS1aLi1dKyl9JC8pPy5bMV0gfHwgZGVmYXVsdElubGluZUNvZGVMYW5nO1xuICAgICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNMYW5nID0gbWV0YVswXSAhPT0gJy4nO1xuICAgICAgICBjb25zdCB0cmVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFttb2RlLCBoaWdobGlnaHRlcl0gb2YgaGlnaGxpZ2h0ZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmICghaXNMYW5nIHx8IG1ldGEgPT09ICdhbnNpJyAmJiAhaGlnaGxpZ2h0ZXIuYW5zaVRvSHRtbCkge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBoaWdobGlnaHRlci5nZXRUaGVtZSgpLnNldHRpbmdzLmZpbmQoKHtcbiAgICAgICAgICAgICAgc2NvcGVcbiAgICAgICAgICAgIH0pID0+IHNjb3BlPy5pbmNsdWRlcyh0b2tlbnNNYXBbbWV0YS5zbGljZSgxKV0gPz8gbWV0YS5zbGljZSgxKSkpPy5zZXR0aW5ncy5mb3JlZ3JvdW5kID8/ICdpbmhlcml0JztcbiAgICAgICAgICAgIHRyZWVzW21vZGVdID0gaGFzdFBhcnNlci5wYXJzZShgPHByZT48Y29kZT48c3BhbiBzdHlsZT1cImNvbG9yOiR7Y29sb3J9XCI+JHtzdHJpcHBlZFZhbHVlfTwvc3Bhbj48L2NvZGU+PC9wcmU+YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBodG1sO1xuICAgICAgICAgICAgaWYgKG1ldGEgPT09ICdhbnNpJykge1xuICAgICAgICAgICAgICBodG1sID0gaGlnaGxpZ2h0ZXIuYW5zaVRvSHRtbChzdHJpcHBlZFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGh0bWwgPSBoaWdobGlnaHRlci5jb2RlVG9IdG1sKHN0cmlwcGVkVmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJlZXNbbW9kZV0gPSBoYXN0UGFyc2VyLnBhcnNlKGh0bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b0ZyYWdtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgICB0cmVlcyxcbiAgICAgICAgICBsYW5nOiBpc0xhbmcgPyBtZXRhIDogJy50b2tlbicsXG4gICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgIGtlZXBCYWNrZ3JvdW5kXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgLy8gQmxvY2sgY29kZVxuICAgICAgLy8gQ2hlY2sgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbGVhZmFjL3JlaHlwZS1zaGlraVxuICAgICAgZWxlbWVudC50YWdOYW1lID09PSAncHJlJyAmJiBBcnJheS5pc0FycmF5KGVsZW1lbnQuY2hpbGRyZW4pICYmIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGlzRWxlbWVudChlbGVtZW50LmNoaWxkcmVuWzBdKSAmJiBlbGVtZW50LmNoaWxkcmVuWzBdLnRhZ05hbWUgPT09ICdjb2RlJykge1xuICAgICAgICBjb25zdCBjb2RlRWxlbWVudCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gY29kZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghaXNFbGVtZW50KGNvZGVFbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFuZyA9IGRlZmF1bHRDb2RlQmxvY2tMYW5nO1xuICAgICAgICBpZiAoY29kZUVsZW1lbnQucHJvcGVydGllcyAmJiBBcnJheS5pc0FycmF5KGNvZGVFbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lKSAmJiB0eXBlb2YgY29kZUVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWVbMF0gPT09ICdzdHJpbmcnICYmIGNvZGVFbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lWzBdLnN0YXJ0c1dpdGgoJ2xhbmd1YWdlLScpKSB7XG4gICAgICAgICAgbGFuZyA9IGNvZGVFbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lWzBdLnJlcGxhY2UoJ2xhbmd1YWdlLScsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhc3RyaW5nID0gY29kZUVsZW1lbnQuZGF0YT8ubWV0YSA/PyBjb2RlRWxlbWVudC5wcm9wZXJ0aWVzPy5tZXRhc3RyaW5nID8/ICcnO1xuICAgICAgICBsZXQgbWV0YSA9IGZpbHRlck1ldGFTdHJpbmcobWV0YXN0cmluZyk7XG4gICAgICAgIGNvbnN0IHRpdGxlTWF0Y2ggPSBtZXRhLm1hdGNoKC90aXRsZT1cIihbXlwiXSopXCIvKTtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aXRsZU1hdGNoPy5bMV0gPz8gbnVsbDtcbiAgICAgICAgbWV0YSA9IG1ldGEucmVwbGFjZSh0aXRsZU1hdGNoPy5bMF0gPz8gJycsICcnKTtcbiAgICAgICAgY29uc3QgY2FwdGlvbk1hdGNoID0gbWV0YS5tYXRjaCgvY2FwdGlvbj1cIihbXlwiXSopXCIvKTtcbiAgICAgICAgY29uc3QgY2FwdGlvbiA9IGNhcHRpb25NYXRjaD8uWzFdID8/IG51bGw7XG4gICAgICAgIG1ldGEgPSBtZXRhLnJlcGxhY2UoY2FwdGlvbk1hdGNoPy5bMF0gPz8gJycsICcnKTtcbiAgICAgICAgY29uc3QgbGluZU51bWJlcnMgPSBtZXRhID8gcmFuZ2VQYXJzZXIobWV0YS5tYXRjaCgvKD86XnxcXHMpeyguKj8pfS8pPy5bMV0gPz8gJycpIDogW107XG4gICAgICAgIGxldCBsaW5lTnVtYmVyc01heERpZ2l0cyA9IDA7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgICAgIGNvbnN0IHdvcmROdW1iZXJzID0gW107XG4gICAgICAgIGNvbnN0IHdvcmRJZHNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHdvcmRNYXRjaGVzID0gbWV0YSA/IFsuLi5tZXRhLm1hdGNoQWxsKC9cXC8oLio/KVxcLyhcXFMqKS9nKV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdvcmRNYXRjaGVzKSkge1xuICAgICAgICAgIHdvcmRNYXRjaGVzLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gd29yZE1hdGNoZXNbaW5kZXhdWzFdO1xuICAgICAgICAgICAgY29uc3Qgd29yZElkQW5kT3JSYW5nZSA9IHdvcmRNYXRjaGVzW2luZGV4XVsyXTtcbiAgICAgICAgICAgIHdvcmRzLnB1c2god29yZCk7XG4gICAgICAgICAgICBjb25zdCBbcmFuZ2UsIGlkXSA9IHdvcmRJZEFuZE9yUmFuZ2Uuc3BsaXQoJyMnKTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICB3b3JkTnVtYmVycy5wdXNoKHJhbmdlUGFyc2VyKHJhbmdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgd29yZElkc01hcC5zZXQod29yZCwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpcHBlZFZhbHVlID0gdGV4dEVsZW1lbnQudmFsdWUucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICAgICAgY29uc3QgdHJlZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbbW9kZSwgaGlnaGxpZ2h0ZXJdIG9mIGhpZ2hsaWdodGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGh0bWw7XG4gICAgICAgICAgICBpZiAobGFuZyA9PT0gJ2Fuc2knICYmIGhpZ2hsaWdodGVyLmFuc2lUb0h0bWwpIHtcbiAgICAgICAgICAgICAgaHRtbCA9IGhpZ2hsaWdodGVyLmFuc2lUb0h0bWwoc3RyaXBwZWRWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBodG1sID0gaGlnaGxpZ2h0ZXIuY29kZVRvSHRtbChzdHJpcHBlZFZhbHVlLCBsYW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyZWVzW21vZGVdID0gaGFzdFBhcnNlci5wYXJzZShodG1sKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBwbGFpbiB0ZXh0IGlmIGEgbGFuZ3VhZ2UgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIHRyZWVzW21vZGVdID0gaGFzdFBhcnNlci5wYXJzZShoaWdobGlnaHRlci5jb2RlVG9IdG1sKHN0cmlwcGVkVmFsdWUsICd0eHQnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHRyZWVzKS5mb3JFYWNoKChbLCB0cmVlXSkgPT4ge1xuICAgICAgICAgIGxldCBsaW5lQ291bnRlciA9IDA7XG4gICAgICAgICAgY29uc3Qgd29yZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICByYW5nZXM6IHdvcmROdW1iZXJzLFxuICAgICAgICAgICAgaWRzTWFwOiB3b3JkSWRzTWFwLFxuICAgICAgICAgICAgY291bnRlck1hcDogbmV3IE1hcCgpXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2aXNpdCh0cmVlLCAnZWxlbWVudCcsIGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ2NvZGUnICYmIC9zcmVibXVOZW5pTHdvaHMoPyEoLiopKFxcLykpLy50ZXN0KHJldmVyc2VTdHJpbmcobWV0YSkpKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50LnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnByb3BlcnRpZXNbJ2RhdGEtbGluZS1udW1iZXJzJ10gPSAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyc1N0YXJ0QXRNYXRjaCA9IHJldmVyc2VTdHJpbmcobWV0YSkubWF0Y2goLyg/OlxcfShcXGQrKXspP3NyZWJtdU5lbmlMd29ocyg/ISguKikoXFwvKSkvKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnROdW1iZXJTdHJpbmcgPSBsaW5lTnVtYmVyc1N0YXJ0QXRNYXRjaD8uWzFdO1xuICAgICAgICAgICAgICBpZiAoc3RhcnROdW1iZXJTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEF0ID0gc3RhcnROdW1iZXJTdHJpbmcgPyBOdW1iZXIocmV2ZXJzZVN0cmluZyhzdGFydE51bWJlclN0cmluZykpIC0gMSA6IDA7XG4gICAgICAgICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMgPSBzdGFydEF0O1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQucHJvcGVydGllcy5zdHlsZSA9IGBjb3VudGVyLXNldDogbGluZSAke3N0YXJ0QXR9O2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50LnByb3BlcnRpZXM/LmNsYXNzTmFtZSkgJiYgZWxlbWVudC5wcm9wZXJ0aWVzPy5jbGFzc05hbWU/LlswXSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgIGlmIChncmlkICYmIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlbiA9IFt7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogJyAnXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5maWx0ZXIoYyA9PiBjICE9PSAnbGluZScpO1xuICAgICAgICAgICAgICBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lLmxlbmd0aCA+IDAgPyBjbGFzc05hbWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGVsZW1lbnQucHJvcGVydGllc1snZGF0YS1saW5lJ10gPSAnJztcbiAgICAgICAgICAgICAgb25WaXNpdExpbmU/LihlbGVtZW50KTtcbiAgICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXJzLmxlbmd0aCAhPT0gMCAmJiBsaW5lTnVtYmVycy5pbmNsdWRlcygrK2xpbmVDb3VudGVyKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucHJvcGVydGllc1snZGF0YS1oaWdobGlnaHRlZC1saW5lJ10gPSAnJztcbiAgICAgICAgICAgICAgICBvblZpc2l0SGlnaGxpZ2h0ZWRMaW5lPy4oZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hhcnNIaWdobGlnaHRlcihlbGVtZW50LCB3b3Jkcywgd29yZE9wdGlvbnMsIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzKTtcbiAgICAgICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRvRnJhZ21lbnQoZWxlbWVudCwge1xuICAgICAgICAgIHRyZWVzLFxuICAgICAgICAgIGxhbmcsXG4gICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgY2FwdGlvbixcbiAgICAgICAgICBrZWVwQmFja2dyb3VuZCxcbiAgICAgICAgICBncmlkLFxuICAgICAgICAgIGxpbmVOdW1iZXJzTWF4RGlnaXRzLFxuICAgICAgICAgIG9uVmlzaXRUaXRsZSxcbiAgICAgICAgICBvblZpc2l0Q2FwdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgcmVoeXBlUHJldHR5Q29kZSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsidmlzaXQiLCJyYW5nZVBhcnNlciIsImdldEhpZ2hsaWdodGVyIiwidW5pZmllZCIsInJlaHlwZVBhcnNlIiwiaGFzaE9iaiIsInRvU3RyaW5nIiwiaXNTaGlraVRoZW1lIiwidmFsdWUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzRWxlbWVudCIsInR5cGUiLCJpc1RleHQiLCJvYmplY3QiLCJzdHJpbmciLCJjYWxsIiwic3BsaXRFbGVtZW50IiwiZWxlbWVudHMiLCJlbGVtZW50VG9XcmFwIiwiaW5uZXJTdHJpbmciLCJyaWdodFN0cmluZyIsImxlZnRTdHJpbmciLCJyZXN0IiwibmV4dEVsZW1lbnRDb250aW51ZXMiLCJpbmRleCIsImlnbm9yZUNoYXJzIiwiY2hpbGRyZW4iLCJuZXdJbmRleCIsInRleHRFbGVtZW50IiwicmlnaHRTdHIiLCJsZWZ0U3RyIiwibGVuZ3RoIiwibWFwIiwicyIsImpvaW4iLCJzcGxpY2UiLCJwcm9wZXJ0aWVzIiwibmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzIiwibmV4dEluZGV4IiwicmVtYWluaW5nUGFydCIsIm5leHROb2RlIiwiY29udGVudCIsImdldENvbnRlbnQiLCJpbmNsdWRlc05leHQiLCJzdGFydHNXaXRoIiwib3ZlcmxhcCIsImZpbmRPdmVybGFwIiwicmVwbGFjZSIsIm5vZGUiLCJhIiwiYiIsImVuZHNXaXRoIiwiaW5kZXhPZiIsInN1YnN0cmluZyIsInJldmVyc2VTdHJpbmciLCJzcGxpdCIsInJldmVyc2UiLCJnZXRFbGVtZW50c1RvSGlnaGxpZ2h0IiwiZWxlbWVudCIsImNoYXJzIiwic3RhcnRJbmRleCIsInRvV3JhcCIsImNoYXJzU29GYXIiLCJpIiwicmVtYWluaW5nIiwibWF5YmVFbGVtZW50IiwicHVzaCIsInBhcnRpYWxNYXRjaCIsIm5leHRQYXJ0Iiwic3BsaXRQYXJ0cyIsImxlZnRQYXJ0IiwicmlnaHRQYXJ0Iiwid2l0aE5leHROb2RlIiwibmV4dE5vZGVPdmVybGFwIiwic3BsaXRJbmRleCIsIm5ld0VsZW1lbnQiLCJ1cGRhdGVkSW5kZXgiLCJ3cmFwSGlnaGxpZ2h0ZWRDaGFycyIsInBhcmVudEVsZW1lbnQiLCJlbGVtZW50c1RvV3JhcCIsIm9wdGlvbnMiLCJpZ25vcmVXb3JkIiwib25WaXNpdEhpZ2hsaWdodGVkQ2hhcnMiLCJ0YWdOYW1lIiwid29yZFN0ciIsInJlZHVjZSIsImFjYyIsImlkIiwiaWRzTWFwIiwiZ2V0IiwiY2hhcnNIaWdobGlnaHRlciIsImNoYXJzTGlzdCIsInJhbmdlcyIsInRleHRDb250ZW50IiwiZm9yRWFjaCIsImluY2x1ZGVzIiwiY3VycmVudENoYXJzUmFuZ2UiLCJjb3VudGVyTWFwIiwic2V0IiwiTWF0aCIsIm1heCIsImNoaWxkTm9kZSIsInByb3BzIiwidG9GcmFnbWVudCIsInRyZWVzIiwibGFuZyIsInRpdGxlIiwiY2FwdGlvbiIsImlubGluZSIsImtlZXBCYWNrZ3JvdW5kIiwiZ3JpZCIsImxpbmVOdW1iZXJzTWF4RGlnaXRzIiwib25WaXNpdFRpdGxlIiwib25WaXNpdENhcHRpb24iLCJPYmplY3QiLCJlbnRyaWVzIiwibW9kZSIsInRyZWUiLCJwcmUiLCJjb2RlIiwiQXJyYXkiLCJpc0FycmF5IiwiY2xhc3NOYW1lIiwiZmlsdGVyIiwiYyIsInVuZGVmaW5lZCIsInN0eWxlIiwiZnJhZ21lbnRzIiwiZWxlbWVudENvbnRlbnQiLCJmbGF0TWFwIiwiZ2xvYmFsSGlnaGxpZ2h0ZXJDYWNoZSIsIk1hcCIsImhhc3RQYXJzZXIiLCJ1c2UiLCJmcmFnbWVudCIsInJlaHlwZVByZXR0eUNvZGUiLCJ0aGVtZSIsImRlZmF1bHRMYW5nIiwidG9rZW5zTWFwIiwiZmlsdGVyTWV0YVN0cmluZyIsInYiLCJnZXRIaWdobGlnaHRlciQxIiwib25WaXNpdExpbmUiLCJvblZpc2l0SGlnaGxpZ2h0ZWRMaW5lIiwib3B0aW9uc0hhc2giLCJhbGdvcml0aG0iLCJoaWdobGlnaHRlckNhY2hlIiwiaGlnaGxpZ2h0ZXJzIiwiZGVmYXVsdENvZGVCbG9ja0xhbmciLCJibG9jayIsImRlZmF1bHRJbmxpbmVDb2RlTGFuZyIsImhhcyIsImxvYWRIaWdobGlnaHRlciIsInBhcmVudCIsInN0cmlwcGVkVmFsdWUiLCJtZXRhIiwibWF0Y2giLCJpc0xhbmciLCJoaWdobGlnaHRlciIsImFuc2lUb0h0bWwiLCJjb2xvciIsImdldFRoZW1lIiwic2V0dGluZ3MiLCJmaW5kIiwic2NvcGUiLCJzbGljZSIsImZvcmVncm91bmQiLCJwYXJzZSIsImh0bWwiLCJjb2RlVG9IdG1sIiwiY29kZUVsZW1lbnQiLCJtZXRhc3RyaW5nIiwiZGF0YSIsInRpdGxlTWF0Y2giLCJjYXB0aW9uTWF0Y2giLCJsaW5lTnVtYmVycyIsIndvcmRzIiwid29yZE51bWJlcnMiLCJ3b3JkSWRzTWFwIiwid29yZE1hdGNoZXMiLCJtYXRjaEFsbCIsIl8iLCJ3b3JkIiwid29yZElkQW5kT3JSYW5nZSIsInJhbmdlIiwiZSIsImxpbmVDb3VudGVyIiwid29yZE9wdGlvbnMiLCJ0ZXN0IiwibGluZU51bWJlcnNTdGFydEF0TWF0Y2giLCJzdGFydE51bWJlclN0cmluZyIsInN0YXJ0QXQiLCJOdW1iZXIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/dist/rehype-pretty-code.js\n");

/***/ })

};
;