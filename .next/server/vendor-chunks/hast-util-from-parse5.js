"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-from-parse5";
exports.ids = ["vendor-chunks/hast-util-from-parse5"];
exports.modules = {

/***/ "(rsc)/./node_modules/hast-util-from-parse5/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/hast-util-from-parse5/lib/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromParse5: () => (/* binding */ fromParse5)\n/* harmony export */ });\n/* harmony import */ var hastscript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hastscript */ \"(rsc)/./node_modules/hastscript/lib/svg.js\");\n/* harmony import */ var hastscript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! hastscript */ \"(rsc)/./node_modules/hastscript/lib/html.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! property-information */ \"(rsc)/./node_modules/property-information/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! property-information */ \"(rsc)/./node_modules/property-information/lib/find.js\");\n/* harmony import */ var vfile_location__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vfile-location */ \"(rsc)/./node_modules/vfile-location/lib/index.js\");\n/* harmony import */ var web_namespaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! web-namespaces */ \"(rsc)/./node_modules/web-namespaces/index.js\");\n/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Token.Location} P5Location\n */ /**\n * @typedef {Content | Root} Node\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in.\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {VFile | null | undefined} [file]\n *   File used to add positional info to nodes.\n *\n *   If given, the file should represent the original HTML source.\n * @property {boolean} [verbose=false]\n *   Whether to add extra positional info about starting tags, closing tags,\n *   and attributes to elements.\n *\n *   > ðŸ‘‰ **Note**: only used when `file` is given.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {Schema} schema\n *   Current schema.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n * @property {boolean} location\n *   Whether location info was found.\n */ \n\n\n\nconst own = {}.hasOwnProperty;\n/** @type {unknown} */ // type-coverage:ignore-next-line\nconst proto = Object.prototype;\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {P5Node} tree\n *   `parse5` tree to transform.\n * @param {Options | VFile | null | undefined} [options]\n *   Configuration.\n * @returns {Node}\n *   hast tree.\n */ function fromParse5(tree, options) {\n    const options_ = options || {};\n    /** @type {Options} */ let settings;\n    /** @type {VFile | undefined} */ let file;\n    if (isFile(options_)) {\n        file = options_;\n        settings = {};\n    } else {\n        file = options_.file || undefined;\n        settings = options_;\n    }\n    return one({\n        schema: settings.space === \"svg\" ? property_information__WEBPACK_IMPORTED_MODULE_0__.svg : property_information__WEBPACK_IMPORTED_MODULE_0__.html,\n        file,\n        verbose: settings.verbose,\n        location: false\n    }, tree);\n}\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} node\n *   p5 node.\n * @returns {Node}\n *   hast node.\n */ function one(state, node) {\n    /** @type {Node} */ let result;\n    switch(node.nodeName){\n        case \"#comment\":\n            {\n                const reference = /** @type {P5Comment} */ node;\n                result = {\n                    type: \"comment\",\n                    value: reference.data\n                };\n                patch(state, reference, result);\n                return result;\n            }\n        case \"#document\":\n        case \"#document-fragment\":\n            {\n                const reference = /** @type {P5Document | P5DocumentFragment} */ node;\n                const quirksMode = \"mode\" in reference ? reference.mode === \"quirks\" || reference.mode === \"limited-quirks\" : false;\n                result = {\n                    type: \"root\",\n                    children: all(state, node.childNodes),\n                    data: {\n                        quirksMode\n                    }\n                };\n                if (state.file && state.location) {\n                    const doc = String(state.file);\n                    const loc = (0,vfile_location__WEBPACK_IMPORTED_MODULE_1__.location)(doc);\n                    const start = loc.toPoint(0);\n                    const end = loc.toPoint(doc.length);\n                    // @ts-expect-error: always defined as we give valid input.\n                    result.position = {\n                        start,\n                        end\n                    };\n                }\n                return result;\n            }\n        case \"#documentType\":\n            {\n                const reference = /** @type {P5DocumentType} */ node;\n                // @ts-expect-error Types are out of date.\n                result = {\n                    type: \"doctype\"\n                };\n                patch(state, reference, result);\n                return result;\n            }\n        case \"#text\":\n            {\n                const reference = /** @type {P5Text} */ node;\n                result = {\n                    type: \"text\",\n                    value: reference.value\n                };\n                patch(state, reference, result);\n                return result;\n            }\n        // Element.\n        default:\n            {\n                const reference = /** @type {P5Element} */ node;\n                result = element(state, reference);\n                return result;\n            }\n    }\n}\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<P5Node>} nodes\n *   Nodes.\n * @returns {Array<Content>}\n *   hast nodes.\n */ function all(state, nodes) {\n    let index = -1;\n    /** @type {Array<Content>} */ const result = [];\n    while(++index < nodes.length){\n        // @ts-expect-error Assume no roots in `nodes`.\n        result[index] = one(state, nodes[index]);\n    }\n    return result;\n}\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Element} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */ function element(state, node) {\n    const schema = state.schema;\n    state.schema = node.namespaceURI === web_namespaces__WEBPACK_IMPORTED_MODULE_2__.webNamespaces.svg ? property_information__WEBPACK_IMPORTED_MODULE_0__.svg : property_information__WEBPACK_IMPORTED_MODULE_0__.html;\n    // Props.\n    let index = -1;\n    /** @type {Record<string, string>} */ const props = {};\n    while(++index < node.attrs.length){\n        const attribute = node.attrs[index];\n        const name = (attribute.prefix ? attribute.prefix + \":\" : \"\") + attribute.name;\n        if (!own.call(proto, name)) {\n            props[name] = attribute.value;\n        }\n    }\n    // Build.\n    const fn = state.schema.space === \"svg\" ? hastscript__WEBPACK_IMPORTED_MODULE_3__.s : hastscript__WEBPACK_IMPORTED_MODULE_4__.h;\n    const result = fn(node.tagName, props, all(state, node.childNodes));\n    patch(state, node, result);\n    // Switch content.\n    if (result.tagName === \"template\") {\n        const reference = /** @type {P5Template} */ node;\n        const pos = reference.sourceCodeLocation;\n        const startTag = pos && pos.startTag && position(pos.startTag);\n        const endTag = pos && pos.endTag && position(pos.endTag);\n        /** @type {Root} */ // @ts-expect-error Types are wrong.\n        const content = one(state, reference.content);\n        if (startTag && endTag && state.file) {\n            content.position = {\n                start: startTag.end,\n                end: endTag.start\n            };\n        }\n        result.content = content;\n    }\n    state.schema = schema;\n    return result;\n}\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} from\n *   p5 node.\n * @param {Node} to\n *   hast node.\n * @returns {void}\n *   Nothing.\n */ function patch(state, from, to) {\n    if (\"sourceCodeLocation\" in from && from.sourceCodeLocation && state.file) {\n        const position = createLocation(state, to, from.sourceCodeLocation);\n        if (position) {\n            state.location = true;\n            to.position = position;\n        }\n    }\n}\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Node} node\n *   hast node.\n * @param {P5ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */ function createLocation(state, node, location) {\n    const result = position(location);\n    if (node.type === \"element\") {\n        const tail = node.children[node.children.length - 1];\n        // Bug for unclosed with children.\n        // See: <https://github.com/inikulin/parse5/issues/109>.\n        if (result && !location.endTag && tail && tail.position && tail.position.end) {\n            result.end = Object.assign({}, tail.position.end);\n        }\n        if (state.verbose) {\n            /** @type {Record<string, Position | undefined>} */ const props = {};\n            /** @type {string} */ let key;\n            if (location.attrs) {\n                for(key in location.attrs){\n                    if (own.call(location.attrs, key)) {\n                        props[(0,property_information__WEBPACK_IMPORTED_MODULE_5__.find)(state.schema, key).property] = position(location.attrs[key]);\n                    }\n                }\n            }\n            node.data = {\n                position: {\n                    // @ts-expect-error: assume not `undefined`.\n                    opening: position(location.startTag),\n                    closing: location.endTag ? position(location.endTag) : null,\n                    properties: props\n                }\n            };\n        }\n    }\n    return result;\n}\n/**\n * Turn a p5 location into a position.\n *\n * @param {P5Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */ function position(loc) {\n    const start = point({\n        line: loc.startLine,\n        column: loc.startCol,\n        offset: loc.startOffset\n    });\n    const end = point({\n        line: loc.endLine,\n        column: loc.endCol,\n        offset: loc.endOffset\n    });\n    // @ts-expect-error `undefined` is fine.\n    return start || end ? {\n        start,\n        end\n    } : undefined;\n}\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */ function point(point) {\n    return point.line && point.column ? point : undefined;\n}\n/**\n * Check if something is a file.\n *\n * @param {VFile | Options} value\n *   File or options.\n * @returns {value is VFile}\n *   Whether `value` is a file.\n */ function isFile(value) {\n    return \"messages\" in value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLWZyb20tcGFyc2U1L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMENDLEdBRThCO0FBQ3FCO0FBQ2I7QUFDSztBQUU1QyxNQUFNTyxNQUFNLENBQUMsRUFBRUMsY0FBYztBQUM3QixvQkFBb0IsR0FDcEIsaUNBQWlDO0FBQ2pDLE1BQU1DLFFBQVFDLE9BQU9DLFNBQVM7QUFFOUI7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU0MsV0FBV0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3RDLE1BQU1DLFdBQVdELFdBQVcsQ0FBQztJQUM3QixvQkFBb0IsR0FDcEIsSUFBSUU7SUFDSiw4QkFBOEIsR0FDOUIsSUFBSUM7SUFFSixJQUFJQyxPQUFPSCxXQUFXO1FBQ3BCRSxPQUFPRjtRQUNQQyxXQUFXLENBQUM7SUFDZCxPQUFPO1FBQ0xDLE9BQU9GLFNBQVNFLElBQUksSUFBSUU7UUFDeEJILFdBQVdEO0lBQ2I7SUFFQSxPQUFPSyxJQUNMO1FBQ0VDLFFBQVFMLFNBQVNNLEtBQUssS0FBSyxRQUFRbkIscURBQUdBLEdBQUdELHNEQUFJQTtRQUM3Q2U7UUFDQU0sU0FBU1AsU0FBU08sT0FBTztRQUN6QmxCLFVBQVU7SUFDWixHQUNBUTtBQUVKO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU08sSUFBSUksS0FBSyxFQUFFQyxJQUFJO0lBQ3RCLGlCQUFpQixHQUNqQixJQUFJQztJQUVKLE9BQVFELEtBQUtFLFFBQVE7UUFDbkIsS0FBSztZQUFZO2dCQUNmLE1BQU1DLFlBQVksc0JBQXNCLEdBQUlIO2dCQUM1Q0MsU0FBUztvQkFBQ0csTUFBTTtvQkFBV0MsT0FBT0YsVUFBVUcsSUFBSTtnQkFBQTtnQkFDaERDLE1BQU1SLE9BQU9JLFdBQVdGO2dCQUN4QixPQUFPQTtZQUNUO1FBRUEsS0FB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QyxJQUFJbUMsU0FBUztRQUNuQkMsUUFBUXBDLElBQUlxQyxRQUFRO1FBQ3BCQyxRQUFRdEMsSUFBSXVDLFdBQVc7SUFDekI7SUFDQSxNQUFNcEMsTUFBTThCLE1BQU07UUFDaEJDLE1BQU1sQyxJQUFJd0MsT0FBTztRQUNqQkosUUFBUXBDLElBQUl5QyxNQUFNO1FBQ2xCSCxRQUFRdEMsSUFBSTBDLFNBQVM7SUFDdkI7SUFDQSx3Q0FBd0M7SUFDeEMsT0FBT3pDLFNBQVNFLE1BQU07UUFBQ0Y7UUFBT0U7SUFBRyxJQUFJeEI7QUFDdkM7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3NELE1BQU1BLEtBQUs7SUFDbEIsT0FBT0EsTUFBTUMsSUFBSSxJQUFJRCxNQUFNRyxNQUFNLEdBQUdILFFBQVF0RDtBQUM5QztBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRCxPQUFPWSxLQUFLO0lBQ25CLE9BQU8sY0FBY0E7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vdmVycmVhY3RlZC8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtZnJvbS1wYXJzZTUvbGliL2luZGV4LmpzP2Y0ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd2ZmlsZScpLlZGaWxlfSBWRmlsZVxuICogQHR5cGVkZWYge2ltcG9ydCgncHJvcGVydHktaW5mb3JtYXRpb24nKS5TY2hlbWF9IFNjaGVtYVxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Qb3NpdGlvbn0gUG9zaXRpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUG9pbnR9IFBvaW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuRWxlbWVudH0gRWxlbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Db250ZW50fSBDb250ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdwYXJzZTUnKS5EZWZhdWx0VHJlZUFkYXB0ZXJNYXB9IERlZmF1bHRUcmVlQWRhcHRlck1hcFxuICogQHR5cGVkZWYge2ltcG9ydCgncGFyc2U1JykuVG9rZW4uRWxlbWVudExvY2F0aW9ufSBQNUVsZW1lbnRMb2NhdGlvblxuICogQHR5cGVkZWYge2ltcG9ydCgncGFyc2U1JykuVG9rZW4uTG9jYXRpb259IFA1TG9jYXRpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtDb250ZW50IHwgUm9vdH0gTm9kZVxuICogQHR5cGVkZWYge0RlZmF1bHRUcmVlQWRhcHRlck1hcFsnZG9jdW1lbnQnXX0gUDVEb2N1bWVudFxuICogQHR5cGVkZWYge0RlZmF1bHRUcmVlQWRhcHRlck1hcFsnZG9jdW1lbnRGcmFnbWVudCddfSBQNURvY3VtZW50RnJhZ21lbnRcbiAqIEB0eXBlZGVmIHtEZWZhdWx0VHJlZUFkYXB0ZXJNYXBbJ2RvY3VtZW50VHlwZSddfSBQNURvY3VtZW50VHlwZVxuICogQHR5cGVkZWYge0RlZmF1bHRUcmVlQWRhcHRlck1hcFsnY29tbWVudE5vZGUnXX0gUDVDb21tZW50XG4gKiBAdHlwZWRlZiB7RGVmYXVsdFRyZWVBZGFwdGVyTWFwWyd0ZXh0Tm9kZSddfSBQNVRleHRcbiAqIEB0eXBlZGVmIHtEZWZhdWx0VHJlZUFkYXB0ZXJNYXBbJ2VsZW1lbnQnXX0gUDVFbGVtZW50XG4gKiBAdHlwZWRlZiB7RGVmYXVsdFRyZWVBZGFwdGVyTWFwWydub2RlJ119IFA1Tm9kZVxuICogQHR5cGVkZWYge0RlZmF1bHRUcmVlQWRhcHRlck1hcFsndGVtcGxhdGUnXX0gUDVUZW1wbGF0ZVxuICpcbiAqIEB0eXBlZGVmIHsnaHRtbCcgfCAnc3ZnJ30gU3BhY2VcbiAqICAgTmFtZXNwYWNlLlxuICpcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7U3BhY2UgfCBudWxsIHwgdW5kZWZpbmVkfSBbc3BhY2U9J2h0bWwnXVxuICogICBXaGljaCBzcGFjZSB0aGUgZG9jdW1lbnQgaXMgaW4uXG4gKlxuICogICBXaGVuIGFuIGA8c3ZnPmAgZWxlbWVudCBpcyBmb3VuZCBpbiB0aGUgSFRNTCBzcGFjZSwgdGhpcyBwYWNrYWdlIGFscmVhZHlcbiAqICAgYXV0b21hdGljYWxseSBzd2l0Y2hlcyB0byBhbmQgZnJvbSB0aGUgU1ZHIHNwYWNlIHdoZW4gZW50ZXJpbmcgYW5kIGV4aXRpbmdcbiAqICAgaXQuXG4gKiBAcHJvcGVydHkge1ZGaWxlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2ZpbGVdXG4gKiAgIEZpbGUgdXNlZCB0byBhZGQgcG9zaXRpb25hbCBpbmZvIHRvIG5vZGVzLlxuICpcbiAqICAgSWYgZ2l2ZW4sIHRoZSBmaWxlIHNob3VsZCByZXByZXNlbnQgdGhlIG9yaWdpbmFsIEhUTUwgc291cmNlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmVyYm9zZT1mYWxzZV1cbiAqICAgV2hldGhlciB0byBhZGQgZXh0cmEgcG9zaXRpb25hbCBpbmZvIGFib3V0IHN0YXJ0aW5nIHRhZ3MsIGNsb3NpbmcgdGFncyxcbiAqICAgYW5kIGF0dHJpYnV0ZXMgdG8gZWxlbWVudHMuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IG9ubHkgdXNlZCB3aGVuIGBmaWxlYCBpcyBnaXZlbi5cbiAqXG4gKiBAdHlwZWRlZiBTdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcHJvcGVydHkge1NjaGVtYX0gc2NoZW1hXG4gKiAgIEN1cnJlbnQgc2NoZW1hLlxuICogQHByb3BlcnR5IHtWRmlsZSB8IHVuZGVmaW5lZH0gZmlsZVxuICogICBDb3JyZXNwb25kaW5nIGZpbGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCB1bmRlZmluZWR9IHZlcmJvc2VcbiAqICAgQWRkIGV4dHJhIHBvc2l0aW9uYWwgaW5mby5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbG9jYXRpb25cbiAqICAgV2hldGhlciBsb2NhdGlvbiBpbmZvIHdhcyBmb3VuZC5cbiAqL1xuXG5pbXBvcnQge2gsIHN9IGZyb20gJ2hhc3RzY3JpcHQnXG5pbXBvcnQge2h0bWwsIHN2ZywgZmluZH0gZnJvbSAncHJvcGVydHktaW5mb3JtYXRpb24nXG5pbXBvcnQge2xvY2F0aW9ufSBmcm9tICd2ZmlsZS1sb2NhdGlvbidcbmltcG9ydCB7d2ViTmFtZXNwYWNlc30gZnJvbSAnd2ViLW5hbWVzcGFjZXMnXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG4vKiogQHR5cGUge3Vua25vd259ICovXG4vLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbmNvbnN0IHByb3RvID0gT2JqZWN0LnByb3RvdHlwZVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGBwYXJzZTVgIEFTVCB0byBoYXN0LlxuICpcbiAqIEBwYXJhbSB7UDVOb2RlfSB0cmVlXG4gKiAgIGBwYXJzZTVgIHRyZWUgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHtPcHRpb25zIHwgVkZpbGUgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIHtOb2RlfVxuICogICBoYXN0IHRyZWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUGFyc2U1KHRyZWUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9uc18gPSBvcHRpb25zIHx8IHt9XG4gIC8qKiBAdHlwZSB7T3B0aW9uc30gKi9cbiAgbGV0IHNldHRpbmdzXG4gIC8qKiBAdHlwZSB7VkZpbGUgfCB1bmRlZmluZWR9ICovXG4gIGxldCBmaWxlXG5cbiAgaWYgKGlzRmlsZShvcHRpb25zXykpIHtcbiAgICBmaWxlID0gb3B0aW9uc19cbiAgICBzZXR0aW5ncyA9IHt9XG4gIH0gZWxzZSB7XG4gICAgZmlsZSA9IG9wdGlvbnNfLmZpbGUgfHwgdW5kZWZpbmVkXG4gICAgc2V0dGluZ3MgPSBvcHRpb25zX1xuICB9XG5cbiAgcmV0dXJuIG9uZShcbiAgICB7XG4gICAgICBzY2hlbWE6IHNldHRpbmdzLnNwYWNlID09PSAnc3ZnJyA/IHN2ZyA6IGh0bWwsXG4gICAgICBmaWxlLFxuICAgICAgdmVyYm9zZTogc2V0dGluZ3MudmVyYm9zZSxcbiAgICAgIGxvY2F0aW9uOiBmYWxzZVxuICAgIH0sXG4gICAgdHJlZVxuICApXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0ge1A1Tm9kZX0gbm9kZVxuICogICBwNSBub2RlLlxuICogQHJldHVybnMge05vZGV9XG4gKiAgIGhhc3Qgbm9kZS5cbiAqL1xuZnVuY3Rpb24gb25lKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgbGV0IHJlc3VsdFxuXG4gIHN3aXRjaCAobm9kZS5ub2RlTmFtZSkge1xuICAgIGNhc2UgJyNjb21tZW50Jzoge1xuICAgICAgY29uc3QgcmVmZXJlbmNlID0gLyoqIEB0eXBlIHtQNUNvbW1lbnR9ICovIChub2RlKVxuICAgICAgcmVzdWx0ID0ge3R5cGU6ICdjb21tZW50JywgdmFsdWU6IHJlZmVyZW5jZS5kYXRhfVxuICAgICAgcGF0Y2goc3RhdGUsIHJlZmVyZW5jZSwgcmVzdWx0KVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgY2FzZSAnI2RvY3VtZW50LWZyYWdtZW50Jzoge1xuICAgICAgY29uc3QgcmVmZXJlbmNlID0gLyoqIEB0eXBlIHtQNURvY3VtZW50IHwgUDVEb2N1bWVudEZyYWdtZW50fSAqLyAobm9kZSlcbiAgICAgIGNvbnN0IHF1aXJrc01vZGUgPVxuICAgICAgICAnbW9kZScgaW4gcmVmZXJlbmNlXG4gICAgICAgICAgPyByZWZlcmVuY2UubW9kZSA9PT0gJ3F1aXJrcycgfHwgcmVmZXJlbmNlLm1vZGUgPT09ICdsaW1pdGVkLXF1aXJrcydcbiAgICAgICAgICA6IGZhbHNlXG5cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogJ3Jvb3QnLFxuICAgICAgICBjaGlsZHJlbjogYWxsKHN0YXRlLCBub2RlLmNoaWxkTm9kZXMpLFxuICAgICAgICBkYXRhOiB7cXVpcmtzTW9kZX1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmZpbGUgJiYgc3RhdGUubG9jYXRpb24pIHtcbiAgICAgICAgY29uc3QgZG9jID0gU3RyaW5nKHN0YXRlLmZpbGUpXG4gICAgICAgIGNvbnN0IGxvYyA9IGxvY2F0aW9uKGRvYylcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb2MudG9Qb2ludCgwKVxuICAgICAgICBjb25zdCBlbmQgPSBsb2MudG9Qb2ludChkb2MubGVuZ3RoKVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhbHdheXMgZGVmaW5lZCBhcyB3ZSBnaXZlIHZhbGlkIGlucHV0LlxuICAgICAgICByZXN1bHQucG9zaXRpb24gPSB7c3RhcnQsIGVuZH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIGNhc2UgJyNkb2N1bWVudFR5cGUnOiB7XG4gICAgICBjb25zdCByZWZlcmVuY2UgPSAvKiogQHR5cGUge1A1RG9jdW1lbnRUeXBlfSAqLyAobm9kZSlcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVHlwZXMgYXJlIG91dCBvZiBkYXRlLlxuICAgICAgcmVzdWx0ID0ge3R5cGU6ICdkb2N0eXBlJ31cbiAgICAgIHBhdGNoKHN0YXRlLCByZWZlcmVuY2UsIHJlc3VsdClcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBjYXNlICcjdGV4dCc6IHtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IC8qKiBAdHlwZSB7UDVUZXh0fSAqLyAobm9kZSlcbiAgICAgIHJlc3VsdCA9IHt0eXBlOiAndGV4dCcsIHZhbHVlOiByZWZlcmVuY2UudmFsdWV9XG4gICAgICBwYXRjaChzdGF0ZSwgcmVmZXJlbmNlLCByZXN1bHQpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLy8gRWxlbWVudC5cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCByZWZlcmVuY2UgPSAvKiogQHR5cGUge1A1RWxlbWVudH0gKi8gKG5vZGUpXG4gICAgICByZXN1bHQgPSBlbGVtZW50KHN0YXRlLCByZWZlcmVuY2UpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7QXJyYXk8UDVOb2RlPn0gbm9kZXNcbiAqICAgTm9kZXMuXG4gKiBAcmV0dXJucyB7QXJyYXk8Q29udGVudD59XG4gKiAgIGhhc3Qgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGFsbChzdGF0ZSwgbm9kZXMpIHtcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtBcnJheTxDb250ZW50Pn0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICB3aGlsZSAoKytpbmRleCA8IG5vZGVzLmxlbmd0aCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQXNzdW1lIG5vIHJvb3RzIGluIGBub2Rlc2AuXG4gICAgcmVzdWx0W2luZGV4XSA9IG9uZShzdGF0ZSwgbm9kZXNbaW5kZXhdKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7UDVFbGVtZW50fSBub2RlXG4gKiAgIGBwYXJzZTVgIG5vZGUgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybnMge0VsZW1lbnR9XG4gKiAgIGhhc3Qgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZWxlbWVudChzdGF0ZSwgbm9kZSkge1xuICBjb25zdCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWFcblxuICBzdGF0ZS5zY2hlbWEgPSBub2RlLm5hbWVzcGFjZVVSSSA9PT0gd2ViTmFtZXNwYWNlcy5zdmcgPyBzdmcgOiBodG1sXG5cbiAgLy8gUHJvcHMuXG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgY29uc3QgcHJvcHMgPSB7fVxuXG4gIHdoaWxlICgrK2luZGV4IDwgbm9kZS5hdHRycy5sZW5ndGgpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJzW2luZGV4XVxuICAgIGNvbnN0IG5hbWUgPVxuICAgICAgKGF0dHJpYnV0ZS5wcmVmaXggPyBhdHRyaWJ1dGUucHJlZml4ICsgJzonIDogJycpICsgYXR0cmlidXRlLm5hbWVcbiAgICBpZiAoIW93bi5jYWxsKHByb3RvLCBuYW1lKSkge1xuICAgICAgcHJvcHNbbmFtZV0gPSBhdHRyaWJ1dGUudmFsdWVcbiAgICB9XG4gIH1cblxuICAvLyBCdWlsZC5cbiAgY29uc3QgZm4gPSBzdGF0ZS5zY2hlbWEuc3BhY2UgPT09ICdzdmcnID8gcyA6IGhcbiAgY29uc3QgcmVzdWx0ID0gZm4obm9kZS50YWdOYW1lLCBwcm9wcywgYWxsKHN0YXRlLCBub2RlLmNoaWxkTm9kZXMpKVxuICBwYXRjaChzdGF0ZSwgbm9kZSwgcmVzdWx0KVxuXG4gIC8vIFN3aXRjaCBjb250ZW50LlxuICBpZiAocmVzdWx0LnRhZ05hbWUgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICBjb25zdCByZWZlcmVuY2UgPSAvKiogQHR5cGUge1A1VGVtcGxhdGV9ICovIChub2RlKVxuICAgIGNvbnN0IHBvcyA9IHJlZmVyZW5jZS5zb3VyY2VDb2RlTG9jYXRpb25cbiAgICBjb25zdCBzdGFydFRhZyA9IHBvcyAmJiBwb3Muc3RhcnRUYWcgJiYgcG9zaXRpb24ocG9zLnN0YXJ0VGFnKVxuICAgIGNvbnN0IGVuZFRhZyA9IHBvcyAmJiBwb3MuZW5kVGFnICYmIHBvc2l0aW9uKHBvcy5lbmRUYWcpXG5cbiAgICAvKiogQHR5cGUge1Jvb3R9ICovXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUeXBlcyBhcmUgd3JvbmcuXG4gICAgY29uc3QgY29udGVudCA9IG9uZShzdGF0ZSwgcmVmZXJlbmNlLmNvbnRlbnQpXG5cbiAgICBpZiAoc3RhcnRUYWcgJiYgZW5kVGFnICYmIHN0YXRlLmZpbGUpIHtcbiAgICAgIGNvbnRlbnQucG9zaXRpb24gPSB7c3RhcnQ6IHN0YXJ0VGFnLmVuZCwgZW5kOiBlbmRUYWcuc3RhcnR9XG4gICAgfVxuXG4gICAgcmVzdWx0LmNvbnRlbnQgPSBjb250ZW50XG4gIH1cblxuICBzdGF0ZS5zY2hlbWEgPSBzY2hlbWFcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogUGF0Y2ggcG9zaXRpb25hbCBpbmZvIGZyb20gYGZyb21gIG9udG8gYHRvYC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0ge1A1Tm9kZX0gZnJvbVxuICogICBwNSBub2RlLlxuICogQHBhcmFtIHtOb2RlfSB0b1xuICogICBoYXN0IG5vZGUuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gcGF0Y2goc3RhdGUsIGZyb20sIHRvKSB7XG4gIGlmICgnc291cmNlQ29kZUxvY2F0aW9uJyBpbiBmcm9tICYmIGZyb20uc291cmNlQ29kZUxvY2F0aW9uICYmIHN0YXRlLmZpbGUpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLCB0bywgZnJvbS5zb3VyY2VDb2RlTG9jYXRpb24pXG5cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHN0YXRlLmxvY2F0aW9uID0gdHJ1ZVxuICAgICAgdG8ucG9zaXRpb24gPSBwb3NpdGlvblxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBjbGVhbiBwb3NpdGlvbmFsIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogICBoYXN0IG5vZGUuXG4gKiBAcGFyYW0ge1A1RWxlbWVudExvY2F0aW9ufSBsb2NhdGlvblxuICogICBwNSBsb2NhdGlvbiBpbmZvLlxuICogQHJldHVybnMge1Bvc2l0aW9uIHwgdW5kZWZpbmVkfVxuICogICBQb3NpdGlvbiwgb3Igbm90aGluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oc3RhdGUsIG5vZGUsIGxvY2F0aW9uKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHBvc2l0aW9uKGxvY2F0aW9uKVxuXG4gIGlmIChub2RlLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgIGNvbnN0IHRhaWwgPSBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cblxuICAgIC8vIEJ1ZyBmb3IgdW5jbG9zZWQgd2l0aCBjaGlsZHJlbi5cbiAgICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L2lzc3Vlcy8xMDk+LlxuICAgIGlmIChcbiAgICAgIHJlc3VsdCAmJlxuICAgICAgIWxvY2F0aW9uLmVuZFRhZyAmJlxuICAgICAgdGFpbCAmJlxuICAgICAgdGFpbC5wb3NpdGlvbiAmJlxuICAgICAgdGFpbC5wb3NpdGlvbi5lbmRcbiAgICApIHtcbiAgICAgIHJlc3VsdC5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCB0YWlsLnBvc2l0aW9uLmVuZClcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUudmVyYm9zZSkge1xuICAgICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBQb3NpdGlvbiB8IHVuZGVmaW5lZD59ICovXG4gICAgICBjb25zdCBwcm9wcyA9IHt9XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIGxldCBrZXlcblxuICAgICAgaWYgKGxvY2F0aW9uLmF0dHJzKSB7XG4gICAgICAgIGZvciAoa2V5IGluIGxvY2F0aW9uLmF0dHJzKSB7XG4gICAgICAgICAgaWYgKG93bi5jYWxsKGxvY2F0aW9uLmF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICBwcm9wc1tmaW5kKHN0YXRlLnNjaGVtYSwga2V5KS5wcm9wZXJ0eV0gPSBwb3NpdGlvbihcbiAgICAgICAgICAgICAgbG9jYXRpb24uYXR0cnNba2V5XVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlLmRhdGEgPSB7XG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYXNzdW1lIG5vdCBgdW5kZWZpbmVkYC5cbiAgICAgICAgICBvcGVuaW5nOiBwb3NpdGlvbihsb2NhdGlvbi5zdGFydFRhZyksXG4gICAgICAgICAgY2xvc2luZzogbG9jYXRpb24uZW5kVGFnID8gcG9zaXRpb24obG9jYXRpb24uZW5kVGFnKSA6IG51bGwsXG4gICAgICAgICAgcHJvcGVydGllczogcHJvcHNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBUdXJuIGEgcDUgbG9jYXRpb24gaW50byBhIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7UDVMb2NhdGlvbn0gbG9jXG4gKiAgIExvY2F0aW9uLlxuICogQHJldHVybnMge1Bvc2l0aW9uIHwgdW5kZWZpbmVkfVxuICogICBQb3NpdGlvbiBvciBub3RoaW5nLlxuICovXG5mdW5jdGlvbiBwb3NpdGlvbihsb2MpIHtcbiAgY29uc3Qgc3RhcnQgPSBwb2ludCh7XG4gICAgbGluZTogbG9jLnN0YXJ0TGluZSxcbiAgICBjb2x1bW46IGxvYy5zdGFydENvbCxcbiAgICBvZmZzZXQ6IGxvYy5zdGFydE9mZnNldFxuICB9KVxuICBjb25zdCBlbmQgPSBwb2ludCh7XG4gICAgbGluZTogbG9jLmVuZExpbmUsXG4gICAgY29sdW1uOiBsb2MuZW5kQ29sLFxuICAgIG9mZnNldDogbG9jLmVuZE9mZnNldFxuICB9KVxuICAvLyBAdHMtZXhwZWN0LWVycm9yIGB1bmRlZmluZWRgIGlzIGZpbmUuXG4gIHJldHVybiBzdGFydCB8fCBlbmQgPyB7c3RhcnQsIGVuZH0gOiB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBGaWx0ZXIgb3V0IGludmFsaWQgcG9pbnRzLlxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gKiAgIFBvaW50IHdpdGggcG90ZW50aWFsbHkgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICogQHJldHVybnMge1BvaW50IHwgdW5kZWZpbmVkfVxuICogICBQb2ludCBvciBub3RoaW5nLlxuICovXG5mdW5jdGlvbiBwb2ludChwb2ludCkge1xuICByZXR1cm4gcG9pbnQubGluZSAmJiBwb2ludC5jb2x1bW4gPyBwb2ludCA6IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIENoZWNrIGlmIHNvbWV0aGluZyBpcyBhIGZpbGUuXG4gKlxuICogQHBhcmFtIHtWRmlsZSB8IE9wdGlvbnN9IHZhbHVlXG4gKiAgIEZpbGUgb3Igb3B0aW9ucy5cbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBWRmlsZX1cbiAqICAgV2hldGhlciBgdmFsdWVgIGlzIGEgZmlsZS5cbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbHVlKSB7XG4gIHJldHVybiAnbWVzc2FnZXMnIGluIHZhbHVlXG59XG4iXSwibmFtZXMiOlsiaCIsInMiLCJodG1sIiwic3ZnIiwiZmluZCIsImxvY2F0aW9uIiwid2ViTmFtZXNwYWNlcyIsIm93biIsImhhc093blByb3BlcnR5IiwicHJvdG8iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJmcm9tUGFyc2U1IiwidHJlZSIsIm9wdGlvbnMiLCJvcHRpb25zXyIsInNldHRpbmdzIiwiZmlsZSIsImlzRmlsZSIsInVuZGVmaW5lZCIsIm9uZSIsInNjaGVtYSIsInNwYWNlIiwidmVyYm9zZSIsInN0YXRlIiwibm9kZSIsInJlc3VsdCIsIm5vZGVOYW1lIiwicmVmZXJlbmNlIiwidHlwZSIsInZhbHVlIiwiZGF0YSIsInBhdGNoIiwicXVpcmtzTW9kZSIsIm1vZGUiLCJjaGlsZHJlbiIsImFsbCIsImNoaWxkTm9kZXMiLCJkb2MiLCJTdHJpbmciLCJsb2MiLCJzdGFydCIsInRvUG9pbnQiLCJlbmQiLCJsZW5ndGgiLCJwb3NpdGlvbiIsImVsZW1lbnQiLCJub2RlcyIsImluZGV4IiwibmFtZXNwYWNlVVJJIiwicHJvcHMiLCJhdHRycyIsImF0dHJpYnV0ZSIsIm5hbWUiLCJwcmVmaXgiLCJjYWxsIiwiZm4iLCJ0YWdOYW1lIiwicG9zIiwic291cmNlQ29kZUxvY2F0aW9uIiwic3RhcnRUYWciLCJlbmRUYWciLCJjb250ZW50IiwiZnJvbSIsInRvIiwiY3JlYXRlTG9jYXRpb24iLCJ0YWlsIiwiYXNzaWduIiwia2V5IiwicHJvcGVydHkiLCJvcGVuaW5nIiwiY2xvc2luZyIsInByb3BlcnRpZXMiLCJwb2ludCIsImxpbmUiLCJzdGFydExpbmUiLCJjb2x1bW4iLCJzdGFydENvbCIsIm9mZnNldCIsInN0YXJ0T2Zmc2V0IiwiZW5kTGluZSIsImVuZENvbCIsImVuZE9mZnNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/hast-util-from-parse5/lib/index.js\n");

/***/ })

};
;