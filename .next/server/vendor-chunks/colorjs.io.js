"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/colorjs.io";
exports.ids = ["vendor-chunks/colorjs.io"];
exports.modules = {

/***/ "(rsc)/./node_modules/colorjs.io/dist/color.js":
/*!***********************************************!*\
  !*** ./node_modules/colorjs.io/dist/color.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Color)\n/* harmony export */ });\n// A is m x n. B is n x p. product is m x p.\nfunction multiplyMatrices(A, B) {\n    let m = A.length;\n    if (!Array.isArray(A[0])) {\n        // A is vector, convert to [[a, b, c, ...]]\n        A = [\n            A\n        ];\n    }\n    if (!Array.isArray(B[0])) {\n        // B is vector, convert to [[a], [b], [c], ...]]\n        B = B.map((x)=>[\n                x\n            ]);\n    }\n    let p = B[0].length;\n    let B_cols = B[0].map((_, i)=>B.map((x)=>x[i])); // transpose B\n    let product = A.map((row)=>B_cols.map((col)=>{\n            let ret = 0;\n            if (!Array.isArray(row)) {\n                for (let c of col){\n                    ret += row * c;\n                }\n                return ret;\n            }\n            for(let i = 0; i < row.length; i++){\n                ret += row[i] * (col[i] || 0);\n            }\n            return ret;\n        }));\n    if (m === 1) {\n        product = product[0]; // Avoid [[a, b, c, ...]]\n    }\n    if (p === 1) {\n        return product.map((x)=>x[0]); // Avoid [[a], [b], [c], ...]]\n    }\n    return product;\n}\n/**\n * Various utility functions\n */ /**\n * Check if a value is a string (including a String object)\n * @param {*} str - Value to check\n * @returns {boolean}\n */ function isString(str) {\n    return type(str) === \"string\";\n}\n/**\n * Determine the internal JavaScript [[Class]] of an object.\n * @param {*} o - Value to check\n * @returns {string}\n */ function type(o) {\n    let str = Object.prototype.toString.call(o);\n    return (str.match(/^\\[object\\s+(.*?)\\]$/)[1] || \"\").toLowerCase();\n}\n/**\n * Round a number to a certain number of significant digits\n * @param {number} n - The number to round\n * @param {number} precision - Number of significant digits\n */ function toPrecision(n, precision) {\n    n = +n;\n    precision = +precision;\n    let integerLength = (Math.floor(n) + \"\").length;\n    if (precision > integerLength) {\n        return +n.toFixed(precision - integerLength);\n    } else {\n        let p10 = 10 ** (integerLength - precision);\n        return Math.round(n / p10) * p10;\n    }\n}\n/**\n* Parse a CSS function, regardless of its name and arguments\n* @param String str String to parse\n* @return {{name, args, rawArgs}}\n*/ function parseFunction(str) {\n    if (!str) {\n        return;\n    }\n    str = str.trim();\n    const isFunctionRegex = /^([a-z]+)\\((.+?)\\)$/i;\n    const isNumberRegex = /^-?[\\d.]+$/;\n    let parts = str.match(isFunctionRegex);\n    if (parts) {\n        // It is a function, parse args\n        let args = [];\n        parts[2].replace(/\\/?\\s*([-\\w.]+(?:%|deg)?)/g, ($0, arg)=>{\n            if (/%$/.test(arg)) {\n                // Convert percentages to 0-1 numbers\n                arg = new Number(arg.slice(0, -1) / 100);\n                arg.type = \"<percentage>\";\n            } else if (/deg$/.test(arg)) {\n                // Drop deg from degrees and convert to number\n                // TODO handle other units too\n                arg = new Number(+arg.slice(0, -3));\n                arg.type = \"<angle>\";\n                arg.unit = \"deg\";\n            } else if (isNumberRegex.test(arg)) {\n                // Convert numerical args to numbers\n                arg = new Number(arg);\n                arg.type = \"<number>\";\n            }\n            if ($0.startsWith(\"/\")) {\n                // It's alpha\n                arg = arg instanceof Number ? arg : new Number(arg);\n                arg.alpha = true;\n            }\n            args.push(arg);\n        });\n        return {\n            name: parts[1].toLowerCase(),\n            rawName: parts[1],\n            rawArgs: parts[2],\n            // An argument could be (as of css-color-4):\n            // a number, percentage, degrees (hue), ident (in color())\n            args\n        };\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction interpolate(start, end, p) {\n    if (isNaN(start)) {\n        return end;\n    }\n    if (isNaN(end)) {\n        return start;\n    }\n    return start + (end - start) * p;\n}\nfunction interpolateInv(start, end, value) {\n    return (value - start) / (end - start);\n}\nfunction mapRange(from, to, value) {\n    return interpolate(to[0], to[1], interpolateInv(from[0], from[1], value));\n}\nfunction parseCoordGrammar(coordGrammars) {\n    return coordGrammars.map((coordGrammar)=>{\n        return coordGrammar.split(\"|\").map((type)=>{\n            type = type.trim();\n            let range = type.match(/^(<[a-z]+>)\\[(-?[.\\d]+),\\s*(-?[.\\d]+)\\]?$/);\n            if (range) {\n                let ret = new String(range[1]);\n                ret.range = [\n                    +range[2],\n                    +range[3]\n                ];\n                return ret;\n            }\n            return type;\n        });\n    });\n}\nvar util = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    interpolate: interpolate,\n    interpolateInv: interpolateInv,\n    isString: isString,\n    last: last,\n    mapRange: mapRange,\n    multiplyMatrices: multiplyMatrices,\n    parseCoordGrammar: parseCoordGrammar,\n    parseFunction: parseFunction,\n    toPrecision: toPrecision,\n    type: type\n});\n/**\n * A class for adding deep extensibility to any piece of JS code\n */ class Hooks {\n    add(name, callback, first) {\n        if (typeof arguments[0] != \"string\") {\n            // Multiple hooks\n            for(var name in arguments[0]){\n                this.add(name, arguments[0][name], arguments[1]);\n            }\n            return;\n        }\n        (Array.isArray(name) ? name : [\n            name\n        ]).forEach(function(name) {\n            this[name] = this[name] || [];\n            if (callback) {\n                this[name][first ? \"unshift\" : \"push\"](callback);\n            }\n        }, this);\n    }\n    run(name, env) {\n        this[name] = this[name] || [];\n        this[name].forEach(function(callback) {\n            callback.call(env && env.context ? env.context : env, env);\n        });\n    }\n}\n/**\n * The instance of {@link Hooks} used throughout Color.js\n */ const hooks = new Hooks();\n// Global defaults one may want to configure\nvar defaults = {\n    gamut_mapping: \"lch.c\",\n    precision: 5,\n    deltaE: \"76\"\n};\nconst WHITES = {\n    // for compatibility, the four-digit chromaticity-derived ones everyone else uses\n    D50: [\n        0.3457 / 0.3585,\n        1.00000,\n        (1.0 - 0.3457 - 0.3585) / 0.3585\n    ],\n    D65: [\n        0.3127 / 0.3290,\n        1.00000,\n        (1.0 - 0.3127 - 0.3290) / 0.3290\n    ]\n};\nfunction getWhite(name) {\n    if (Array.isArray(name)) {\n        return name;\n    }\n    return WHITES[name];\n}\n// Adapt XYZ from white point W1 to W2\nfunction adapt$1(W1, W2, XYZ, options = {}) {\n    W1 = getWhite(W1);\n    W2 = getWhite(W2);\n    if (!W1 || !W2) {\n        throw new TypeError(`Missing white point to convert ${!W1 ? \"from\" : \"\"}${!W1 && !W2 ? \"/\" : \"\"}${!W2 ? \"to\" : \"\"}`);\n    }\n    if (W1 === W2) {\n        // Same whitepoints, no conversion needed\n        return XYZ;\n    }\n    let env = {\n        W1,\n        W2,\n        XYZ,\n        options\n    };\n    hooks.run(\"chromatic-adaptation-start\", env);\n    if (!env.M) {\n        if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {\n            env.M = [\n                [\n                    1.0479298208405488,\n                    0.022946793341019088,\n                    -0.05019222954313557\n                ],\n                [\n                    0.029627815688159344,\n                    0.990434484573249,\n                    -0.01707382502938514\n                ],\n                [\n                    -0.009243058152591178,\n                    0.015055144896577895,\n                    0.7518742899580008\n                ]\n            ];\n        } else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {\n            env.M = [\n                [\n                    0.9554734527042182,\n                    -0.023098536874261423,\n                    0.0632593086610217\n                ],\n                [\n                    -0.028369706963208136,\n                    1.0099954580058226,\n                    0.021041398966943008\n                ],\n                [\n                    0.012314001688319899,\n                    -0.020507696433477912,\n                    1.3303659366080753\n                ]\n            ];\n        }\n    }\n    hooks.run(\"chromatic-adaptation-end\", env);\n    if (env.M) {\n        return multiplyMatrices(env.M, env.XYZ);\n    } else {\n        throw new TypeError(\"Only Bradford CAT with white points D50 and D65 supported for now.\");\n    }\n}\nconst ε$4 = .000075;\n/**\n * Class to represent a color space\n */ class ColorSpace {\n    constructor(options){\n        this.id = options.id;\n        this.name = options.name;\n        this.base = options.base ? ColorSpace.get(options.base) : null;\n        this.aliases = options.aliases;\n        if (this.base) {\n            this.fromBase = options.fromBase;\n            this.toBase = options.toBase;\n        }\n        // Coordinate metadata\n        let coords = options.coords ?? this.base.coords;\n        for(let name in coords){\n            if (!(\"name\" in coords[name])) {\n                coords[name].name = name;\n            }\n        }\n        this.coords = coords;\n        // White point\n        let white = options.white ?? this.base.white ?? \"D65\";\n        this.white = getWhite(white);\n        // Sort out formats\n        this.formats = options.formats ?? {};\n        for(let name in this.formats){\n            let format = this.formats[name];\n            format.type ||= \"function\";\n            format.name ||= name;\n        }\n        if (options.cssId && !this.formats.functions?.color) {\n            this.formats.color = {\n                id: options.cssId\n            };\n            Object.defineProperty(this, \"cssId\", {\n                value: options.cssId\n            });\n        } else if (this.formats?.color && !this.formats?.color.id) {\n            this.formats.color.id = this.id;\n        }\n        // Other stuff\n        this.referred = options.referred;\n        // Compute ancestors and store them, since they will never change\n        Object.defineProperty(this, \"path\", {\n            value: getPath(this).reverse(),\n            writable: false,\n            enumerable: true,\n            configurable: true\n        });\n        hooks.run(\"colorspace-init-end\", this);\n    }\n    inGamut(coords, { epsilon = ε$4 } = {}) {\n        if (this.isPolar) {\n            // Do not check gamut through polar coordinates\n            coords = this.toBase(coords);\n            return this.base.inGamut(coords, {\n                epsilon\n            });\n        }\n        let coordMeta = Object.values(this.coords);\n        return coords.every((c, i)=>{\n            let meta = coordMeta[i];\n            if (meta.type !== \"angle\" && meta.range) {\n                if (Number.isNaN(c)) {\n                    // NaN is always in gamut\n                    return true;\n                }\n                let [min, max] = meta.range;\n                return (min === undefined || c >= min - epsilon) && (max === undefined || c <= max + epsilon);\n            }\n            return true;\n        });\n    }\n    get cssId() {\n        return this.formats.functions?.color?.id || this.id;\n    }\n    get isPolar() {\n        for(let id in this.coords){\n            if (this.coords[id].type === \"angle\") {\n                return true;\n            }\n        }\n        return false;\n    }\n    getFormat(format) {\n        if (typeof format === \"object\") {\n            format = processFormat(format, this);\n            return format;\n        }\n        let ret;\n        if (format === \"default\") {\n            // Get first format\n            ret = Object.values(this.formats)[0];\n        } else {\n            ret = this.formats[format];\n        }\n        if (ret) {\n            ret = processFormat(ret, this);\n            return ret;\n        }\n        return null;\n    }\n    // We cannot rely on simple === because then ColorSpace objects cannot be proxied\n    equals(space) {\n        if (!space) {\n            return false;\n        }\n        return this === space || this.id === space.id;\n    }\n    to(space, coords) {\n        if (arguments.length === 1) {\n            [space, coords] = [\n                space.space,\n                space.coords\n            ];\n        }\n        space = ColorSpace.get(space);\n        if (this.equals(space)) {\n            // Same space, no change needed\n            return coords;\n        }\n        // Convert NaN to 0, which seems to be valid in every coordinate of every color space\n        coords = coords.map((c)=>Number.isNaN(c) ? 0 : c);\n        // Find connection space = lowest common ancestor in the base tree\n        let myPath = this.path;\n        let otherPath = space.path;\n        let connectionSpace, connectionSpaceIndex;\n        for(let i = 0; i < myPath.length; i++){\n            if (myPath[i].equals(otherPath[i])) {\n                connectionSpace = myPath[i];\n                connectionSpaceIndex = i;\n            } else {\n                break;\n            }\n        }\n        if (!connectionSpace) {\n            // This should never happen\n            throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);\n        }\n        // Go up from current space to connection space\n        for(let i = myPath.length - 1; i > connectionSpaceIndex; i--){\n            coords = myPath[i].toBase(coords);\n        }\n        // Go down from connection space to target space\n        for(let i = connectionSpaceIndex + 1; i < otherPath.length; i++){\n            coords = otherPath[i].fromBase(coords);\n        }\n        return coords;\n    }\n    from(space, coords) {\n        if (arguments.length === 1) {\n            [space, coords] = [\n                space.space,\n                space.coords\n            ];\n        }\n        space = ColorSpace.get(space);\n        return space.to(this, coords);\n    }\n    toString() {\n        return `${this.name} (${this.id})`;\n    }\n    getMinCoords() {\n        let ret = [];\n        for(let id in this.coords){\n            let meta = this.coords[id];\n            let range = meta.range || meta.refRange;\n            ret.push(range?.min ?? 0);\n        }\n        return ret;\n    }\n    static{\n        this.registry = {};\n    }\n    // Returns array of unique color spaces\n    static get all() {\n        return [\n            ...new Set(Object.values(ColorSpace.registry))\n        ];\n    }\n    static register(id, space) {\n        if (arguments.length === 1) {\n            space = arguments[0];\n            id = space.id;\n        }\n        space = this.get(space);\n        if (this.registry[id] && this.registry[id] !== space) {\n            throw new Error(`Duplicate color space registration: '${id}'`);\n        }\n        this.registry[id] = space;\n        // Register aliases when called without an explicit ID.\n        if (arguments.length === 1 && space.aliases) {\n            for (let alias of space.aliases){\n                this.register(alias, space);\n            }\n        }\n        return space;\n    }\n    /**\n\t * Lookup ColorSpace object by name\n\t * @param {ColorSpace | string} name\n\t */ static get(space, ...alternatives) {\n        if (!space || space instanceof ColorSpace) {\n            return space;\n        }\n        let argType = type(space);\n        if (argType === \"string\") {\n            // It's a color space id\n            let ret = ColorSpace.registry[space.toLowerCase()];\n            if (!ret) {\n                throw new TypeError(`No color space found with id = \"${space}\"`);\n            }\n            return ret;\n        }\n        if (alternatives.length) {\n            return ColorSpace.get(...alternatives);\n        }\n        throw new TypeError(`${space} is not a valid color space`);\n    }\n    /**\n\t * Get metadata about a coordinate of a color space\n\t *\n\t * @static\n\t * @param {Array | string} ref\n\t * @param {ColorSpace | string} [workingSpace]\n\t * @return {Object}\n\t */ static resolveCoord(ref, workingSpace) {\n        let coordType = type(ref);\n        let space, coord;\n        if (coordType === \"string\") {\n            if (ref.includes(\".\")) {\n                // Absolute coordinate\n                [space, coord] = ref.split(\".\");\n            } else {\n                // Relative coordinate\n                [space, coord] = [\n                    ,\n                    ref\n                ];\n            }\n        } else if (Array.isArray(ref)) {\n            [space, coord] = ref;\n        } else {\n            // Object\n            space = ref.space;\n            coord = ref.coordId;\n        }\n        space = ColorSpace.get(space);\n        if (!space) {\n            space = workingSpace;\n        }\n        if (!space) {\n            throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);\n        }\n        coordType = type(coord);\n        if (coordType === \"number\" || coordType === \"string\" && coord >= 0) {\n            // Resolve numerical coord\n            let meta = Object.entries(space.coords)[coord];\n            if (meta) {\n                return {\n                    space,\n                    id: meta[0],\n                    index: coord,\n                    ...meta[1]\n                };\n            }\n        }\n        space = ColorSpace.get(space);\n        let normalizedCoord = coord.toLowerCase();\n        let i = 0;\n        for(let id in space.coords){\n            let meta = space.coords[id];\n            if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {\n                return {\n                    space,\n                    id,\n                    index: i,\n                    ...meta\n                };\n            }\n            i++;\n        }\n        throw new TypeError(`No \"${coord}\" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(\", \")}`);\n    }\n    static{\n        this.DEFAULT_FORMAT = {\n            type: \"functions\",\n            name: \"color\"\n        };\n    }\n}\nfunction getPath(space) {\n    let ret = [\n        space\n    ];\n    for(let s = space; s = s.base;){\n        ret.push(s);\n    }\n    return ret;\n}\nfunction processFormat(format, { coords } = {}) {\n    if (format.coords && !format.coordGrammar) {\n        format.type ||= \"function\";\n        format.name ||= \"color\";\n        // Format has not been processed\n        format.coordGrammar = parseCoordGrammar(format.coords);\n        let coordFormats = Object.entries(coords).map(([id, coordMeta], i)=>{\n            // Preferred format for each coord is the first one\n            let outputType = format.coordGrammar[i][0];\n            let fromRange = coordMeta.range || coordMeta.refRange;\n            let toRange = outputType.range, suffix = \"\";\n            // Non-strict equals intentional since outputType could be a string object\n            if (outputType == \"<percentage>\") {\n                toRange = [\n                    0,\n                    100\n                ];\n                suffix = \"%\";\n            } else if (outputType == \"<angle>\") {\n                suffix = \"deg\";\n            }\n            return {\n                fromRange,\n                toRange,\n                suffix\n            };\n        });\n        format.serializeCoords = (coords, precision)=>{\n            return coords.map((c, i)=>{\n                let { fromRange, toRange, suffix } = coordFormats[i];\n                if (fromRange && toRange) {\n                    c = mapRange(fromRange, toRange, c);\n                }\n                c = toPrecision(c, precision);\n                if (suffix) {\n                    c += suffix;\n                }\n                return c;\n            });\n        };\n    }\n    return format;\n}\nvar XYZ_D65 = new ColorSpace({\n    id: \"xyz-d65\",\n    name: \"XYZ D65\",\n    coords: {\n        x: {\n            name: \"X\"\n        },\n        y: {\n            name: \"Y\"\n        },\n        z: {\n            name: \"Z\"\n        }\n    },\n    white: \"D65\",\n    formats: {\n        color: {\n            ids: [\n                \"xyz-d65\",\n                \"xyz\"\n            ]\n        }\n    },\n    aliases: [\n        \"xyz\"\n    ]\n});\n/**\n * Convenience class for RGB color spaces\n * @extends {ColorSpace}\n */ class RGBColorSpace extends ColorSpace {\n    /**\n\t * Creates a new RGB ColorSpace.\n\t * If coords are not specified, they will use the default RGB coords.\n\t * Instead of `fromBase()` and `toBase()` functions,\n\t * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.\n\t * @param {*} options - Same options as {@link ColorSpace} plus:\n\t * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ\n\t * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ\n\t */ constructor(options){\n        if (!options.coords) {\n            options.coords = {\n                r: {\n                    range: [\n                        0,\n                        1\n                    ],\n                    name: \"Red\"\n                },\n                g: {\n                    range: [\n                        0,\n                        1\n                    ],\n                    name: \"Green\"\n                },\n                b: {\n                    range: [\n                        0,\n                        1\n                    ],\n                    name: \"Blue\"\n                }\n            };\n        }\n        if (!options.base) {\n            options.base = XYZ_D65;\n        }\n        if (options.toXYZ_M && options.fromXYZ_M) {\n            options.toBase ??= (rgb)=>{\n                let xyz = multiplyMatrices(options.toXYZ_M, rgb);\n                if (this.white !== this.base.white) {\n                    // Perform chromatic adaptation\n                    xyz = adapt$1(this.white, this.base.white, xyz);\n                }\n                return xyz;\n            };\n            options.fromBase ??= (xyz)=>{\n                xyz = adapt$1(this.base.white, this.white, xyz);\n                return multiplyMatrices(options.fromXYZ_M, xyz);\n            };\n        }\n        options.referred ??= \"display\";\n        super(options);\n    }\n}\n/**\n * Convert a CSS Color string to a color object\n * @param {string} str\n * @param {object} [options]\n * @param {object} [options.meta] - Object for additional information about the parsing\n * @returns { Color }\n */ function parse(str, { meta } = {}) {\n    let env = {\n        \"str\": String(str)?.trim()\n    };\n    hooks.run(\"parse-start\", env);\n    if (env.color) {\n        return env.color;\n    }\n    env.parsed = parseFunction(env.str);\n    if (env.parsed) {\n        // Is a functional syntax\n        let name = env.parsed.name;\n        if (name === \"color\") {\n            // color() function\n            let id = env.parsed.args.shift();\n            let alpha = env.parsed.rawArgs.indexOf(\"/\") > 0 ? env.parsed.args.pop() : 1;\n            for (let space of ColorSpace.all){\n                let colorSpec = space.getFormat(\"color\");\n                if (colorSpec) {\n                    if (id === colorSpec.id || colorSpec.ids?.includes(id)) {\n                        // From https://drafts.csswg.org/css-color-4/#color-function\n                        // If more <number>s or <percentage>s are provided than parameters that the colorspace takes, the excess <number>s at the end are ignored.\n                        // If less <number>s or <percentage>s are provided than parameters that the colorspace takes, the missing parameters default to 0. (This is particularly convenient for multichannel printers where the additional inks are spot colors or varnishes that most colors on the page won’t use.)\n                        const coords = Object.keys(space.coords).map((_, i)=>env.parsed.args[i] || 0);\n                        if (meta) {\n                            meta.formatId = \"color\";\n                        }\n                        return {\n                            spaceId: space.id,\n                            coords,\n                            alpha\n                        };\n                    }\n                }\n            }\n            // Not found\n            let didYouMean = \"\";\n            if (id in ColorSpace.registry) {\n                // Used color space id instead of color() id, these are often different\n                let cssId = ColorSpace.registry[id].formats?.functions?.color?.id;\n                if (cssId) {\n                    didYouMean = `Did you mean color(${cssId})?`;\n                }\n            }\n            throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || \"Missing a plugin?\"));\n        } else {\n            for (let space of ColorSpace.all){\n                // color space specific function\n                let format = space.getFormat(name);\n                if (format && format.type === \"function\") {\n                    let alpha = 1;\n                    if (format.lastAlpha || last(env.parsed.args).alpha) {\n                        alpha = env.parsed.args.pop();\n                    }\n                    let coords = env.parsed.args;\n                    let types;\n                    if (format.coordGrammar) {\n                        types = Object.entries(space.coords).map(([id, coordMeta], i)=>{\n                            let coordGrammar = format.coordGrammar[i];\n                            let providedType = coords[i]?.type;\n                            // Find grammar alternative that matches the provided type\n                            // Non-strict equals is intentional because we are comparing w/ string objects\n                            let type = coordGrammar.find((c)=>c == providedType);\n                            // Check that each coord conforms to its grammar\n                            if (!type) {\n                                // Type does not exist in the grammar, throw\n                                let coordName = coordMeta.name || id;\n                                throw new TypeError(`${providedType} not allowed for ${coordName} in ${name}()`);\n                            }\n                            let fromRange = type.range;\n                            if (providedType === \"<percentage>\") {\n                                fromRange ||= [\n                                    0,\n                                    1\n                                ];\n                            }\n                            let toRange = coordMeta.range || coordMeta.refRange;\n                            if (fromRange && toRange) {\n                                coords[i] = mapRange(fromRange, toRange, coords[i]);\n                            }\n                            return type;\n                        });\n                    }\n                    if (meta) {\n                        Object.assign(meta, {\n                            formatId: format.name,\n                            types\n                        });\n                    }\n                    return {\n                        spaceId: space.id,\n                        coords,\n                        alpha\n                    };\n                }\n            }\n        }\n    } else {\n        // Custom, colorspace-specific format\n        for (let space of ColorSpace.all){\n            for(let formatId in space.formats){\n                let format = space.formats[formatId];\n                if (format.type !== \"custom\") {\n                    continue;\n                }\n                if (format.test && !format.test(env.str)) {\n                    continue;\n                }\n                let color = format.parse(env.str);\n                if (color) {\n                    color.alpha ??= 1;\n                    if (meta) {\n                        meta.formatId = formatId;\n                    }\n                    return color;\n                }\n            }\n        }\n    }\n    // If we're here, we couldn't parse\n    throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);\n}\n/**\n * Resolves a color reference (object or string) to a plain color object\n * @param {Color | {space, coords, alpha} | string} color\n * @returns {{space, coords, alpha}}\n */ function getColor(color) {\n    if (!color) {\n        throw new TypeError(\"Empty color reference\");\n    }\n    if (isString(color)) {\n        color = parse(color);\n    }\n    // Object fixup\n    let space = color.space || color.spaceId;\n    if (!(space instanceof ColorSpace)) {\n        // Convert string id to color space object\n        color.space = ColorSpace.get(space);\n    }\n    if (color.alpha === undefined) {\n        color.alpha = 1;\n    }\n    return color;\n}\n/**\n * Get the coordinates of a color in another color space\n *\n * @param {string | ColorSpace} space\n * @returns {number[]}\n */ function getAll(color, space) {\n    space = ColorSpace.get(space);\n    return space.from(color);\n}\nfunction get(color, prop) {\n    let { space, index } = ColorSpace.resolveCoord(prop, color.space);\n    let coords = getAll(color, space);\n    return coords[index];\n}\nfunction setAll(color, space, coords) {\n    space = ColorSpace.get(space);\n    color.coords = space.to(color.space, coords);\n    return color;\n}\n// Set properties and return current instance\nfunction set(color, prop, value) {\n    color = getColor(color);\n    if (arguments.length === 2 && type(arguments[1]) === \"object\") {\n        // Argument is an object literal\n        let object = arguments[1];\n        for(let p in object){\n            set(color, p, object[p]);\n        }\n    } else {\n        if (typeof value === \"function\") {\n            value = value(get(color, prop));\n        }\n        let { space, index } = ColorSpace.resolveCoord(prop, color.space);\n        let coords = getAll(color, space);\n        coords[index] = value;\n        setAll(color, space, coords);\n    }\n    return color;\n}\nvar XYZ_D50 = new ColorSpace({\n    id: \"xyz-d50\",\n    name: \"XYZ D50\",\n    white: \"D50\",\n    base: XYZ_D65,\n    fromBase: (coords)=>adapt$1(XYZ_D65.white, \"D50\", coords),\n    toBase: (coords)=>adapt$1(\"D50\", XYZ_D65.white, coords),\n    formats: {\n        color: {}\n    }\n});\n// κ * ε  = 2^3 = 8\nconst ε$3 = 216 / 24389; // 6^3/29^3 == (24/116)^3\nconst ε3$1 = 24 / 116;\nconst κ$1 = 24389 / 27; // 29^3/3^3\nlet white$1 = WHITES.D50;\nvar lab = new ColorSpace({\n    id: \"lab\",\n    name: \"Lab\",\n    coords: {\n        l: {\n            refRange: [\n                0,\n                100\n            ],\n            name: \"L\"\n        },\n        a: {\n            refRange: [\n                -125,\n                125\n            ]\n        },\n        b: {\n            refRange: [\n                -125,\n                125\n            ]\n        }\n    },\n    // Assuming XYZ is relative to D50, convert to CIE Lab\n    // from CIE standard, which now defines these as a rational fraction\n    white: white$1,\n    base: XYZ_D50,\n    // Convert D50-adapted XYX to Lab\n    //  CIE 15.3:2004 section 8.2.1.1\n    fromBase (XYZ) {\n        // compute xyz, which is XYZ scaled relative to reference white\n        let xyz = XYZ.map((value, i)=>value / white$1[i]);\n        // now compute f\n        let f = xyz.map((value)=>value > ε$3 ? Math.cbrt(value) : (κ$1 * value + 16) / 116);\n        return [\n            116 * f[1] - 16,\n            500 * (f[0] - f[1]),\n            200 * (f[1] - f[2] // b\n            )\n        ];\n    },\n    // Convert Lab to D50-adapted XYZ\n    // Same result as CIE 15.3:2004 Appendix D although the derivation is different\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    toBase (Lab) {\n        // compute f, starting with the luminance-related term\n        let f = [];\n        f[1] = (Lab[0] + 16) / 116;\n        f[0] = Lab[1] / 500 + f[1];\n        f[2] = f[1] - Lab[2] / 200;\n        // compute xyz\n        let xyz = [\n            f[0] > ε3$1 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ$1,\n            Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ$1,\n            f[2] > ε3$1 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ$1\n        ];\n        // Compute XYZ by scaling xyz by reference white\n        return xyz.map((value, i)=>value * white$1[i]);\n    },\n    formats: {\n        \"lab\": {\n            coords: [\n                \"<number> | <percentage>\",\n                \"<number> | <percentage>[-1,1]\",\n                \"<number> | <percentage>[-1,1]\"\n            ]\n        }\n    }\n});\nfunction constrain(angle) {\n    return (angle % 360 + 360) % 360;\n}\nfunction adjust(arc, angles) {\n    if (arc === \"raw\") {\n        return angles;\n    }\n    let [a1, a2] = angles.map(constrain);\n    let angleDiff = a2 - a1;\n    if (arc === \"increasing\") {\n        if (angleDiff < 0) {\n            a2 += 360;\n        }\n    } else if (arc === \"decreasing\") {\n        if (angleDiff > 0) {\n            a1 += 360;\n        }\n    } else if (arc === \"longer\") {\n        if (-180 < angleDiff && angleDiff < 180) {\n            if (angleDiff > 0) {\n                a1 += 360;\n            } else {\n                a2 += 360;\n            }\n        }\n    } else if (arc === \"shorter\") {\n        if (angleDiff > 180) {\n            a1 += 360;\n        } else if (angleDiff < -180) {\n            a2 += 360;\n        }\n    }\n    return [\n        a1,\n        a2\n    ];\n}\nvar lch = new ColorSpace({\n    id: \"lch\",\n    name: \"LCH\",\n    coords: {\n        l: {\n            refRange: [\n                0,\n                100\n            ],\n            name: \"Lightness\"\n        },\n        c: {\n            refRange: [\n                0,\n                150\n            ],\n            name: \"Chroma\"\n        },\n        h: {\n            refRange: [\n                0,\n                360\n            ],\n            type: \"angle\",\n            name: \"Hue\"\n        }\n    },\n    base: lab,\n    fromBase (Lab) {\n        // Convert to polar form\n        let [L, a, b] = Lab;\n        let hue;\n        const ε = 0.02;\n        if (Math.abs(a) < ε && Math.abs(b) < ε) {\n            hue = NaN;\n        } else {\n            hue = Math.atan2(b, a) * 180 / Math.PI;\n        }\n        return [\n            L,\n            Math.sqrt(a ** 2 + b ** 2),\n            constrain(hue) // Hue, in degrees [0 to 360)\n        ];\n    },\n    toBase (LCH) {\n        // Convert from polar form\n        let [Lightness, Chroma, Hue] = LCH;\n        // Clamp any negative Chroma\n        if (Chroma < 0) {\n            Chroma = 0;\n        } // Deal with NaN Hue\n        if (isNaN(Hue)) {\n            Hue = 0;\n        }\n        return [\n            Lightness,\n            Chroma * Math.cos(Hue * Math.PI / 180),\n            Chroma * Math.sin(Hue * Math.PI / 180) // b\n        ];\n    },\n    formats: {\n        \"lch\": {\n            coords: [\n                \"<number> | <percentage>\",\n                \"<number> | <percentage>\",\n                \"<number> | <angle>\"\n            ]\n        }\n    }\n});\n// deltaE2000 is a statistically significant improvement\n// and is recommended by the CIE and Idealliance\n// especially for color differences less than 10 deltaE76\n// but is wicked complicated\n// and many implementations have small errors!\n// DeltaE2000 is also discontinuous; in case this\n// matters to you, use deltaECMC instead.\nconst Gfactor = 25 ** 7;\nconst π$1 = Math.PI;\nconst r2d = 180 / π$1;\nconst d2r$1 = π$1 / 180;\nfunction deltaE2000(color, sample, { kL = 1, kC = 1, kH = 1 } = {}) {\n    // Given this color as the reference\n    // and the function parameter as the sample,\n    // calculate deltaE 2000.\n    // This implementation assumes the parametric\n    // weighting factors kL, kC and kH\n    // for the influence of viewing conditions\n    // are all 1, as sadly seems typical.\n    // kL should be increased for lightness texture or noise\n    // and kC increased for chroma noise\n    let [L1, a1, b1] = lab.from(color);\n    let C1 = lch.from(lab, [\n        L1,\n        a1,\n        b1\n    ])[1];\n    let [L2, a2, b2] = lab.from(sample);\n    let C2 = lch.from(lab, [\n        L2,\n        a2,\n        b2\n    ])[1];\n    // Check for negative Chroma,\n    // which might happen through\n    // direct user input of LCH values\n    if (C1 < 0) {\n        C1 = 0;\n    }\n    if (C2 < 0) {\n        C2 = 0;\n    }\n    let Cbar = (C1 + C2) / 2; // mean Chroma\n    // calculate a-axis asymmetry factor from mean Chroma\n    // this turns JND ellipses for near-neutral colors back into circles\n    let C7 = Cbar ** 7;\n    let G = 0.5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));\n    // scale a axes by asymmetry factor\n    // this by the way is why there is no Lab2000 colorspace\n    let adash1 = (1 + G) * a1;\n    let adash2 = (1 + G) * a2;\n    // calculate new Chroma from scaled a and original b axes\n    let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);\n    let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);\n    // calculate new hues, with zero hue for true neutrals\n    // and in degrees, not radians\n    let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);\n    let h2 = adash2 === 0 && b2 === 0 ? 0 : Math.atan2(b2, adash2);\n    if (h1 < 0) {\n        h1 += 2 * π$1;\n    }\n    if (h2 < 0) {\n        h2 += 2 * π$1;\n    }\n    h1 *= r2d;\n    h2 *= r2d;\n    // Lightness and Chroma differences; sign matters\n    let ΔL = L2 - L1;\n    let ΔC = Cdash2 - Cdash1;\n    // Hue difference, getting the sign correct\n    let hdiff = h2 - h1;\n    let hsum = h1 + h2;\n    let habs = Math.abs(hdiff);\n    let Δh;\n    if (Cdash1 * Cdash2 === 0) {\n        Δh = 0;\n    } else if (habs <= 180) {\n        Δh = hdiff;\n    } else if (hdiff > 180) {\n        Δh = hdiff - 360;\n    } else if (hdiff < -180) {\n        Δh = hdiff + 360;\n    } else {\n        console.log(\"the unthinkable has happened\");\n    }\n    // weighted Hue difference, more for larger Chroma\n    let ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r$1 / 2);\n    // calculate mean Lightness and Chroma\n    let Ldash = (L1 + L2) / 2;\n    let Cdash = (Cdash1 + Cdash2) / 2;\n    let Cdash7 = Math.pow(Cdash, 7);\n    // Compensate for non-linearity in the blue region of Lab.\n    // Four possibilities for hue weighting factor,\n    // depending on the angles, to get the correct sign\n    let hdash;\n    if (Cdash1 * Cdash2 === 0) {\n        hdash = hsum; // which should be zero\n    } else if (habs <= 180) {\n        hdash = hsum / 2;\n    } else if (hsum < 360) {\n        hdash = (hsum + 360) / 2;\n    } else {\n        hdash = (hsum - 360) / 2;\n    }\n    // positional corrections to the lack of uniformity of CIELAB\n    // These are all trying to make JND ellipsoids more like spheres\n    // SL Lightness crispening factor\n    // a background with L=50 is assumed\n    let lsq = (Ldash - 50) ** 2;\n    let SL = 1 + 0.015 * lsq / Math.sqrt(20 + lsq);\n    // SC Chroma factor, similar to those in CMC and deltaE 94 formulae\n    let SC = 1 + 0.045 * Cdash;\n    // Cross term T for blue non-linearity\n    let T = 1;\n    T -= 0.17 * Math.cos((hdash - 30) * d2r$1);\n    T += 0.24 * Math.cos(2 * hdash * d2r$1);\n    T += 0.32 * Math.cos((3 * hdash + 6) * d2r$1);\n    T -= 0.20 * Math.cos((4 * hdash - 63) * d2r$1);\n    // SH Hue factor depends on Chroma,\n    // as well as adjusted hue angle like deltaE94.\n    let SH = 1 + 0.015 * Cdash * T;\n    // RT Hue rotation term compensates for rotation of JND ellipses\n    // and Munsell constant hue lines\n    // in the medium-high Chroma blue region\n    // (Hue 225 to 315)\n    let Δθ = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);\n    let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));\n    let RT = -1 * Math.sin(2 * Δθ * d2r$1) * RC;\n    // Finally calculate the deltaE, term by term as root sume of squares\n    let dE = (ΔL / (kL * SL)) ** 2;\n    dE += (ΔC / (kC * SC)) ** 2;\n    dE += (ΔH / (kH * SH)) ** 2;\n    dE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));\n    return Math.sqrt(dE);\n// Yay!!!\n}\nconst ε$2 = .000075;\n/**\n * Check if a color is in gamut of either its own or another color space\n * @return {Boolean} Is the color in gamut?\n */ function inGamut(color, space = color.space, { epsilon = ε$2 } = {}) {\n    color = getColor(color);\n    space = ColorSpace.get(space);\n    let coords = color.coords;\n    if (space !== color.space) {\n        coords = space.from(color);\n    }\n    return space.inGamut(coords, {\n        epsilon\n    });\n}\nfunction clone(color) {\n    return {\n        space: color.space,\n        coords: color.coords.slice(),\n        alpha: color.alpha\n    };\n}\n/**\n * Force coordinates to be in gamut of a certain color space.\n * Mutates the color it is passed.\n * @param {Object} options\n * @param {string} options.method - How to force into gamut.\n *        If \"clip\", coordinates are just clipped to their reference range.\n *        If in the form [colorSpaceId].[coordName], that coordinate is reduced\n *        until the color is in gamut. Please note that this may produce nonsensical\n *        results for certain coordinates (e.g. hue) or infinite loops if reducing the coordinate never brings the color in gamut.\n * @param {ColorSpace|string} options.space - The space whose gamut we want to map to\n */ function toGamut(color, { method = defaults.gamut_mapping, space = color.space } = {}) {\n    if (isString(arguments[1])) {\n        space = arguments[1];\n    }\n    space = ColorSpace.get(space);\n    if (inGamut(color, space, {\n        epsilon: 0\n    })) {\n        return getColor(color);\n    }\n    // 3 spaces:\n    // color.space: current color space\n    // space: space whose gamut we are mapping to\n    // mapSpace: space with the coord we're reducing\n    let spaceColor = to(color, space);\n    if (method !== \"clip\" && !inGamut(color, space)) {\n        let clipped = toGamut(clone(spaceColor), {\n            method: \"clip\",\n            space\n        });\n        if (deltaE2000(color, clipped) > 2) {\n            // Reduce a coordinate of a certain color space until the color is in gamut\n            let coordMeta = ColorSpace.resolveCoord(method);\n            let mapSpace = coordMeta.space;\n            let coordId = coordMeta.id;\n            let mappedColor = to(spaceColor, mapSpace);\n            let bounds = coordMeta.range || coordMeta.refRange;\n            let min = bounds[0];\n            let ε = .01; // for deltaE\n            let low = min;\n            let high = get(mappedColor, coordId);\n            while(high - low > ε){\n                let clipped = clone(mappedColor);\n                clipped = toGamut(clipped, {\n                    space,\n                    method: \"clip\"\n                });\n                let deltaE = deltaE2000(mappedColor, clipped);\n                if (deltaE - 2 < ε) {\n                    low = get(mappedColor, coordId);\n                } else {\n                    high = get(mappedColor, coordId);\n                }\n                set(mappedColor, coordId, (low + high) / 2);\n            }\n            spaceColor = to(mappedColor, space);\n        } else {\n            spaceColor = clipped;\n        }\n    }\n    if (method === \"clip\" // Dumb coord clipping\n     || !inGamut(spaceColor, space, {\n        epsilon: 0\n    })) {\n        let bounds = Object.values(space.coords).map((c)=>c.range || []);\n        spaceColor.coords = spaceColor.coords.map((c, i)=>{\n            let [min, max] = bounds[i];\n            if (min !== undefined) {\n                c = Math.max(min, c);\n            }\n            if (max !== undefined) {\n                c = Math.min(c, max);\n            }\n            return c;\n        });\n    }\n    if (space !== color.space) {\n        spaceColor = to(spaceColor, color.space);\n    }\n    color.coords = spaceColor.coords;\n    return color;\n}\ntoGamut.returns = \"color\";\n/**\n * Convert to color space and return a new color\n * @param {Object|string} space - Color space object or id\n * @param {Object} options\n * @param {boolean} options.inGamut - Whether to force resulting color in gamut\n * @returns {Color}\n */ function to(color, space, { inGamut } = {}) {\n    color = getColor(color);\n    space = ColorSpace.get(space);\n    let coords = space.from(color);\n    let ret = {\n        space,\n        coords,\n        alpha: color.alpha\n    };\n    if (inGamut) {\n        ret = toGamut(ret);\n    }\n    return ret;\n}\nto.returns = \"color\";\n/**\n * Generic toString() method, outputs a color(spaceId ...coords) function, a functional syntax, or custom formats defined by the color space\n * @param {Object} options\n * @param {number} options.precision - Significant digits\n * @param {boolean} options.inGamut - Adjust coordinates to fit in gamut first? [default: false]\n */ function serialize(color, { precision = defaults.precision, format = \"default\", inGamut: inGamut$1 = true, ...customOptions } = {}) {\n    let ret;\n    color = getColor(color);\n    let formatId = format;\n    format = color.space.getFormat(format) ?? color.space.getFormat(\"default\") ?? ColorSpace.DEFAULT_FORMAT;\n    inGamut$1 ||= format.toGamut;\n    let coords = color.coords;\n    // Convert NaN to zeros to have a chance at a valid CSS color\n    // Also convert -0 to 0\n    // This also clones it so we can manipulate it\n    coords = coords.map((c)=>c ? c : 0);\n    if (inGamut$1 && !inGamut(color)) {\n        coords = toGamut(clone(color), inGamut$1 === true ? undefined : inGamut$1).coords;\n    }\n    if (format.type === \"custom\") {\n        customOptions.precision = precision;\n        if (format.serialize) {\n            ret = format.serialize(coords, color.alpha, customOptions);\n        } else {\n            throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);\n        }\n    } else {\n        // Functional syntax\n        let name = format.name || \"color\";\n        if (format.serializeCoords) {\n            coords = format.serializeCoords(coords, precision);\n        } else {\n            if (precision !== null) {\n                coords = coords.map((c)=>toPrecision(c, precision));\n            }\n        }\n        let args = [\n            ...coords\n        ];\n        if (name === \"color\") {\n            // If output is a color() function, add colorspace id as first argument\n            let cssId = format.id || format.ids?.[0] || color.space.id;\n            args.unshift(cssId);\n        }\n        let alpha = color.alpha;\n        if (precision !== null) {\n            alpha = toPrecision(alpha, precision);\n        }\n        let strAlpha = color.alpha < 1 && !format.noAlpha ? `${format.commas ? \",\" : \" /\"} ${alpha}` : \"\";\n        ret = `${name}(${args.join(format.commas ? \", \" : \" \")}${strAlpha})`;\n    }\n    return ret;\n}\n// convert an array of linear-light rec2020 values to CIE XYZ\n// using  D65 (no chromatic adaptation)\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// 0 is actually calculated as  4.994106574466076e-17\nconst toXYZ_M$5 = [\n    [\n        0.6369580483012914,\n        0.14461690358620832,\n        0.1688809751641721\n    ],\n    [\n        0.2627002120112671,\n        0.6779980715188708,\n        0.05930171646986196\n    ],\n    [\n        0.000000000000000,\n        0.028072693049087428,\n        1.060985057710791\n    ]\n];\n// from ITU-R BT.2124-0 Annex 2 p.3\nconst fromXYZ_M$5 = [\n    [\n        1.716651187971268,\n        -0.355670783776392,\n        -0.253366281373660\n    ],\n    [\n        -0.666684351832489,\n        1.616481236634939,\n        0.0157685458139111\n    ],\n    [\n        0.017639857445311,\n        -0.042770613257809,\n        0.942103121235474\n    ]\n];\nvar REC2020Linear = new RGBColorSpace({\n    id: \"rec2020-linear\",\n    name: \"Linear REC.2020\",\n    white: \"D65\",\n    toXYZ_M: toXYZ_M$5,\n    fromXYZ_M: fromXYZ_M$5,\n    formats: {\n        color: {}\n    }\n});\n// import sRGB from \"./srgb.js\";\nconst α = 1.09929682680944;\nconst β = 0.018053968510807;\nvar REC2020 = new RGBColorSpace({\n    id: \"rec2020\",\n    name: \"REC.2020\",\n    base: REC2020Linear,\n    // Non-linear transfer function from Rec. ITU-R BT.2020-2 table 4\n    toBase (RGB) {\n        return RGB.map(function(val) {\n            if (val < β * 4.5) {\n                return val / 4.5;\n            }\n            return Math.pow((val + α - 1) / α, 1 / 0.45);\n        });\n    },\n    fromBase (RGB) {\n        return RGB.map(function(val) {\n            if (val >= β) {\n                return α * Math.pow(val, 0.45) - (α - 1);\n            }\n            return 4.5 * val;\n        });\n    },\n    formats: {\n        color: {}\n    }\n});\nconst toXYZ_M$4 = [\n    [\n        0.4865709486482162,\n        0.26566769316909306,\n        0.1982172852343625\n    ],\n    [\n        0.2289745640697488,\n        0.6917385218365064,\n        0.079286914093745\n    ],\n    [\n        0.0000000000000000,\n        0.04511338185890264,\n        1.043944368900976\n    ]\n];\nconst fromXYZ_M$4 = [\n    [\n        2.493496911941425,\n        -0.9313836179191239,\n        -0.40271078445071684\n    ],\n    [\n        -0.8294889695615747,\n        1.7626640603183463,\n        0.023624685841943577\n    ],\n    [\n        0.03584583024378447,\n        -0.07617238926804182,\n        0.9568845240076872\n    ]\n];\nvar P3Linear = new RGBColorSpace({\n    id: \"p3-linear\",\n    name: \"Linear P3\",\n    white: \"D65\",\n    toXYZ_M: toXYZ_M$4,\n    fromXYZ_M: fromXYZ_M$4\n});\n// This is the linear-light version of sRGB\n// as used for example in SVG filters\n// or in Canvas\n// This matrix was calculated directly from the RGB and white chromaticities\n// when rounded to 8 decimal places, it agrees completely with the official matrix\n// see https://github.com/w3c/csswg-drafts/issues/5922\nconst toXYZ_M$3 = [\n    [\n        0.41239079926595934,\n        0.357584339383878,\n        0.1804807884018343\n    ],\n    [\n        0.21263900587151027,\n        0.715168678767756,\n        0.07219231536073371\n    ],\n    [\n        0.01933081871559182,\n        0.11919477979462598,\n        0.9505321522496607\n    ]\n];\n// This matrix is the inverse of the above;\n// again it agrees with the official definition when rounded to 8 decimal places\nconst fromXYZ_M$3 = [\n    [\n        3.2409699419045226,\n        -1.537383177570094,\n        -0.4986107602930034\n    ],\n    [\n        -0.9692436362808796,\n        1.8759675015077202,\n        0.04155505740717559\n    ],\n    [\n        0.05563007969699366,\n        -0.20397695888897652,\n        1.0569715142428786\n    ]\n];\nvar sRGBLinear = new RGBColorSpace({\n    id: \"srgb-linear\",\n    name: \"Linear sRGB\",\n    white: \"D65\",\n    toXYZ_M: toXYZ_M$3,\n    fromXYZ_M: fromXYZ_M$3,\n    formats: {\n        color: {}\n    }\n});\n/* List of CSS color keywords\n * Note that this does not include currentColor, transparent,\n * or system colors\n */ // To produce: Visit https://www.w3.org/TR/css-color-4/#named-colors\n// and run in the console:\n// copy($$(\"tr\", $(\".named-color-table tbody\")).map(tr => `\"${tr.cells[2].textContent.trim()}\": [${tr.cells[4].textContent.trim().split(/\\s+/).map(c => c === \"0\"? \"0\" : c === \"255\"? \"1\" : c + \" / 255\").join(\", \")}]`).join(\",\\n\"))\nvar KEYWORDS = {\n    \"aliceblue\": [\n        240 / 255,\n        248 / 255,\n        1\n    ],\n    \"antiquewhite\": [\n        250 / 255,\n        235 / 255,\n        215 / 255\n    ],\n    \"aqua\": [\n        0,\n        1,\n        1\n    ],\n    \"aquamarine\": [\n        127 / 255,\n        1,\n        212 / 255\n    ],\n    \"azure\": [\n        240 / 255,\n        1,\n        1\n    ],\n    \"beige\": [\n        245 / 255,\n        245 / 255,\n        220 / 255\n    ],\n    \"bisque\": [\n        1,\n        228 / 255,\n        196 / 255\n    ],\n    \"black\": [\n        0,\n        0,\n        0\n    ],\n    \"blanchedalmond\": [\n        1,\n        235 / 255,\n        205 / 255\n    ],\n    \"blue\": [\n        0,\n        0,\n        1\n    ],\n    \"blueviolet\": [\n        138 / 255,\n        43 / 255,\n        226 / 255\n    ],\n    \"brown\": [\n        165 / 255,\n        42 / 255,\n        42 / 255\n    ],\n    \"burlywood\": [\n        222 / 255,\n        184 / 255,\n        135 / 255\n    ],\n    \"cadetblue\": [\n        95 / 255,\n        158 / 255,\n        160 / 255\n    ],\n    \"chartreuse\": [\n        127 / 255,\n        1,\n        0\n    ],\n    \"chocolate\": [\n        210 / 255,\n        105 / 255,\n        30 / 255\n    ],\n    \"coral\": [\n        1,\n        127 / 255,\n        80 / 255\n    ],\n    \"cornflowerblue\": [\n        100 / 255,\n        149 / 255,\n        237 / 255\n    ],\n    \"cornsilk\": [\n        1,\n        248 / 255,\n        220 / 255\n    ],\n    \"crimson\": [\n        220 / 255,\n        20 / 255,\n        60 / 255\n    ],\n    \"cyan\": [\n        0,\n        1,\n        1\n    ],\n    \"darkblue\": [\n        0,\n        0,\n        139 / 255\n    ],\n    \"darkcyan\": [\n        0,\n        139 / 255,\n        139 / 255\n    ],\n    \"darkgoldenrod\": [\n        184 / 255,\n        134 / 255,\n        11 / 255\n    ],\n    \"darkgray\": [\n        169 / 255,\n        169 / 255,\n        169 / 255\n    ],\n    \"darkgreen\": [\n        0,\n        100 / 255,\n        0\n    ],\n    \"darkgrey\": [\n        169 / 255,\n        169 / 255,\n        169 / 255\n    ],\n    \"darkkhaki\": [\n        189 / 255,\n        183 / 255,\n        107 / 255\n    ],\n    \"darkmagenta\": [\n        139 / 255,\n        0,\n        139 / 255\n    ],\n    \"darkolivegreen\": [\n        85 / 255,\n        107 / 255,\n        47 / 255\n    ],\n    \"darkorange\": [\n        1,\n        140 / 255,\n        0\n    ],\n    \"darkorchid\": [\n        153 / 255,\n        50 / 255,\n        204 / 255\n    ],\n    \"darkred\": [\n        139 / 255,\n        0,\n        0\n    ],\n    \"darksalmon\": [\n        233 / 255,\n        150 / 255,\n        122 / 255\n    ],\n    \"darkseagreen\": [\n        143 / 255,\n        188 / 255,\n        143 / 255\n    ],\n    \"darkslateblue\": [\n        72 / 255,\n        61 / 255,\n        139 / 255\n    ],\n    \"darkslategray\": [\n        47 / 255,\n        79 / 255,\n        79 / 255\n    ],\n    \"darkslategrey\": [\n        47 / 255,\n        79 / 255,\n        79 / 255\n    ],\n    \"darkturquoise\": [\n        0,\n        206 / 255,\n        209 / 255\n    ],\n    \"darkviolet\": [\n        148 / 255,\n        0,\n        211 / 255\n    ],\n    \"deeppink\": [\n        1,\n        20 / 255,\n        147 / 255\n    ],\n    \"deepskyblue\": [\n        0,\n        191 / 255,\n        1\n    ],\n    \"dimgray\": [\n        105 / 255,\n        105 / 255,\n        105 / 255\n    ],\n    \"dimgrey\": [\n        105 / 255,\n        105 / 255,\n        105 / 255\n    ],\n    \"dodgerblue\": [\n        30 / 255,\n        144 / 255,\n        1\n    ],\n    \"firebrick\": [\n        178 / 255,\n        34 / 255,\n        34 / 255\n    ],\n    \"floralwhite\": [\n        1,\n        250 / 255,\n        240 / 255\n    ],\n    \"forestgreen\": [\n        34 / 255,\n        139 / 255,\n        34 / 255\n    ],\n    \"fuchsia\": [\n        1,\n        0,\n        1\n    ],\n    \"gainsboro\": [\n        220 / 255,\n        220 / 255,\n        220 / 255\n    ],\n    \"ghostwhite\": [\n        248 / 255,\n        248 / 255,\n        1\n    ],\n    \"gold\": [\n        1,\n        215 / 255,\n        0\n    ],\n    \"goldenrod\": [\n        218 / 255,\n        165 / 255,\n        32 / 255\n    ],\n    \"gray\": [\n        128 / 255,\n        128 / 255,\n        128 / 255\n    ],\n    \"green\": [\n        0,\n        128 / 255,\n        0\n    ],\n    \"greenyellow\": [\n        173 / 255,\n        1,\n        47 / 255\n    ],\n    \"grey\": [\n        128 / 255,\n        128 / 255,\n        128 / 255\n    ],\n    \"honeydew\": [\n        240 / 255,\n        1,\n        240 / 255\n    ],\n    \"hotpink\": [\n        1,\n        105 / 255,\n        180 / 255\n    ],\n    \"indianred\": [\n        205 / 255,\n        92 / 255,\n        92 / 255\n    ],\n    \"indigo\": [\n        75 / 255,\n        0,\n        130 / 255\n    ],\n    \"ivory\": [\n        1,\n        1,\n        240 / 255\n    ],\n    \"khaki\": [\n        240 / 255,\n        230 / 255,\n        140 / 255\n    ],\n    \"lavender\": [\n        230 / 255,\n        230 / 255,\n        250 / 255\n    ],\n    \"lavenderblush\": [\n        1,\n        240 / 255,\n        245 / 255\n    ],\n    \"lawngreen\": [\n        124 / 255,\n        252 / 255,\n        0\n    ],\n    \"lemonchiffon\": [\n        1,\n        250 / 255,\n        205 / 255\n    ],\n    \"lightblue\": [\n        173 / 255,\n        216 / 255,\n        230 / 255\n    ],\n    \"lightcoral\": [\n        240 / 255,\n        128 / 255,\n        128 / 255\n    ],\n    \"lightcyan\": [\n        224 / 255,\n        1,\n        1\n    ],\n    \"lightgoldenrodyellow\": [\n        250 / 255,\n        250 / 255,\n        210 / 255\n    ],\n    \"lightgray\": [\n        211 / 255,\n        211 / 255,\n        211 / 255\n    ],\n    \"lightgreen\": [\n        144 / 255,\n        238 / 255,\n        144 / 255\n    ],\n    \"lightgrey\": [\n        211 / 255,\n        211 / 255,\n        211 / 255\n    ],\n    \"lightpink\": [\n        1,\n        182 / 255,\n        193 / 255\n    ],\n    \"lightsalmon\": [\n        1,\n        160 / 255,\n        122 / 255\n    ],\n    \"lightseagreen\": [\n        32 / 255,\n        178 / 255,\n        170 / 255\n    ],\n    \"lightskyblue\": [\n        135 / 255,\n        206 / 255,\n        250 / 255\n    ],\n    \"lightslategray\": [\n        119 / 255,\n        136 / 255,\n        153 / 255\n    ],\n    \"lightslategrey\": [\n        119 / 255,\n        136 / 255,\n        153 / 255\n    ],\n    \"lightsteelblue\": [\n        176 / 255,\n        196 / 255,\n        222 / 255\n    ],\n    \"lightyellow\": [\n        1,\n        1,\n        224 / 255\n    ],\n    \"lime\": [\n        0,\n        1,\n        0\n    ],\n    \"limegreen\": [\n        50 / 255,\n        205 / 255,\n        50 / 255\n    ],\n    \"linen\": [\n        250 / 255,\n        240 / 255,\n        230 / 255\n    ],\n    \"magenta\": [\n        1,\n        0,\n        1\n    ],\n    \"maroon\": [\n        128 / 255,\n        0,\n        0\n    ],\n    \"mediumaquamarine\": [\n        102 / 255,\n        205 / 255,\n        170 / 255\n    ],\n    \"mediumblue\": [\n        0,\n        0,\n        205 / 255\n    ],\n    \"mediumorchid\": [\n        186 / 255,\n        85 / 255,\n        211 / 255\n    ],\n    \"mediumpurple\": [\n        147 / 255,\n        112 / 255,\n        219 / 255\n    ],\n    \"mediumseagreen\": [\n        60 / 255,\n        179 / 255,\n        113 / 255\n    ],\n    \"mediumslateblue\": [\n        123 / 255,\n        104 / 255,\n        238 / 255\n    ],\n    \"mediumspringgreen\": [\n        0,\n        250 / 255,\n        154 / 255\n    ],\n    \"mediumturquoise\": [\n        72 / 255,\n        209 / 255,\n        204 / 255\n    ],\n    \"mediumvioletred\": [\n        199 / 255,\n        21 / 255,\n        133 / 255\n    ],\n    \"midnightblue\": [\n        25 / 255,\n        25 / 255,\n        112 / 255\n    ],\n    \"mintcream\": [\n        245 / 255,\n        1,\n        250 / 255\n    ],\n    \"mistyrose\": [\n        1,\n        228 / 255,\n        225 / 255\n    ],\n    \"moccasin\": [\n        1,\n        228 / 255,\n        181 / 255\n    ],\n    \"navajowhite\": [\n        1,\n        222 / 255,\n        173 / 255\n    ],\n    \"navy\": [\n        0,\n        0,\n        128 / 255\n    ],\n    \"oldlace\": [\n        253 / 255,\n        245 / 255,\n        230 / 255\n    ],\n    \"olive\": [\n        128 / 255,\n        128 / 255,\n        0\n    ],\n    \"olivedrab\": [\n        107 / 255,\n        142 / 255,\n        35 / 255\n    ],\n    \"orange\": [\n        1,\n        165 / 255,\n        0\n    ],\n    \"orangered\": [\n        1,\n        69 / 255,\n        0\n    ],\n    \"orchid\": [\n        218 / 255,\n        112 / 255,\n        214 / 255\n    ],\n    \"palegoldenrod\": [\n        238 / 255,\n        232 / 255,\n        170 / 255\n    ],\n    \"palegreen\": [\n        152 / 255,\n        251 / 255,\n        152 / 255\n    ],\n    \"paleturquoise\": [\n        175 / 255,\n        238 / 255,\n        238 / 255\n    ],\n    \"palevioletred\": [\n        219 / 255,\n        112 / 255,\n        147 / 255\n    ],\n    \"papayawhip\": [\n        1,\n        239 / 255,\n        213 / 255\n    ],\n    \"peachpuff\": [\n        1,\n        218 / 255,\n        185 / 255\n    ],\n    \"peru\": [\n        205 / 255,\n        133 / 255,\n        63 / 255\n    ],\n    \"pink\": [\n        1,\n        192 / 255,\n        203 / 255\n    ],\n    \"plum\": [\n        221 / 255,\n        160 / 255,\n        221 / 255\n    ],\n    \"powderblue\": [\n        176 / 255,\n        224 / 255,\n        230 / 255\n    ],\n    \"purple\": [\n        128 / 255,\n        0,\n        128 / 255\n    ],\n    \"rebeccapurple\": [\n        102 / 255,\n        51 / 255,\n        153 / 255\n    ],\n    \"red\": [\n        1,\n        0,\n        0\n    ],\n    \"rosybrown\": [\n        188 / 255,\n        143 / 255,\n        143 / 255\n    ],\n    \"royalblue\": [\n        65 / 255,\n        105 / 255,\n        225 / 255\n    ],\n    \"saddlebrown\": [\n        139 / 255,\n        69 / 255,\n        19 / 255\n    ],\n    \"salmon\": [\n        250 / 255,\n        128 / 255,\n        114 / 255\n    ],\n    \"sandybrown\": [\n        244 / 255,\n        164 / 255,\n        96 / 255\n    ],\n    \"seagreen\": [\n        46 / 255,\n        139 / 255,\n        87 / 255\n    ],\n    \"seashell\": [\n        1,\n        245 / 255,\n        238 / 255\n    ],\n    \"sienna\": [\n        160 / 255,\n        82 / 255,\n        45 / 255\n    ],\n    \"silver\": [\n        192 / 255,\n        192 / 255,\n        192 / 255\n    ],\n    \"skyblue\": [\n        135 / 255,\n        206 / 255,\n        235 / 255\n    ],\n    \"slateblue\": [\n        106 / 255,\n        90 / 255,\n        205 / 255\n    ],\n    \"slategray\": [\n        112 / 255,\n        128 / 255,\n        144 / 255\n    ],\n    \"slategrey\": [\n        112 / 255,\n        128 / 255,\n        144 / 255\n    ],\n    \"snow\": [\n        1,\n        250 / 255,\n        250 / 255\n    ],\n    \"springgreen\": [\n        0,\n        1,\n        127 / 255\n    ],\n    \"steelblue\": [\n        70 / 255,\n        130 / 255,\n        180 / 255\n    ],\n    \"tan\": [\n        210 / 255,\n        180 / 255,\n        140 / 255\n    ],\n    \"teal\": [\n        0,\n        128 / 255,\n        128 / 255\n    ],\n    \"thistle\": [\n        216 / 255,\n        191 / 255,\n        216 / 255\n    ],\n    \"tomato\": [\n        1,\n        99 / 255,\n        71 / 255\n    ],\n    \"turquoise\": [\n        64 / 255,\n        224 / 255,\n        208 / 255\n    ],\n    \"violet\": [\n        238 / 255,\n        130 / 255,\n        238 / 255\n    ],\n    \"wheat\": [\n        245 / 255,\n        222 / 255,\n        179 / 255\n    ],\n    \"white\": [\n        1,\n        1,\n        1\n    ],\n    \"whitesmoke\": [\n        245 / 255,\n        245 / 255,\n        245 / 255\n    ],\n    \"yellow\": [\n        1,\n        1,\n        0\n    ],\n    \"yellowgreen\": [\n        154 / 255,\n        205 / 255,\n        50 / 255\n    ]\n};\nlet coordGrammar = Array(3).fill(\"<percentage> | <number>[0, 255]\");\nlet coordGrammarNumber = Array(3).fill(\"<number>[0, 255]\");\nvar sRGB = new RGBColorSpace({\n    id: \"srgb\",\n    name: \"sRGB\",\n    base: sRGBLinear,\n    fromBase: (rgb)=>{\n        // convert an array of linear-light sRGB values in the range 0.0-1.0\n        // to gamma corrected form\n        // https://en.wikipedia.org/wiki/SRGB\n        return rgb.map((val)=>{\n            let sign = val < 0 ? -1 : 1;\n            let abs = val * sign;\n            if (abs > 0.0031308) {\n                return sign * (1.055 * abs ** (1 / 2.4) - 0.055);\n            }\n            return 12.92 * val;\n        });\n    },\n    toBase: (rgb)=>{\n        // convert an array of sRGB values in the range 0.0 - 1.0\n        // to linear light (un-companded) form.\n        // https://en.wikipedia.org/wiki/SRGB\n        return rgb.map((val)=>{\n            let sign = val < 0 ? -1 : 1;\n            let abs = val * sign;\n            if (abs < 0.04045) {\n                return val / 12.92;\n            }\n            return sign * ((abs + 0.055) / 1.055) ** 2.4;\n        });\n    },\n    formats: {\n        \"rgb\": {\n            coords: coordGrammar\n        },\n        \"rgb_number\": {\n            name: \"rgb\",\n            commas: true,\n            coords: coordGrammarNumber,\n            noAlpha: true\n        },\n        \"color\": {},\n        \"rgba\": {\n            coords: coordGrammar,\n            commas: true,\n            lastAlpha: true\n        },\n        \"rgba_number\": {\n            name: \"rgba\",\n            commas: true,\n            coords: coordGrammarNumber\n        },\n        \"hex\": {\n            type: \"custom\",\n            toGamut: true,\n            test: (str)=>/^#([a-f0-9]{3,4}){1,2}$/i.test(str),\n            parse (str) {\n                if (str.length <= 5) {\n                    // #rgb or #rgba, duplicate digits\n                    str = str.replace(/[a-f0-9]/gi, \"$&$&\");\n                }\n                let rgba = [];\n                str.replace(/[a-f0-9]{2}/gi, (component)=>{\n                    rgba.push(parseInt(component, 16) / 255);\n                });\n                return {\n                    spaceId: \"srgb\",\n                    coords: rgba.slice(0, 3),\n                    alpha: rgba.slice(3)[0]\n                };\n            },\n            serialize: (coords, alpha, { collapse = true // collapse to 3-4 digit hex when possible?\n             } = {})=>{\n                if (alpha < 1) {\n                    coords.push(alpha);\n                }\n                coords = coords.map((c)=>Math.round(c * 255));\n                let collapsible = collapse && coords.every((c)=>c % 17 === 0);\n                let hex = coords.map((c)=>{\n                    if (collapsible) {\n                        return (c / 17).toString(16);\n                    }\n                    return c.toString(16).padStart(2, \"0\");\n                }).join(\"\");\n                return \"#\" + hex;\n            }\n        },\n        \"keyword\": {\n            type: \"custom\",\n            test: (str)=>/^[a-z]+$/i.test(str),\n            parse (str) {\n                str = str.toLowerCase();\n                let ret = {\n                    spaceId: \"srgb\",\n                    coords: null,\n                    alpha: 1\n                };\n                if (str === \"transparent\") {\n                    ret.coords = KEYWORDS.black;\n                    ret.alpha = 0;\n                } else {\n                    ret.coords = KEYWORDS[str];\n                }\n                if (ret.coords) {\n                    return ret;\n                }\n            }\n        }\n    }\n});\nvar P3 = new RGBColorSpace({\n    id: \"p3\",\n    name: \"P3\",\n    base: P3Linear,\n    // Gamma encoding/decoding is the same as sRGB\n    fromBase: sRGB.fromBase,\n    toBase: sRGB.toBase,\n    formats: {\n        color: {\n            id: \"display-p3\"\n        }\n    }\n});\n// Default space for CSS output. Code in Color.js makes this wider if there's a DOM available\ndefaults.display_space = sRGB;\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n    // Find widest supported color space for CSS\n    for (let space of [\n        lab,\n        REC2020,\n        P3\n    ]){\n        let coords = space.getMinCoords();\n        let color = {\n            space,\n            coords,\n            alpha: 1\n        };\n        let str = serialize(color);\n        if (CSS.supports(\"color\", str)) {\n            defaults.display_space = space;\n            break;\n        }\n    }\n}\n/**\n * Returns a serialization of the color that can actually be displayed in the browser.\n * If the default serialization can be displayed, it is returned.\n * Otherwise, the color is converted to Lab, REC2020, or P3, whichever is the widest supported.\n * In Node.js, this is basically equivalent to `serialize()` but returns a `String` object instead.\n *\n * @export\n * @param {{space, coords} | Color | string} color\n * @param {*} [options={}] Options to be passed to serialize()\n * @param {ColorSpace | string} [options.space = defaults.display_space] Color space to use for serialization if default is not supported\n * @returns {String} String object containing the serialized color with a color property containing the converted color (or the original, if no conversion was necessary)\n */ function display(color, { space = defaults.display_space, ...options } = {}) {\n    let ret = serialize(color, options);\n    if (typeof CSS === \"undefined\" || CSS.supports(\"color\", ret) || !defaults.display_space) {\n        ret = new String(ret);\n        ret.color = color;\n    } else {\n        // If we're here, what we were about to output is not supported\n        // Fall back to fallback space\n        let fallbackColor = to(color, space);\n        ret = new String(serialize(fallbackColor, options));\n        ret.color = fallbackColor;\n    }\n    return ret;\n}\n/**\n * Euclidean distance of colors in an arbitrary color space\n */ function distance(color1, color2, space = \"lab\") {\n    space = ColorSpace.get(space);\n    let coords1 = space.from(color1);\n    let coords2 = space.from(color2);\n    return Math.sqrt(coords1.reduce((acc, c1, i)=>{\n        let c2 = coords2[i];\n        if (isNaN(c1) || isNaN(c2)) {\n            return acc;\n        }\n        return acc + (c2 - c1) ** 2;\n    }, 0));\n}\nfunction equals(color1, color2) {\n    color1 = getColor(color1);\n    color2 = getColor(color2);\n    return color1.space === color2.space && color1.alpha === color2.alpha && color1.coords.every((c, i)=>c === color2.coords[i]);\n}\n/**\n * Relative luminance\n */ function getLuminance(color) {\n    return get(color, [\n        XYZ_D65,\n        \"y\"\n    ]);\n}\nfunction setLuminance(color, value) {\n    set(color, [\n        XYZ_D65,\n        \"y\"\n    ], value);\n}\nfunction register$2(Color) {\n    Object.defineProperty(Color.prototype, \"luminance\", {\n        get () {\n            return getLuminance(this);\n        },\n        set (value) {\n            setLuminance(this, value);\n        }\n    });\n}\nvar luminance = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    getLuminance: getLuminance,\n    register: register$2,\n    setLuminance: setLuminance\n});\n// WCAG 2.0 contrast https://www.w3.org/TR/WCAG20-TECHS/G18.html\n// Simple contrast, with fixed 5% viewing flare contribution\n// Symmetric, does not matter which is foreground and which is background\nfunction contrastWCAG21(color1, color2) {\n    color1 = getColor(color1);\n    color2 = getColor(color2);\n    let Y1 = Math.max(getLuminance(color1), 0);\n    let Y2 = Math.max(getLuminance(color2), 0);\n    if (Y2 > Y1) {\n        [Y1, Y2] = [\n            Y2,\n            Y1\n        ];\n    }\n    return (Y1 + .05) / (Y2 + .05);\n}\n// APCA 0.0.98G\n// https://github.com/Myndex/apca-w3\n// see also https://github.com/w3c/silver/issues/643\n// exponents\nconst normBG = 0.56;\nconst normTXT = 0.57;\nconst revTXT = 0.62;\nconst revBG = 0.65;\n// clamps\nconst blkThrs = 0.022;\nconst blkClmp = 1.414;\nconst loClip = 0.1;\nconst deltaYmin = 0.0005;\n// scalers\n// see https://github.com/w3c/silver/issues/645\nconst scaleBoW = 1.14;\nconst loBoWoffset = 0.027;\nconst scaleWoB = 1.14;\nfunction fclamp(Y) {\n    if (Y >= blkThrs) {\n        return Y;\n    }\n    return Y + (blkThrs - Y) ** blkClmp;\n}\nfunction linearize(val) {\n    let sign = val < 0 ? -1 : 1;\n    let abs = Math.abs(val);\n    return sign * Math.pow(abs, 2.4);\n}\n// Not symmetric, requires a foreground (text) color, and a background color\nfunction contrastAPCA(background, foreground) {\n    foreground = getColor(foreground);\n    background = getColor(background);\n    let S;\n    let C;\n    let Sapc;\n    // Myndex as-published, assumes sRGB inputs\n    let R, G, B;\n    foreground = to(foreground, \"srgb\");\n    // Should these be clamped to in-gamut values?\n    // Calculates \"screen luminance\" with non-standard simple gamma EOTF\n    // weights should be from CSS Color 4, not the ones here which are via Myndex and copied from Lindbloom\n    [R, G, B] = foreground.coords;\n    let lumTxt = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;\n    background = to(background, \"srgb\");\n    [R, G, B] = background.coords;\n    let lumBg = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;\n    // toe clamping of very dark values to account for flare\n    let Ytxt = fclamp(lumTxt);\n    let Ybg = fclamp(lumBg);\n    // are we \"Black on White\" (dark on light), or light on dark?\n    let BoW = Ybg > Ytxt;\n    // why is this a delta, when Y is not perceptually uniform?\n    // Answer: it is a noise gate, see\n    // https://github.com/LeaVerou/color.js/issues/208\n    if (Math.abs(Ybg - Ytxt) < deltaYmin) {\n        C = 0;\n    } else {\n        if (BoW) {\n            // dark text on light background\n            S = Ybg ** normBG - Ytxt ** normTXT;\n            C = S * scaleBoW;\n        } else {\n            // light text on dark background\n            S = Ybg ** revBG - Ytxt ** revTXT;\n            C = S * scaleWoB;\n        }\n    }\n    if (Math.abs(C) < loClip) {\n        Sapc = 0;\n    } else if (C > 0) {\n        // not clear whether Woffset is loBoWoffset or loWoBoffset\n        // but they have the same value\n        Sapc = C - loBoWoffset;\n    } else {\n        Sapc = C + loBoWoffset;\n    }\n    return Sapc * 100;\n}\n// Michelson  luminance contrast\n// the relation between the spread and the sum of the two luminances\n// Symmetric, does not matter which is foreground and which is background\n// No black level compensation for flare.\nfunction contrastMichelson(color1, color2) {\n    color1 = getColor(color1);\n    color2 = getColor(color2);\n    let Y1 = Math.max(getLuminance(color1), 0);\n    let Y2 = Math.max(getLuminance(color2), 0);\n    if (Y2 > Y1) {\n        [Y1, Y2] = [\n            Y2,\n            Y1\n        ];\n    }\n    let denom = Y1 + Y2;\n    return denom === 0 ? 0 : (Y1 - Y2) / denom;\n}\n// Weber luminance contrast\n// The difference between the two luminances divided by the lower luminance\n// Symmetric, does not matter which is foreground and which is background\n// No black level compensation for flare.\n// the darkest sRGB color above black is #000001 and this produces\n// a plain Weber contrast of ~45647.\n// So, setting the divide-by-zero result at 50000 is a reasonable\n// max clamp for the plain Weber\nconst max = 50000;\nfunction contrastWeber(color1, color2) {\n    color1 = getColor(color1);\n    color2 = getColor(color2);\n    let Y1 = Math.max(getLuminance(color1), 0);\n    let Y2 = Math.max(getLuminance(color2), 0);\n    if (Y2 > Y1) {\n        [Y1, Y2] = [\n            Y2,\n            Y1\n        ];\n    }\n    return Y2 === 0 ? max : (Y1 - Y2) / Y2;\n}\n// CIE Lightness difference, as used by Google Material Design\n// Google HCT Tone is the same as CIE Lightness\n// https://material.io/blog/science-of-color-design\nfunction contrastLstar(color1, color2) {\n    color1 = getColor(color1);\n    color2 = getColor(color2);\n    let L1 = get(color1, [\n        lab,\n        \"l\"\n    ]);\n    let L2 = get(color2, [\n        lab,\n        \"l\"\n    ]);\n    return Math.abs(L1 - L2);\n}\n// κ * ε  = 2^3 = 8\nconst ε$1 = 216 / 24389; // 6^3/29^3 == (24/116)^3\nconst ε3 = 24 / 116;\nconst κ = 24389 / 27; // 29^3/3^3\nlet white = WHITES.D65;\nvar lab_d65 = new ColorSpace({\n    id: \"lab-d65\",\n    name: \"Lab D65\",\n    coords: {\n        l: {\n            refRange: [\n                0,\n                100\n            ],\n            name: \"L\"\n        },\n        a: {\n            refRange: [\n                -125,\n                125\n            ]\n        },\n        b: {\n            refRange: [\n                -125,\n                125\n            ]\n        }\n    },\n    // Assuming XYZ is relative to D65, convert to CIE Lab\n    // from CIE standard, which now defines these as a rational fraction\n    white,\n    base: XYZ_D65,\n    // Convert D65-adapted XYZ to Lab\n    //  CIE 15.3:2004 section 8.2.1.1\n    fromBase (XYZ) {\n        // compute xyz, which is XYZ scaled relative to reference white\n        let xyz = XYZ.map((value, i)=>value / white[i]);\n        // now compute f\n        let f = xyz.map((value)=>value > ε$1 ? Math.cbrt(value) : (κ * value + 16) / 116);\n        return [\n            116 * f[1] - 16,\n            500 * (f[0] - f[1]),\n            200 * (f[1] - f[2] // b\n            )\n        ];\n    },\n    // Convert Lab to D65-adapted XYZ\n    // Same result as CIE 15.3:2004 Appendix D although the derivation is different\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    toBase (Lab) {\n        // compute f, starting with the luminance-related term\n        let f = [];\n        f[1] = (Lab[0] + 16) / 116;\n        f[0] = Lab[1] / 500 + f[1];\n        f[2] = f[1] - Lab[2] / 200;\n        // compute xyz\n        let xyz = [\n            f[0] > ε3 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ,\n            Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ,\n            f[2] > ε3 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ\n        ];\n        // Compute XYZ by scaling xyz by reference white\n        return xyz.map((value, i)=>value * white[i]);\n    },\n    formats: {\n        \"lab-d65\": {\n            coords: [\n                \"<number> | <percentage>\",\n                \"<number> | <percentage>[-1,1]\",\n                \"<number> | <percentage>[-1,1]\"\n            ]\n        }\n    }\n});\n// Delta Phi Star perceptual lightness contrast\n// See https://github.com/Myndex/deltaphistar\n// The (difference between two Lstars each raised to phi) raised to (1/phi)\n// Symmetric, does not matter which is foreground and which is background\nconst phi = Math.pow(5, 0.5) * 0.5 + 0.5; // Math.phi can be used if Math.js\nfunction contrastDeltaPhi(color1, color2) {\n    color1 = getColor(color1);\n    color2 = getColor(color2);\n    let Lstr1 = get(color1, [\n        lab_d65,\n        \"l\"\n    ]);\n    let Lstr2 = get(color2, [\n        lab_d65,\n        \"l\"\n    ]);\n    let deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));\n    let contrast = Math.pow(deltaPhiStar, 1 / phi) * Math.SQRT2 - 40;\n    return contrast < 7.5 ? 0.0 : contrast;\n}\nvar contrastMethods = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    contrastAPCA: contrastAPCA,\n    contrastDeltaPhi: contrastDeltaPhi,\n    contrastLstar: contrastLstar,\n    contrastMichelson: contrastMichelson,\n    contrastWCAG21: contrastWCAG21,\n    contrastWeber: contrastWeber\n});\nfunction contrast(background, foreground, o = {}) {\n    if (isString(o)) {\n        o = {\n            algorithm: o\n        };\n    }\n    let { algorithm, ...rest } = o;\n    if (!algorithm) {\n        let algorithms = Object.keys(contrastMethods).map((a)=>a.replace(/^contrast/, \"\")).join(\", \");\n        throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);\n    }\n    background = getColor(background);\n    foreground = getColor(foreground);\n    for(let a in contrastMethods){\n        if (\"contrast\" + algorithm.toLowerCase() === a.toLowerCase()) {\n            return contrastMethods[a](background, foreground, rest);\n        }\n    }\n    throw new TypeError(`Unknown contrast algorithm: ${algorithm}`);\n}\n// Chromaticity coordinates\nfunction uv(color) {\n    let [X, Y, Z] = getAll(color, XYZ_D65);\n    let denom = X + 15 * Y + 3 * Z;\n    return [\n        4 * X / denom,\n        9 * Y / denom\n    ];\n}\nfunction xy(color) {\n    let [X, Y, Z] = getAll(color, XYZ_D65);\n    let sum = X + Y + Z;\n    return [\n        X / sum,\n        Y / sum\n    ];\n}\nfunction register$1(Color) {\n    // no setters, as lightness information is lost\n    // when converting color to chromaticity\n    Object.defineProperty(Color.prototype, \"uv\", {\n        get () {\n            return uv(this);\n        }\n    });\n    Object.defineProperty(Color.prototype, \"xy\", {\n        get () {\n            return xy(this);\n        }\n    });\n}\nvar chromaticity = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    register: register$1,\n    uv: uv,\n    xy: xy\n});\nfunction deltaE76(color, sample) {\n    return distance(color, sample, \"lab\");\n}\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in Lab\n// CMC by the Color Measurement Committee of the\n// Bradford Society of Dyeists and Colorsts, 1994.\n// Uses LCH rather than Lab,\n// with different weights for L, C and H differences\n// A nice increase in accuracy for modest increase in complexity\nconst π = Math.PI;\nconst d2r = π / 180;\nfunction deltaECMC(color, sample, { l = 2, c = 1 } = {}) {\n    // Given this color as the reference\n    // and a sample,\n    // calculate deltaE CMC.\n    // This implementation assumes the parametric\n    // weighting factors l:c are 2:1\n    // which is typical for non-textile uses.\n    let [L1, a1, b1] = lab.from(color);\n    let [, C1, H1] = lch.from(lab, [\n        L1,\n        a1,\n        b1\n    ]);\n    let [L2, a2, b2] = lab.from(sample);\n    let C2 = lch.from(lab, [\n        L2,\n        a2,\n        b2\n    ])[1];\n    // let [L1, a1, b1] = color.getAll(lab);\n    // let C1 = color.get(\"lch.c\");\n    // let H1 = color.get(\"lch.h\");\n    // let [L2, a2, b2] = sample.getAll(lab);\n    // let C2 = sample.get(\"lch.c\");\n    // Check for negative Chroma,\n    // which might happen through\n    // direct user input of LCH values\n    if (C1 < 0) {\n        C1 = 0;\n    }\n    if (C2 < 0) {\n        C2 = 0;\n    }\n    // we don't need H2 as ΔH is calculated from Δa, Δb and ΔC\n    // Lightness and Chroma differences\n    // These are (color - sample), unlike deltaE2000\n    let ΔL = L1 - L2;\n    let ΔC = C1 - C2;\n    let Δa = a1 - a2;\n    let Δb = b1 - b2;\n    // weighted Hue difference, less for larger Chroma difference\n    let H2 = Δa ** 2 + Δb ** 2 - ΔC ** 2;\n    // due to roundoff error it is possible that, for zero a and b,\n    // ΔC > Δa + Δb is 0, resulting in attempting\n    // to take the square root of a negative number\n    // trying instead the equation from Industrial Color Physics\n    // By Georg A. Klein\n    // let ΔH = ((a1 * b2) - (a2 * b1)) / Math.sqrt(0.5 * ((C2 * C1) + (a2 * a1) + (b2 * b1)));\n    // console.log({ΔH});\n    // This gives the same result to 12 decimal places\n    // except it sometimes NaNs when trying to root a negative number\n    // let ΔH = Math.sqrt(H2); we never actually use the root, it gets squared again!!\n    // positional corrections to the lack of uniformity of CIELAB\n    // These are all trying to make JND ellipsoids more like spheres\n    // SL Lightness crispening factor, depends entirely on L1 not L2\n    let SL = 0.511; // linear portion of the Y to L transfer function\n    if (L1 >= 16) {\n        SL = 0.040975 * L1 / (1 + 0.01765 * L1);\n    }\n    // SC Chroma factor\n    let SC = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;\n    // Cross term T for blue non-linearity\n    let T;\n    if (Number.isNaN(H1)) {\n        H1 = 0;\n    }\n    if (H1 >= 164 && H1 <= 345) {\n        T = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));\n    } else {\n        T = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));\n    }\n    // console.log({T});\n    // SH Hue factor also depends on C1,\n    let C4 = Math.pow(C1, 4);\n    let F = Math.sqrt(C4 / (C4 + 1900));\n    let SH = SC * (F * T + 1 - F);\n    // Finally calculate the deltaE, term by term as root sume of squares\n    let dE = (ΔL / (l * SL)) ** 2;\n    dE += (ΔC / (c * SC)) ** 2;\n    dE += H2 / SH ** 2;\n    // dE += (ΔH / SH)  ** 2;\n    return Math.sqrt(dE);\n// Yay!!!\n}\nconst Yw$1 = 203; // absolute luminance of media white\nvar XYZ_Abs_D65 = new ColorSpace({\n    // Absolute CIE XYZ, with a D65 whitepoint,\n    // as used in most HDR colorspaces as a starting point.\n    // SDR spaces are converted per BT.2048\n    // so that diffuse, media white is 203 cd/m²\n    id: \"xyz-abs-d65\",\n    name: \"Absolute XYZ D65\",\n    coords: {\n        x: {\n            refRange: [\n                0,\n                9504.7\n            ],\n            name: \"Xa\"\n        },\n        y: {\n            refRange: [\n                0,\n                10000\n            ],\n            name: \"Ya\"\n        },\n        z: {\n            refRange: [\n                0,\n                10888.3\n            ],\n            name: \"Za\"\n        }\n    },\n    base: XYZ_D65,\n    fromBase (XYZ) {\n        // Make XYZ absolute, not relative to media white\n        // Maximum luminance in PQ is 10,000 cd/m²\n        // Relative XYZ has Y=1 for media white\n        return XYZ.map((v)=>Math.max(v * Yw$1, 0));\n    },\n    toBase (AbsXYZ) {\n        // Convert to media-white relative XYZ\n        return AbsXYZ.map((v)=>Math.max(v / Yw$1, 0));\n    }\n});\nconst b$1 = 1.15;\nconst g = 0.66;\nconst n$1 = 2610 / 2 ** 14;\nconst ninv$1 = 2 ** 14 / 2610;\nconst c1$2 = 3424 / 2 ** 12;\nconst c2$2 = 2413 / 2 ** 7;\nconst c3$2 = 2392 / 2 ** 7;\nconst p = 1.7 * 2523 / 2 ** 5;\nconst pinv = 2 ** 5 / (1.7 * 2523);\nconst d = -0.56;\nconst d0 = 1.6295499532821566E-11;\nconst XYZtoCone_M = [\n    [\n        0.41478972,\n        0.579999,\n        0.0146480\n    ],\n    [\n        -0.2015100,\n        1.120649,\n        0.0531008\n    ],\n    [\n        -0.0166008,\n        0.264800,\n        0.6684799\n    ]\n];\n// XYZtoCone_M inverted\nconst ConetoXYZ_M = [\n    [\n        1.9242264357876067,\n        -1.0047923125953657,\n        0.037651404030618\n    ],\n    [\n        0.35031676209499907,\n        0.7264811939316552,\n        -0.06538442294808501\n    ],\n    [\n        -0.09098281098284752,\n        -0.3127282905230739,\n        1.5227665613052603\n    ]\n];\nconst ConetoIab_M = [\n    [\n        0.5,\n        0.5,\n        0\n    ],\n    [\n        3.524000,\n        -4.066708,\n        0.542708\n    ],\n    [\n        0.199076,\n        1.096799,\n        -1.295875\n    ]\n];\n// ConetoIab_M inverted\nconst IabtoCone_M = [\n    [\n        1,\n        0.1386050432715393,\n        0.05804731615611886\n    ],\n    [\n        0.9999999999999999,\n        -0.1386050432715393,\n        -0.05804731615611886\n    ],\n    [\n        0.9999999999999998,\n        -0.09601924202631895,\n        -0.8118918960560388\n    ]\n];\nvar Jzazbz = new ColorSpace({\n    id: \"jzazbz\",\n    name: \"Jzazbz\",\n    coords: {\n        jz: {\n            refRange: [\n                0,\n                1\n            ],\n            name: \"Jz\"\n        },\n        az: {\n            refRange: [\n                -0.5,\n                0.5\n            ]\n        },\n        bz: {\n            refRange: [\n                -0.5,\n                0.5\n            ]\n        }\n    },\n    base: XYZ_Abs_D65,\n    fromBase (XYZ) {\n        // First make XYZ absolute, not relative to media white\n        // Maximum luminance in PQ is 10,000 cd/m²\n        // Relative XYZ has Y=1 for media white\n        // BT.2048 says media white Y=203 at PQ 58\n        let [Xa, Ya, Za] = XYZ;\n        // modify X and Y\n        let Xm = b$1 * Xa - (b$1 - 1) * Za;\n        let Ym = g * Ya - (g - 1) * Xa;\n        // move to LMS cone domain\n        let LMS = multiplyMatrices(XYZtoCone_M, [\n            Xm,\n            Ym,\n            Za\n        ]);\n        // PQ-encode LMS\n        let PQLMS = LMS.map(function(val) {\n            let num = c1$2 + c2$2 * (val / 10000) ** n$1;\n            let denom = 1 + c3$2 * (val / 10000) ** n$1;\n            return (num / denom) ** p;\n        });\n        // almost there, calculate Iz az bz\n        let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);\n        // console.log({Iz, az, bz});\n        let Jz = (1 + d) * Iz / (1 + d * Iz) - d0;\n        return [\n            Jz,\n            az,\n            bz\n        ];\n    },\n    toBase (Jzazbz) {\n        let [Jz, az, bz] = Jzazbz;\n        let Iz = (Jz + d0) / (1 + d - d * (Jz + d0));\n        // bring into LMS cone domain\n        let PQLMS = multiplyMatrices(IabtoCone_M, [\n            Iz,\n            az,\n            bz\n        ]);\n        // convert from PQ-coded to linear-light\n        let LMS = PQLMS.map(function(val) {\n            let num = c1$2 - val ** pinv;\n            let denom = c3$2 * val ** pinv - c2$2;\n            let x = 10000 * (num / denom) ** ninv$1;\n            return x; // luminance relative to diffuse white, [0, 70 or so].\n        });\n        // modified abs XYZ\n        let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, LMS);\n        // restore standard D50 relative XYZ, relative to media white\n        let Xa = (Xm + (b$1 - 1) * Za) / b$1;\n        let Ya = (Ym + (g - 1) * Xa) / g;\n        return [\n            Xa,\n            Ya,\n            Za\n        ];\n    },\n    formats: {\n        // https://drafts.csswg.org/css-color-hdr/#Jzazbz\n        \"color\": {}\n    }\n});\nvar jzczhz = new ColorSpace({\n    id: \"jzczhz\",\n    name: \"JzCzHz\",\n    coords: {\n        jz: {\n            refRange: [\n                0,\n                1\n            ],\n            name: \"Jz\"\n        },\n        cz: {\n            refRange: [\n                0,\n                1\n            ],\n            name: \"Chroma\"\n        },\n        hz: {\n            refRange: [\n                0,\n                360\n            ],\n            type: \"angle\",\n            name: \"Hue\"\n        }\n    },\n    base: Jzazbz,\n    fromBase (jzazbz) {\n        // Convert to polar form\n        let [Jz, az, bz] = jzazbz;\n        let hue;\n        const ε = 0.0002; // chromatic components much smaller than a,b\n        if (Math.abs(az) < ε && Math.abs(bz) < ε) {\n            hue = NaN;\n        } else {\n            hue = Math.atan2(bz, az) * 180 / Math.PI;\n        }\n        return [\n            Jz,\n            Math.sqrt(az ** 2 + bz ** 2),\n            constrain(hue) // Hue, in degrees [0 to 360)\n        ];\n    },\n    toBase (jzczhz) {\n        // Convert from polar form\n        // debugger;\n        return [\n            jzczhz[0],\n            jzczhz[1] * Math.cos(jzczhz[2] * Math.PI / 180),\n            jzczhz[1] * Math.sin(jzczhz[2] * Math.PI / 180) // bz\n        ];\n    },\n    formats: {\n        color: {}\n    }\n});\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in Lab\n// Uses JzCzHz, which has improved perceptual uniformity\n// and thus a simple Euclidean root-sum of ΔL² ΔC² ΔH²\n// gives good results.\nfunction deltaEJz(color, sample) {\n    // Given this color as the reference\n    // and a sample,\n    // calculate deltaE in JzCzHz.\n    let [Jz1, Cz1, Hz1] = jzczhz.from(color);\n    let [Jz2, Cz2, Hz2] = jzczhz.from(sample);\n    // Lightness and Chroma differences\n    // sign does not matter as they are squared.\n    let ΔJ = Jz1 - Jz2;\n    let ΔC = Cz1 - Cz2;\n    // length of chord for ΔH\n    if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {\n        // both undefined hues\n        Hz1 = 0;\n        Hz2 = 0;\n    } else if (Number.isNaN(Hz1)) {\n        // one undefined, set to the defined hue\n        Hz1 = Hz2;\n    } else if (Number.isNaN(Hz2)) {\n        Hz2 = Hz1;\n    }\n    let Δh = Hz1 - Hz2;\n    let ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(Δh / 2 * (Math.PI / 180));\n    return Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);\n}\nconst c1$1 = 3424 / 4096;\nconst c2$1 = 2413 / 128;\nconst c3$1 = 2392 / 128;\nconst m1 = 2610 / 16384;\nconst m2 = 2523 / 32;\nconst im1 = 16384 / 2610;\nconst im2 = 32 / 2523;\n// The matrix below includes the 4% crosstalk components\n// and is from the Dolby \"What is ICtCp\" paper\"\nconst XYZtoLMS_M$1 = [\n    [\n        0.3592,\n        0.6976,\n        -0.0358\n    ],\n    [\n        -0.1922,\n        1.1004,\n        0.0755\n    ],\n    [\n        0.0070,\n        0.0749,\n        0.8434\n    ]\n];\n// linear-light Rec.2020 to LMS, again with crosstalk\n// rational terms from Jan Fröhlich,\n// Encoding High Dynamic Range andWide Color Gamut Imagery, p.97\n// and ITU-R BT.2124-0 p.2\n/*\nconst Rec2020toLMS_M = [\n\t[ 1688 / 4096,  2146 / 4096,   262 / 4096 ],\n\t[  683 / 4096,  2951 / 4096,   462 / 4096 ],\n\t[   99 / 4096,   309 / 4096,  3688 / 4096 ]\n];\n*/ // this includes the Ebner LMS coefficients,\n// the rotation, and the scaling to [-0.5,0.5] range\n// rational terms from Fröhlich p.97\n// and ITU-R BT.2124-0 pp.2-3\nconst LMStoIPT_M = [\n    [\n        2048 / 4096,\n        2048 / 4096,\n        0\n    ],\n    [\n        6610 / 4096,\n        -13613 / 4096,\n        7003 / 4096\n    ],\n    [\n        17933 / 4096,\n        -17390 / 4096,\n        -543 / 4096\n    ]\n];\n// inverted matrices, calculated from the above\nconst IPTtoLMS_M = [\n    [\n        0.99998889656284013833,\n        0.00860505014728705821,\n        0.1110343715986164786\n    ],\n    [\n        1.0000111034371598616,\n        -0.00860505014728705821,\n        -0.1110343715986164786\n    ],\n    [\n        1.000032063391005412,\n        0.56004913547279000113,\n        -0.32063391005412026469\n    ]\n];\n/*\nconst LMStoRec2020_M = [\n\t[ 3.4375568932814012112,   -2.5072112125095058195,   0.069654319228104608382],\n\t[-0.79142868665644156125,   1.9838372198740089874,  -0.19240853321756742626 ],\n\t[-0.025646662911506476363, -0.099240248643945566751, 1.1248869115554520431  ]\n];\n*/ const LMStoXYZ_M$1 = [\n    [\n        2.0701800566956135096,\n        -1.3264568761030210255,\n        0.20661600684785517081\n    ],\n    [\n        0.36498825003265747974,\n        0.68046736285223514102,\n        -0.045421753075853231409\n    ],\n    [\n        -0.049595542238932107896,\n        -0.049421161186757487412,\n        1.1879959417328034394\n    ]\n];\n// Only the PQ form of ICtCp is implemented here. There is also an HLG form.\n// from Dolby, \"WHAT IS ICTCP?\"\n// https://professional.dolby.com/siteassets/pdfs/ictcp_dolbywhitepaper_v071.pdf\n// and\n// Dolby, \"Perceptual Color Volume\n// Measuring the Distinguishable Colors of HDR and WCG Displays\"\n// https://professional.dolby.com/siteassets/pdfs/dolby-vision-measuring-perceptual-color-volume-v7.1.pdf\nvar ictcp = new ColorSpace({\n    id: \"ictcp\",\n    name: \"ICTCP\",\n    // From BT.2100-2 page 7:\n    // During production, signal values are expected to exceed the\n    // range E′ = [0.0 : 1.0]. This provides processing headroom and avoids\n    // signal degradation during cascaded processing. Such values of E′,\n    // below 0.0 or exceeding 1.0, should not be clipped during production\n    // and exchange.\n    // Values below 0.0 should not be clipped in reference displays (even\n    // though they represent “negative” light) to allow the black level of\n    // the signal (LB) to be properly set using test signals known as “PLUGE”\n    coords: {\n        i: {\n            refRange: [\n                0,\n                1\n            ],\n            name: \"I\"\n        },\n        ct: {\n            refRange: [\n                -0.5,\n                0.5\n            ],\n            name: \"CT\"\n        },\n        cp: {\n            refRange: [\n                -0.5,\n                0.5\n            ],\n            name: \"CP\"\n        }\n    },\n    base: XYZ_Abs_D65,\n    fromBase (XYZ) {\n        // move to LMS cone domain\n        let LMS = multiplyMatrices(XYZtoLMS_M$1, XYZ);\n        return LMStoICtCp(LMS);\n    },\n    toBase (ICtCp) {\n        let LMS = ICtCptoLMS(ICtCp);\n        return multiplyMatrices(LMStoXYZ_M$1, LMS);\n    },\n    formats: {\n        color: {}\n    }\n});\nfunction LMStoICtCp(LMS) {\n    // apply the PQ EOTF\n    // we can't ever be dividing by zero because of the \"1 +\" in the denominator\n    let PQLMS = LMS.map(function(val) {\n        let num = c1$1 + c2$1 * (val / 10000) ** m1;\n        let denom = 1 + c3$1 * (val / 10000) ** m1;\n        return (num / denom) ** m2;\n    });\n    // LMS to IPT, with rotation for Y'C'bC'r compatibility\n    return multiplyMatrices(LMStoIPT_M, PQLMS);\n}\nfunction ICtCptoLMS(ICtCp) {\n    let PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);\n    // From BT.2124-0 Annex 2 Conversion 3\n    let LMS = PQLMS.map(function(val) {\n        let num = Math.max(val ** im2 - c1$1, 0);\n        let denom = c2$1 - c3$1 * val ** im2;\n        return 10000 * (num / denom) ** im1;\n    });\n    return LMS;\n}\n// Delta E in ICtCp space,\n// which the ITU calls Delta E ITP, which is shorter\n// formulae from ITU Rec. ITU-R BT.2124-0\nfunction deltaEITP(color, sample) {\n    // Given this color as the reference\n    // and a sample,\n    // calculate deltaE in ICtCp\n    // which is simply the Euclidean distance\n    let [I1, T1, P1] = ictcp.from(color);\n    let [I2, T2, P2] = ictcp.from(sample);\n    // the 0.25 factor is to undo the encoding scaling in Ct\n    // the 720 is so that 1 deltaE = 1 JND\n    // per  ITU-R BT.2124-0 p.3\n    return 720 * Math.sqrt((I1 - I2) ** 2 + 0.25 * (T1 - T2) ** 2 + (P1 - P2) ** 2);\n}\n// Recalculated for consistent reference white\n// see https://github.com/w3c/csswg-drafts/issues/6642#issuecomment-943521484\nconst XYZtoLMS_M = [\n    [\n        0.8190224432164319,\n        0.3619062562801221,\n        -0.12887378261216414\n    ],\n    [\n        0.0329836671980271,\n        0.9292868468965546,\n        0.03614466816999844\n    ],\n    [\n        0.048177199566046255,\n        0.26423952494422764,\n        0.6335478258136937\n    ]\n];\n// inverse of XYZtoLMS_M\nconst LMStoXYZ_M = [\n    [\n        1.2268798733741557,\n        -0.5578149965554813,\n        0.28139105017721583\n    ],\n    [\n        -0.04057576262431372,\n        1.1122868293970594,\n        -0.07171106666151701\n    ],\n    [\n        -0.07637294974672142,\n        -0.4214933239627914,\n        1.5869240244272418\n    ]\n];\nconst LMStoLab_M = [\n    [\n        0.2104542553,\n        0.7936177850,\n        -0.0040720468\n    ],\n    [\n        1.9779984951,\n        -2.4285922050,\n        0.4505937099\n    ],\n    [\n        0.0259040371,\n        0.7827717662,\n        -0.8086757660\n    ]\n];\n// LMStoIab_M inverted\nconst LabtoLMS_M = [\n    [\n        0.99999999845051981432,\n        0.39633779217376785678,\n        0.21580375806075880339\n    ],\n    [\n        1.0000000088817607767,\n        -0.1055613423236563494,\n        -0.063854174771705903402\n    ],\n    [\n        1.0000000546724109177,\n        -0.089484182094965759684,\n        -1.2914855378640917399\n    ]\n];\nvar OKLab = new ColorSpace({\n    id: \"oklab\",\n    name: \"Oklab\",\n    coords: {\n        l: {\n            refRange: [\n                0,\n                1\n            ],\n            name: \"L\"\n        },\n        a: {\n            refRange: [\n                -0.4,\n                0.4\n            ]\n        },\n        b: {\n            refRange: [\n                -0.4,\n                0.4\n            ]\n        }\n    },\n    // Note that XYZ is relative to D65\n    white: \"D65\",\n    base: XYZ_D65,\n    fromBase (XYZ) {\n        // move to LMS cone domain\n        let LMS = multiplyMatrices(XYZtoLMS_M, XYZ);\n        // non-linearity\n        let LMSg = LMS.map((val)=>Math.cbrt(val));\n        return multiplyMatrices(LMStoLab_M, LMSg);\n    },\n    toBase (OKLab) {\n        // move to LMS cone domain\n        let LMSg = multiplyMatrices(LabtoLMS_M, OKLab);\n        // restore linearity\n        let LMS = LMSg.map((val)=>val ** 3);\n        return multiplyMatrices(LMStoXYZ_M, LMS);\n    },\n    formats: {\n        \"oklab\": {\n            coords: [\n                \"<percentage> | <number>\",\n                \"<number> | <percentage>[-1,1]\",\n                \"<number> | <percentage>[-1,1]\"\n            ]\n        }\n    }\n});\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in CIE Lab\nfunction deltaEOK(color, sample) {\n    // Given this color as the reference\n    // and a sample,\n    // calculate deltaEOK, term by term as root sum of squares\n    let [L1, a1, b1] = OKLab.from(color);\n    let [L2, a2, b2] = OKLab.from(sample);\n    let ΔL = L1 - L2;\n    let Δa = a1 - a2;\n    let Δb = b1 - b2;\n    return Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);\n}\nvar deltaEMethods = {\n    deltaE76,\n    deltaECMC,\n    deltaE2000,\n    deltaEJz,\n    deltaEITP,\n    deltaEOK\n};\nfunction deltaE(c1, c2, o = {}) {\n    if (isString(o)) {\n        o = {\n            method: o\n        };\n    }\n    let { method = defaults.deltaE, ...rest } = o;\n    c1 = getColor(c1);\n    c2 = getColor(c2);\n    for(let m in deltaEMethods){\n        if (\"deltae\" + method.toLowerCase() === m.toLowerCase()) {\n            return deltaEMethods[m](c1, c2, rest);\n        }\n    }\n    throw new TypeError(`Unknown deltaE method: ${method}`);\n}\nfunction lighten(color, amount = .25) {\n    let space = ColorSpace.get(\"oklch\", \"lch\");\n    let lightness = [\n        space,\n        \"l\"\n    ];\n    return set(color, lightness, (l)=>l * (1 + amount));\n}\nfunction darken(color, amount = .25) {\n    let space = ColorSpace.get(\"oklch\", \"lch\");\n    let lightness = [\n        space,\n        \"l\"\n    ];\n    return set(color, lightness, (l)=>l * (1 - amount));\n}\nvar variations = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    darken: darken,\n    lighten: lighten\n});\n/**\n * Functions related to color interpolation\n */ /**\n * Return an intermediate color between two colors\n * Signatures: mix(c1, c2, p, options)\n *             mix(c1, c2, options)\n *             mix(color)\n * @param {Color | string} c1 The first color\n * @param {Color | string} [c2] The second color\n * @param {number} [p=.5] A 0-1 percentage where 0 is c1 and 1 is c2\n * @param {Object} [o={}]\n * @return {Color}\n */ function mix(c1, c2, p = .5, o = {}) {\n    [c1, c2] = [\n        getColor(c1),\n        getColor(c2)\n    ];\n    if (type(p) === \"object\") {\n        [p, o] = [\n            .5,\n            p\n        ];\n    }\n    let { space, outputSpace, premultiplied } = o;\n    let r = range(c1, c2, {\n        space,\n        outputSpace,\n        premultiplied\n    });\n    return r(p);\n}\n/**\n *\n * @param {Color | string | Function} c1 The first color or a range\n * @param {Color | string} [c2] The second color if c1 is not a range\n * @param {Object} [options={}]\n * @return {Color[]}\n */ function steps(c1, c2, options = {}) {\n    let colorRange;\n    if (isRange(c1)) {\n        // Tweaking existing range\n        [colorRange, options] = [\n            c1,\n            c2\n        ];\n        [c1, c2] = colorRange.rangeArgs.colors;\n    }\n    let { maxDeltaE, deltaEMethod, steps = 2, maxSteps = 1000, ...rangeOptions } = options;\n    if (!colorRange) {\n        [c1, c2] = [\n            getColor(c1),\n            getColor(c2)\n        ];\n        colorRange = range(c1, c2, rangeOptions);\n    }\n    let totalDelta = deltaE(c1, c2);\n    let actualSteps = maxDeltaE > 0 ? Math.max(steps, Math.ceil(totalDelta / maxDeltaE) + 1) : steps;\n    let ret = [];\n    if (maxSteps !== undefined) {\n        actualSteps = Math.min(actualSteps, maxSteps);\n    }\n    if (actualSteps === 1) {\n        ret = [\n            {\n                p: .5,\n                color: colorRange(.5)\n            }\n        ];\n    } else {\n        let step = 1 / (actualSteps - 1);\n        ret = Array.from({\n            length: actualSteps\n        }, (_, i)=>{\n            let p = i * step;\n            return {\n                p,\n                color: colorRange(p)\n            };\n        });\n    }\n    if (maxDeltaE > 0) {\n        // Iterate over all stops and find max deltaE\n        let maxDelta = ret.reduce((acc, cur, i)=>{\n            if (i === 0) {\n                return 0;\n            }\n            let ΔΕ = deltaE(cur.color, ret[i - 1].color, deltaEMethod);\n            return Math.max(acc, ΔΕ);\n        }, 0);\n        while(maxDelta > maxDeltaE){\n            // Insert intermediate stops and measure maxDelta again\n            // We need to do this for all pairs, otherwise the midpoint shifts\n            maxDelta = 0;\n            for(let i = 1; i < ret.length && ret.length < maxSteps; i++){\n                let prev = ret[i - 1];\n                let cur = ret[i];\n                let p = (cur.p + prev.p) / 2;\n                let color = colorRange(p);\n                maxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));\n                ret.splice(i, 0, {\n                    p,\n                    color: colorRange(p)\n                });\n                i++;\n            }\n        }\n    }\n    ret = ret.map((a)=>a.color);\n    return ret;\n}\n/**\n * Interpolate to color2 and return a function that takes a 0-1 percentage\n * @param {Color | string | Function} color1 The first color or an existing range\n * @param {Color | string} [color2] If color1 is a color, this is the second color\n * @param {Object} [options={}]\n * @returns {Function} A function that takes a 0-1 percentage and returns a color\n */ function range(color1, color2, options = {}) {\n    if (isRange(color1)) {\n        // Tweaking existing range\n        let [r, options] = [\n            color1,\n            color2\n        ];\n        return range(...r.rangeArgs.colors, {\n            ...r.rangeArgs.options,\n            ...options\n        });\n    }\n    let { space, outputSpace, progression, premultiplied } = options;\n    color1 = getColor(color1);\n    color2 = getColor(color2);\n    // Make sure we're working on copies of these colors\n    color1 = clone(color1);\n    color2 = clone(color2);\n    let rangeArgs = {\n        colors: [\n            color1,\n            color2\n        ],\n        options\n    };\n    if (space) {\n        space = ColorSpace.get(space);\n    } else {\n        space = ColorSpace.registry[defaults.interpolationSpace] || color1.space;\n    }\n    outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;\n    color1 = to(color1, space);\n    color2 = to(color2, space);\n    // Gamut map to avoid areas of flat color\n    color1 = toGamut(color1);\n    color2 = toGamut(color2);\n    // Handle hue interpolation\n    // See https://github.com/w3c/csswg-drafts/issues/4735#issuecomment-635741840\n    if (space.coords.h && space.coords.h.type === \"angle\") {\n        let arc = options.hue = options.hue || \"shorter\";\n        let hue = [\n            space,\n            \"h\"\n        ];\n        let [θ1, θ2] = [\n            get(color1, hue),\n            get(color2, hue)\n        ];\n        [θ1, θ2] = adjust(arc, [\n            θ1,\n            θ2\n        ]);\n        set(color1, hue, θ1);\n        set(color2, hue, θ2);\n    }\n    if (premultiplied) {\n        // not coping with polar spaces yet\n        color1.coords = color1.coords.map((c)=>c * color1.alpha);\n        color2.coords = color2.coords.map((c)=>c * color2.alpha);\n    }\n    return Object.assign((p)=>{\n        p = progression ? progression(p) : p;\n        let coords = color1.coords.map((start, i)=>{\n            let end = color2.coords[i];\n            return interpolate(start, end, p);\n        });\n        let alpha = interpolate(color1.alpha, color2.alpha, p);\n        let ret = {\n            space,\n            coords,\n            alpha\n        };\n        if (premultiplied) {\n            // undo premultiplication\n            ret.coords = ret.coords.map((c)=>c / alpha);\n        }\n        if (outputSpace !== space) {\n            ret = to(ret, outputSpace);\n        }\n        return ret;\n    }, {\n        rangeArgs\n    });\n}\nfunction isRange(val) {\n    return type(val) === \"function\" && !!val.rangeArgs;\n}\ndefaults.interpolationSpace = \"lab\";\nfunction register(Color) {\n    Color.defineFunction(\"mix\", mix, {\n        returns: \"color\"\n    });\n    Color.defineFunction(\"range\", range, {\n        returns: \"function<color>\"\n    });\n    Color.defineFunction(\"steps\", steps, {\n        returns: \"array<color>\"\n    });\n}\nvar interpolation = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    isRange: isRange,\n    mix: mix,\n    range: range,\n    register: register,\n    steps: steps\n});\nvar HSL = new ColorSpace({\n    id: \"hsl\",\n    name: \"HSL\",\n    coords: {\n        h: {\n            refRange: [\n                0,\n                360\n            ],\n            type: \"angle\",\n            name: \"Hue\"\n        },\n        s: {\n            range: [\n                0,\n                100\n            ],\n            name: \"Saturation\"\n        },\n        l: {\n            range: [\n                0,\n                100\n            ],\n            name: \"Lightness\"\n        }\n    },\n    base: sRGB,\n    // Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB\n    fromBase: (rgb)=>{\n        let max = Math.max(...rgb);\n        let min = Math.min(...rgb);\n        let [r, g, b] = rgb;\n        let [h, s, l] = [\n            NaN,\n            0,\n            (min + max) / 2\n        ];\n        let d = max - min;\n        if (d !== 0) {\n            s = l === 0 || l === 1 ? 0 : (max - l) / Math.min(l, 1 - l);\n            switch(max){\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n            }\n            h = h * 60;\n        }\n        return [\n            h,\n            s * 100,\n            l * 100\n        ];\n    },\n    // Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative\n    toBase: (hsl)=>{\n        let [h, s, l] = hsl;\n        h = h % 360;\n        if (h < 0) {\n            h += 360;\n        }\n        s /= 100;\n        l /= 100;\n        function f(n) {\n            let k = (n + h / 30) % 12;\n            let a = s * Math.min(l, 1 - l);\n            return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));\n        }\n        return [\n            f(0),\n            f(8),\n            f(4)\n        ];\n    },\n    formats: {\n        \"hsl\": {\n            toGamut: true,\n            coords: [\n                \"<number> | <angle>\",\n                \"<percentage>\",\n                \"<percentage>\"\n            ]\n        },\n        \"hsla\": {\n            coords: [\n                \"<number> | <angle>\",\n                \"<percentage>\",\n                \"<percentage>\"\n            ],\n            commas: true,\n            lastAlpha: true\n        }\n    }\n});\n// The Hue, Whiteness Blackness (HWB) colorspace\n// See https://drafts.csswg.org/css-color-4/#the-hwb-notation\n// Note that, like HSL, calculations are done directly on\n// gamma-corrected sRGB values rather than linearising them first.\nvar HSV = new ColorSpace({\n    id: \"hsv\",\n    name: \"HSV\",\n    coords: {\n        h: {\n            refRange: [\n                0,\n                360\n            ],\n            type: \"angle\",\n            name: \"Hue\"\n        },\n        s: {\n            range: [\n                0,\n                100\n            ],\n            name: \"Saturation\"\n        },\n        v: {\n            range: [\n                0,\n                100\n            ],\n            name: \"Value\"\n        }\n    },\n    base: HSL,\n    // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion\n    fromBase (hsl) {\n        let [h, s, l] = hsl;\n        s /= 100;\n        l /= 100;\n        let v = l + s * Math.min(l, 1 - l);\n        return [\n            h,\n            v === 0 ? 0 : 200 * (1 - l / v),\n            100 * v\n        ];\n    },\n    // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion\n    toBase (hsv) {\n        let [h, s, v] = hsv;\n        s /= 100;\n        v /= 100;\n        let l = v * (1 - s / 2);\n        return [\n            h,\n            l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l) * 100,\n            l * 100\n        ];\n    },\n    formats: {\n        color: {\n            toGamut: true\n        }\n    }\n});\n// The Hue, Whiteness Blackness (HWB) colorspace\n// See https://drafts.csswg.org/css-color-4/#the-hwb-notation\n// Note that, like HSL, calculations are done directly on\n// gamma-corrected sRGB values rather than linearising them first.\nvar hwb = new ColorSpace({\n    id: \"hwb\",\n    name: \"HWB\",\n    coords: {\n        h: {\n            refRange: [\n                0,\n                360\n            ],\n            type: \"angle\",\n            name: \"Hue\"\n        },\n        w: {\n            range: [\n                0,\n                100\n            ],\n            name: \"Whiteness\"\n        },\n        b: {\n            range: [\n                0,\n                100\n            ],\n            name: \"Blackness\"\n        }\n    },\n    base: HSV,\n    fromBase (hsv) {\n        let [h, s, v] = hsv;\n        return [\n            h,\n            v * (100 - s) / 100,\n            100 - v\n        ];\n    },\n    toBase (hwb) {\n        let [h, w, b] = hwb;\n        // Now convert percentages to [0..1]\n        w /= 100;\n        b /= 100;\n        // Achromatic check (white plus black >= 1)\n        let sum = w + b;\n        if (sum >= 1) {\n            let gray = w / sum;\n            return [\n                h,\n                0,\n                gray * 100\n            ];\n        }\n        let v = 1 - b;\n        let s = v === 0 ? 0 : 1 - w / v;\n        return [\n            h,\n            s * 100,\n            v * 100\n        ];\n    },\n    formats: {\n        \"hwb\": {\n            toGamut: true,\n            coords: [\n                \"<number> | <angle>\",\n                \"<percentage>\",\n                \"<percentage>\"\n            ]\n        }\n    }\n});\n// convert an array of linear-light a98-rgb values to CIE XYZ\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// has greater numerical precision than section 4.3.5.3 of\n// https://www.adobe.com/digitalimag/pdfs/AdobeRGB1998.pdf\n// but the values below were calculated from first principles\n// from the chromaticity coordinates of R G B W\nconst toXYZ_M$2 = [\n    [\n        0.5766690429101305,\n        0.1855582379065463,\n        0.1882286462349947\n    ],\n    [\n        0.29734497525053605,\n        0.6273635662554661,\n        0.07529145849399788\n    ],\n    [\n        0.02703136138641234,\n        0.07068885253582723,\n        0.9913375368376388\n    ]\n];\nconst fromXYZ_M$2 = [\n    [\n        2.0415879038107465,\n        -0.5650069742788596,\n        -0.34473135077832956\n    ],\n    [\n        -0.9692436362808795,\n        1.8759675015077202,\n        0.04155505740717557\n    ],\n    [\n        0.013444280632031142,\n        -0.11836239223101838,\n        1.0151749943912054\n    ]\n];\nvar A98Linear = new RGBColorSpace({\n    id: \"a98rgb-linear\",\n    name: \"Linear Adobe\\xae 98 RGB compatible\",\n    white: \"D65\",\n    toXYZ_M: toXYZ_M$2,\n    fromXYZ_M: fromXYZ_M$2\n});\nvar a98rgb = new RGBColorSpace({\n    id: \"a98rgb\",\n    name: \"Adobe\\xae 98 RGB compatible\",\n    base: A98Linear,\n    toBase: (RGB)=>RGB.map((val)=>Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),\n    fromBase: (RGB)=>RGB.map((val)=>Math.pow(Math.abs(val), 256 / 563) * Math.sign(val)),\n    formats: {\n        color: {\n            id: \"a98-rgb\"\n        }\n    }\n});\n// convert an array of  prophoto-rgb values to CIE XYZ\n// using  D50 (so no chromatic adaptation needed afterwards)\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\nconst toXYZ_M$1 = [\n    [\n        0.7977604896723027,\n        0.13518583717574031,\n        0.0313493495815248\n    ],\n    [\n        0.2880711282292934,\n        0.7118432178101014,\n        0.00008565396060525902\n    ],\n    [\n        0.0,\n        0.0,\n        0.8251046025104601\n    ]\n];\nconst fromXYZ_M$1 = [\n    [\n        1.3457989731028281,\n        -0.25558010007997534,\n        -0.05110628506753401\n    ],\n    [\n        -0.5446224939028347,\n        1.5082327413132781,\n        0.02053603239147973\n    ],\n    [\n        0.0,\n        0.0,\n        1.2119675456389454\n    ]\n];\nvar ProPhotoLinear = new RGBColorSpace({\n    id: \"prophoto-linear\",\n    name: \"Linear ProPhoto\",\n    white: \"D50\",\n    base: XYZ_D50,\n    toXYZ_M: toXYZ_M$1,\n    fromXYZ_M: fromXYZ_M$1\n});\nconst Et = 1 / 512;\nconst Et2 = 16 / 512;\nvar prophoto = new RGBColorSpace({\n    id: \"prophoto\",\n    name: \"ProPhoto\",\n    base: ProPhotoLinear,\n    toBase (RGB) {\n        // Transfer curve is gamma 1.8 with a small linear portion\n        return RGB.map((v)=>v < Et2 ? v / 16 : v ** 1.8);\n    },\n    fromBase (RGB) {\n        return RGB.map((v)=>v >= Et ? v ** (1 / 1.8) : 16 * v);\n    },\n    formats: {\n        color: {\n            id: \"prophoto-rgb\"\n        }\n    }\n});\nvar oklch = new ColorSpace({\n    id: \"oklch\",\n    name: \"Oklch\",\n    coords: {\n        l: {\n            refRange: [\n                0,\n                1\n            ],\n            name: \"Lightness\"\n        },\n        c: {\n            refRange: [\n                0,\n                0.4\n            ],\n            name: \"Chroma\"\n        },\n        h: {\n            refRange: [\n                0,\n                360\n            ],\n            type: \"angle\",\n            name: \"Hue\"\n        }\n    },\n    white: \"D65\",\n    base: OKLab,\n    fromBase (oklab) {\n        // Convert to polar form\n        let [L, a, b] = oklab;\n        let h;\n        const ε = 0.0002; // chromatic components much smaller than a,b\n        if (Math.abs(a) < ε && Math.abs(b) < ε) {\n            h = NaN;\n        } else {\n            h = Math.atan2(b, a) * 180 / Math.PI;\n        }\n        return [\n            L,\n            Math.sqrt(a ** 2 + b ** 2),\n            constrain(h) // Hue, in degrees [0 to 360)\n        ];\n    },\n    // Convert from polar form\n    toBase (oklch) {\n        let [L, C, h] = oklch;\n        let a, b;\n        // check for NaN hue\n        if (isNaN(h)) {\n            a = 0;\n            b = 0;\n        } else {\n            a = C * Math.cos(h * Math.PI / 180);\n            b = C * Math.sin(h * Math.PI / 180);\n        }\n        return [\n            L,\n            a,\n            b\n        ];\n    },\n    formats: {\n        \"oklch\": {\n            coords: [\n                \"<number> | <percentage>\",\n                \"<number> | <percentage>[0,1]\",\n                \"<number> | <angle>\"\n            ]\n        }\n    }\n});\nconst Yw = 203; // absolute luminance of media white, cd/m²\nconst n = 2610 / 2 ** 14;\nconst ninv = 2 ** 14 / 2610;\nconst m = 2523 / 2 ** 5;\nconst minv = 2 ** 5 / 2523;\nconst c1 = 3424 / 2 ** 12;\nconst c2 = 2413 / 2 ** 7;\nconst c3 = 2392 / 2 ** 7;\nvar rec2100Pq = new RGBColorSpace({\n    id: \"rec2100pq\",\n    name: \"REC.2100-PQ\",\n    base: REC2020Linear,\n    toBase (RGB) {\n        // given PQ encoded component in range [0, 1]\n        // return media-white relative linear-light\n        return RGB.map(function(val) {\n            let x = (Math.max(val ** minv - c1, 0) / (c2 - c3 * val ** minv)) ** ninv;\n            return x * 10000 / Yw; // luminance relative to diffuse white, [0, 70 or so].\n        });\n    },\n    fromBase (RGB) {\n        // given media-white relative linear-light\n        // returnPQ encoded component in range [0, 1]\n        return RGB.map(function(val) {\n            let x = Math.max(val * Yw / 10000, 0); // absolute luminance of peak white is 10,000 cd/m².\n            let num = c1 + c2 * x ** n;\n            let denom = 1 + c3 * x ** n;\n            return (num / denom) ** m;\n        });\n    },\n    formats: {\n        color: {\n            id: \"rec2100-pq\"\n        }\n    }\n});\n// FIXME see https://github.com/LeaVerou/color.js/issues/190\nconst a = 0.17883277;\nconst b = 0.28466892; // 1 - (4 * a)\nconst c = 0.55991073; // 0.5 - a * Math.log(4 *a)\nconst scale = 3.7743; // Place 18% grey at HLG 0.38, so media white at 0.75\nvar rec2100Hlg = new RGBColorSpace({\n    id: \"rec2100hlg\",\n    cssid: \"rec2100-hlg\",\n    name: \"REC.2100-HLG\",\n    referred: \"scene\",\n    base: REC2020Linear,\n    toBase (RGB) {\n        // given HLG encoded component in range [0, 1]\n        // return media-white relative linear-light\n        return RGB.map(function(val) {\n            // first the HLG EOTF\n            // ITU-R BT.2390-10 p.30 section\n            // 6.3 The hybrid log-gamma electro-optical transfer function (EOTF)\n            // Then scale by 3 so media white is 1.0\n            if (val <= 0.5) {\n                return val ** 2 / 3 * scale;\n            }\n            return (Math.exp((val - c) / a) + b) / 12 * scale;\n        });\n    },\n    fromBase (RGB) {\n        // given media-white relative linear-light\n        // where diffuse white is 1.0,\n        // return HLG encoded component in range [0, 1]\n        return RGB.map(function(val) {\n            // first scale to put linear-light media white at 1/3\n            val /= scale;\n            // now the HLG OETF\n            // ITU-R BT.2390-10 p.23\n            // 6.1 The hybrid log-gamma opto-electronic transfer function (OETF)\n            if (val <= 1 / 12) {\n                return Math.sqrt(3 * val);\n            }\n            return a * Math.log(12 * val - b) + c;\n        });\n    },\n    formats: {\n        color: {\n            id: \"rec2100-hlg\"\n        }\n    }\n});\nconst CATs = {};\nhooks.add(\"chromatic-adaptation-start\", (env)=>{\n    if (env.options.method) {\n        env.M = adapt(env.W1, env.W2, env.options.method);\n    }\n});\nhooks.add(\"chromatic-adaptation-end\", (env)=>{\n    if (!env.M) {\n        env.M = adapt(env.W1, env.W2, env.options.method);\n    }\n});\nfunction defineCAT({ id, toCone_M, fromCone_M }) {\n    // Use id, toCone_M, fromCone_M like variables\n    CATs[id] = arguments[0];\n}\nfunction adapt(W1, W2, id = \"Bradford\") {\n    // adapt from a source whitepoint or illuminant W1\n    // to a destination whitepoint or illuminant W2,\n    // using the given chromatic adaptation transform (CAT)\n    // debugger;\n    let method = CATs[id];\n    let [ρs, γs, βs] = multiplyMatrices(method.toCone_M, W1);\n    let [ρd, γd, βd] = multiplyMatrices(method.toCone_M, W2);\n    // all practical illuminants have non-zero XYZ so no division by zero can occur below\n    let scale = [\n        [\n            ρd / ρs,\n            0,\n            0\n        ],\n        [\n            0,\n            γd / γs,\n            0\n        ],\n        [\n            0,\n            0,\n            βd / βs\n        ]\n    ];\n    // console.log({scale});\n    let scaled_cone_M = multiplyMatrices(scale, method.toCone_M);\n    let adapt_M = multiplyMatrices(method.fromCone_M, scaled_cone_M);\n    // console.log({scaled_cone_M, adapt_M});\n    return adapt_M;\n}\ndefineCAT({\n    id: \"von Kries\",\n    toCone_M: [\n        [\n            0.4002400,\n            0.7076000,\n            -0.0808100\n        ],\n        [\n            -0.2263000,\n            1.1653200,\n            0.0457000\n        ],\n        [\n            0.0000000,\n            0.0000000,\n            0.9182200\n        ]\n    ],\n    fromCone_M: [\n        [\n            1.8599364,\n            -1.1293816,\n            0.2198974\n        ],\n        [\n            0.3611914,\n            0.6388125,\n            -0.0000064\n        ],\n        [\n            0.0000000,\n            0.0000000,\n            1.0890636\n        ]\n    ]\n});\ndefineCAT({\n    id: \"Bradford\",\n    // Convert an array of XYZ values in the range 0.0 - 1.0\n    // to cone fundamentals\n    toCone_M: [\n        [\n            0.8951000,\n            0.2664000,\n            -0.1614000\n        ],\n        [\n            -0.7502000,\n            1.7135000,\n            0.0367000\n        ],\n        [\n            0.0389000,\n            -0.0685000,\n            1.0296000\n        ]\n    ],\n    // and back\n    fromCone_M: [\n        [\n            0.9869929,\n            -0.1470543,\n            0.1599627\n        ],\n        [\n            0.4323053,\n            0.5183603,\n            0.0492912\n        ],\n        [\n            -0.0085287,\n            0.0400428,\n            0.9684867\n        ]\n    ]\n});\ndefineCAT({\n    id: \"CAT02\",\n    // with complete chromatic adaptation to W2, so D = 1.0\n    toCone_M: [\n        [\n            0.7328000,\n            0.4296000,\n            -0.1624000\n        ],\n        [\n            -0.7036000,\n            1.6975000,\n            0.0061000\n        ],\n        [\n            0.0030000,\n            0.0136000,\n            0.9834000\n        ]\n    ],\n    fromCone_M: [\n        [\n            1.0961238,\n            -0.2788690,\n            0.1827452\n        ],\n        [\n            0.4543690,\n            0.4735332,\n            0.0720978\n        ],\n        [\n            -0.0096276,\n            -0.0056980,\n            1.0153256\n        ]\n    ]\n});\ndefineCAT({\n    id: \"CAT16\",\n    toCone_M: [\n        [\n            0.401288,\n            0.650173,\n            -0.051461\n        ],\n        [\n            -0.250268,\n            1.204414,\n            0.045854\n        ],\n        [\n            -0.002079,\n            0.048952,\n            0.953127\n        ]\n    ],\n    // the extra precision is needed to avoid roundtripping errors\n    fromCone_M: [\n        [\n            1.862067855087233e+0,\n            -1.011254630531685e+0,\n            1.491867754444518e-1\n        ],\n        [\n            3.875265432361372e-1,\n            6.214474419314753e-1,\n            -8.973985167612518e-3\n        ],\n        [\n            -1.584149884933386e-2,\n            -3.412293802851557e-2,\n            1.049964436877850e+0\n        ]\n    ]\n});\nObject.assign(WHITES, {\n    // whitepoint values from ASTM E308-01 with 10nm spacing, 1931 2 degree observer\n    // all normalized to Y (luminance) = 1.00000\n    // Illuminant A is a tungsten electric light, giving a very warm, orange light.\n    A: [\n        1.09850,\n        1.00000,\n        0.35585\n    ],\n    // Illuminant C was an early approximation to daylight: illuminant A with a blue filter.\n    C: [\n        0.98074,\n        1.000000,\n        1.18232\n    ],\n    // The daylight series of illuminants simulate natural daylight.\n    // The color temperature (in degrees Kelvin/100) ranges from\n    // cool, overcast daylight (D50) to bright, direct sunlight (D65).\n    D55: [\n        0.95682,\n        1.00000,\n        0.92149\n    ],\n    D75: [\n        0.94972,\n        1.00000,\n        1.22638\n    ],\n    // Equal-energy illuminant, used in two-stage CAT16\n    E: [\n        1.00000,\n        1.00000,\n        1.00000\n    ],\n    // The F series of illuminants represent fluorescent lights\n    F2: [\n        0.99186,\n        1.00000,\n        0.67393\n    ],\n    F7: [\n        0.95041,\n        1.00000,\n        1.08747\n    ],\n    F11: [\n        1.00962,\n        1.00000,\n        0.64350\n    ]\n});\n// The ACES whitepoint\n// see TB-2018-001 Derivation of the ACES White Point CIE Chromaticity Coordinates\n// also https://github.com/ampas/aces-dev/blob/master/documents/python/TB-2018-001/aces_wp.py\n// Similar to D60\nWHITES.ACES = [\n    0.32168 / 0.33767,\n    1.00000,\n    (1.00000 - 0.32168 - 0.33767) / 0.33767\n];\n// convert an array of linear-light ACEScc values to CIE XYZ\nconst toXYZ_M = [\n    [\n        0.6624541811085053,\n        0.13400420645643313,\n        0.1561876870049078\n    ],\n    [\n        0.27222871678091454,\n        0.6740817658111484,\n        0.05368951740793705\n    ],\n    [\n        -0.005574649490394108,\n        0.004060733528982826,\n        1.0103391003129971\n    ]\n];\nconst fromXYZ_M = [\n    [\n        1.6410233796943257,\n        -0.32480329418479,\n        -0.23642469523761225\n    ],\n    [\n        -0.6636628587229829,\n        1.6153315916573379,\n        0.016756347685530137\n    ],\n    [\n        0.011721894328375376,\n        -0.008284441996237409,\n        0.9883948585390215\n    ]\n];\nvar ACEScg = new RGBColorSpace({\n    id: \"acescg\",\n    name: \"ACEScg\",\n    // ACEScg – A scene-referred, linear-light encoding of ACES Data\n    // https://docs.acescentral.com/specifications/acescg/\n    // uses the AP1 primaries, see section 4.3.1 Color primaries\n    coords: {\n        r: {\n            range: [\n                0,\n                65504\n            ],\n            name: \"Red\"\n        },\n        g: {\n            range: [\n                0,\n                65504\n            ],\n            name: \"Green\"\n        },\n        b: {\n            range: [\n                0,\n                65504\n            ],\n            name: \"Blue\"\n        }\n    },\n    referred: \"scene\",\n    white: WHITES.ACES,\n    toXYZ_M,\n    fromXYZ_M,\n    formats: {\n        color: {}\n    }\n});\n// export default Color;\nconst ε = 2 ** -16;\n// the smallest value which, in the 32bit IEEE 754 float encoding,\n// decodes as a non-negative value\nconst ACES_min_nonzero = -0.35828683;\n// brightest encoded value, decodes to 65504\nconst ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52; // 1.468\nvar acescc = new RGBColorSpace({\n    id: \"acescc\",\n    name: \"ACEScc\",\n    // see S-2014-003 ACEScc – A Logarithmic Encoding of ACES Data\n    // https://docs.acescentral.com/specifications/acescc/\n    // uses the AP1 primaries, see section 4.3.1 Color primaries\n    // Appendix A: \"Very small ACES scene referred values below 7 1/4 stops\n    // below 18% middle gray are encoded as negative ACEScc values.\n    // These values should be preserved per the encoding in Section 4.4\n    // so that all positive ACES values are maintained.\"\n    coords: {\n        r: {\n            range: [\n                ACES_min_nonzero,\n                ACES_cc_max\n            ],\n            name: \"Red\"\n        },\n        g: {\n            range: [\n                ACES_min_nonzero,\n                ACES_cc_max\n            ],\n            name: \"Green\"\n        },\n        b: {\n            range: [\n                ACES_min_nonzero,\n                ACES_cc_max\n            ],\n            name: \"Blue\"\n        }\n    },\n    referred: \"scene\",\n    base: ACEScg,\n    // from section 4.4.2 Decoding Function\n    toBase (RGB) {\n        const low = (9.72 - 15) / 17.52; // -0.3014\n        return RGB.map(function(val) {\n            if (val <= low) {\n                return (2 ** (val * 17.52 - 9.72) - ε) * 2; // very low values, below -0.3014\n            } else if (val < ACES_cc_max) {\n                return 2 ** (val * 17.52 - 9.72);\n            } else {\n                return 65504;\n            }\n        });\n    },\n    // Non-linear encoding function from S-2014-003, section 4.4.1 Encoding Function\n    fromBase (RGB) {\n        return RGB.map(function(val) {\n            if (val <= 0) {\n                return (Math.log2(ε) + 9.72) / 17.52; // -0.3584\n            } else if (val < ε) {\n                return (Math.log2(ε + val * 0.5) + 9.72) / 17.52;\n            } else {\n                return (Math.log2(val) + 9.72) / 17.52;\n            }\n        });\n    },\n    // encoded media white (rgb 1,1,1) => linear  [ 222.861, 222.861, 222.861 ]\n    // encoded media black (rgb 0,0,0) => linear [ 0.0011857, 0.0011857, 0.0011857]\n    formats: {\n        color: {}\n    }\n});\nvar spaces = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    A98RGB: a98rgb,\n    A98RGB_Linear: A98Linear,\n    ACEScc: acescc,\n    ACEScg: ACEScg,\n    HSL: HSL,\n    HSV: HSV,\n    HWB: hwb,\n    ICTCP: ictcp,\n    JzCzHz: jzczhz,\n    Jzazbz: Jzazbz,\n    LCH: lch,\n    Lab: lab,\n    Lab_D65: lab_d65,\n    OKLCH: oklch,\n    OKLab: OKLab,\n    P3: P3,\n    P3_Linear: P3Linear,\n    ProPhoto: prophoto,\n    ProPhoto_Linear: ProPhotoLinear,\n    REC_2020: REC2020,\n    REC_2020_Linear: REC2020Linear,\n    REC_2100_HLG: rec2100Hlg,\n    REC_2100_PQ: rec2100Pq,\n    XYZ_ABS_D65: XYZ_Abs_D65,\n    XYZ_D50: XYZ_D50,\n    XYZ_D65: XYZ_D65,\n    sRGB: sRGB,\n    sRGB_Linear: sRGBLinear\n});\n/**\n * Class that represents a color\n */ class Color {\n    /**\n\t * Creates an instance of Color.\n\t * Signatures:\n\t * - `new Color(stringToParse)`\n\t * - `new Color(otherColor)`\n\t * - `new Color({space, coords, alpha})`\n\t * - `new Color(space, coords, alpha)`\n\t * - `new Color(spaceId, coords, alpha)`\n\t */ constructor(...args){\n        let color;\n        if (args.length === 1) {\n            color = getColor(args[0]);\n        }\n        let space, coords, alpha;\n        if (color) {\n            space = color.space || color.spaceId;\n            coords = color.coords;\n            alpha = color.alpha;\n        } else {\n            // default signature new Color(ColorSpace, array [, alpha])\n            [space, coords, alpha] = args;\n        }\n        Object.defineProperty(this, \"space\", {\n            value: ColorSpace.get(space),\n            writable: false,\n            enumerable: true,\n            configurable: true\n        });\n        this.coords = coords ? coords.slice() : [\n            0,\n            0,\n            0\n        ];\n        this.alpha = alpha < 1 ? alpha : 1; // this also deals with NaN etc\n        // Convert \"NaN\" to NaN\n        for(let i = 0; i < this.coords.length; i++){\n            if (this.coords[i] === \"NaN\") {\n                this.coords[i] = NaN;\n            }\n        }\n        // Define getters and setters for each coordinate\n        for(let id in this.space.coords){\n            Object.defineProperty(this, id, {\n                get: ()=>this.get(id),\n                set: (value)=>this.set(id, value)\n            });\n        }\n    }\n    get spaceId() {\n        return this.space.id;\n    }\n    clone() {\n        return new Color(this.space, this.coords, this.alpha);\n    }\n    toJSON() {\n        return {\n            spaceId: this.spaceId,\n            coords: this.coords,\n            alpha: this.alpha\n        };\n    }\n    display(...args) {\n        let ret = display(this, ...args);\n        // Convert color object to Color instance\n        ret.color = new Color(ret.color);\n        return ret;\n    }\n    /**\n\t * Get a color from the argument passed\n\t * Basically gets us the same result as new Color(color) but doesn't clone an existing color object\n\t */ static get(color, ...args) {\n        if (color instanceof Color) {\n            return color;\n        }\n        return new Color(color, ...args);\n    }\n    static defineFunction(name, code, o = code) {\n        let { instance = true, returns } = o;\n        let func = function(...args) {\n            let ret = code(...args);\n            if (returns === \"color\") {\n                ret = Color.get(ret);\n            } else if (returns === \"function<color>\") {\n                let f = ret;\n                ret = function(...args) {\n                    let ret = f(...args);\n                    return Color.get(ret);\n                };\n                // Copy any function metadata\n                Object.assign(ret, f);\n            } else if (returns === \"array<color>\") {\n                ret = ret.map((c)=>Color.get(c));\n            }\n            return ret;\n        };\n        if (!(name in Color)) {\n            Color[name] = func;\n        }\n        if (instance) {\n            Color.prototype[name] = function(...args) {\n                return func(this, ...args);\n            };\n        }\n    }\n    static defineFunctions(o) {\n        for(let name in o){\n            Color.defineFunction(name, o[name], o[name]);\n        }\n    }\n    static extend(exports) {\n        if (exports.register) {\n            exports.register(Color);\n        } else {\n            // No register method, just add the module's functions\n            for(let name in exports){\n                Color.defineFunction(name, exports[name]);\n            }\n        }\n    }\n}\nColor.defineFunctions({\n    get,\n    getAll,\n    set,\n    setAll,\n    to,\n    equals,\n    inGamut,\n    toGamut,\n    distance,\n    toString: serialize\n});\nObject.assign(Color, {\n    util,\n    hooks,\n    WHITES,\n    Space: ColorSpace,\n    spaces: ColorSpace.registry,\n    parse,\n    // Global defaults one may want to configure\n    defaults\n});\nfor (let key of Object.keys(spaces)){\n    ColorSpace.register(spaces[key]);\n}\n/**\n * This plugin defines getters and setters for color[spaceId]\n * e.g. color.lch on *any* color gives us the lch coords\n */ // Add space accessors to existing color spaces\nfor(let id in ColorSpace.registry){\n    addSpaceAccessors(id, ColorSpace.registry[id]);\n}\n// Add space accessors to color spaces not yet created\nhooks.add(\"colorspace-init-end\", (space)=>{\n    addSpaceAccessors(space.id, space);\n    space.aliases?.forEach((alias)=>{\n        addSpaceAccessors(alias, space);\n    });\n});\nfunction addSpaceAccessors(id, space) {\n    // Coordinates can be looked up by both id and name\n    Object.keys(space.coords);\n    Object.values(space.coords).map((c)=>c.name);\n    let propId = id.replace(/-/g, \"_\");\n    Object.defineProperty(Color.prototype, propId, {\n        // Convert coords to coords in another colorspace and return them\n        // Source colorspace: this.spaceId\n        // Target colorspace: id\n        get () {\n            let ret = this.getAll(id);\n            if (typeof Proxy === \"undefined\") {\n                // If proxies are not supported, just return a static array\n                return ret;\n            }\n            // Enable color.spaceId.coordName syntax\n            return new Proxy(ret, {\n                has: (obj, property)=>{\n                    try {\n                        ColorSpace.resolveCoord([\n                            space,\n                            property\n                        ]);\n                        return true;\n                    } catch (e) {}\n                    return Reflect.has(obj, property);\n                },\n                get: (obj, property, receiver)=>{\n                    if (property && typeof property !== \"symbol\" && !(property in obj)) {\n                        let { index } = ColorSpace.resolveCoord([\n                            space,\n                            property\n                        ]);\n                        if (index >= 0) {\n                            return obj[index];\n                        }\n                    }\n                    return Reflect.get(obj, property, receiver);\n                },\n                set: (obj, property, value, receiver)=>{\n                    if (property && typeof property !== \"symbol\" && !(property in obj) || property >= 0) {\n                        let { index } = ColorSpace.resolveCoord([\n                            space,\n                            property\n                        ]);\n                        if (index >= 0) {\n                            obj[index] = value;\n                            // Update color.coords\n                            this.setAll(id, obj);\n                            return true;\n                        }\n                    }\n                    return Reflect.set(obj, property, value, receiver);\n                }\n            });\n        },\n        // Convert coords in another colorspace to internal coords and set them\n        // Target colorspace: this.spaceId\n        // Source colorspace: id\n        set (coords) {\n            this.setAll(id, coords);\n        },\n        configurable: true,\n        enumerable: true\n    });\n}\n// Import all modules of Color.js\nColor.extend(deltaEMethods);\nColor.extend({\n    deltaE\n});\nObject.assign(Color, {\n    deltaEMethods\n});\nColor.extend(variations);\nColor.extend({\n    contrast\n});\nColor.extend(chromaticity);\nColor.extend(luminance);\nColor.extend(interpolation);\nColor.extend(contrastMethods);\n //# sourceMappingURL=color.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY29sb3Jqcy5pby9kaXN0L2NvbG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw0Q0FBNEM7QUFDNUMsU0FBU0EsaUJBQWtCQyxDQUFDLEVBQUVDLENBQUM7SUFDOUIsSUFBSUMsSUFBSUYsRUFBRUcsTUFBTTtJQUVoQixJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsR0FBRztRQUN6QiwyQ0FBMkM7UUFDM0NBLElBQUk7WUFBQ0E7U0FBRTtJQUNSO0lBRUEsSUFBSSxDQUFDSSxNQUFNQyxPQUFPLENBQUNKLENBQUMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsZ0RBQWdEO1FBQ2hEQSxJQUFJQSxFQUFFSyxHQUFHLENBQUNDLENBQUFBLElBQUs7Z0JBQUNBO2FBQUU7SUFDbkI7SUFFQSxJQUFJQyxJQUFJUCxDQUFDLENBQUMsRUFBRSxDQUFDRSxNQUFNO0lBQ25CLElBQUlNLFNBQVNSLENBQUMsQ0FBQyxFQUFFLENBQUNLLEdBQUcsQ0FBQyxDQUFDSSxHQUFHQyxJQUFNVixFQUFFSyxHQUFHLENBQUNDLENBQUFBLElBQUtBLENBQUMsQ0FBQ0ksRUFBRSxJQUFJLGNBQWM7SUFDakUsSUFBSUMsVUFBVVosRUFBRU0sR0FBRyxDQUFDTyxDQUFBQSxNQUFPSixPQUFPSCxHQUFHLENBQUNRLENBQUFBO1lBQ3JDLElBQUlDLE1BQU07WUFFVixJQUFJLENBQUNYLE1BQU1DLE9BQU8sQ0FBQ1EsTUFBTTtnQkFDeEIsS0FBSyxJQUFJRyxLQUFLRixJQUFLO29CQUNsQkMsT0FBT0YsTUFBTUc7Z0JBQ2Q7Z0JBRUEsT0FBT0Q7WUFDUjtZQUVBLElBQUssSUFBSUosSUFBRSxHQUFHQSxJQUFJRSxJQUFJVixNQUFNLEVBQUVRLElBQUs7Z0JBQ2xDSSxPQUFPRixHQUFHLENBQUNGLEVBQUUsR0FBSUcsQ0FBQUEsR0FBRyxDQUFDSCxFQUFFLElBQUk7WUFDNUI7WUFFQSxPQUFPSTtRQUNSO0lBRUEsSUFBSWIsTUFBTSxH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QUNEO1FBQ0Q7UUFDQSx1RUFBdUU7UUFDdkUsa0NBQWtDO1FBQ2xDLHdCQUF3QjtRQUN4QjNaLEtBQUs5RixNQUFNO1lBQ1YsSUFBSSxDQUFDNkYsTUFBTSxDQUFDbkcsSUFBSU07UUFDakI7UUFDQWEsY0FBYztRQUNkRCxZQUFZO0lBQ2I7QUFDRDtBQUVBLGlDQUFpQztBQUVqQ3VPLE1BQU0wUCxNQUFNLENBQUM3RztBQUNiN0ksTUFBTTBQLE1BQU0sQ0FBQztJQUFDbGdCO0FBQU07QUFDcEJsRSxPQUFPZ0wsTUFBTSxDQUFDMEosT0FBTztJQUFDNkk7QUFBYTtBQUNuQzdJLE1BQU0wUCxNQUFNLENBQUN4RztBQUNibEosTUFBTTBQLE1BQU0sQ0FBQztJQUFDOU07QUFBUTtBQUN0QjVDLE1BQU0wUCxNQUFNLENBQUNsTTtBQUNieEQsTUFBTTBQLE1BQU0sQ0FBQ3pQO0FBQ2JELE1BQU0wUCxNQUFNLENBQUM3RTtBQUNiN0ssTUFBTTBQLE1BQU0sQ0FBQzVNO0FBRWUsQ0FDNUIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3ZlcnJlYWN0ZWQvLi9ub2RlX21vZHVsZXMvY29sb3Jqcy5pby9kaXN0L2NvbG9yLmpzPzk1MjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBpcyBtIHggbi4gQiBpcyBuIHggcC4gcHJvZHVjdCBpcyBtIHggcC5cbmZ1bmN0aW9uIG11bHRpcGx5TWF0cmljZXMgKEEsIEIpIHtcblx0bGV0IG0gPSBBLmxlbmd0aDtcblxuXHRpZiAoIUFycmF5LmlzQXJyYXkoQVswXSkpIHtcblx0XHQvLyBBIGlzIHZlY3RvciwgY29udmVydCB0byBbW2EsIGIsIGMsIC4uLl1dXG5cdFx0QSA9IFtBXTtcblx0fVxuXG5cdGlmICghQXJyYXkuaXNBcnJheShCWzBdKSkge1xuXHRcdC8vIEIgaXMgdmVjdG9yLCBjb252ZXJ0IHRvIFtbYV0sIFtiXSwgW2NdLCAuLi5dXVxuXHRcdEIgPSBCLm1hcCh4ID0+IFt4XSk7XG5cdH1cblxuXHRsZXQgcCA9IEJbMF0ubGVuZ3RoO1xuXHRsZXQgQl9jb2xzID0gQlswXS5tYXAoKF8sIGkpID0+IEIubWFwKHggPT4geFtpXSkpOyAvLyB0cmFuc3Bvc2UgQlxuXHRsZXQgcHJvZHVjdCA9IEEubWFwKHJvdyA9PiBCX2NvbHMubWFwKGNvbCA9PiB7XG5cdFx0bGV0IHJldCA9IDA7XG5cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkocm93KSkge1xuXHRcdFx0Zm9yIChsZXQgYyBvZiBjb2wpIHtcblx0XHRcdFx0cmV0ICs9IHJvdyAqIGM7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaT0wOyBpIDwgcm93Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRyZXQgKz0gcm93W2ldICogKGNvbFtpXSB8fCAwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9KSk7XG5cblx0aWYgKG0gPT09IDEpIHtcblx0XHRwcm9kdWN0ID0gcHJvZHVjdFswXTsgLy8gQXZvaWQgW1thLCBiLCBjLCAuLi5dXVxuXHR9XG5cblx0aWYgKHAgPT09IDEpIHtcblx0XHRyZXR1cm4gcHJvZHVjdC5tYXAoeCA9PiB4WzBdKTsgLy8gQXZvaWQgW1thXSwgW2JdLCBbY10sIC4uLl1dXG5cdH1cblxuXHRyZXR1cm4gcHJvZHVjdDtcbn1cblxuLyoqXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zXG4gKi9cblxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcgKGluY2x1ZGluZyBhIFN0cmluZyBvYmplY3QpXG4gKiBAcGFyYW0geyp9IHN0ciAtIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcgKHN0cikge1xuXHRyZXR1cm4gdHlwZShzdHIpID09PSBcInN0cmluZ1wiO1xufVxuXG4vKipcbiAqIERldGVybWluZSB0aGUgaW50ZXJuYWwgSmF2YVNjcmlwdCBbW0NsYXNzXV0gb2YgYW4gb2JqZWN0LlxuICogQHBhcmFtIHsqfSBvIC0gVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHR5cGUgKG8pIHtcblx0bGV0IHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcblxuXHRyZXR1cm4gKHN0ci5tYXRjaCgvXlxcW29iamVjdFxccysoLio/KVxcXSQvKVsxXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIFJvdW5kIGEgbnVtYmVyIHRvIGEgY2VydGFpbiBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgdG8gcm91bmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjaXNpb24gLSBOdW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXG4gKi9cbmZ1bmN0aW9uIHRvUHJlY2lzaW9uIChuLCBwcmVjaXNpb24pIHtcblx0biA9ICtuO1xuXHRwcmVjaXNpb24gPSArcHJlY2lzaW9uO1xuXHRsZXQgaW50ZWdlckxlbmd0aCA9IChNYXRoLmZsb29yKG4pICsgXCJcIikubGVuZ3RoO1xuXG5cdGlmIChwcmVjaXNpb24gPiBpbnRlZ2VyTGVuZ3RoKSB7XG5cdFx0cmV0dXJuICtuLnRvRml4ZWQocHJlY2lzaW9uIC0gaW50ZWdlckxlbmd0aCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0bGV0IHAxMCA9IDEwICoqIChpbnRlZ2VyTGVuZ3RoIC0gcHJlY2lzaW9uKTtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChuIC8gcDEwKSAqIHAxMDtcblx0fVxufVxuXG4vKipcbiogUGFyc2UgYSBDU1MgZnVuY3Rpb24sIHJlZ2FyZGxlc3Mgb2YgaXRzIG5hbWUgYW5kIGFyZ3VtZW50c1xuKiBAcGFyYW0gU3RyaW5nIHN0ciBTdHJpbmcgdG8gcGFyc2VcbiogQHJldHVybiB7e25hbWUsIGFyZ3MsIHJhd0FyZ3N9fVxuKi9cbmZ1bmN0aW9uIHBhcnNlRnVuY3Rpb24gKHN0cikge1xuXHRpZiAoIXN0cikge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHN0ciA9IHN0ci50cmltKCk7XG5cblx0Y29uc3QgaXNGdW5jdGlvblJlZ2V4ID0gL14oW2Etel0rKVxcKCguKz8pXFwpJC9pO1xuXHRjb25zdCBpc051bWJlclJlZ2V4ID0gL14tP1tcXGQuXSskLztcblx0bGV0IHBhcnRzID0gc3RyLm1hdGNoKGlzRnVuY3Rpb25SZWdleCk7XG5cblx0aWYgKHBhcnRzKSB7XG5cdFx0Ly8gSXQgaXMgYSBmdW5jdGlvbiwgcGFyc2UgYXJnc1xuXHRcdGxldCBhcmdzID0gW107XG5cdFx0cGFydHNbMl0ucmVwbGFjZSgvXFwvP1xccyooWy1cXHcuXSsoPzolfGRlZyk/KS9nLCAoJDAsIGFyZykgPT4ge1xuXHRcdFx0aWYgKC8lJC8udGVzdChhcmcpKSB7XG5cdFx0XHRcdC8vIENvbnZlcnQgcGVyY2VudGFnZXMgdG8gMC0xIG51bWJlcnNcblx0XHRcdFx0YXJnID0gbmV3IE51bWJlcihhcmcuc2xpY2UoMCwgLTEpIC8gMTAwKTtcblx0XHRcdFx0YXJnLnR5cGUgPSBcIjxwZXJjZW50YWdlPlwiO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoL2RlZyQvLnRlc3QoYXJnKSkge1xuXHRcdFx0XHQvLyBEcm9wIGRlZyBmcm9tIGRlZ3JlZXMgYW5kIGNvbnZlcnQgdG8gbnVtYmVyXG5cdFx0XHRcdC8vIFRPRE8gaGFuZGxlIG90aGVyIHVuaXRzIHRvb1xuXHRcdFx0XHRhcmcgPSBuZXcgTnVtYmVyKCthcmcuc2xpY2UoMCwgLTMpKTtcblx0XHRcdFx0YXJnLnR5cGUgPSBcIjxhbmdsZT5cIjtcblx0XHRcdFx0YXJnLnVuaXQgPSBcImRlZ1wiO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoaXNOdW1iZXJSZWdleC50ZXN0KGFyZykpIHtcblx0XHRcdFx0Ly8gQ29udmVydCBudW1lcmljYWwgYXJncyB0byBudW1iZXJzXG5cdFx0XHRcdGFyZyA9IG5ldyBOdW1iZXIoYXJnKTtcblx0XHRcdFx0YXJnLnR5cGUgPSBcIjxudW1iZXI+XCI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgkMC5zdGFydHNXaXRoKFwiL1wiKSkge1xuXHRcdFx0XHQvLyBJdCdzIGFscGhhXG5cdFx0XHRcdGFyZyA9IGFyZyBpbnN0YW5jZW9mIE51bWJlcj8gYXJnIDogbmV3IE51bWJlcihhcmcpO1xuXHRcdFx0XHRhcmcuYWxwaGEgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRhcmdzLnB1c2goYXJnKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0cmF3TmFtZTogcGFydHNbMV0sXG5cdFx0XHRyYXdBcmdzOiBwYXJ0c1syXSxcblx0XHRcdC8vIEFuIGFyZ3VtZW50IGNvdWxkIGJlIChhcyBvZiBjc3MtY29sb3ItNCk6XG5cdFx0XHQvLyBhIG51bWJlciwgcGVyY2VudGFnZSwgZGVncmVlcyAoaHVlKSwgaWRlbnQgKGluIGNvbG9yKCkpXG5cdFx0XHRhcmdzXG5cdFx0fTtcblx0fVxufVxuXG5mdW5jdGlvbiBsYXN0IChhcnIpIHtcblx0cmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlIChzdGFydCwgZW5kLCBwKSB7XG5cdGlmIChpc05hTihzdGFydCkpIHtcblx0XHRyZXR1cm4gZW5kO1xuXHR9XG5cblx0aWYgKGlzTmFOKGVuZCkpIHtcblx0XHRyZXR1cm4gc3RhcnQ7XG5cdH1cblxuXHRyZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcDtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVJbnYgKHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG5cdHJldHVybiAodmFsdWUgLSBzdGFydCkgLyAoZW5kIC0gc3RhcnQpO1xufVxuXG5mdW5jdGlvbiBtYXBSYW5nZSAoZnJvbSwgdG8sIHZhbHVlKSB7XG5cdHJldHVybiBpbnRlcnBvbGF0ZSh0b1swXSwgdG9bMV0sIGludGVycG9sYXRlSW52KGZyb21bMF0sIGZyb21bMV0sIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29vcmRHcmFtbWFyIChjb29yZEdyYW1tYXJzKSB7XG5cdHJldHVybiBjb29yZEdyYW1tYXJzLm1hcChjb29yZEdyYW1tYXIgPT4ge1xuXHRcdHJldHVybiBjb29yZEdyYW1tYXIuc3BsaXQoXCJ8XCIpLm1hcCh0eXBlID0+IHtcblx0XHRcdHR5cGUgPSB0eXBlLnRyaW0oKTtcblx0XHRcdGxldCByYW5nZSA9IHR5cGUubWF0Y2goL14oPFthLXpdKz4pXFxbKC0/Wy5cXGRdKyksXFxzKigtP1suXFxkXSspXFxdPyQvKTtcblxuXHRcdFx0aWYgKHJhbmdlKSB7XG5cdFx0XHRcdGxldCByZXQgPSBuZXcgU3RyaW5nKHJhbmdlWzFdKTtcblx0XHRcdFx0cmV0LnJhbmdlID0gWytyYW5nZVsyXSwgK3JhbmdlWzNdXTtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fSk7XG5cdH0pO1xufVxuXG52YXIgdXRpbCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGUsXG5cdGludGVycG9sYXRlSW52OiBpbnRlcnBvbGF0ZUludixcblx0aXNTdHJpbmc6IGlzU3RyaW5nLFxuXHRsYXN0OiBsYXN0LFxuXHRtYXBSYW5nZTogbWFwUmFuZ2UsXG5cdG11bHRpcGx5TWF0cmljZXM6IG11bHRpcGx5TWF0cmljZXMsXG5cdHBhcnNlQ29vcmRHcmFtbWFyOiBwYXJzZUNvb3JkR3JhbW1hcixcblx0cGFyc2VGdW5jdGlvbjogcGFyc2VGdW5jdGlvbixcblx0dG9QcmVjaXNpb246IHRvUHJlY2lzaW9uLFxuXHR0eXBlOiB0eXBlXG59KTtcblxuLyoqXG4gKiBBIGNsYXNzIGZvciBhZGRpbmcgZGVlcCBleHRlbnNpYmlsaXR5IHRvIGFueSBwaWVjZSBvZiBKUyBjb2RlXG4gKi9cbmNsYXNzIEhvb2tzIHtcblx0YWRkIChuYW1lLCBjYWxsYmFjaywgZmlyc3QpIHtcblx0XHRpZiAodHlwZW9mIGFyZ3VtZW50c1swXSAhPSBcInN0cmluZ1wiKSB7XG5cdFx0XHQvLyBNdWx0aXBsZSBob29rc1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBhcmd1bWVudHNbMF0pIHtcblx0XHRcdFx0dGhpcy5hZGQobmFtZSwgYXJndW1lbnRzWzBdW25hbWVdLCBhcmd1bWVudHNbMV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0KEFycmF5LmlzQXJyYXkobmFtZSk/IG5hbWUgOiBbbmFtZV0pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHRoaXNbbmFtZV0gPSB0aGlzW25hbWVdIHx8IFtdO1xuXG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0dGhpc1tuYW1lXVtmaXJzdD8gXCJ1bnNoaWZ0XCIgOiBcInB1c2hcIl0oY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpO1xuXHR9XG5cblx0cnVuIChuYW1lLCBlbnYpIHtcblx0XHR0aGlzW25hbWVdID0gdGhpc1tuYW1lXSB8fCBbXTtcblx0XHR0aGlzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjay5jYWxsKGVudiAmJiBlbnYuY29udGV4dD8gZW52LmNvbnRleHQgOiBlbnYsIGVudik7XG5cdFx0fSk7XG5cdH1cbn1cbi8qKlxuICogVGhlIGluc3RhbmNlIG9mIHtAbGluayBIb29rc30gdXNlZCB0aHJvdWdob3V0IENvbG9yLmpzXG4gKi9cbmNvbnN0IGhvb2tzID0gbmV3IEhvb2tzKCk7XG5cbi8vIEdsb2JhbCBkZWZhdWx0cyBvbmUgbWF5IHdhbnQgdG8gY29uZmlndXJlXG5cbnZhciBkZWZhdWx0cyA9IHtcblx0Z2FtdXRfbWFwcGluZzogXCJsY2guY1wiLFxuXHRwcmVjaXNpb246IDUsXG5cdGRlbHRhRTogXCI3NlwiLCAvLyBEZWZhdWx0IGRlbHRhRSBtZXRob2Rcbn07XG5cbmNvbnN0IFdISVRFUyA9IHtcblx0Ly8gZm9yIGNvbXBhdGliaWxpdHksIHRoZSBmb3VyLWRpZ2l0IGNocm9tYXRpY2l0eS1kZXJpdmVkIG9uZXMgZXZlcnlvbmUgZWxzZSB1c2VzXG5cdEQ1MDogWzAuMzQ1NyAvIDAuMzU4NSwgMS4wMDAwMCwgKDEuMCAtIDAuMzQ1NyAtIDAuMzU4NSkgLyAwLjM1ODVdLFxuXHRENjU6IFswLjMxMjcgLyAwLjMyOTAsIDEuMDAwMDAsICgxLjAgLSAwLjMxMjcgLSAwLjMyOTApIC8gMC4zMjkwXSxcbn07XG5cbmZ1bmN0aW9uIGdldFdoaXRlIChuYW1lKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHRyZXR1cm4gV0hJVEVTW25hbWVdO1xufVxuXG4vLyBBZGFwdCBYWVogZnJvbSB3aGl0ZSBwb2ludCBXMSB0byBXMlxuZnVuY3Rpb24gYWRhcHQkMSAoVzEsIFcyLCBYWVosIG9wdGlvbnMgPSB7fSkge1xuXHRXMSA9IGdldFdoaXRlKFcxKTtcblx0VzIgPSBnZXRXaGl0ZShXMik7XG5cblx0aWYgKCFXMSB8fCAhVzIpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBNaXNzaW5nIHdoaXRlIHBvaW50IHRvIGNvbnZlcnQgJHshVzE/IFwiZnJvbVwiIDogXCJcIn0keyFXMSYmIVcyPyBcIi9cIiA6IFwiXCJ9JHshVzI/IFwidG9cIiA6IFwiXCJ9YCk7XG5cdH1cblxuXHRpZiAoVzEgPT09IFcyKSB7XG5cdFx0Ly8gU2FtZSB3aGl0ZXBvaW50cywgbm8gY29udmVyc2lvbiBuZWVkZWRcblx0XHRyZXR1cm4gWFlaO1xuXHR9XG5cblx0bGV0IGVudiA9IHtXMSwgVzIsIFhZWiwgb3B0aW9uc307XG5cblx0aG9va3MucnVuKFwiY2hyb21hdGljLWFkYXB0YXRpb24tc3RhcnRcIiwgZW52KTtcblxuXHRpZiAoIWVudi5NKSB7XG5cdFx0aWYgKGVudi5XMSA9PT0gV0hJVEVTLkQ2NSAmJiBlbnYuVzIgPT09IFdISVRFUy5ENTApIHtcblx0XHRcdGVudi5NID0gW1xuXHRcdFx0XHRbICAxLjA0NzkyOTgyMDg0MDU0ODgsICAgIDAuMDIyOTQ2NzkzMzQxMDE5MDg4LCAgLTAuMDUwMTkyMjI5NTQzMTM1NTcgXSxcblx0XHRcdFx0WyAgMC4wMjk2Mjc4MTU2ODgxNTkzNDQsICAwLjk5MDQzNDQ4NDU3MzI0OSwgICAgIC0wLjAxNzA3MzgyNTAyOTM4NTE0IF0sXG5cdFx0XHRcdFsgLTAuMDA5MjQzMDU4MTUyNTkxMTc4LCAgMC4wMTUwNTUxNDQ4OTY1Nzc4OTUsICAgMC43NTE4NzQyODk5NTgwMDA4ICBdXG5cdFx0XHRdO1xuXHRcdH1cblx0XHRlbHNlIGlmIChlbnYuVzEgPT09IFdISVRFUy5ENTAgJiYgZW52LlcyID09PSBXSElURVMuRDY1KSB7XG5cblx0XHRcdGVudi5NID0gW1xuXHRcdFx0XHRbICAwLjk1NTQ3MzQ1MjcwNDIxODIsICAgLTAuMDIzMDk4NTM2ODc0MjYxNDIzLCAgMC4wNjMyNTkzMDg2NjEwMjE3ICAgXSxcblx0XHRcdFx0WyAtMC4wMjgzNjk3MDY5NjMyMDgxMzYsICAxLjAwOTk5NTQ1ODAwNTgyMjYsICAgIDAuMDIxMDQxMzk4OTY2OTQzMDA4IF0sXG5cdFx0XHRcdFsgIDAuMDEyMzE0MDAxNjg4MzE5ODk5LCAtMC4wMjA1MDc2OTY0MzM0Nzc5MTIsICAxLjMzMDM2NTkzNjYwODA3NTMgICBdXG5cdFx0XHRdO1xuXHRcdH1cblx0fVxuXG5cdGhvb2tzLnJ1bihcImNocm9tYXRpYy1hZGFwdGF0aW9uLWVuZFwiLCBlbnYpO1xuXG5cdGlmIChlbnYuTSkge1xuXHRcdHJldHVybiBtdWx0aXBseU1hdHJpY2VzKGVudi5NLCBlbnYuWFlaKTtcblx0fVxuXHRlbHNlIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiT25seSBCcmFkZm9yZCBDQVQgd2l0aCB3aGl0ZSBwb2ludHMgRDUwIGFuZCBENjUgc3VwcG9ydGVkIGZvciBub3cuXCIpO1xuXHR9XG59XG5cbmNvbnN0IM61JDQgPSAuMDAwMDc1O1xuXG4vKipcbiAqIENsYXNzIHRvIHJlcHJlc2VudCBhIGNvbG9yIHNwYWNlXG4gKi9cbmNsYXNzIENvbG9yU3BhY2Uge1xuXHRjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuXHRcdHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuXHRcdHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcblx0XHR0aGlzLmJhc2UgPSBvcHRpb25zLmJhc2UgPyBDb2xvclNwYWNlLmdldChvcHRpb25zLmJhc2UpIDogbnVsbDtcblx0XHR0aGlzLmFsaWFzZXMgPSBvcHRpb25zLmFsaWFzZXM7XG5cblx0XHRpZiAodGhpcy5iYXNlKSB7XG5cdFx0XHR0aGlzLmZyb21CYXNlID0gb3B0aW9ucy5mcm9tQmFzZTtcblx0XHRcdHRoaXMudG9CYXNlID0gb3B0aW9ucy50b0Jhc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ29vcmRpbmF0ZSBtZXRhZGF0YVxuXG5cdFx0bGV0IGNvb3JkcyA9IG9wdGlvbnMuY29vcmRzID8/IHRoaXMuYmFzZS5jb29yZHM7XG5cblx0XHRmb3IgKGxldCBuYW1lIGluIGNvb3Jkcykge1xuXHRcdFx0aWYgKCEoXCJuYW1lXCIgaW4gY29vcmRzW25hbWVdKSkge1xuXHRcdFx0XHRjb29yZHNbbmFtZV0ubmFtZSA9IG5hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuY29vcmRzID0gY29vcmRzO1xuXG5cdFx0Ly8gV2hpdGUgcG9pbnRcblxuXHRcdGxldCB3aGl0ZSA9IG9wdGlvbnMud2hpdGUgPz8gdGhpcy5iYXNlLndoaXRlID8/IFwiRDY1XCI7XG5cdFx0dGhpcy53aGl0ZSA9IGdldFdoaXRlKHdoaXRlKTtcblxuXHRcdC8vIFNvcnQgb3V0IGZvcm1hdHNcblxuXHRcdHRoaXMuZm9ybWF0cyA9IG9wdGlvbnMuZm9ybWF0cyA/PyB7fTtcblxuXHRcdGZvciAobGV0IG5hbWUgaW4gdGhpcy5mb3JtYXRzKSB7XG5cdFx0XHRsZXQgZm9ybWF0ID0gdGhpcy5mb3JtYXRzW25hbWVdO1xuXHRcdFx0Zm9ybWF0LnR5cGUgfHw9IFwiZnVuY3Rpb25cIjtcblx0XHRcdGZvcm1hdC5uYW1lIHx8PSBuYW1lO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmNzc0lkICYmICF0aGlzLmZvcm1hdHMuZnVuY3Rpb25zPy5jb2xvcikge1xuXHRcdFx0dGhpcy5mb3JtYXRzLmNvbG9yID0geyBpZDogb3B0aW9ucy5jc3NJZCB9O1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY3NzSWRcIiwge3ZhbHVlOiBvcHRpb25zLmNzc0lkfSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuZm9ybWF0cz8uY29sb3IgJiYgIXRoaXMuZm9ybWF0cz8uY29sb3IuaWQpIHtcblx0XHRcdHRoaXMuZm9ybWF0cy5jb2xvci5pZCA9IHRoaXMuaWQ7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgc3R1ZmZcblx0XHR0aGlzLnJlZmVycmVkID0gb3B0aW9ucy5yZWZlcnJlZDtcblxuXHRcdC8vIENvbXB1dGUgYW5jZXN0b3JzIGFuZCBzdG9yZSB0aGVtLCBzaW5jZSB0aGV5IHdpbGwgbmV2ZXIgY2hhbmdlXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGF0aFwiLCB7XG5cdFx0XHR2YWx1ZTogZ2V0UGF0aCh0aGlzKS5yZXZlcnNlKCksXG5cdFx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdH0pO1xuXG5cdFx0aG9va3MucnVuKFwiY29sb3JzcGFjZS1pbml0LWVuZFwiLCB0aGlzKTtcblx0fVxuXG5cdGluR2FtdXQgKGNvb3Jkcywge2Vwc2lsb24gPSDOtSQ0fSA9IHt9KSB7XG5cdFx0aWYgKHRoaXMuaXNQb2xhcikge1xuXHRcdFx0Ly8gRG8gbm90IGNoZWNrIGdhbXV0IHRocm91Z2ggcG9sYXIgY29vcmRpbmF0ZXNcblx0XHRcdGNvb3JkcyA9IHRoaXMudG9CYXNlKGNvb3Jkcyk7XG5cblx0XHRcdHJldHVybiB0aGlzLmJhc2UuaW5HYW11dChjb29yZHMsIHtlcHNpbG9ufSk7XG5cdFx0fVxuXG5cdFx0bGV0IGNvb3JkTWV0YSA9IE9iamVjdC52YWx1ZXModGhpcy5jb29yZHMpO1xuXG5cdFx0cmV0dXJuIGNvb3Jkcy5ldmVyeSgoYywgaSkgPT4ge1xuXHRcdFx0bGV0IG1ldGEgPSBjb29yZE1ldGFbaV07XG5cblx0XHRcdGlmIChtZXRhLnR5cGUgIT09IFwiYW5nbGVcIiAmJiBtZXRhLnJhbmdlKSB7XG5cdFx0XHRcdGlmIChOdW1iZXIuaXNOYU4oYykpIHtcblx0XHRcdFx0XHQvLyBOYU4gaXMgYWx3YXlzIGluIGdhbXV0XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgW21pbiwgbWF4XSA9IG1ldGEucmFuZ2U7XG5cdFx0XHRcdHJldHVybiAobWluID09PSB1bmRlZmluZWQgfHwgYyA+PSBtaW4gLSBlcHNpbG9uKVxuXHRcdFx0XHQgICAgJiYgKG1heCA9PT0gdW5kZWZpbmVkIHx8IGMgPD0gbWF4ICsgZXBzaWxvbik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXHR9XG5cblx0Z2V0IGNzc0lkICgpIHtcblx0XHRyZXR1cm4gdGhpcy5mb3JtYXRzLmZ1bmN0aW9ucz8uY29sb3I/LmlkIHx8IHRoaXMuaWQ7XG5cdH1cblxuXHRnZXQgaXNQb2xhciAoKSB7XG5cdFx0Zm9yIChsZXQgaWQgaW4gdGhpcy5jb29yZHMpIHtcblx0XHRcdGlmICh0aGlzLmNvb3Jkc1tpZF0udHlwZSA9PT0gXCJhbmdsZVwiKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGdldEZvcm1hdCAoZm9ybWF0KSB7XG5cdFx0aWYgKHR5cGVvZiBmb3JtYXQgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdGZvcm1hdCA9IHByb2Nlc3NGb3JtYXQoZm9ybWF0LCB0aGlzKTtcblx0XHRcdHJldHVybiBmb3JtYXQ7XG5cdFx0fVxuXG5cdFx0bGV0IHJldDtcblx0XHRpZiAoZm9ybWF0ID09PSBcImRlZmF1bHRcIikge1xuXHRcdFx0Ly8gR2V0IGZpcnN0IGZvcm1hdFxuXHRcdFx0cmV0ID0gT2JqZWN0LnZhbHVlcyh0aGlzLmZvcm1hdHMpWzBdO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldCA9IHRoaXMuZm9ybWF0c1tmb3JtYXRdO1xuXHRcdH1cblxuXHRcdGlmIChyZXQpIHtcblx0XHRcdHJldCA9IHByb2Nlc3NGb3JtYXQocmV0LCB0aGlzKTtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBXZSBjYW5ub3QgcmVseSBvbiBzaW1wbGUgPT09IGJlY2F1c2UgdGhlbiBDb2xvclNwYWNlIG9iamVjdHMgY2Fubm90IGJlIHByb3hpZWRcblx0ZXF1YWxzIChzcGFjZSkge1xuXHRcdGlmICghc3BhY2UpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcyA9PT0gc3BhY2UgfHwgdGhpcy5pZCA9PT0gc3BhY2UuaWQ7XG5cdH1cblxuXHR0byAoc3BhY2UsIGNvb3Jkcykge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRbc3BhY2UsIGNvb3Jkc10gPSBbc3BhY2Uuc3BhY2UsIHNwYWNlLmNvb3Jkc107XG5cdFx0fVxuXG5cdFx0c3BhY2UgPSBDb2xvclNwYWNlLmdldChzcGFjZSk7XG5cblx0XHRpZiAodGhpcy5lcXVhbHMoc3BhY2UpKSB7XG5cdFx0XHQvLyBTYW1lIHNwYWNlLCBubyBjaGFuZ2UgbmVlZGVkXG5cdFx0XHRyZXR1cm4gY29vcmRzO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgTmFOIHRvIDAsIHdoaWNoIHNlZW1zIHRvIGJlIHZhbGlkIGluIGV2ZXJ5IGNvb3JkaW5hdGUgb2YgZXZlcnkgY29sb3Igc3BhY2Vcblx0XHRjb29yZHMgPSBjb29yZHMubWFwKGMgPT4gTnVtYmVyLmlzTmFOKGMpPyAwIDogYyk7XG5cblx0XHQvLyBGaW5kIGNvbm5lY3Rpb24gc3BhY2UgPSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIGluIHRoZSBiYXNlIHRyZWVcblx0XHRsZXQgbXlQYXRoID0gdGhpcy5wYXRoO1xuXHRcdGxldCBvdGhlclBhdGggPSBzcGFjZS5wYXRoO1xuXG5cdFx0bGV0IGNvbm5lY3Rpb25TcGFjZSwgY29ubmVjdGlvblNwYWNlSW5kZXg7XG5cblx0XHRmb3IgKGxldCBpPTA7IGkgPCBteVBhdGgubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChteVBhdGhbaV0uZXF1YWxzKG90aGVyUGF0aFtpXSkpIHtcblx0XHRcdFx0Y29ubmVjdGlvblNwYWNlID0gbXlQYXRoW2ldO1xuXHRcdFx0XHRjb25uZWN0aW9uU3BhY2VJbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFjb25uZWN0aW9uU3BhY2UpIHtcblx0XHRcdC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29udmVydCBiZXR3ZWVuIGNvbG9yIHNwYWNlcyAke3RoaXN9IGFuZCAke3NwYWNlfTogbm8gY29ubmVjdGlvbiBzcGFjZSB3YXMgZm91bmRgKTtcblx0XHR9XG5cblx0XHQvLyBHbyB1cCBmcm9tIGN1cnJlbnQgc3BhY2UgdG8gY29ubmVjdGlvbiBzcGFjZVxuXHRcdGZvciAobGV0IGkgPSBteVBhdGgubGVuZ3RoIC0gMTsgaSA+IGNvbm5lY3Rpb25TcGFjZUluZGV4OyBpLS0pIHtcblx0XHRcdGNvb3JkcyA9IG15UGF0aFtpXS50b0Jhc2UoY29vcmRzKTtcblx0XHR9XG5cblx0XHQvLyBHbyBkb3duIGZyb20gY29ubmVjdGlvbiBzcGFjZSB0byB0YXJnZXQgc3BhY2Vcblx0XHRmb3IgKGxldCBpID0gY29ubmVjdGlvblNwYWNlSW5kZXggKyAxOyBpIDwgb3RoZXJQYXRoLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb29yZHMgPSBvdGhlclBhdGhbaV0uZnJvbUJhc2UoY29vcmRzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9XG5cblx0ZnJvbSAoc3BhY2UsIGNvb3Jkcykge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRbc3BhY2UsIGNvb3Jkc10gPSBbc3BhY2Uuc3BhY2UsIHNwYWNlLmNvb3Jkc107XG5cdFx0fVxuXG5cdFx0c3BhY2UgPSBDb2xvclNwYWNlLmdldChzcGFjZSk7XG5cblx0XHRyZXR1cm4gc3BhY2UudG8odGhpcywgY29vcmRzKTtcblx0fVxuXG5cdHRvU3RyaW5nICgpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy5uYW1lfSAoJHt0aGlzLmlkfSlgO1xuXHR9XG5cblx0Z2V0TWluQ29vcmRzICgpIHtcblx0XHRsZXQgcmV0ID0gW107XG5cblx0XHRmb3IgKGxldCBpZCBpbiB0aGlzLmNvb3Jkcykge1xuXHRcdFx0bGV0IG1ldGEgPSB0aGlzLmNvb3Jkc1tpZF07XG5cdFx0XHRsZXQgcmFuZ2UgPSBtZXRhLnJhbmdlIHx8IG1ldGEucmVmUmFuZ2U7XG5cdFx0XHRyZXQucHVzaChyYW5nZT8ubWluID8/IDApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHRzdGF0aWMgcmVnaXN0cnkgPSB7fTtcblxuXHQvLyBSZXR1cm5zIGFycmF5IG9mIHVuaXF1ZSBjb2xvciBzcGFjZXNcblx0c3RhdGljIGdldCBhbGwgKCkge1xuXHRcdHJldHVybiBbLi4ubmV3IFNldChPYmplY3QudmFsdWVzKENvbG9yU3BhY2UucmVnaXN0cnkpKV07XG5cdH1cblxuXHRzdGF0aWMgcmVnaXN0ZXIgKGlkLCBzcGFjZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRzcGFjZSA9IGFyZ3VtZW50c1swXTtcblx0XHRcdGlkID0gc3BhY2UuaWQ7XG5cdFx0fVxuXG5cdFx0c3BhY2UgPSB0aGlzLmdldChzcGFjZSk7XG5cblx0XHRpZiAodGhpcy5yZWdpc3RyeVtpZF0gJiYgdGhpcy5yZWdpc3RyeVtpZF0gIT09IHNwYWNlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBjb2xvciBzcGFjZSByZWdpc3RyYXRpb246ICcke2lkfSdgKTtcblx0XHR9XG5cdFx0dGhpcy5yZWdpc3RyeVtpZF0gPSBzcGFjZTtcblxuXHRcdC8vIFJlZ2lzdGVyIGFsaWFzZXMgd2hlbiBjYWxsZWQgd2l0aG91dCBhbiBleHBsaWNpdCBJRC5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBzcGFjZS5hbGlhc2VzKSB7XG5cdFx0XHRmb3IgKGxldCBhbGlhcyBvZiBzcGFjZS5hbGlhc2VzKSB7XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXIoYWxpYXMsIHNwYWNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc3BhY2U7XG5cdH1cblxuXHQvKipcblx0ICogTG9va3VwIENvbG9yU3BhY2Ugb2JqZWN0IGJ5IG5hbWVcblx0ICogQHBhcmFtIHtDb2xvclNwYWNlIHwgc3RyaW5nfSBuYW1lXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IChzcGFjZSwgLi4uYWx0ZXJuYXRpdmVzKSB7XG5cdFx0aWYgKCFzcGFjZSB8fCBzcGFjZSBpbnN0YW5jZW9mIENvbG9yU3BhY2UpIHtcblx0XHRcdHJldHVybiBzcGFjZTtcblx0XHR9XG5cblx0XHRsZXQgYXJnVHlwZSA9IHR5cGUoc3BhY2UpO1xuXG5cdFx0aWYgKGFyZ1R5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdC8vIEl0J3MgYSBjb2xvciBzcGFjZSBpZFxuXHRcdFx0bGV0IHJldCA9IENvbG9yU3BhY2UucmVnaXN0cnlbc3BhY2UudG9Mb3dlckNhc2UoKV07XG5cblx0XHRcdGlmICghcmV0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIGNvbG9yIHNwYWNlIGZvdW5kIHdpdGggaWQgPSBcIiR7c3BhY2V9XCJgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRpZiAoYWx0ZXJuYXRpdmVzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIENvbG9yU3BhY2UuZ2V0KC4uLmFsdGVybmF0aXZlcyk7XG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHtzcGFjZX0gaXMgbm90IGEgdmFsaWQgY29sb3Igc3BhY2VgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgbWV0YWRhdGEgYWJvdXQgYSBjb29yZGluYXRlIG9mIGEgY29sb3Igc3BhY2Vcblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0FycmF5IHwgc3RyaW5nfSByZWZcblx0ICogQHBhcmFtIHtDb2xvclNwYWNlIHwgc3RyaW5nfSBbd29ya2luZ1NwYWNlXVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqL1xuXHRzdGF0aWMgcmVzb2x2ZUNvb3JkIChyZWYsIHdvcmtpbmdTcGFjZSkge1xuXHRcdGxldCBjb29yZFR5cGUgPSB0eXBlKHJlZik7XG5cdFx0bGV0IHNwYWNlLCBjb29yZDtcblxuXHRcdGlmIChjb29yZFR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGlmIChyZWYuaW5jbHVkZXMoXCIuXCIpKSB7XG5cdFx0XHRcdC8vIEFic29sdXRlIGNvb3JkaW5hdGVcblx0XHRcdFx0W3NwYWNlLCBjb29yZF0gPSByZWYuc3BsaXQoXCIuXCIpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIFJlbGF0aXZlIGNvb3JkaW5hdGVcblx0XHRcdFx0W3NwYWNlLCBjb29yZF0gPSBbLCByZWZdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlZikpIHtcblx0XHRcdFtzcGFjZSwgY29vcmRdID0gcmVmO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE9iamVjdFxuXHRcdFx0c3BhY2UgPSByZWYuc3BhY2U7XG5cdFx0XHRjb29yZCA9IHJlZi5jb29yZElkO1xuXHRcdH1cblxuXHRcdHNwYWNlID0gQ29sb3JTcGFjZS5nZXQoc3BhY2UpO1xuXG5cdFx0aWYgKCFzcGFjZSkge1xuXHRcdFx0c3BhY2UgPSB3b3JraW5nU3BhY2U7XG5cdFx0fVxuXG5cdFx0aWYgKCFzcGFjZSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgQ2Fubm90IHJlc29sdmUgY29vcmRpbmF0ZSByZWZlcmVuY2UgJHtyZWZ9OiBObyBjb2xvciBzcGFjZSBzcGVjaWZpZWQgYW5kIHJlbGF0aXZlIHJlZmVyZW5jZXMgYXJlIG5vdCBhbGxvd2VkIGhlcmVgKTtcblx0XHR9XG5cblx0XHRjb29yZFR5cGUgPSB0eXBlKGNvb3JkKTtcblxuXHRcdGlmIChjb29yZFR5cGUgPT09IFwibnVtYmVyXCIgfHwgY29vcmRUeXBlID09PSBcInN0cmluZ1wiICYmIGNvb3JkID49IDApIHtcblx0XHRcdC8vIFJlc29sdmUgbnVtZXJpY2FsIGNvb3JkXG5cdFx0XHRsZXQgbWV0YSA9IE9iamVjdC5lbnRyaWVzKHNwYWNlLmNvb3JkcylbY29vcmRdO1xuXG5cdFx0XHRpZiAobWV0YSkge1xuXHRcdFx0XHRyZXR1cm4ge3NwYWNlLCBpZDogbWV0YVswXSwgaW5kZXg6IGNvb3JkLCAuLi5tZXRhWzFdfTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzcGFjZSA9IENvbG9yU3BhY2UuZ2V0KHNwYWNlKTtcblxuXHRcdGxldCBub3JtYWxpemVkQ29vcmQgPSBjb29yZC50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0bGV0IGkgPSAwO1xuXHRcdGZvciAobGV0IGlkIGluIHNwYWNlLmNvb3Jkcykge1xuXHRcdFx0bGV0IG1ldGEgPSBzcGFjZS5jb29yZHNbaWRdO1xuXG5cdFx0XHRpZiAoaWQudG9Mb3dlckNhc2UoKSA9PT0gbm9ybWFsaXplZENvb3JkIHx8IG1ldGEubmFtZT8udG9Mb3dlckNhc2UoKSA9PT0gbm9ybWFsaXplZENvb3JkKSB7XG5cdFx0XHRcdHJldHVybiB7c3BhY2UsIGlkLCBpbmRleDogaSwgLi4ubWV0YX07XG5cdFx0XHR9XG5cblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBcIiR7Y29vcmR9XCIgY29vcmRpbmF0ZSBmb3VuZCBpbiAke3NwYWNlLm5hbWV9LiBJdHMgY29vcmRpbmF0ZXMgYXJlOiAke09iamVjdC5rZXlzKHNwYWNlLmNvb3Jkcykuam9pbihcIiwgXCIpfWApO1xuXHR9XG5cblx0c3RhdGljIERFRkFVTFRfRk9STUFUID0ge1xuXHRcdHR5cGU6IFwiZnVuY3Rpb25zXCIsXG5cdFx0bmFtZTogXCJjb2xvclwiLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoIChzcGFjZSkge1xuXHRsZXQgcmV0ID0gW3NwYWNlXTtcblxuXHRmb3IgKGxldCBzID0gc3BhY2U7IHMgPSBzLmJhc2U7KSB7XG5cdFx0cmV0LnB1c2gocyk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9ybWF0IChmb3JtYXQsIHtjb29yZHN9ID0ge30pIHtcblx0aWYgKGZvcm1hdC5jb29yZHMgJiYgIWZvcm1hdC5jb29yZEdyYW1tYXIpIHtcblx0XHRmb3JtYXQudHlwZSB8fD0gXCJmdW5jdGlvblwiO1xuXHRcdGZvcm1hdC5uYW1lIHx8PSBcImNvbG9yXCI7XG5cblx0XHQvLyBGb3JtYXQgaGFzIG5vdCBiZWVuIHByb2Nlc3NlZFxuXHRcdGZvcm1hdC5jb29yZEdyYW1tYXIgPSBwYXJzZUNvb3JkR3JhbW1hcihmb3JtYXQuY29vcmRzKTtcblxuXHRcdGxldCBjb29yZEZvcm1hdHMgPSBPYmplY3QuZW50cmllcyhjb29yZHMpLm1hcCgoW2lkLCBjb29yZE1ldGFdLCBpKSA9PiB7XG5cdFx0XHQvLyBQcmVmZXJyZWQgZm9ybWF0IGZvciBlYWNoIGNvb3JkIGlzIHRoZSBmaXJzdCBvbmVcblx0XHRcdGxldCBvdXRwdXRUeXBlID0gZm9ybWF0LmNvb3JkR3JhbW1hcltpXVswXTtcblxuXHRcdFx0bGV0IGZyb21SYW5nZSA9IGNvb3JkTWV0YS5yYW5nZSB8fCBjb29yZE1ldGEucmVmUmFuZ2U7XG5cdFx0XHRsZXQgdG9SYW5nZSA9IG91dHB1dFR5cGUucmFuZ2UsIHN1ZmZpeCA9IFwiXCI7XG5cblx0XHRcdC8vIE5vbi1zdHJpY3QgZXF1YWxzIGludGVudGlvbmFsIHNpbmNlIG91dHB1dFR5cGUgY291bGQgYmUgYSBzdHJpbmcgb2JqZWN0XG5cdFx0XHRpZiAob3V0cHV0VHlwZSA9PSBcIjxwZXJjZW50YWdlPlwiKSB7XG5cdFx0XHRcdHRvUmFuZ2UgPSBbMCwgMTAwXTtcblx0XHRcdFx0c3VmZml4ID0gXCIlXCI7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChvdXRwdXRUeXBlID09IFwiPGFuZ2xlPlwiKSB7XG5cdFx0XHRcdHN1ZmZpeCA9IFwiZGVnXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAge2Zyb21SYW5nZSwgdG9SYW5nZSwgc3VmZml4fTtcblx0XHR9KTtcblxuXHRcdGZvcm1hdC5zZXJpYWxpemVDb29yZHMgPSAoY29vcmRzLCBwcmVjaXNpb24pID0+IHtcblx0XHRcdHJldHVybiBjb29yZHMubWFwKChjLCBpKSA9PiB7XG5cdFx0XHRcdGxldCB7ZnJvbVJhbmdlLCB0b1JhbmdlLCBzdWZmaXh9ID0gY29vcmRGb3JtYXRzW2ldO1xuXG5cdFx0XHRcdGlmIChmcm9tUmFuZ2UgJiYgdG9SYW5nZSkge1xuXHRcdFx0XHRcdGMgPSBtYXBSYW5nZShmcm9tUmFuZ2UsIHRvUmFuZ2UsIGMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YyA9IHRvUHJlY2lzaW9uKGMsIHByZWNpc2lvbik7XG5cblx0XHRcdFx0aWYgKHN1ZmZpeCkge1xuXHRcdFx0XHRcdGMgKz0gc3VmZml4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGM7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGZvcm1hdDtcbn1cblxudmFyIFhZWl9ENjUgPSBuZXcgQ29sb3JTcGFjZSh7XG5cdGlkOiBcInh5ei1kNjVcIixcblx0bmFtZTogXCJYWVogRDY1XCIsXG5cdGNvb3Jkczoge1xuXHRcdHg6IHtuYW1lOiBcIlhcIn0sXG5cdFx0eToge25hbWU6IFwiWVwifSxcblx0XHR6OiB7bmFtZTogXCJaXCJ9LFxuXHR9LFxuXHR3aGl0ZTogXCJENjVcIixcblx0Zm9ybWF0czoge1xuXHRcdGNvbG9yOiB7XG5cdFx0XHRpZHM6IFtcInh5ei1kNjVcIiwgXCJ4eXpcIl0sXG5cdFx0fVxuXHR9LFxuXHRhbGlhc2VzOiBbXCJ4eXpcIl0sXG59KTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjbGFzcyBmb3IgUkdCIGNvbG9yIHNwYWNlc1xuICogQGV4dGVuZHMge0NvbG9yU3BhY2V9XG4gKi9cbmNsYXNzIFJHQkNvbG9yU3BhY2UgZXh0ZW5kcyBDb2xvclNwYWNlIHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgUkdCIENvbG9yU3BhY2UuXG5cdCAqIElmIGNvb3JkcyBhcmUgbm90IHNwZWNpZmllZCwgdGhleSB3aWxsIHVzZSB0aGUgZGVmYXVsdCBSR0IgY29vcmRzLlxuXHQgKiBJbnN0ZWFkIG9mIGBmcm9tQmFzZSgpYCBhbmQgYHRvQmFzZSgpYCBmdW5jdGlvbnMsXG5cdCAqIHlvdSBjYW4gc3BlY2lmeSB0by9mcm9tIFhZWiBtYXRyaWNlcyBhbmQgaGF2ZSBgdG9CYXNlKClgIGFuZCBgZnJvbUJhc2UoKWAgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG5cdCAqIEBwYXJhbSB7Kn0gb3B0aW9ucyAtIFNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgQ29sb3JTcGFjZX0gcGx1czpcblx0ICogQHBhcmFtIHtudW1iZXJbXVtdfSBvcHRpb25zLnRvWFlaX00gLSBNYXRyaXggdG8gY29udmVydCB0byBYWVpcblx0ICogQHBhcmFtIHtudW1iZXJbXVtdfSBvcHRpb25zLmZyb21YWVpfTSAtIE1hdHJpeCB0byBjb252ZXJ0IGZyb20gWFlaXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucy5jb29yZHMpIHtcblx0XHRcdG9wdGlvbnMuY29vcmRzID0ge1xuXHRcdFx0XHRyOiB7XG5cdFx0XHRcdFx0cmFuZ2U6IFswLCAxXSxcblx0XHRcdFx0XHRuYW1lOiBcIlJlZFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGc6IHtcblx0XHRcdFx0XHRyYW5nZTogWzAsIDFdLFxuXHRcdFx0XHRcdG5hbWU6IFwiR3JlZW5cIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRiOiB7XG5cdFx0XHRcdFx0cmFuZ2U6IFswLCAxXSxcblx0XHRcdFx0XHRuYW1lOiBcIkJsdWVcIlxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmICghb3B0aW9ucy5iYXNlKSB7XG5cdFx0XHRvcHRpb25zLmJhc2UgPSBYWVpfRDY1O1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnRvWFlaX00gJiYgb3B0aW9ucy5mcm9tWFlaX00pIHtcblx0XHRcdG9wdGlvbnMudG9CYXNlID8/PSByZ2IgPT4ge1xuXHRcdFx0XHRsZXQgeHl6ID0gbXVsdGlwbHlNYXRyaWNlcyhvcHRpb25zLnRvWFlaX00sIHJnYik7XG5cblx0XHRcdFx0aWYgKHRoaXMud2hpdGUgIT09IHRoaXMuYmFzZS53aGl0ZSkge1xuXHRcdFx0XHRcdC8vIFBlcmZvcm0gY2hyb21hdGljIGFkYXB0YXRpb25cblx0XHRcdFx0XHR4eXogPSBhZGFwdCQxKHRoaXMud2hpdGUsIHRoaXMuYmFzZS53aGl0ZSwgeHl6KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB4eXo7XG5cdFx0XHR9O1xuXG5cdFx0XHRvcHRpb25zLmZyb21CYXNlID8/PSB4eXogPT4ge1xuXHRcdFx0XHR4eXogPSBhZGFwdCQxKHRoaXMuYmFzZS53aGl0ZSwgdGhpcy53aGl0ZSwgeHl6KTtcblx0XHRcdFx0cmV0dXJuIG11bHRpcGx5TWF0cmljZXMob3B0aW9ucy5mcm9tWFlaX00sIHh5eik7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdG9wdGlvbnMucmVmZXJyZWQgPz89IFwiZGlzcGxheVwiO1xuXG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgQ1NTIENvbG9yIHN0cmluZyB0byBhIGNvbG9yIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1ldGFdIC0gT2JqZWN0IGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwYXJzaW5nXG4gKiBAcmV0dXJucyB7IENvbG9yIH1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwge21ldGF9ID0ge30pIHtcblx0bGV0IGVudiA9IHtcInN0clwiOiBTdHJpbmcoc3RyKT8udHJpbSgpfTtcblx0aG9va3MucnVuKFwicGFyc2Utc3RhcnRcIiwgZW52KTtcblxuXHRpZiAoZW52LmNvbG9yKSB7XG5cdFx0cmV0dXJuIGVudi5jb2xvcjtcblx0fVxuXG5cdGVudi5wYXJzZWQgPSBwYXJzZUZ1bmN0aW9uKGVudi5zdHIpO1xuXG5cdGlmIChlbnYucGFyc2VkKSB7XG5cdFx0Ly8gSXMgYSBmdW5jdGlvbmFsIHN5bnRheFxuXHRcdGxldCBuYW1lID0gZW52LnBhcnNlZC5uYW1lO1xuXG5cdFx0aWYgKG5hbWUgPT09IFwiY29sb3JcIikge1xuXHRcdFx0Ly8gY29sb3IoKSBmdW5jdGlvblxuXHRcdFx0bGV0IGlkID0gZW52LnBhcnNlZC5hcmdzLnNoaWZ0KCk7XG5cdFx0XHRsZXQgYWxwaGEgPSBlbnYucGFyc2VkLnJhd0FyZ3MuaW5kZXhPZihcIi9cIikgPiAwPyBlbnYucGFyc2VkLmFyZ3MucG9wKCkgOiAxO1xuXG5cdFx0XHRmb3IgKGxldCBzcGFjZSBvZiBDb2xvclNwYWNlLmFsbCkge1xuXHRcdFx0XHRsZXQgY29sb3JTcGVjID0gc3BhY2UuZ2V0Rm9ybWF0KFwiY29sb3JcIik7XG5cblx0XHRcdFx0aWYgKGNvbG9yU3BlYykge1xuXHRcdFx0XHRcdGlmIChpZCA9PT0gY29sb3JTcGVjLmlkIHx8IGNvbG9yU3BlYy5pZHM/LmluY2x1ZGVzKGlkKSkge1xuXHRcdFx0XHRcdFx0Ly8gRnJvbSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLTQvI2NvbG9yLWZ1bmN0aW9uXG5cdFx0XHRcdFx0XHQvLyBJZiBtb3JlIDxudW1iZXI+cyBvciA8cGVyY2VudGFnZT5zIGFyZSBwcm92aWRlZCB0aGFuIHBhcmFtZXRlcnMgdGhhdCB0aGUgY29sb3JzcGFjZSB0YWtlcywgdGhlIGV4Y2VzcyA8bnVtYmVyPnMgYXQgdGhlIGVuZCBhcmUgaWdub3JlZC5cblx0XHRcdFx0XHRcdC8vIElmIGxlc3MgPG51bWJlcj5zIG9yIDxwZXJjZW50YWdlPnMgYXJlIHByb3ZpZGVkIHRoYW4gcGFyYW1ldGVycyB0aGF0IHRoZSBjb2xvcnNwYWNlIHRha2VzLCB0aGUgbWlzc2luZyBwYXJhbWV0ZXJzIGRlZmF1bHQgdG8gMC4gKFRoaXMgaXMgcGFydGljdWxhcmx5IGNvbnZlbmllbnQgZm9yIG11bHRpY2hhbm5lbCBwcmludGVycyB3aGVyZSB0aGUgYWRkaXRpb25hbCBpbmtzIGFyZSBzcG90IGNvbG9ycyBvciB2YXJuaXNoZXMgdGhhdCBtb3N0IGNvbG9ycyBvbiB0aGUgcGFnZSB3b27igJl0IHVzZS4pXG5cdFx0XHRcdFx0XHRjb25zdCBjb29yZHMgPSBPYmplY3Qua2V5cyhzcGFjZS5jb29yZHMpLm1hcCgoXywgaSkgPT4gZW52LnBhcnNlZC5hcmdzW2ldIHx8IDApO1xuXG5cdFx0XHRcdFx0XHRpZiAobWV0YSkge1xuXHRcdFx0XHRcdFx0XHRtZXRhLmZvcm1hdElkID0gXCJjb2xvclwiO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge3NwYWNlSWQ6IHNwYWNlLmlkLCBjb29yZHMsIGFscGhhfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTm90IGZvdW5kXG5cdFx0XHRsZXQgZGlkWW91TWVhbiA9IFwiXCI7XG5cdFx0XHRpZiAoaWQgaW4gQ29sb3JTcGFjZS5yZWdpc3RyeSkge1xuXHRcdFx0XHQvLyBVc2VkIGNvbG9yIHNwYWNlIGlkIGluc3RlYWQgb2YgY29sb3IoKSBpZCwgdGhlc2UgYXJlIG9mdGVuIGRpZmZlcmVudFxuXHRcdFx0XHRsZXQgY3NzSWQgPSBDb2xvclNwYWNlLnJlZ2lzdHJ5W2lkXS5mb3JtYXRzPy5mdW5jdGlvbnM/LmNvbG9yPy5pZDtcblxuXHRcdFx0XHRpZiAoY3NzSWQpIHtcblx0XHRcdFx0XHRkaWRZb3VNZWFuID0gYERpZCB5b3UgbWVhbiBjb2xvcigke2Nzc0lkfSk/YDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcGFyc2UgY29sb3IoJHtpZH0pLiBgICsgKGRpZFlvdU1lYW4gfHwgXCJNaXNzaW5nIGEgcGx1Z2luP1wiKSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9yIChsZXQgc3BhY2Ugb2YgQ29sb3JTcGFjZS5hbGwpIHtcblx0XHRcdFx0Ly8gY29sb3Igc3BhY2Ugc3BlY2lmaWMgZnVuY3Rpb25cblx0XHRcdFx0bGV0IGZvcm1hdCA9IHNwYWNlLmdldEZvcm1hdChuYW1lKTtcblx0XHRcdFx0aWYgKGZvcm1hdCAmJiBmb3JtYXQudHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0bGV0IGFscGhhID0gMTtcblxuXHRcdFx0XHRcdGlmIChmb3JtYXQubGFzdEFscGhhIHx8IGxhc3QoZW52LnBhcnNlZC5hcmdzKS5hbHBoYSkge1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBlbnYucGFyc2VkLmFyZ3MucG9wKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGNvb3JkcyA9IGVudi5wYXJzZWQuYXJncztcblxuXHRcdFx0XHRcdGxldCB0eXBlcztcblxuXHRcdFx0XHRcdGlmIChmb3JtYXQuY29vcmRHcmFtbWFyKSB7XG5cdFx0XHRcdFx0XHR0eXBlcyA9IE9iamVjdC5lbnRyaWVzKHNwYWNlLmNvb3JkcykubWFwKChbaWQsIGNvb3JkTWV0YV0sIGkpID0+IHtcblx0XHRcdFx0XHRcdFx0bGV0IGNvb3JkR3JhbW1hciA9IGZvcm1hdC5jb29yZEdyYW1tYXJbaV07XG5cdFx0XHRcdFx0XHRcdGxldCBwcm92aWRlZFR5cGUgPSBjb29yZHNbaV0/LnR5cGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRmluZCBncmFtbWFyIGFsdGVybmF0aXZlIHRoYXQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgdHlwZVxuXHRcdFx0XHRcdFx0XHQvLyBOb24tc3RyaWN0IGVxdWFscyBpcyBpbnRlbnRpb25hbCBiZWNhdXNlIHdlIGFyZSBjb21wYXJpbmcgdy8gc3RyaW5nIG9iamVjdHNcblx0XHRcdFx0XHRcdFx0bGV0IHR5cGUgPSBjb29yZEdyYW1tYXIuZmluZChjID0+IGMgPT0gcHJvdmlkZWRUeXBlKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBDaGVjayB0aGF0IGVhY2ggY29vcmQgY29uZm9ybXMgdG8gaXRzIGdyYW1tYXJcblx0XHRcdFx0XHRcdFx0aWYgKCF0eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVHlwZSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZ3JhbW1hciwgdGhyb3dcblx0XHRcdFx0XHRcdFx0XHRsZXQgY29vcmROYW1lID0gY29vcmRNZXRhLm5hbWUgfHwgaWQ7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHtwcm92aWRlZFR5cGV9IG5vdCBhbGxvd2VkIGZvciAke2Nvb3JkTmFtZX0gaW4gJHtuYW1lfSgpYCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRsZXQgZnJvbVJhbmdlID0gdHlwZS5yYW5nZTtcblxuXHRcdFx0XHRcdFx0XHRpZiAocHJvdmlkZWRUeXBlID09PSBcIjxwZXJjZW50YWdlPlwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZnJvbVJhbmdlIHx8PSBbMCwgMV07XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRsZXQgdG9SYW5nZSA9IGNvb3JkTWV0YS5yYW5nZSB8fCBjb29yZE1ldGEucmVmUmFuZ2U7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGZyb21SYW5nZSAmJiB0b1JhbmdlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29vcmRzW2ldID0gbWFwUmFuZ2UoZnJvbVJhbmdlLCB0b1JhbmdlLCBjb29yZHNbaV0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAobWV0YSkge1xuXHRcdFx0XHRcdFx0T2JqZWN0LmFzc2lnbihtZXRhLCB7Zm9ybWF0SWQ6IGZvcm1hdC5uYW1lLCB0eXBlc30pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRzcGFjZUlkOiBzcGFjZS5pZCxcblx0XHRcdFx0XHRcdGNvb3JkcywgYWxwaGFcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEN1c3RvbSwgY29sb3JzcGFjZS1zcGVjaWZpYyBmb3JtYXRcblx0XHRmb3IgKGxldCBzcGFjZSBvZiBDb2xvclNwYWNlLmFsbCkge1xuXHRcdFx0Zm9yIChsZXQgZm9ybWF0SWQgaW4gc3BhY2UuZm9ybWF0cykge1xuXHRcdFx0XHRsZXQgZm9ybWF0ID0gc3BhY2UuZm9ybWF0c1tmb3JtYXRJZF07XG5cblx0XHRcdFx0aWYgKGZvcm1hdC50eXBlICE9PSBcImN1c3RvbVwiKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZm9ybWF0LnRlc3QgJiYgIWZvcm1hdC50ZXN0KGVudi5zdHIpKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgY29sb3IgPSBmb3JtYXQucGFyc2UoZW52LnN0cik7XG5cblx0XHRcdFx0aWYgKGNvbG9yKSB7XG5cdFx0XHRcdFx0Y29sb3IuYWxwaGEgPz89IDE7XG5cblx0XHRcdFx0XHRpZiAobWV0YSkge1xuXHRcdFx0XHRcdFx0bWV0YS5mb3JtYXRJZCA9IGZvcm1hdElkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBjb2xvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0Ly8gSWYgd2UncmUgaGVyZSwgd2UgY291bGRuJ3QgcGFyc2Vcblx0dGhyb3cgbmV3IFR5cGVFcnJvcihgQ291bGQgbm90IHBhcnNlICR7c3RyfSBhcyBhIGNvbG9yLiBNaXNzaW5nIGEgcGx1Z2luP2ApO1xufVxuXG4vKipcbiAqIFJlc29sdmVzIGEgY29sb3IgcmVmZXJlbmNlIChvYmplY3Qgb3Igc3RyaW5nKSB0byBhIHBsYWluIGNvbG9yIG9iamVjdFxuICogQHBhcmFtIHtDb2xvciB8IHtzcGFjZSwgY29vcmRzLCBhbHBoYX0gfCBzdHJpbmd9IGNvbG9yXG4gKiBAcmV0dXJucyB7e3NwYWNlLCBjb29yZHMsIGFscGhhfX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29sb3IgKGNvbG9yKSB7XG5cdGlmICghY29sb3IpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiRW1wdHkgY29sb3IgcmVmZXJlbmNlXCIpO1xuXHR9XG5cblx0aWYgKGlzU3RyaW5nKGNvbG9yKSkge1xuXHRcdGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXHR9XG5cblx0Ly8gT2JqZWN0IGZpeHVwXG5cdGxldCBzcGFjZSA9IGNvbG9yLnNwYWNlIHx8IGNvbG9yLnNwYWNlSWQ7XG5cblx0aWYgKCEoc3BhY2UgaW5zdGFuY2VvZiBDb2xvclNwYWNlKSkge1xuXHRcdC8vIENvbnZlcnQgc3RyaW5nIGlkIHRvIGNvbG9yIHNwYWNlIG9iamVjdFxuXHRcdGNvbG9yLnNwYWNlID0gQ29sb3JTcGFjZS5nZXQoc3BhY2UpO1xuXHR9XG5cblx0aWYgKGNvbG9yLmFscGhhID09PSB1bmRlZmluZWQpIHtcblx0XHRjb2xvci5hbHBoYSA9IDE7XG5cdH1cblxuXHRyZXR1cm4gY29sb3I7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb29yZGluYXRlcyBvZiBhIGNvbG9yIGluIGFub3RoZXIgY29sb3Igc3BhY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IENvbG9yU3BhY2V9IHNwYWNlXG4gKiBAcmV0dXJucyB7bnVtYmVyW119XG4gKi9cbmZ1bmN0aW9uIGdldEFsbCAoY29sb3IsIHNwYWNlKSB7XG5cdHNwYWNlID0gQ29sb3JTcGFjZS5nZXQoc3BhY2UpO1xuXHRyZXR1cm4gc3BhY2UuZnJvbShjb2xvcik7XG59XG5cbmZ1bmN0aW9uIGdldCAoY29sb3IsIHByb3ApIHtcblx0bGV0IHtzcGFjZSwgaW5kZXh9ID0gQ29sb3JTcGFjZS5yZXNvbHZlQ29vcmQocHJvcCwgY29sb3Iuc3BhY2UpO1xuXHRsZXQgY29vcmRzID0gZ2V0QWxsKGNvbG9yLCBzcGFjZSk7XG5cdHJldHVybiBjb29yZHNbaW5kZXhdO1xufVxuXG5mdW5jdGlvbiBzZXRBbGwgKGNvbG9yLCBzcGFjZSwgY29vcmRzKSB7XG5cdHNwYWNlID0gQ29sb3JTcGFjZS5nZXQoc3BhY2UpO1xuXHRjb2xvci5jb29yZHMgPSBzcGFjZS50byhjb2xvci5zcGFjZSwgY29vcmRzKTtcblx0cmV0dXJuIGNvbG9yO1xufVxuXG4vLyBTZXQgcHJvcGVydGllcyBhbmQgcmV0dXJuIGN1cnJlbnQgaW5zdGFuY2VcbmZ1bmN0aW9uIHNldCAoY29sb3IsIHByb3AsIHZhbHVlKSB7XG5cdGNvbG9yID0gZ2V0Q29sb3IoY29sb3IpO1xuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGUoYXJndW1lbnRzWzFdKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIEFyZ3VtZW50IGlzIGFuIG9iamVjdCBsaXRlcmFsXG5cdFx0bGV0IG9iamVjdCA9IGFyZ3VtZW50c1sxXTtcblx0XHRmb3IgKGxldCBwIGluIG9iamVjdCkge1xuXHRcdFx0c2V0KGNvbG9yLCBwLCBvYmplY3RbcF0pO1xuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhbHVlID0gdmFsdWUoZ2V0KGNvbG9yLCBwcm9wKSk7XG5cdFx0fVxuXG5cdFx0bGV0IHtzcGFjZSwgaW5kZXh9ID0gQ29sb3JTcGFjZS5yZXNvbHZlQ29vcmQocHJvcCwgY29sb3Iuc3BhY2UpO1xuXHRcdGxldCBjb29yZHMgPSBnZXRBbGwoY29sb3IsIHNwYWNlKTtcblx0XHRjb29yZHNbaW5kZXhdID0gdmFsdWU7XG5cdFx0c2V0QWxsKGNvbG9yLCBzcGFjZSwgY29vcmRzKTtcblx0fVxuXG5cdHJldHVybiBjb2xvcjtcbn1cblxudmFyIFhZWl9ENTAgPSBuZXcgQ29sb3JTcGFjZSh7XG5cdGlkOiBcInh5ei1kNTBcIixcblx0bmFtZTogXCJYWVogRDUwXCIsXG5cdHdoaXRlOiBcIkQ1MFwiLFxuXHRiYXNlOiBYWVpfRDY1LFxuXHRmcm9tQmFzZTogY29vcmRzID0+IGFkYXB0JDEoWFlaX0Q2NS53aGl0ZSwgXCJENTBcIiwgY29vcmRzKSxcblx0dG9CYXNlOiBjb29yZHMgPT4gYWRhcHQkMShcIkQ1MFwiLCBYWVpfRDY1LndoaXRlLCBjb29yZHMpLFxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHt9XG5cdH0sXG59KTtcblxuLy8gzrogKiDOtSAgPSAyXjMgPSA4XG5jb25zdCDOtSQzID0gMjE2LzI0Mzg5OyAgLy8gNl4zLzI5XjMgPT0gKDI0LzExNileM1xuY29uc3QgzrUzJDEgPSAyNC8xMTY7XG5jb25zdCDOuiQxID0gMjQzODkvMjc7ICAgLy8gMjleMy8zXjNcblxubGV0IHdoaXRlJDEgPSBXSElURVMuRDUwO1xuXG52YXIgbGFiID0gbmV3IENvbG9yU3BhY2Uoe1xuXHRpZDogXCJsYWJcIixcblx0bmFtZTogXCJMYWJcIixcblx0Y29vcmRzOiB7XG5cdFx0bDoge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAxMDBdLFxuXHRcdFx0bmFtZTogXCJMXCJcblx0XHR9LFxuXHRcdGE6IHtcblx0XHRcdHJlZlJhbmdlOiBbLTEyNSwgMTI1XVxuXHRcdH0sXG5cdFx0Yjoge1xuXHRcdFx0cmVmUmFuZ2U6IFstMTI1LCAxMjVdXG5cdFx0fVxuXHR9LFxuXG5cdC8vIEFzc3VtaW5nIFhZWiBpcyByZWxhdGl2ZSB0byBENTAsIGNvbnZlcnQgdG8gQ0lFIExhYlxuXHQvLyBmcm9tIENJRSBzdGFuZGFyZCwgd2hpY2ggbm93IGRlZmluZXMgdGhlc2UgYXMgYSByYXRpb25hbCBmcmFjdGlvblxuXHR3aGl0ZTogd2hpdGUkMSxcblxuXHRiYXNlOiBYWVpfRDUwLFxuXHQvLyBDb252ZXJ0IEQ1MC1hZGFwdGVkIFhZWCB0byBMYWJcblx0Ly8gIENJRSAxNS4zOjIwMDQgc2VjdGlvbiA4LjIuMS4xXG5cdGZyb21CYXNlIChYWVopIHtcblx0XHQvLyBjb21wdXRlIHh5eiwgd2hpY2ggaXMgWFlaIHNjYWxlZCByZWxhdGl2ZSB0byByZWZlcmVuY2Ugd2hpdGVcblx0XHRsZXQgeHl6ID0gWFlaLm1hcCgodmFsdWUsIGkpID0+IHZhbHVlIC8gd2hpdGUkMVtpXSk7XG5cblx0XHQvLyBub3cgY29tcHV0ZSBmXG5cdFx0bGV0IGYgPSB4eXoubWFwKHZhbHVlID0+IHZhbHVlID4gzrUkMyA/IE1hdGguY2JydCh2YWx1ZSkgOiAozrokMSAqIHZhbHVlICsgMTYpLzExNik7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0KDExNiAqIGZbMV0pIC0gMTYsIFx0IC8vIExcblx0XHRcdDUwMCAqIChmWzBdIC0gZlsxXSksIC8vIGFcblx0XHRcdDIwMCAqIChmWzFdIC0gZlsyXSkgIC8vIGJcblx0XHRdO1xuXHR9LFxuXHQvLyBDb252ZXJ0IExhYiB0byBENTAtYWRhcHRlZCBYWVpcblx0Ly8gU2FtZSByZXN1bHQgYXMgQ0lFIDE1LjM6MjAwNCBBcHBlbmRpeCBEIGFsdGhvdWdoIHRoZSBkZXJpdmF0aW9uIGlzIGRpZmZlcmVudFxuXHQvLyBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0Vxbl9SR0JfWFlaX01hdHJpeC5odG1sXG5cdHRvQmFzZSAoTGFiKSB7XG5cdFx0Ly8gY29tcHV0ZSBmLCBzdGFydGluZyB3aXRoIHRoZSBsdW1pbmFuY2UtcmVsYXRlZCB0ZXJtXG5cdFx0bGV0IGYgPSBbXTtcblx0XHRmWzFdID0gKExhYlswXSArIDE2KS8xMTY7XG5cdFx0ZlswXSA9IExhYlsxXS81MDAgKyBmWzFdO1xuXHRcdGZbMl0gPSBmWzFdIC0gTGFiWzJdLzIwMDtcblxuXHRcdC8vIGNvbXB1dGUgeHl6XG5cdFx0bGV0IHh5eiA9IFtcblx0XHRcdGZbMF0gICA+IM61MyQxICA/ICBNYXRoLnBvdyhmWzBdLCAzKSAgICAgICAgICAgIDogKDExNipmWzBdLTE2KS/OuiQxLFxuXHRcdFx0TGFiWzBdID4gOCAgID8gIE1hdGgucG93KChMYWJbMF0rMTYpLzExNiwgMykgOiBMYWJbMF0vzrokMSxcblx0XHRcdGZbMl0gICA+IM61MyQxICA/ICBNYXRoLnBvdyhmWzJdLCAzKSAgICAgICAgICAgIDogKDExNipmWzJdLTE2KS/OuiQxXG5cdFx0XTtcblxuXHRcdC8vIENvbXB1dGUgWFlaIGJ5IHNjYWxpbmcgeHl6IGJ5IHJlZmVyZW5jZSB3aGl0ZVxuXHRcdHJldHVybiB4eXoubWFwKCh2YWx1ZSwgaSkgPT4gdmFsdWUgKiB3aGl0ZSQxW2ldKTtcblx0fSxcblxuXHRmb3JtYXRzOiB7XG5cdFx0XCJsYWJcIjoge1xuXHRcdFx0Y29vcmRzOiBbXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPlwiLCBcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+Wy0xLDFdXCIsIFwiPG51bWJlcj4gfCA8cGVyY2VudGFnZT5bLTEsMV1cIl0sXG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gY29uc3RyYWluIChhbmdsZSkge1xuXHRyZXR1cm4gKChhbmdsZSAlIDM2MCkgKyAzNjApICUgMzYwO1xufVxuXG5mdW5jdGlvbiBhZGp1c3QgKGFyYywgYW5nbGVzKSB7XG5cdGlmIChhcmMgPT09IFwicmF3XCIpIHtcblx0XHRyZXR1cm4gYW5nbGVzO1xuXHR9XG5cblx0bGV0IFthMSwgYTJdID0gYW5nbGVzLm1hcChjb25zdHJhaW4pO1xuXG5cdGxldCBhbmdsZURpZmYgPSBhMiAtIGExO1xuXG5cdGlmIChhcmMgPT09IFwiaW5jcmVhc2luZ1wiKSB7XG5cdFx0aWYgKGFuZ2xlRGlmZiA8IDApIHtcblx0XHRcdGEyICs9IDM2MDtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoYXJjID09PSBcImRlY3JlYXNpbmdcIikge1xuXHRcdGlmIChhbmdsZURpZmYgPiAwKSB7XG5cdFx0XHRhMSArPSAzNjA7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKGFyYyA9PT0gXCJsb25nZXJcIikge1xuXHRcdGlmICgtMTgwIDwgYW5nbGVEaWZmICYmIGFuZ2xlRGlmZiA8IDE4MCkge1xuXHRcdFx0aWYgKGFuZ2xlRGlmZiA+IDApIHtcblx0XHRcdFx0YTEgKz0gMzYwO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGEyICs9IDM2MDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoYXJjID09PSBcInNob3J0ZXJcIikge1xuXHRcdGlmIChhbmdsZURpZmYgPiAxODApIHtcblx0XHRcdGExICs9IDM2MDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoYW5nbGVEaWZmIDwgLTE4MCkge1xuXHRcdFx0YTIgKz0gMzYwO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbYTEsIGEyXTtcbn1cblxudmFyIGxjaCA9IG5ldyBDb2xvclNwYWNlKHtcblx0aWQ6IFwibGNoXCIsXG5cdG5hbWU6IFwiTENIXCIsXG5cdGNvb3Jkczoge1xuXHRcdGw6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMTAwXSxcblx0XHRcdG5hbWU6IFwiTGlnaHRuZXNzXCJcblx0XHR9LFxuXHRcdGM6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMTUwXSxcblx0XHRcdG5hbWU6IFwiQ2hyb21hXCJcblx0XHR9LFxuXHRcdGg6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMzYwXSxcblx0XHRcdHR5cGU6IFwiYW5nbGVcIixcblx0XHRcdG5hbWU6IFwiSHVlXCJcblx0XHR9XG5cdH0sXG5cblx0YmFzZTogbGFiLFxuXHRmcm9tQmFzZSAoTGFiKSB7XG5cdFx0Ly8gQ29udmVydCB0byBwb2xhciBmb3JtXG5cdFx0bGV0IFtMLCBhLCBiXSA9IExhYjtcblx0XHRsZXQgaHVlO1xuXHRcdGNvbnN0IM61ID0gMC4wMjtcblxuXHRcdGlmIChNYXRoLmFicyhhKSA8IM61ICYmIE1hdGguYWJzKGIpIDwgzrUpIHtcblx0XHRcdGh1ZSA9IE5hTjtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRodWUgPSBNYXRoLmF0YW4yKGIsIGEpICogMTgwIC8gTWF0aC5QSTtcblx0XHR9XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0TCwgLy8gTCBpcyBzdGlsbCBMXG5cdFx0XHRNYXRoLnNxcnQoYSAqKiAyICsgYiAqKiAyKSwgLy8gQ2hyb21hXG5cdFx0XHRjb25zdHJhaW4oaHVlKSAvLyBIdWUsIGluIGRlZ3JlZXMgWzAgdG8gMzYwKVxuXHRcdF07XG5cdH0sXG5cdHRvQmFzZSAoTENIKSB7XG5cdFx0Ly8gQ29udmVydCBmcm9tIHBvbGFyIGZvcm1cblx0XHRsZXQgW0xpZ2h0bmVzcywgQ2hyb21hLCBIdWVdID0gTENIO1xuXHRcdC8vIENsYW1wIGFueSBuZWdhdGl2ZSBDaHJvbWFcblx0XHRpZiAoQ2hyb21hIDwgMCkge1xuXHRcdFx0Q2hyb21hID0gMDtcblx0XHR9XHRcdC8vIERlYWwgd2l0aCBOYU4gSHVlXG5cdFx0aWYgKGlzTmFOKEh1ZSkpIHtcblx0XHRcdEh1ZSA9IDA7XG5cdFx0fVxuXHRcdHJldHVybiBbXG5cdFx0XHRMaWdodG5lc3MsIC8vIEwgaXMgc3RpbGwgTFxuXHRcdFx0Q2hyb21hICogTWF0aC5jb3MoSHVlICogTWF0aC5QSSAvIDE4MCksIC8vIGFcblx0XHRcdENocm9tYSAqIE1hdGguc2luKEh1ZSAqIE1hdGguUEkgLyAxODApICAvLyBiXG5cdFx0XTtcblx0fSxcblxuXHRmb3JtYXRzOiB7XG5cdFx0XCJsY2hcIjoge1xuXHRcdFx0Y29vcmRzOiBbXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPlwiLCBcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+XCIsIFwiPG51bWJlcj4gfCA8YW5nbGU+XCJdLFxuXHRcdH1cblx0fVxufSk7XG5cbi8vIGRlbHRhRTIwMDAgaXMgYSBzdGF0aXN0aWNhbGx5IHNpZ25pZmljYW50IGltcHJvdmVtZW50XG4vLyBhbmQgaXMgcmVjb21tZW5kZWQgYnkgdGhlIENJRSBhbmQgSWRlYWxsaWFuY2Vcbi8vIGVzcGVjaWFsbHkgZm9yIGNvbG9yIGRpZmZlcmVuY2VzIGxlc3MgdGhhbiAxMCBkZWx0YUU3NlxuLy8gYnV0IGlzIHdpY2tlZCBjb21wbGljYXRlZFxuLy8gYW5kIG1hbnkgaW1wbGVtZW50YXRpb25zIGhhdmUgc21hbGwgZXJyb3JzIVxuLy8gRGVsdGFFMjAwMCBpcyBhbHNvIGRpc2NvbnRpbnVvdXM7IGluIGNhc2UgdGhpc1xuLy8gbWF0dGVycyB0byB5b3UsIHVzZSBkZWx0YUVDTUMgaW5zdGVhZC5cblxuY29uc3QgR2ZhY3RvciA9IDI1ICoqIDc7XG5jb25zdCDPgCQxID0gTWF0aC5QSTtcbmNvbnN0IHIyZCA9IDE4MCAvIM+AJDE7XG5jb25zdCBkMnIkMSA9IM+AJDEgLyAxODA7XG5cbmZ1bmN0aW9uIGRlbHRhRTIwMDAgKGNvbG9yLCBzYW1wbGUsIHtrTCA9IDEsIGtDID0gMSwga0ggPSAxfSA9IHt9KSB7XG5cdC8vIEdpdmVuIHRoaXMgY29sb3IgYXMgdGhlIHJlZmVyZW5jZVxuXHQvLyBhbmQgdGhlIGZ1bmN0aW9uIHBhcmFtZXRlciBhcyB0aGUgc2FtcGxlLFxuXHQvLyBjYWxjdWxhdGUgZGVsdGFFIDIwMDAuXG5cblx0Ly8gVGhpcyBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoZSBwYXJhbWV0cmljXG5cdC8vIHdlaWdodGluZyBmYWN0b3JzIGtMLCBrQyBhbmQga0hcblx0Ly8gZm9yIHRoZSBpbmZsdWVuY2Ugb2Ygdmlld2luZyBjb25kaXRpb25zXG5cdC8vIGFyZSBhbGwgMSwgYXMgc2FkbHkgc2VlbXMgdHlwaWNhbC5cblx0Ly8ga0wgc2hvdWxkIGJlIGluY3JlYXNlZCBmb3IgbGlnaHRuZXNzIHRleHR1cmUgb3Igbm9pc2Vcblx0Ly8gYW5kIGtDIGluY3JlYXNlZCBmb3IgY2hyb21hIG5vaXNlXG5cblx0bGV0IFtMMSwgYTEsIGIxXSA9IGxhYi5mcm9tKGNvbG9yKTtcblx0bGV0IEMxID0gbGNoLmZyb20obGFiLCBbTDEsIGExLCBiMV0pWzFdO1xuXHRsZXQgW0wyLCBhMiwgYjJdID0gbGFiLmZyb20oc2FtcGxlKTtcblx0bGV0IEMyID0gbGNoLmZyb20obGFiLCBbTDIsIGEyLCBiMl0pWzFdO1xuXG5cdC8vIENoZWNrIGZvciBuZWdhdGl2ZSBDaHJvbWEsXG5cdC8vIHdoaWNoIG1pZ2h0IGhhcHBlbiB0aHJvdWdoXG5cdC8vIGRpcmVjdCB1c2VyIGlucHV0IG9mIExDSCB2YWx1ZXNcblxuXHRpZiAoQzEgPCAwKSB7XG5cdFx0QzEgPSAwO1xuXHR9XG5cdGlmIChDMiA8IDApIHtcblx0XHRDMiA9IDA7XG5cdH1cblxuXHRsZXQgQ2JhciA9IChDMSArIEMyKS8yOyAvLyBtZWFuIENocm9tYVxuXG5cdC8vIGNhbGN1bGF0ZSBhLWF4aXMgYXN5bW1ldHJ5IGZhY3RvciBmcm9tIG1lYW4gQ2hyb21hXG5cdC8vIHRoaXMgdHVybnMgSk5EIGVsbGlwc2VzIGZvciBuZWFyLW5ldXRyYWwgY29sb3JzIGJhY2sgaW50byBjaXJjbGVzXG5cdGxldCBDNyA9IENiYXIgKiogNztcblxuXHRsZXQgRyA9IDAuNSAqICgxIC0gTWF0aC5zcXJ0KEM3LyhDNyArIEdmYWN0b3IpKSk7XG5cblx0Ly8gc2NhbGUgYSBheGVzIGJ5IGFzeW1tZXRyeSBmYWN0b3Jcblx0Ly8gdGhpcyBieSB0aGUgd2F5IGlzIHdoeSB0aGVyZSBpcyBubyBMYWIyMDAwIGNvbG9yc3BhY2Vcblx0bGV0IGFkYXNoMSA9ICgxICsgRykgKiBhMTtcblx0bGV0IGFkYXNoMiA9ICgxICsgRykgKiBhMjtcblxuXHQvLyBjYWxjdWxhdGUgbmV3IENocm9tYSBmcm9tIHNjYWxlZCBhIGFuZCBvcmlnaW5hbCBiIGF4ZXNcblx0bGV0IENkYXNoMSA9IE1hdGguc3FydChhZGFzaDEgKiogMiArIGIxICoqIDIpO1xuXHRsZXQgQ2Rhc2gyID0gTWF0aC5zcXJ0KGFkYXNoMiAqKiAyICsgYjIgKiogMik7XG5cblx0Ly8gY2FsY3VsYXRlIG5ldyBodWVzLCB3aXRoIHplcm8gaHVlIGZvciB0cnVlIG5ldXRyYWxzXG5cdC8vIGFuZCBpbiBkZWdyZWVzLCBub3QgcmFkaWFuc1xuXG5cdGxldCBoMSA9IChhZGFzaDEgPT09IDAgJiYgYjEgPT09IDApPyAwOiBNYXRoLmF0YW4yKGIxLCBhZGFzaDEpO1xuXHRsZXQgaDIgPSAoYWRhc2gyID09PSAwICYmIGIyID09PSAwKT8gMDogTWF0aC5hdGFuMihiMiwgYWRhc2gyKTtcblxuXHRpZiAoaDEgPCAwKSB7XG5cdFx0aDEgKz0gMiAqIM+AJDE7XG5cdH1cblx0aWYgKGgyIDwgMCkge1xuXHRcdGgyICs9IDIgKiDPgCQxO1xuXHR9XG5cblx0aDEgKj0gcjJkO1xuXHRoMiAqPSByMmQ7XG5cblx0Ly8gTGlnaHRuZXNzIGFuZCBDaHJvbWEgZGlmZmVyZW5jZXM7IHNpZ24gbWF0dGVyc1xuXHRsZXQgzpRMID0gTDIgLSBMMTtcblx0bGV0IM6UQyA9IENkYXNoMiAtIENkYXNoMTtcblxuXHQvLyBIdWUgZGlmZmVyZW5jZSwgZ2V0dGluZyB0aGUgc2lnbiBjb3JyZWN0XG5cdGxldCBoZGlmZiA9IGgyIC0gaDE7XG5cdGxldCBoc3VtID0gaDEgKyBoMjtcblx0bGV0IGhhYnMgPSBNYXRoLmFicyhoZGlmZik7XG5cdGxldCDOlGg7XG5cblx0aWYgKENkYXNoMSAqIENkYXNoMiA9PT0gMCkge1xuXHRcdM6UaCA9IDA7XG5cdH1cblx0ZWxzZSBpZiAoaGFicyA8PSAxODApIHtcblx0XHTOlGggPSBoZGlmZjtcblx0fVxuXHRlbHNlIGlmIChoZGlmZiA+IDE4MCkge1xuXHRcdM6UaCA9IGhkaWZmIC0gMzYwO1xuXHR9XG5cdGVsc2UgaWYgKGhkaWZmIDwgLTE4MCkge1xuXHRcdM6UaCA9IGhkaWZmICsgMzYwO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGNvbnNvbGUubG9nKFwidGhlIHVudGhpbmthYmxlIGhhcyBoYXBwZW5lZFwiKTtcblx0fVxuXG5cdC8vIHdlaWdodGVkIEh1ZSBkaWZmZXJlbmNlLCBtb3JlIGZvciBsYXJnZXIgQ2hyb21hXG5cdGxldCDOlEggPSAyICogTWF0aC5zcXJ0KENkYXNoMiAqIENkYXNoMSkgKiBNYXRoLnNpbijOlGggKiBkMnIkMSAvIDIpO1xuXG5cdC8vIGNhbGN1bGF0ZSBtZWFuIExpZ2h0bmVzcyBhbmQgQ2hyb21hXG5cdGxldCBMZGFzaCA9IChMMSArIEwyKS8yO1xuXHRsZXQgQ2Rhc2ggPSAoQ2Rhc2gxICsgQ2Rhc2gyKS8yO1xuXHRsZXQgQ2Rhc2g3ID0gTWF0aC5wb3coQ2Rhc2gsIDcpO1xuXG5cdC8vIENvbXBlbnNhdGUgZm9yIG5vbi1saW5lYXJpdHkgaW4gdGhlIGJsdWUgcmVnaW9uIG9mIExhYi5cblx0Ly8gRm91ciBwb3NzaWJpbGl0aWVzIGZvciBodWUgd2VpZ2h0aW5nIGZhY3Rvcixcblx0Ly8gZGVwZW5kaW5nIG9uIHRoZSBhbmdsZXMsIHRvIGdldCB0aGUgY29ycmVjdCBzaWduXG5cdGxldCBoZGFzaDtcblx0aWYgKENkYXNoMSAqIENkYXNoMiA9PT0gMCkge1xuXHRcdGhkYXNoID0gaHN1bTsgICAvLyB3aGljaCBzaG91bGQgYmUgemVyb1xuXHR9XG5cdGVsc2UgaWYgKGhhYnMgPD0gMTgwKSB7XG5cdFx0aGRhc2ggPSBoc3VtIC8gMjtcblx0fVxuXHRlbHNlIGlmIChoc3VtIDwgMzYwKSB7XG5cdFx0aGRhc2ggPSAoaHN1bSArIDM2MCkgLyAyO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGhkYXNoID0gKGhzdW0gLSAzNjApIC8gMjtcblx0fVxuXG5cdC8vIHBvc2l0aW9uYWwgY29ycmVjdGlvbnMgdG8gdGhlIGxhY2sgb2YgdW5pZm9ybWl0eSBvZiBDSUVMQUJcblx0Ly8gVGhlc2UgYXJlIGFsbCB0cnlpbmcgdG8gbWFrZSBKTkQgZWxsaXBzb2lkcyBtb3JlIGxpa2Ugc3BoZXJlc1xuXG5cdC8vIFNMIExpZ2h0bmVzcyBjcmlzcGVuaW5nIGZhY3RvclxuXHQvLyBhIGJhY2tncm91bmQgd2l0aCBMPTUwIGlzIGFzc3VtZWRcblx0bGV0IGxzcSA9IChMZGFzaCAtIDUwKSAqKiAyO1xuXHRsZXQgU0wgPSAxICsgKCgwLjAxNSAqIGxzcSkgLyBNYXRoLnNxcnQoMjAgKyBsc3EpKTtcblxuXHQvLyBTQyBDaHJvbWEgZmFjdG9yLCBzaW1pbGFyIHRvIHRob3NlIGluIENNQyBhbmQgZGVsdGFFIDk0IGZvcm11bGFlXG5cdGxldCBTQyA9IDEgKyAwLjA0NSAqIENkYXNoO1xuXG5cdC8vIENyb3NzIHRlcm0gVCBmb3IgYmx1ZSBub24tbGluZWFyaXR5XG5cdGxldCBUID0gMTtcblx0VCAtPSAoMC4xNyAqIE1hdGguY29zKCggICAgIGhkYXNoIC0gMzApICAqIGQyciQxKSk7XG5cdFQgKz0gKDAuMjQgKiBNYXRoLmNvcyggIDIgKiBoZGFzaCAgICAgICAgKiBkMnIkMSkpO1xuXHRUICs9ICgwLjMyICogTWF0aC5jb3MoKCgzICogaGRhc2gpICsgNikgICogZDJyJDEpKTtcblx0VCAtPSAoMC4yMCAqIE1hdGguY29zKCgoNCAqIGhkYXNoKSAtIDYzKSAqIGQyciQxKSk7XG5cblx0Ly8gU0ggSHVlIGZhY3RvciBkZXBlbmRzIG9uIENocm9tYSxcblx0Ly8gYXMgd2VsbCBhcyBhZGp1c3RlZCBodWUgYW5nbGUgbGlrZSBkZWx0YUU5NC5cblx0bGV0IFNIID0gMSArIDAuMDE1ICogQ2Rhc2ggKiBUO1xuXG5cdC8vIFJUIEh1ZSByb3RhdGlvbiB0ZXJtIGNvbXBlbnNhdGVzIGZvciByb3RhdGlvbiBvZiBKTkQgZWxsaXBzZXNcblx0Ly8gYW5kIE11bnNlbGwgY29uc3RhbnQgaHVlIGxpbmVzXG5cdC8vIGluIHRoZSBtZWRpdW0taGlnaCBDaHJvbWEgYmx1ZSByZWdpb25cblx0Ly8gKEh1ZSAyMjUgdG8gMzE1KVxuXHRsZXQgzpTOuCA9IDMwICogTWF0aC5leHAoLTEgKiAoKChoZGFzaCAtIDI3NSkvMjUpICoqIDIpKTtcblx0bGV0IFJDID0gMiAqIE1hdGguc3FydChDZGFzaDcvKENkYXNoNyArIEdmYWN0b3IpKTtcblx0bGV0IFJUID0gLTEgKiBNYXRoLnNpbigyICogzpTOuCAqIGQyciQxKSAqIFJDO1xuXG5cdC8vIEZpbmFsbHkgY2FsY3VsYXRlIHRoZSBkZWx0YUUsIHRlcm0gYnkgdGVybSBhcyByb290IHN1bWUgb2Ygc3F1YXJlc1xuXHRsZXQgZEUgPSAozpRMIC8gKGtMICogU0wpKSAqKiAyO1xuXHRkRSArPSAozpRDIC8gKGtDICogU0MpKSAqKiAyO1xuXHRkRSArPSAozpRIIC8gKGtIICogU0gpKSAqKiAyO1xuXHRkRSArPSBSVCAqICjOlEMgLyAoa0MgKiBTQykpICogKM6USCAvIChrSCAqIFNIKSk7XG5cdHJldHVybiBNYXRoLnNxcnQoZEUpO1xuXHQvLyBZYXkhISFcbn1cblxuY29uc3QgzrUkMiA9IC4wMDAwNzU7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjb2xvciBpcyBpbiBnYW11dCBvZiBlaXRoZXIgaXRzIG93biBvciBhbm90aGVyIGNvbG9yIHNwYWNlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBJcyB0aGUgY29sb3IgaW4gZ2FtdXQ/XG4gKi9cbmZ1bmN0aW9uIGluR2FtdXQgKGNvbG9yLCBzcGFjZSA9IGNvbG9yLnNwYWNlLCB7ZXBzaWxvbiA9IM61JDJ9ID0ge30pIHtcblx0Y29sb3IgPSBnZXRDb2xvcihjb2xvcik7XG5cdHNwYWNlID0gQ29sb3JTcGFjZS5nZXQoc3BhY2UpO1xuXHRsZXQgY29vcmRzID0gY29sb3IuY29vcmRzO1xuXG5cdGlmIChzcGFjZSAhPT0gY29sb3Iuc3BhY2UpIHtcblx0XHRjb29yZHMgPSBzcGFjZS5mcm9tKGNvbG9yKTtcblx0fVxuXG5cdHJldHVybiBzcGFjZS5pbkdhbXV0KGNvb3Jkcywge2Vwc2lsb259KTtcbn1cblxuZnVuY3Rpb24gY2xvbmUgKGNvbG9yKSB7XG5cdHJldHVybiB7XG5cdFx0c3BhY2U6IGNvbG9yLnNwYWNlLFxuXHRcdGNvb3JkczogY29sb3IuY29vcmRzLnNsaWNlKCksXG5cdFx0YWxwaGE6IGNvbG9yLmFscGhhXG5cdH07XG59XG5cbi8qKlxuICogRm9yY2UgY29vcmRpbmF0ZXMgdG8gYmUgaW4gZ2FtdXQgb2YgYSBjZXJ0YWluIGNvbG9yIHNwYWNlLlxuICogTXV0YXRlcyB0aGUgY29sb3IgaXQgaXMgcGFzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1ldGhvZCAtIEhvdyB0byBmb3JjZSBpbnRvIGdhbXV0LlxuICogICAgICAgIElmIFwiY2xpcFwiLCBjb29yZGluYXRlcyBhcmUganVzdCBjbGlwcGVkIHRvIHRoZWlyIHJlZmVyZW5jZSByYW5nZS5cbiAqICAgICAgICBJZiBpbiB0aGUgZm9ybSBbY29sb3JTcGFjZUlkXS5bY29vcmROYW1lXSwgdGhhdCBjb29yZGluYXRlIGlzIHJlZHVjZWRcbiAqICAgICAgICB1bnRpbCB0aGUgY29sb3IgaXMgaW4gZ2FtdXQuIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBtYXkgcHJvZHVjZSBub25zZW5zaWNhbFxuICogICAgICAgIHJlc3VsdHMgZm9yIGNlcnRhaW4gY29vcmRpbmF0ZXMgKGUuZy4gaHVlKSBvciBpbmZpbml0ZSBsb29wcyBpZiByZWR1Y2luZyB0aGUgY29vcmRpbmF0ZSBuZXZlciBicmluZ3MgdGhlIGNvbG9yIGluIGdhbXV0LlxuICogQHBhcmFtIHtDb2xvclNwYWNlfHN0cmluZ30gb3B0aW9ucy5zcGFjZSAtIFRoZSBzcGFjZSB3aG9zZSBnYW11dCB3ZSB3YW50IHRvIG1hcCB0b1xuICovXG5mdW5jdGlvbiB0b0dhbXV0IChjb2xvciwge21ldGhvZCA9IGRlZmF1bHRzLmdhbXV0X21hcHBpbmcsIHNwYWNlID0gY29sb3Iuc3BhY2V9ID0ge30pIHtcblx0aWYgKGlzU3RyaW5nKGFyZ3VtZW50c1sxXSkpIHtcblx0XHRzcGFjZSA9IGFyZ3VtZW50c1sxXTtcblx0fVxuXG5cdHNwYWNlID0gQ29sb3JTcGFjZS5nZXQoc3BhY2UpO1xuXG5cdGlmIChpbkdhbXV0KGNvbG9yLCBzcGFjZSwge2Vwc2lsb246IDB9KSkge1xuXHRcdHJldHVybiBnZXRDb2xvcihjb2xvcik7XG5cdH1cblxuXHQvLyAzIHNwYWNlczpcblx0Ly8gY29sb3Iuc3BhY2U6IGN1cnJlbnQgY29sb3Igc3BhY2Vcblx0Ly8gc3BhY2U6IHNwYWNlIHdob3NlIGdhbXV0IHdlIGFyZSBtYXBwaW5nIHRvXG5cdC8vIG1hcFNwYWNlOiBzcGFjZSB3aXRoIHRoZSBjb29yZCB3ZSdyZSByZWR1Y2luZ1xuXHRsZXQgc3BhY2VDb2xvciA9IHRvKGNvbG9yLCBzcGFjZSk7XG5cblx0aWYgKG1ldGhvZCAhPT0gXCJjbGlwXCIgJiYgIWluR2FtdXQoY29sb3IsIHNwYWNlKSkge1xuXHRcdGxldCBjbGlwcGVkID0gdG9HYW11dChjbG9uZShzcGFjZUNvbG9yKSwge21ldGhvZDogXCJjbGlwXCIsIHNwYWNlfSk7XG5cdFx0aWYgKGRlbHRhRTIwMDAoY29sb3IsIGNsaXBwZWQpID4gMikge1xuXHRcdFx0Ly8gUmVkdWNlIGEgY29vcmRpbmF0ZSBvZiBhIGNlcnRhaW4gY29sb3Igc3BhY2UgdW50aWwgdGhlIGNvbG9yIGlzIGluIGdhbXV0XG5cdFx0XHRsZXQgY29vcmRNZXRhID0gQ29sb3JTcGFjZS5yZXNvbHZlQ29vcmQobWV0aG9kKTtcblx0XHRcdGxldCBtYXBTcGFjZSA9IGNvb3JkTWV0YS5zcGFjZTtcblx0XHRcdGxldCBjb29yZElkID0gY29vcmRNZXRhLmlkO1xuXG5cdFx0XHRsZXQgbWFwcGVkQ29sb3IgPSB0byhzcGFjZUNvbG9yLCBtYXBTcGFjZSk7XG5cdFx0XHRsZXQgYm91bmRzID0gY29vcmRNZXRhLnJhbmdlIHx8IGNvb3JkTWV0YS5yZWZSYW5nZTtcblx0XHRcdGxldCBtaW4gPSBib3VuZHNbMF07XG5cdFx0XHRsZXQgzrUgPSAuMDE7IC8vIGZvciBkZWx0YUVcblx0XHRcdGxldCBsb3cgPSBtaW47XG5cdFx0XHRsZXQgaGlnaCA9IGdldChtYXBwZWRDb2xvciwgY29vcmRJZCk7XG5cblx0XHRcdHdoaWxlIChoaWdoIC0gbG93ID4gzrUpIHtcblx0XHRcdFx0bGV0IGNsaXBwZWQgPSBjbG9uZShtYXBwZWRDb2xvcik7XG5cdFx0XHRcdGNsaXBwZWQgPSB0b0dhbXV0KGNsaXBwZWQsIHtzcGFjZSwgbWV0aG9kOiBcImNsaXBcIn0pO1xuXHRcdFx0XHRsZXQgZGVsdGFFID0gZGVsdGFFMjAwMChtYXBwZWRDb2xvciwgY2xpcHBlZCk7XG5cblx0XHRcdFx0aWYgKGRlbHRhRSAtIDIgPCDOtSkge1xuXHRcdFx0XHRcdGxvdyA9IGdldChtYXBwZWRDb2xvciwgY29vcmRJZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aGlnaCA9IGdldChtYXBwZWRDb2xvciwgY29vcmRJZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZXQobWFwcGVkQ29sb3IsIGNvb3JkSWQsIChsb3cgKyBoaWdoKSAvIDIpO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGFjZUNvbG9yID0gdG8obWFwcGVkQ29sb3IsIHNwYWNlKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzcGFjZUNvbG9yID0gY2xpcHBlZDtcblx0XHR9XG5cdH1cblxuXHRpZiAobWV0aG9kID09PSBcImNsaXBcIiAvLyBEdW1iIGNvb3JkIGNsaXBwaW5nXG5cdFx0Ly8gZmluaXNoIG9mZiBzbWFydGVyIGdhbXV0IG1hcHBpbmcgd2l0aCBjbGlwIHRvIGdldCByaWQgb2YgzrUsIHNlZSAjMTdcblx0XHR8fCAhaW5HYW11dChzcGFjZUNvbG9yLCBzcGFjZSwge2Vwc2lsb246IDB9KVxuXHQpIHtcblx0XHRsZXQgYm91bmRzID0gT2JqZWN0LnZhbHVlcyhzcGFjZS5jb29yZHMpLm1hcChjID0+IGMucmFuZ2UgfHwgW10pO1xuXG5cdFx0c3BhY2VDb2xvci5jb29yZHMgPSBzcGFjZUNvbG9yLmNvb3Jkcy5tYXAoKGMsIGkpID0+IHtcblx0XHRcdGxldCBbbWluLCBtYXhdID0gYm91bmRzW2ldO1xuXG5cdFx0XHRpZiAobWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YyA9IE1hdGgubWF4KG1pbiwgYyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjID0gTWF0aC5taW4oYywgbWF4KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGM7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoc3BhY2UgIT09IGNvbG9yLnNwYWNlKSB7XG5cdFx0c3BhY2VDb2xvciA9IHRvKHNwYWNlQ29sb3IsIGNvbG9yLnNwYWNlKTtcblx0fVxuXG5cdGNvbG9yLmNvb3JkcyA9IHNwYWNlQ29sb3IuY29vcmRzO1xuXHRyZXR1cm4gY29sb3I7XG59XG5cbnRvR2FtdXQucmV0dXJucyA9IFwiY29sb3JcIjtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGNvbG9yIHNwYWNlIGFuZCByZXR1cm4gYSBuZXcgY29sb3JcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gc3BhY2UgLSBDb2xvciBzcGFjZSBvYmplY3Qgb3IgaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaW5HYW11dCAtIFdoZXRoZXIgdG8gZm9yY2UgcmVzdWx0aW5nIGNvbG9yIGluIGdhbXV0XG4gKiBAcmV0dXJucyB7Q29sb3J9XG4gKi9cbmZ1bmN0aW9uIHRvIChjb2xvciwgc3BhY2UsIHtpbkdhbXV0fSA9IHt9KSB7XG5cdGNvbG9yID0gZ2V0Q29sb3IoY29sb3IpO1xuXHRzcGFjZSA9IENvbG9yU3BhY2UuZ2V0KHNwYWNlKTtcblxuXHRsZXQgY29vcmRzID0gc3BhY2UuZnJvbShjb2xvcik7XG5cdGxldCByZXQgPSB7c3BhY2UsIGNvb3JkcywgYWxwaGE6IGNvbG9yLmFscGhhfTtcblxuXHRpZiAoaW5HYW11dCkge1xuXHRcdHJldCA9IHRvR2FtdXQocmV0KTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cbnRvLnJldHVybnMgPSBcImNvbG9yXCI7XG5cbi8qKlxuICogR2VuZXJpYyB0b1N0cmluZygpIG1ldGhvZCwgb3V0cHV0cyBhIGNvbG9yKHNwYWNlSWQgLi4uY29vcmRzKSBmdW5jdGlvbiwgYSBmdW5jdGlvbmFsIHN5bnRheCwgb3IgY3VzdG9tIGZvcm1hdHMgZGVmaW5lZCBieSB0aGUgY29sb3Igc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5wcmVjaXNpb24gLSBTaWduaWZpY2FudCBkaWdpdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5pbkdhbXV0IC0gQWRqdXN0IGNvb3JkaW5hdGVzIHRvIGZpdCBpbiBnYW11dCBmaXJzdD8gW2RlZmF1bHQ6IGZhbHNlXVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemUgKGNvbG9yLCB7XG5cdHByZWNpc2lvbiA9IGRlZmF1bHRzLnByZWNpc2lvbixcblx0Zm9ybWF0ID0gXCJkZWZhdWx0XCIsXG5cdGluR2FtdXQ6IGluR2FtdXQkMSA9IHRydWUsXG5cdC4uLmN1c3RvbU9wdGlvbnNcbn0gPSB7fSkge1xuXHRsZXQgcmV0O1xuXG5cdGNvbG9yID0gZ2V0Q29sb3IoY29sb3IpO1xuXG5cdGxldCBmb3JtYXRJZCA9IGZvcm1hdDtcblx0Zm9ybWF0ID0gY29sb3Iuc3BhY2UuZ2V0Rm9ybWF0KGZvcm1hdClcblx0XHQgICA/PyBjb2xvci5zcGFjZS5nZXRGb3JtYXQoXCJkZWZhdWx0XCIpXG5cdFx0ICAgPz8gQ29sb3JTcGFjZS5ERUZBVUxUX0ZPUk1BVDtcblxuXHRpbkdhbXV0JDEgfHw9IGZvcm1hdC50b0dhbXV0O1xuXG5cdGxldCBjb29yZHMgPSBjb2xvci5jb29yZHM7XG5cblx0Ly8gQ29udmVydCBOYU4gdG8gemVyb3MgdG8gaGF2ZSBhIGNoYW5jZSBhdCBhIHZhbGlkIENTUyBjb2xvclxuXHQvLyBBbHNvIGNvbnZlcnQgLTAgdG8gMFxuXHQvLyBUaGlzIGFsc28gY2xvbmVzIGl0IHNvIHdlIGNhbiBtYW5pcHVsYXRlIGl0XG5cdGNvb3JkcyA9IGNvb3Jkcy5tYXAoYyA9PiBjPyBjIDogMCk7XG5cblx0aWYgKGluR2FtdXQkMSAmJiAhaW5HYW11dChjb2xvcikpIHtcblx0XHRjb29yZHMgPSB0b0dhbXV0KGNsb25lKGNvbG9yKSwgaW5HYW11dCQxID09PSB0cnVlPyB1bmRlZmluZWQgOiBpbkdhbXV0JDEpLmNvb3Jkcztcblx0fVxuXG5cdGlmIChmb3JtYXQudHlwZSA9PT0gXCJjdXN0b21cIikge1xuXHRcdGN1c3RvbU9wdGlvbnMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuXG5cdFx0aWYgKGZvcm1hdC5zZXJpYWxpemUpIHtcblx0XHRcdHJldCA9IGZvcm1hdC5zZXJpYWxpemUoY29vcmRzLCBjb2xvci5hbHBoYSwgY3VzdG9tT3B0aW9ucyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgZm9ybWF0ICR7Zm9ybWF0SWR9IGNhbiBvbmx5IGJlIHVzZWQgdG8gcGFyc2UgY29sb3JzLCBub3QgZm9yIHNlcmlhbGl6YXRpb25gKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gRnVuY3Rpb25hbCBzeW50YXhcblx0XHRsZXQgbmFtZSA9IGZvcm1hdC5uYW1lIHx8IFwiY29sb3JcIjtcblxuXHRcdGlmIChmb3JtYXQuc2VyaWFsaXplQ29vcmRzKSB7XG5cdFx0XHRjb29yZHMgPSBmb3JtYXQuc2VyaWFsaXplQ29vcmRzKGNvb3JkcywgcHJlY2lzaW9uKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAocHJlY2lzaW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdGNvb3JkcyA9IGNvb3Jkcy5tYXAoYyA9PiB0b1ByZWNpc2lvbihjLCBwcmVjaXNpb24pKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgYXJncyA9IFsuLi5jb29yZHNdO1xuXG5cdFx0aWYgKG5hbWUgPT09IFwiY29sb3JcIikge1xuXHRcdFx0Ly8gSWYgb3V0cHV0IGlzIGEgY29sb3IoKSBmdW5jdGlvbiwgYWRkIGNvbG9yc3BhY2UgaWQgYXMgZmlyc3QgYXJndW1lbnRcblx0XHRcdGxldCBjc3NJZCA9IGZvcm1hdC5pZCB8fCBmb3JtYXQuaWRzPy5bMF0gfHwgY29sb3Iuc3BhY2UuaWQ7XG5cdFx0XHRhcmdzLnVuc2hpZnQoY3NzSWQpO1xuXHRcdH1cblxuXHRcdGxldCBhbHBoYSA9IGNvbG9yLmFscGhhO1xuXHRcdGlmIChwcmVjaXNpb24gIT09IG51bGwpIHtcblx0XHRcdGFscGhhID0gdG9QcmVjaXNpb24oYWxwaGEsIHByZWNpc2lvbik7XG5cdFx0fVxuXG5cdFx0bGV0IHN0ckFscGhhID0gY29sb3IuYWxwaGEgPCAxICYmICFmb3JtYXQubm9BbHBoYT8gYCR7Zm9ybWF0LmNvbW1hcz8gXCIsXCIgOiBcIiAvXCJ9ICR7YWxwaGF9YCA6IFwiXCI7XG5cdFx0cmV0ID0gYCR7bmFtZX0oJHthcmdzLmpvaW4oZm9ybWF0LmNvbW1hcz8gXCIsIFwiIDogXCIgXCIpfSR7c3RyQWxwaGF9KWA7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG4vLyBjb252ZXJ0IGFuIGFycmF5IG9mIGxpbmVhci1saWdodCByZWMyMDIwIHZhbHVlcyB0byBDSUUgWFlaXG4vLyB1c2luZyAgRDY1IChubyBjaHJvbWF0aWMgYWRhcHRhdGlvbilcbi8vIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX1JHQl9YWVpfTWF0cml4Lmh0bWxcbi8vIDAgaXMgYWN0dWFsbHkgY2FsY3VsYXRlZCBhcyAgNC45OTQxMDY1NzQ0NjYwNzZlLTE3XG5jb25zdCB0b1hZWl9NJDUgPSBbXG5cdFsgMC42MzY5NTgwNDgzMDEyOTE0LCAwLjE0NDYxNjkwMzU4NjIwODMyLCAgMC4xNjg4ODA5NzUxNjQxNzIxICBdLFxuXHRbIDAuMjYyNzAwMjEyMDExMjY3MSwgMC42Nzc5OTgwNzE1MTg4NzA4LCAgIDAuMDU5MzAxNzE2NDY5ODYxOTYgXSxcblx0WyAwLjAwMDAwMDAwMDAwMDAwMCwgIDAuMDI4MDcyNjkzMDQ5MDg3NDI4LCAxLjA2MDk4NTA1NzcxMDc5MSAgIF1cbl07XG5cbi8vIGZyb20gSVRVLVIgQlQuMjEyNC0wIEFubmV4IDIgcC4zXG5jb25zdCBmcm9tWFlaX00kNSA9IFtcblx0WyAgMS43MTY2NTExODc5NzEyNjgsICAtMC4zNTU2NzA3ODM3NzYzOTIsIC0wLjI1MzM2NjI4MTM3MzY2MCAgXSxcblx0WyAtMC42NjY2ODQzNTE4MzI0ODksICAgMS42MTY0ODEyMzY2MzQ5MzksICAwLjAxNTc2ODU0NTgxMzkxMTEgXSxcblx0WyAgMC4wMTc2Mzk4NTc0NDUzMTEsICAtMC4wNDI3NzA2MTMyNTc4MDksICAwLjk0MjEwMzEyMTIzNTQ3NCAgXVxuXTtcblxudmFyIFJFQzIwMjBMaW5lYXIgPSBuZXcgUkdCQ29sb3JTcGFjZSh7XG5cdGlkOiBcInJlYzIwMjAtbGluZWFyXCIsXG5cdG5hbWU6IFwiTGluZWFyIFJFQy4yMDIwXCIsXG5cdHdoaXRlOiBcIkQ2NVwiLFxuXHR0b1hZWl9NOiB0b1hZWl9NJDUsXG5cdGZyb21YWVpfTTogZnJvbVhZWl9NJDUsXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge30sXG5cdH1cbn0pO1xuXG4vLyBpbXBvcnQgc1JHQiBmcm9tIFwiLi9zcmdiLmpzXCI7XG5cbmNvbnN0IM6xID0gMS4wOTkyOTY4MjY4MDk0NDtcbmNvbnN0IM6yID0gMC4wMTgwNTM5Njg1MTA4MDc7XG5cbnZhciBSRUMyMDIwID0gbmV3IFJHQkNvbG9yU3BhY2Uoe1xuXHRpZDogXCJyZWMyMDIwXCIsXG5cdG5hbWU6IFwiUkVDLjIwMjBcIixcblx0YmFzZTogUkVDMjAyMExpbmVhcixcblx0Ly8gTm9uLWxpbmVhciB0cmFuc2ZlciBmdW5jdGlvbiBmcm9tIFJlYy4gSVRVLVIgQlQuMjAyMC0yIHRhYmxlIDRcblx0dG9CYXNlIChSR0IpIHtcblx0XHRyZXR1cm4gUkdCLm1hcChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRpZiAodmFsIDwgzrIgKiA0LjUgKSB7XG5cdFx0XHRcdHJldHVybiB2YWwgLyA0LjU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBNYXRoLnBvdygodmFsICsgzrEgLTEgKSAvIM6xLCAxLzAuNDUpO1xuXHRcdH0pO1xuXHR9LFxuXHRmcm9tQmFzZSAoUkdCKSB7XG5cdFx0cmV0dXJuIFJHQi5tYXAoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0aWYgKHZhbCA+PSDOsiApIHtcblx0XHRcdFx0cmV0dXJuIM6xICogTWF0aC5wb3codmFsLCAwLjQ1KSAtICjOsSAtIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gNC41ICogdmFsO1xuXHRcdH0pO1xuXHR9LFxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHt9LFxuXHR9XG59KTtcblxuY29uc3QgdG9YWVpfTSQ0ID0gW1xuXHRbMC40ODY1NzA5NDg2NDgyMTYyLCAwLjI2NTY2NzY5MzE2OTA5MzA2LCAwLjE5ODIxNzI4NTIzNDM2MjVdLFxuXHRbMC4yMjg5NzQ1NjQwNjk3NDg4LCAwLjY5MTczODUyMTgzNjUwNjQsICAwLjA3OTI4NjkxNDA5Mzc0NV0sXG5cdFswLjAwMDAwMDAwMDAwMDAwMDAsIDAuMDQ1MTEzMzgxODU4OTAyNjQsIDEuMDQzOTQ0MzY4OTAwOTc2XVxuXTtcblxuY29uc3QgZnJvbVhZWl9NJDQgPSBbXG5cdFsgMi40OTM0OTY5MTE5NDE0MjUsICAgLTAuOTMxMzgzNjE3OTE5MTIzOSwgLTAuNDAyNzEwNzg0NDUwNzE2ODRdLFxuXHRbLTAuODI5NDg4OTY5NTYxNTc0NywgICAxLjc2MjY2NDA2MDMxODM0NjMsICAwLjAyMzYyNDY4NTg0MTk0MzU3N10sXG5cdFsgMC4wMzU4NDU4MzAyNDM3ODQ0NywgLTAuMDc2MTcyMzg5MjY4MDQxODIsIDAuOTU2ODg0NTI0MDA3Njg3Ml1cbl07XG5cbnZhciBQM0xpbmVhciA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwicDMtbGluZWFyXCIsXG5cdG5hbWU6IFwiTGluZWFyIFAzXCIsXG5cdHdoaXRlOiBcIkQ2NVwiLFxuXHR0b1hZWl9NOiB0b1hZWl9NJDQsXG5cdGZyb21YWVpfTTogZnJvbVhZWl9NJDRcbn0pO1xuXG4vLyBUaGlzIGlzIHRoZSBsaW5lYXItbGlnaHQgdmVyc2lvbiBvZiBzUkdCXG4vLyBhcyB1c2VkIGZvciBleGFtcGxlIGluIFNWRyBmaWx0ZXJzXG4vLyBvciBpbiBDYW52YXNcblxuLy8gVGhpcyBtYXRyaXggd2FzIGNhbGN1bGF0ZWQgZGlyZWN0bHkgZnJvbSB0aGUgUkdCIGFuZCB3aGl0ZSBjaHJvbWF0aWNpdGllc1xuLy8gd2hlbiByb3VuZGVkIHRvIDggZGVjaW1hbCBwbGFjZXMsIGl0IGFncmVlcyBjb21wbGV0ZWx5IHdpdGggdGhlIG9mZmljaWFsIG1hdHJpeFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvY3Nzd2ctZHJhZnRzL2lzc3Vlcy81OTIyXG5jb25zdCB0b1hZWl9NJDMgPSBbXG5cdFsgMC40MTIzOTA3OTkyNjU5NTkzNCwgMC4zNTc1ODQzMzkzODM4NzgsICAgMC4xODA0ODA3ODg0MDE4MzQzICBdLFxuXHRbIDAuMjEyNjM5MDA1ODcxNTEwMjcsIDAuNzE1MTY4Njc4NzY3NzU2LCAgIDAuMDcyMTkyMzE1MzYwNzMzNzEgXSxcblx0WyAwLjAxOTMzMDgxODcxNTU5MTgyLCAwLjExOTE5NDc3OTc5NDYyNTk4LCAwLjk1MDUzMjE1MjI0OTY2MDcgIF1cbl07XG5cbi8vIFRoaXMgbWF0cml4IGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBhYm92ZTtcbi8vIGFnYWluIGl0IGFncmVlcyB3aXRoIHRoZSBvZmZpY2lhbCBkZWZpbml0aW9uIHdoZW4gcm91bmRlZCB0byA4IGRlY2ltYWwgcGxhY2VzXG5jb25zdCBmcm9tWFlaX00kMyA9IFtcblx0WyAgMy4yNDA5Njk5NDE5MDQ1MjI2LCAgLTEuNTM3MzgzMTc3NTcwMDk0LCAgIC0wLjQ5ODYxMDc2MDI5MzAwMzQgIF0sXG5cdFsgLTAuOTY5MjQzNjM2MjgwODc5NiwgICAxLjg3NTk2NzUwMTUwNzcyMDIsICAgMC4wNDE1NTUwNTc0MDcxNzU1OSBdLFxuXHRbICAwLjA1NTYzMDA3OTY5Njk5MzY2LCAtMC4yMDM5NzY5NTg4ODg5NzY1MiwgIDEuMDU2OTcxNTE0MjQyODc4NiAgXVxuXTtcblxudmFyIHNSR0JMaW5lYXIgPSBuZXcgUkdCQ29sb3JTcGFjZSh7XG5cdGlkOiBcInNyZ2ItbGluZWFyXCIsXG5cdG5hbWU6IFwiTGluZWFyIHNSR0JcIixcblx0d2hpdGU6IFwiRDY1XCIsXG5cdHRvWFlaX006IHRvWFlaX00kMyxcblx0ZnJvbVhZWl9NOiBmcm9tWFlaX00kMyxcblx0Zm9ybWF0czoge1xuXHRcdGNvbG9yOiB7fVxuXHR9LFxufSk7XG5cbi8qIExpc3Qgb2YgQ1NTIGNvbG9yIGtleXdvcmRzXG4gKiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBpbmNsdWRlIGN1cnJlbnRDb2xvciwgdHJhbnNwYXJlbnQsXG4gKiBvciBzeXN0ZW0gY29sb3JzXG4gKi9cblxuLy8gVG8gcHJvZHVjZTogVmlzaXQgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci00LyNuYW1lZC1jb2xvcnNcbi8vIGFuZCBydW4gaW4gdGhlIGNvbnNvbGU6XG4vLyBjb3B5KCQkKFwidHJcIiwgJChcIi5uYW1lZC1jb2xvci10YWJsZSB0Ym9keVwiKSkubWFwKHRyID0+IGBcIiR7dHIuY2VsbHNbMl0udGV4dENvbnRlbnQudHJpbSgpfVwiOiBbJHt0ci5jZWxsc1s0XS50ZXh0Q29udGVudC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoYyA9PiBjID09PSBcIjBcIj8gXCIwXCIgOiBjID09PSBcIjI1NVwiPyBcIjFcIiA6IGMgKyBcIiAvIDI1NVwiKS5qb2luKFwiLCBcIil9XWApLmpvaW4oXCIsXFxuXCIpKVxudmFyIEtFWVdPUkRTID0ge1xuXHRcImFsaWNlYmx1ZVwiOiBbMjQwIC8gMjU1LCAyNDggLyAyNTUsIDFdLFxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwIC8gMjU1LCAyMzUgLyAyNTUsIDIxNSAvIDI1NV0sXG5cdFwiYXF1YVwiOiBbMCwgMSwgMV0sXG5cdFwiYXF1YW1hcmluZVwiOiBbMTI3IC8gMjU1LCAxLCAyMTIgLyAyNTVdLFxuXHRcImF6dXJlXCI6IFsyNDAgLyAyNTUsIDEsIDFdLFxuXHRcImJlaWdlXCI6IFsyNDUgLyAyNTUsIDI0NSAvIDI1NSwgMjIwIC8gMjU1XSxcblx0XCJiaXNxdWVcIjogWzEsIDIyOCAvIDI1NSwgMTk2IC8gMjU1XSxcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXG5cdFwiYmxhbmNoZWRhbG1vbmRcIjogWzEsIDIzNSAvIDI1NSwgMjA1IC8gMjU1XSxcblx0XCJibHVlXCI6IFswLCAwLCAxXSxcblx0XCJibHVldmlvbGV0XCI6IFsxMzggLyAyNTUsIDQzIC8gMjU1LCAyMjYgLyAyNTVdLFxuXHRcImJyb3duXCI6IFsxNjUgLyAyNTUsIDQyIC8gMjU1LCA0MiAvIDI1NV0sXG5cdFwiYnVybHl3b29kXCI6IFsyMjIgLyAyNTUsIDE4NCAvIDI1NSwgMTM1IC8gMjU1XSxcblx0XCJjYWRldGJsdWVcIjogWzk1IC8gMjU1LCAxNTggLyAyNTUsIDE2MCAvIDI1NV0sXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3IC8gMjU1LCAxLCAwXSxcblx0XCJjaG9jb2xhdGVcIjogWzIxMCAvIDI1NSwgMTA1IC8gMjU1LCAzMCAvIDI1NV0sXG5cdFwiY29yYWxcIjogWzEsIDEyNyAvIDI1NSwgODAgLyAyNTVdLFxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAgLyAyNTUsIDE0OSAvIDI1NSwgMjM3IC8gMjU1XSxcblx0XCJjb3Juc2lsa1wiOiBbMSwgMjQ4IC8gMjU1LCAyMjAgLyAyNTVdLFxuXHRcImNyaW1zb25cIjogWzIyMCAvIDI1NSwgMjAgLyAyNTUsIDYwIC8gMjU1XSxcblx0XCJjeWFuXCI6IFswLCAxLCAxXSxcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5IC8gMjU1XSxcblx0XCJkYXJrY3lhblwiOiBbMCwgMTM5IC8gMjU1LCAxMzkgLyAyNTVdLFxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCAvIDI1NSwgMTM0IC8gMjU1LCAxMSAvIDI1NV0sXG5cdFwiZGFya2dyYXlcIjogWzE2OSAvIDI1NSwgMTY5IC8gMjU1LCAxNjkgLyAyNTVdLFxuXHRcImRhcmtncmVlblwiOiBbMCwgMTAwIC8gMjU1LCAwXSxcblx0XCJkYXJrZ3JleVwiOiBbMTY5IC8gMjU1LCAxNjkgLyAyNTUsIDE2OSAvIDI1NV0sXG5cdFwiZGFya2toYWtpXCI6IFsxODkgLyAyNTUsIDE4MyAvIDI1NSwgMTA3IC8gMjU1XSxcblx0XCJkYXJrbWFnZW50YVwiOiBbMTM5IC8gMjU1LCAwLCAxMzkgLyAyNTVdLFxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSAvIDI1NSwgMTA3IC8gMjU1LCA0NyAvIDI1NV0sXG5cdFwiZGFya29yYW5nZVwiOiBbMSwgMTQwIC8gMjU1LCAwXSxcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMgLyAyNTUsIDUwIC8gMjU1LCAyMDQgLyAyNTVdLFxuXHRcImRhcmtyZWRcIjogWzEzOSAvIDI1NSwgMCwgMF0sXG5cdFwiZGFya3NhbG1vblwiOiBbMjMzIC8gMjU1LCAxNTAgLyAyNTUsIDEyMiAvIDI1NV0sXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMgLyAyNTUsIDE4OCAvIDI1NSwgMTQzIC8gMjU1XSxcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiAvIDI1NSwgNjEgLyAyNTUsIDEzOSAvIDI1NV0sXG5cdFwiZGFya3NsYXRlZ3JheVwiOiBbNDcgLyAyNTUsIDc5IC8gMjU1LCA3OSAvIDI1NV0sXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcgLyAyNTUsIDc5IC8gMjU1LCA3OSAvIDI1NV0sXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2IC8gMjU1LCAyMDkgLyAyNTVdLFxuXHRcImRhcmt2aW9sZXRcIjogWzE0OCAvIDI1NSwgMCwgMjExIC8gMjU1XSxcblx0XCJkZWVwcGlua1wiOiBbMSwgMjAgLyAyNTUsIDE0NyAvIDI1NV0sXG5cdFwiZGVlcHNreWJsdWVcIjogWzAsIDE5MSAvIDI1NSwgMV0sXG5cdFwiZGltZ3JheVwiOiBbMTA1IC8gMjU1LCAxMDUgLyAyNTUsIDEwNSAvIDI1NV0sXG5cdFwiZGltZ3JleVwiOiBbMTA1IC8gMjU1LCAxMDUgLyAyNTUsIDEwNSAvIDI1NV0sXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAgLyAyNTUsIDE0NCAvIDI1NSwgMV0sXG5cdFwiZmlyZWJyaWNrXCI6IFsxNzggLyAyNTUsIDM0IC8gMjU1LCAzNCAvIDI1NV0sXG5cdFwiZmxvcmFsd2hpdGVcIjogWzEsIDI1MCAvIDI1NSwgMjQwIC8gMjU1XSxcblx0XCJmb3Jlc3RncmVlblwiOiBbMzQgLyAyNTUsIDEzOSAvIDI1NSwgMzQgLyAyNTVdLFxuXHRcImZ1Y2hzaWFcIjogWzEsIDAsIDFdLFxuXHRcImdhaW5zYm9yb1wiOiBbMjIwIC8gMjU1LCAyMjAgLyAyNTUsIDIyMCAvIDI1NV0sXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4IC8gMjU1LCAyNDggLyAyNTUsIDFdLFxuXHRcImdvbGRcIjogWzEsIDIxNSAvIDI1NSwgMF0sXG5cdFwiZ29sZGVucm9kXCI6IFsyMTggLyAyNTUsIDE2NSAvIDI1NSwgMzIgLyAyNTVdLFxuXHRcImdyYXlcIjogWzEyOCAvIDI1NSwgMTI4IC8gMjU1LCAxMjggLyAyNTVdLFxuXHRcImdyZWVuXCI6IFswLCAxMjggLyAyNTUsIDBdLFxuXHRcImdyZWVueWVsbG93XCI6IFsxNzMgLyAyNTUsIDEsIDQ3IC8gMjU1XSxcblx0XCJncmV5XCI6IFsxMjggLyAyNTUsIDEyOCAvIDI1NSwgMTI4IC8gMjU1XSxcblx0XCJob25leWRld1wiOiBbMjQwIC8gMjU1LCAxLCAyNDAgLyAyNTVdLFxuXHRcImhvdHBpbmtcIjogWzEsIDEwNSAvIDI1NSwgMTgwIC8gMjU1XSxcblx0XCJpbmRpYW5yZWRcIjogWzIwNSAvIDI1NSwgOTIgLyAyNTUsIDkyIC8gMjU1XSxcblx0XCJpbmRpZ29cIjogWzc1IC8gMjU1LCAwLCAxMzAgLyAyNTVdLFxuXHRcIml2b3J5XCI6IFsxLCAxLCAyNDAgLyAyNTVdLFxuXHRcImtoYWtpXCI6IFsyNDAgLyAyNTUsIDIzMCAvIDI1NSwgMTQwIC8gMjU1XSxcblx0XCJsYXZlbmRlclwiOiBbMjMwIC8gMjU1LCAyMzAgLyAyNTUsIDI1MCAvIDI1NV0sXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMSwgMjQwIC8gMjU1LCAyNDUgLyAyNTVdLFxuXHRcImxhd25ncmVlblwiOiBbMTI0IC8gMjU1LCAyNTIgLyAyNTUsIDBdLFxuXHRcImxlbW9uY2hpZmZvblwiOiBbMSwgMjUwIC8gMjU1LCAyMDUgLyAyNTVdLFxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczIC8gMjU1LCAyMTYgLyAyNTUsIDIzMCAvIDI1NV0sXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwIC8gMjU1LCAxMjggLyAyNTUsIDEyOCAvIDI1NV0sXG5cdFwibGlnaHRjeWFuXCI6IFsyMjQgLyAyNTUsIDEsIDFdLFxuXHRcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAgLyAyNTUsIDI1MCAvIDI1NSwgMjEwIC8gMjU1XSxcblx0XCJsaWdodGdyYXlcIjogWzIxMSAvIDI1NSwgMjExIC8gMjU1LCAyMTEgLyAyNTVdLFxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCAvIDI1NSwgMjM4IC8gMjU1LCAxNDQgLyAyNTVdLFxuXHRcImxpZ2h0Z3JleVwiOiBbMjExIC8gMjU1LCAyMTEgLyAyNTUsIDIxMSAvIDI1NV0sXG5cdFwibGlnaHRwaW5rXCI6IFsxLCAxODIgLyAyNTUsIDE5MyAvIDI1NV0sXG5cdFwibGlnaHRzYWxtb25cIjogWzEsIDE2MCAvIDI1NSwgMTIyIC8gMjU1XSxcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiAvIDI1NSwgMTc4IC8gMjU1LCAxNzAgLyAyNTVdLFxuXHRcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1IC8gMjU1LCAyMDYgLyAyNTUsIDI1MCAvIDI1NV0sXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSAvIDI1NSwgMTM2IC8gMjU1LCAxNTMgLyAyNTVdLFxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTkgLyAyNTUsIDEzNiAvIDI1NSwgMTUzIC8gMjU1XSxcblx0XCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2IC8gMjU1LCAxOTYgLyAyNTUsIDIyMiAvIDI1NV0sXG5cdFwibGlnaHR5ZWxsb3dcIjogWzEsIDEsIDIyNCAvIDI1NV0sXG5cdFwibGltZVwiOiBbMCwgMSwgMF0sXG5cdFwibGltZWdyZWVuXCI6IFs1MCAvIDI1NSwgMjA1IC8gMjU1LCA1MCAvIDI1NV0sXG5cdFwibGluZW5cIjogWzI1MCAvIDI1NSwgMjQwIC8gMjU1LCAyMzAgLyAyNTVdLFxuXHRcIm1hZ2VudGFcIjogWzEsIDAsIDFdLFxuXHRcIm1hcm9vblwiOiBbMTI4IC8gMjU1LCAwLCAwXSxcblx0XCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIgLyAyNTUsIDIwNSAvIDI1NSwgMTcwIC8gMjU1XSxcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDUgLyAyNTVdLFxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2IC8gMjU1LCA4NSAvIDI1NSwgMjExIC8gMjU1XSxcblx0XCJtZWRpdW1wdXJwbGVcIjogWzE0NyAvIDI1NSwgMTEyIC8gMjU1LCAyMTkgLyAyNTVdLFxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCAvIDI1NSwgMTc5IC8gMjU1LCAxMTMgLyAyNTVdLFxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzIC8gMjU1LCAxMDQgLyAyNTUsIDIzOCAvIDI1NV0sXG5cdFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsIDI1MCAvIDI1NSwgMTU0IC8gMjU1XSxcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyIC8gMjU1LCAyMDkgLyAyNTUsIDIwNCAvIDI1NV0sXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTkgLyAyNTUsIDIxIC8gMjU1LCAxMzMgLyAyNTVdLFxuXHRcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUgLyAyNTUsIDI1IC8gMjU1LCAxMTIgLyAyNTVdLFxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1IC8gMjU1LCAxLCAyNTAgLyAyNTVdLFxuXHRcIm1pc3R5cm9zZVwiOiBbMSwgMjI4IC8gMjU1LCAyMjUgLyAyNTVdLFxuXHRcIm1vY2Nhc2luXCI6IFsxLCAyMjggLyAyNTUsIDE4MSAvIDI1NV0sXG5cdFwibmF2YWpvd2hpdGVcIjogWzEsIDIyMiAvIDI1NSwgMTczIC8gMjU1XSxcblx0XCJuYXZ5XCI6IFswLCAwLCAxMjggLyAyNTVdLFxuXHRcIm9sZGxhY2VcIjogWzI1MyAvIDI1NSwgMjQ1IC8gMjU1LCAyMzAgLyAyNTVdLFxuXHRcIm9saXZlXCI6IFsxMjggLyAyNTUsIDEyOCAvIDI1NSwgMF0sXG5cdFwib2xpdmVkcmFiXCI6IFsxMDcgLyAyNTUsIDE0MiAvIDI1NSwgMzUgLyAyNTVdLFxuXHRcIm9yYW5nZVwiOiBbMSwgMTY1IC8gMjU1LCAwXSxcblx0XCJvcmFuZ2VyZWRcIjogWzEsIDY5IC8gMjU1LCAwXSxcblx0XCJvcmNoaWRcIjogWzIxOCAvIDI1NSwgMTEyIC8gMjU1LCAyMTQgLyAyNTVdLFxuXHRcInBhbGVnb2xkZW5yb2RcIjogWzIzOCAvIDI1NSwgMjMyIC8gMjU1LCAxNzAgLyAyNTVdLFxuXHRcInBhbGVncmVlblwiOiBbMTUyIC8gMjU1LCAyNTEgLyAyNTUsIDE1MiAvIDI1NV0sXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1IC8gMjU1LCAyMzggLyAyNTUsIDIzOCAvIDI1NV0sXG5cdFwicGFsZXZpb2xldHJlZFwiOiBbMjE5IC8gMjU1LCAxMTIgLyAyNTUsIDE0NyAvIDI1NV0sXG5cdFwicGFwYXlhd2hpcFwiOiBbMSwgMjM5IC8gMjU1LCAyMTMgLyAyNTVdLFxuXHRcInBlYWNocHVmZlwiOiBbMSwgMjE4IC8gMjU1LCAxODUgLyAyNTVdLFxuXHRcInBlcnVcIjogWzIwNSAvIDI1NSwgMTMzIC8gMjU1LCA2MyAvIDI1NV0sXG5cdFwicGlua1wiOiBbMSwgMTkyIC8gMjU1LCAyMDMgLyAyNTVdLFxuXHRcInBsdW1cIjogWzIyMSAvIDI1NSwgMTYwIC8gMjU1LCAyMjEgLyAyNTVdLFxuXHRcInBvd2RlcmJsdWVcIjogWzE3NiAvIDI1NSwgMjI0IC8gMjU1LCAyMzAgLyAyNTVdLFxuXHRcInB1cnBsZVwiOiBbMTI4IC8gMjU1LCAwLCAxMjggLyAyNTVdLFxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiAvIDI1NSwgNTEgLyAyNTUsIDE1MyAvIDI1NV0sXG5cdFwicmVkXCI6IFsxLCAwLCAwXSxcblx0XCJyb3N5YnJvd25cIjogWzE4OCAvIDI1NSwgMTQzIC8gMjU1LCAxNDMgLyAyNTVdLFxuXHRcInJveWFsYmx1ZVwiOiBbNjUgLyAyNTUsIDEwNSAvIDI1NSwgMjI1IC8gMjU1XSxcblx0XCJzYWRkbGVicm93blwiOiBbMTM5IC8gMjU1LCA2OSAvIDI1NSwgMTkgLyAyNTVdLFxuXHRcInNhbG1vblwiOiBbMjUwIC8gMjU1LCAxMjggLyAyNTUsIDExNCAvIDI1NV0sXG5cdFwic2FuZHlicm93blwiOiBbMjQ0IC8gMjU1LCAxNjQgLyAyNTUsIDk2IC8gMjU1XSxcblx0XCJzZWFncmVlblwiOiBbNDYgLyAyNTUsIDEzOSAvIDI1NSwgODcgLyAyNTVdLFxuXHRcInNlYXNoZWxsXCI6IFsxLCAyNDUgLyAyNTUsIDIzOCAvIDI1NV0sXG5cdFwic2llbm5hXCI6IFsxNjAgLyAyNTUsIDgyIC8gMjU1LCA0NSAvIDI1NV0sXG5cdFwic2lsdmVyXCI6IFsxOTIgLyAyNTUsIDE5MiAvIDI1NSwgMTkyIC8gMjU1XSxcblx0XCJza3libHVlXCI6IFsxMzUgLyAyNTUsIDIwNiAvIDI1NSwgMjM1IC8gMjU1XSxcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiAvIDI1NSwgOTAgLyAyNTUsIDIwNSAvIDI1NV0sXG5cdFwic2xhdGVncmF5XCI6IFsxMTIgLyAyNTUsIDEyOCAvIDI1NSwgMTQ0IC8gMjU1XSxcblx0XCJzbGF0ZWdyZXlcIjogWzExMiAvIDI1NSwgMTI4IC8gMjU1LCAxNDQgLyAyNTVdLFxuXHRcInNub3dcIjogWzEsIDI1MCAvIDI1NSwgMjUwIC8gMjU1XSxcblx0XCJzcHJpbmdncmVlblwiOiBbMCwgMSwgMTI3IC8gMjU1XSxcblx0XCJzdGVlbGJsdWVcIjogWzcwIC8gMjU1LCAxMzAgLyAyNTUsIDE4MCAvIDI1NV0sXG5cdFwidGFuXCI6IFsyMTAgLyAyNTUsIDE4MCAvIDI1NSwgMTQwIC8gMjU1XSxcblx0XCJ0ZWFsXCI6IFswLCAxMjggLyAyNTUsIDEyOCAvIDI1NV0sXG5cdFwidGhpc3RsZVwiOiBbMjE2IC8gMjU1LCAxOTEgLyAyNTUsIDIxNiAvIDI1NV0sXG5cdFwidG9tYXRvXCI6IFsxLCA5OSAvIDI1NSwgNzEgLyAyNTVdLFxuXHRcInR1cnF1b2lzZVwiOiBbNjQgLyAyNTUsIDIyNCAvIDI1NSwgMjA4IC8gMjU1XSxcblx0XCJ2aW9sZXRcIjogWzIzOCAvIDI1NSwgMTMwIC8gMjU1LCAyMzggLyAyNTVdLFxuXHRcIndoZWF0XCI6IFsyNDUgLyAyNTUsIDIyMiAvIDI1NSwgMTc5IC8gMjU1XSxcblx0XCJ3aGl0ZVwiOiBbMSwgMSwgMV0sXG5cdFwid2hpdGVzbW9rZVwiOiBbMjQ1IC8gMjU1LCAyNDUgLyAyNTUsIDI0NSAvIDI1NV0sXG5cdFwieWVsbG93XCI6IFsxLCAxLCAwXSxcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0IC8gMjU1LCAyMDUgLyAyNTUsIDUwIC8gMjU1XVxufTtcblxubGV0IGNvb3JkR3JhbW1hciA9IEFycmF5KDMpLmZpbGwoXCI8cGVyY2VudGFnZT4gfCA8bnVtYmVyPlswLCAyNTVdXCIpO1xubGV0IGNvb3JkR3JhbW1hck51bWJlciA9IEFycmF5KDMpLmZpbGwoXCI8bnVtYmVyPlswLCAyNTVdXCIpO1xuXG52YXIgc1JHQiA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwic3JnYlwiLFxuXHRuYW1lOiBcInNSR0JcIixcblx0YmFzZTogc1JHQkxpbmVhcixcblx0ZnJvbUJhc2U6IHJnYiA9PiB7XG5cdFx0Ly8gY29udmVydCBhbiBhcnJheSBvZiBsaW5lYXItbGlnaHQgc1JHQiB2YWx1ZXMgaW4gdGhlIHJhbmdlIDAuMC0xLjBcblx0XHQvLyB0byBnYW1tYSBjb3JyZWN0ZWQgZm9ybVxuXHRcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NSR0Jcblx0XHRyZXR1cm4gcmdiLm1hcCh2YWwgPT4ge1xuXHRcdFx0bGV0IHNpZ24gPSB2YWwgPCAwPyAtMSA6IDE7XG5cdFx0XHRsZXQgYWJzID0gdmFsICogc2lnbjtcblxuXHRcdFx0aWYgKGFicyA+IDAuMDAzMTMwOCkge1xuXHRcdFx0XHRyZXR1cm4gc2lnbiAqICgxLjA1NSAqIChhYnMgKiogKDEvMi40KSkgLSAwLjA1NSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAxMi45MiAqIHZhbDtcblx0XHR9KTtcblx0fSxcblx0dG9CYXNlOiByZ2IgPT4ge1xuXHRcdC8vIGNvbnZlcnQgYW4gYXJyYXkgb2Ygc1JHQiB2YWx1ZXMgaW4gdGhlIHJhbmdlIDAuMCAtIDEuMFxuXHRcdC8vIHRvIGxpbmVhciBsaWdodCAodW4tY29tcGFuZGVkKSBmb3JtLlxuXHRcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NSR0Jcblx0XHRyZXR1cm4gcmdiLm1hcCh2YWwgPT4ge1xuXHRcdFx0bGV0IHNpZ24gPSB2YWwgPCAwPyAtMSA6IDE7XG5cdFx0XHRsZXQgYWJzID0gdmFsICogc2lnbjtcblxuXHRcdFx0aWYgKGFicyA8IDAuMDQwNDUpIHtcblx0XHRcdFx0cmV0dXJuIHZhbCAvIDEyLjkyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2lnbiAqICgoKGFicyArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQpO1xuXHRcdH0pO1xuXHR9LFxuXHRmb3JtYXRzOiB7XG5cdFx0XCJyZ2JcIjoge1xuXHRcdFx0Y29vcmRzOiBjb29yZEdyYW1tYXIsXG5cdFx0fSxcblx0XHRcInJnYl9udW1iZXJcIjoge1xuXHRcdFx0bmFtZTogXCJyZ2JcIixcblx0XHRcdGNvbW1hczogdHJ1ZSxcblx0XHRcdGNvb3JkczogY29vcmRHcmFtbWFyTnVtYmVyLFxuXHRcdFx0bm9BbHBoYTogdHJ1ZSxcblx0XHR9LFxuXHRcdFwiY29sb3JcIjogeyAvKiB1c2UgZGVmYXVsdHMgKi8gfSxcblx0XHRcInJnYmFcIjoge1xuXHRcdFx0Y29vcmRzOiBjb29yZEdyYW1tYXIsXG5cdFx0XHRjb21tYXM6IHRydWUsXG5cdFx0XHRsYXN0QWxwaGE6IHRydWUsXG5cdFx0fSxcblx0XHRcInJnYmFfbnVtYmVyXCI6IHtcblx0XHRcdG5hbWU6IFwicmdiYVwiLFxuXHRcdFx0Y29tbWFzOiB0cnVlLFxuXHRcdFx0Y29vcmRzOiBjb29yZEdyYW1tYXJOdW1iZXJcblx0XHR9LFxuXHRcdFwiaGV4XCI6IHtcblx0XHRcdHR5cGU6IFwiY3VzdG9tXCIsXG5cdFx0XHR0b0dhbXV0OiB0cnVlLFxuXHRcdFx0dGVzdDogc3RyID0+IC9eIyhbYS1mMC05XXszLDR9KXsxLDJ9JC9pLnRlc3Qoc3RyKSxcblx0XHRcdHBhcnNlIChzdHIpIHtcblx0XHRcdFx0aWYgKHN0ci5sZW5ndGggPD0gNSkge1xuXHRcdFx0XHRcdC8vICNyZ2Igb3IgI3JnYmEsIGR1cGxpY2F0ZSBkaWdpdHNcblx0XHRcdFx0XHRzdHIgPSBzdHIucmVwbGFjZSgvW2EtZjAtOV0vZ2ksIFwiJCYkJlwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCByZ2JhID0gW107XG5cdFx0XHRcdHN0ci5yZXBsYWNlKC9bYS1mMC05XXsyfS9naSwgY29tcG9uZW50ID0+IHtcblx0XHRcdFx0XHRyZ2JhLnB1c2gocGFyc2VJbnQoY29tcG9uZW50LCAxNikgLyAyNTUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHNwYWNlSWQ6IFwic3JnYlwiLFxuXHRcdFx0XHRcdGNvb3JkczogcmdiYS5zbGljZSgwLCAzKSxcblx0XHRcdFx0XHRhbHBoYTogcmdiYS5zbGljZSgzKVswXVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdHNlcmlhbGl6ZTogKGNvb3JkcywgYWxwaGEsIHtcblx0XHRcdFx0Y29sbGFwc2UgPSB0cnVlIC8vIGNvbGxhcHNlIHRvIDMtNCBkaWdpdCBoZXggd2hlbiBwb3NzaWJsZT9cblx0XHRcdH0gPSB7fSkgPT4ge1xuXHRcdFx0XHRpZiAoYWxwaGEgPCAxKSB7XG5cdFx0XHRcdFx0Y29vcmRzLnB1c2goYWxwaGEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29vcmRzID0gY29vcmRzLm1hcChjID0+IE1hdGgucm91bmQoYyAqIDI1NSkpO1xuXG5cdFx0XHRcdGxldCBjb2xsYXBzaWJsZSA9IGNvbGxhcHNlICYmIGNvb3Jkcy5ldmVyeShjID0+IGMgJSAxNyA9PT0gMCk7XG5cblx0XHRcdFx0bGV0IGhleCA9IGNvb3Jkcy5tYXAoYyA9PiB7XG5cdFx0XHRcdFx0aWYgKGNvbGxhcHNpYmxlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKGMvMTcpLnRvU3RyaW5nKDE2KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gYy50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xuXHRcdFx0XHR9KS5qb2luKFwiXCIpO1xuXG5cdFx0XHRcdHJldHVybiBcIiNcIiArIGhleDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwia2V5d29yZFwiOiB7XG5cdFx0XHR0eXBlOiBcImN1c3RvbVwiLFxuXHRcdFx0dGVzdDogc3RyID0+IC9eW2Etel0rJC9pLnRlc3Qoc3RyKSxcblx0XHRcdHBhcnNlIChzdHIpIHtcblx0XHRcdFx0c3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGxldCByZXQgPSB7c3BhY2VJZDogXCJzcmdiXCIsIGNvb3JkczogbnVsbCwgYWxwaGE6IDF9O1xuXG5cdFx0XHRcdGlmIChzdHIgPT09IFwidHJhbnNwYXJlbnRcIikge1xuXHRcdFx0XHRcdHJldC5jb29yZHMgPSBLRVlXT1JEUy5ibGFjaztcblx0XHRcdFx0XHRyZXQuYWxwaGEgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldC5jb29yZHMgPSBLRVlXT1JEU1tzdHJdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJldC5jb29yZHMpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0fVxufSk7XG5cbnZhciBQMyA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwicDNcIixcblx0bmFtZTogXCJQM1wiLFxuXHRiYXNlOiBQM0xpbmVhcixcblx0Ly8gR2FtbWEgZW5jb2RpbmcvZGVjb2RpbmcgaXMgdGhlIHNhbWUgYXMgc1JHQlxuXHRmcm9tQmFzZTogc1JHQi5mcm9tQmFzZSxcblx0dG9CYXNlOiBzUkdCLnRvQmFzZSxcblx0Zm9ybWF0czoge1xuXHRcdGNvbG9yOiB7XG5cdFx0XHRpZDogXCJkaXNwbGF5LXAzXCIsXG5cdFx0fVxuXHR9LFxufSk7XG5cbi8vIERlZmF1bHQgc3BhY2UgZm9yIENTUyBvdXRwdXQuIENvZGUgaW4gQ29sb3IuanMgbWFrZXMgdGhpcyB3aWRlciBpZiB0aGVyZSdzIGEgRE9NIGF2YWlsYWJsZVxuZGVmYXVsdHMuZGlzcGxheV9zcGFjZSA9IHNSR0I7XG5cbmlmICh0eXBlb2YgQ1NTICE9PSBcInVuZGVmaW5lZFwiICYmIENTUy5zdXBwb3J0cykge1xuXHQvLyBGaW5kIHdpZGVzdCBzdXBwb3J0ZWQgY29sb3Igc3BhY2UgZm9yIENTU1xuXHRmb3IgKGxldCBzcGFjZSBvZiBbbGFiLCBSRUMyMDIwLCBQM10pIHtcblx0XHRsZXQgY29vcmRzID0gc3BhY2UuZ2V0TWluQ29vcmRzKCk7XG5cdFx0bGV0IGNvbG9yID0ge3NwYWNlLCBjb29yZHMsIGFscGhhOiAxfTtcblx0XHRsZXQgc3RyID0gc2VyaWFsaXplKGNvbG9yKTtcblxuXHRcdGlmIChDU1Muc3VwcG9ydHMoXCJjb2xvclwiLCBzdHIpKSB7XG5cdFx0XHRkZWZhdWx0cy5kaXNwbGF5X3NwYWNlID0gc3BhY2U7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2VyaWFsaXphdGlvbiBvZiB0aGUgY29sb3IgdGhhdCBjYW4gYWN0dWFsbHkgYmUgZGlzcGxheWVkIGluIHRoZSBicm93c2VyLlxuICogSWYgdGhlIGRlZmF1bHQgc2VyaWFsaXphdGlvbiBjYW4gYmUgZGlzcGxheWVkLCBpdCBpcyByZXR1cm5lZC5cbiAqIE90aGVyd2lzZSwgdGhlIGNvbG9yIGlzIGNvbnZlcnRlZCB0byBMYWIsIFJFQzIwMjAsIG9yIFAzLCB3aGljaGV2ZXIgaXMgdGhlIHdpZGVzdCBzdXBwb3J0ZWQuXG4gKiBJbiBOb2RlLmpzLCB0aGlzIGlzIGJhc2ljYWxseSBlcXVpdmFsZW50IHRvIGBzZXJpYWxpemUoKWAgYnV0IHJldHVybnMgYSBgU3RyaW5nYCBvYmplY3QgaW5zdGVhZC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0ge3tzcGFjZSwgY29vcmRzfSB8IENvbG9yIHwgc3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHsqfSBbb3B0aW9ucz17fV0gT3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gc2VyaWFsaXplKClcbiAqIEBwYXJhbSB7Q29sb3JTcGFjZSB8IHN0cmluZ30gW29wdGlvbnMuc3BhY2UgPSBkZWZhdWx0cy5kaXNwbGF5X3NwYWNlXSBDb2xvciBzcGFjZSB0byB1c2UgZm9yIHNlcmlhbGl6YXRpb24gaWYgZGVmYXVsdCBpcyBub3Qgc3VwcG9ydGVkXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmcgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNlcmlhbGl6ZWQgY29sb3Igd2l0aCBhIGNvbG9yIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIGNvbnZlcnRlZCBjb2xvciAob3IgdGhlIG9yaWdpbmFsLCBpZiBubyBjb252ZXJzaW9uIHdhcyBuZWNlc3NhcnkpXG4gKi9cbmZ1bmN0aW9uIGRpc3BsYXkgKGNvbG9yLCB7c3BhY2UgPSBkZWZhdWx0cy5kaXNwbGF5X3NwYWNlLCAuLi5vcHRpb25zfSA9IHt9KSB7XG5cdGxldCByZXQgPSBzZXJpYWxpemUoY29sb3IsIG9wdGlvbnMpO1xuXG5cdGlmICh0eXBlb2YgQ1NTID09PSBcInVuZGVmaW5lZFwiIHx8IENTUy5zdXBwb3J0cyhcImNvbG9yXCIsIHJldCkgfHwgIWRlZmF1bHRzLmRpc3BsYXlfc3BhY2UpIHtcblx0XHRyZXQgPSBuZXcgU3RyaW5nKHJldCk7XG5cdFx0cmV0LmNvbG9yID0gY29sb3I7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gSWYgd2UncmUgaGVyZSwgd2hhdCB3ZSB3ZXJlIGFib3V0IHRvIG91dHB1dCBpcyBub3Qgc3VwcG9ydGVkXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGZhbGxiYWNrIHNwYWNlXG5cdFx0bGV0IGZhbGxiYWNrQ29sb3IgPSB0byhjb2xvciwgc3BhY2UpO1xuXHRcdHJldCA9IG5ldyBTdHJpbmcoc2VyaWFsaXplKGZhbGxiYWNrQ29sb3IsIG9wdGlvbnMpKTtcblx0XHRyZXQuY29sb3IgPSBmYWxsYmFja0NvbG9yO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFdWNsaWRlYW4gZGlzdGFuY2Ugb2YgY29sb3JzIGluIGFuIGFyYml0cmFyeSBjb2xvciBzcGFjZVxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSAoY29sb3IxLCBjb2xvcjIsIHNwYWNlID0gXCJsYWJcIikge1xuXHRzcGFjZSA9IENvbG9yU3BhY2UuZ2V0KHNwYWNlKTtcblxuXHRsZXQgY29vcmRzMSA9IHNwYWNlLmZyb20oY29sb3IxKTtcblx0bGV0IGNvb3JkczIgPSBzcGFjZS5mcm9tKGNvbG9yMik7XG5cblx0cmV0dXJuIE1hdGguc3FydChjb29yZHMxLnJlZHVjZSgoYWNjLCBjMSwgaSkgPT4ge1xuXHRcdGxldCBjMiA9IGNvb3JkczJbaV07XG5cdFx0aWYgKGlzTmFOKGMxKSB8fCBpc05hTihjMikpIHtcblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjYyArIChjMiAtIGMxKSAqKiAyO1xuXHR9LCAwKSk7XG59XG5cbmZ1bmN0aW9uIGVxdWFscyAoY29sb3IxLCBjb2xvcjIpIHtcblx0Y29sb3IxID0gZ2V0Q29sb3IoY29sb3IxKTtcblx0Y29sb3IyID0gZ2V0Q29sb3IoY29sb3IyKTtcblxuXHRyZXR1cm4gY29sb3IxLnNwYWNlID09PSBjb2xvcjIuc3BhY2Vcblx0XHQgICAmJiBjb2xvcjEuYWxwaGEgPT09IGNvbG9yMi5hbHBoYVxuXHRcdCAgICYmIGNvbG9yMS5jb29yZHMuZXZlcnkoKGMsIGkpID0+IGMgPT09IGNvbG9yMi5jb29yZHNbaV0pO1xufVxuXG4vKipcbiAqIFJlbGF0aXZlIGx1bWluYW5jZVxuICovXG5cbmZ1bmN0aW9uIGdldEx1bWluYW5jZSAoY29sb3IpIHtcblx0cmV0dXJuIGdldChjb2xvciwgW1hZWl9ENjUsIFwieVwiXSk7XG59XG5cbmZ1bmN0aW9uIHNldEx1bWluYW5jZSAoY29sb3IsIHZhbHVlKSB7XG5cdHNldChjb2xvciwgW1hZWl9ENjUsIFwieVwiXSwgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlciQyIChDb2xvcikge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCBcImx1bWluYW5jZVwiLCB7XG5cdFx0Z2V0ICgpIHtcblx0XHRcdHJldHVybiBnZXRMdW1pbmFuY2UodGhpcyk7XG5cdFx0fSxcblx0XHRzZXQgKHZhbHVlKSB7XG5cdFx0XHRzZXRMdW1pbmFuY2UodGhpcywgdmFsdWUpO1xuXHRcdH1cblx0fSk7XG59XG5cbnZhciBsdW1pbmFuY2UgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0Z2V0THVtaW5hbmNlOiBnZXRMdW1pbmFuY2UsXG5cdHJlZ2lzdGVyOiByZWdpc3RlciQyLFxuXHRzZXRMdW1pbmFuY2U6IHNldEx1bWluYW5jZVxufSk7XG5cbi8vIFdDQUcgMi4wIGNvbnRyYXN0IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvRzE4Lmh0bWxcbi8vIFNpbXBsZSBjb250cmFzdCwgd2l0aCBmaXhlZCA1JSB2aWV3aW5nIGZsYXJlIGNvbnRyaWJ1dGlvblxuLy8gU3ltbWV0cmljLCBkb2VzIG5vdCBtYXR0ZXIgd2hpY2ggaXMgZm9yZWdyb3VuZCBhbmQgd2hpY2ggaXMgYmFja2dyb3VuZFxuXG5cbmZ1bmN0aW9uIGNvbnRyYXN0V0NBRzIxIChjb2xvcjEsIGNvbG9yMikge1xuXHRjb2xvcjEgPSBnZXRDb2xvcihjb2xvcjEpO1xuXHRjb2xvcjIgPSBnZXRDb2xvcihjb2xvcjIpO1xuXG5cdGxldCBZMSA9IE1hdGgubWF4KGdldEx1bWluYW5jZShjb2xvcjEpLCAwKTtcblx0bGV0IFkyID0gTWF0aC5tYXgoZ2V0THVtaW5hbmNlKGNvbG9yMiksIDApO1xuXG5cdGlmIChZMiA+IFkxKSB7XG5cdFx0W1kxLCBZMl0gPSBbWTIsIFkxXTtcblx0fVxuXG5cdHJldHVybiAoWTEgKyAuMDUpIC8gKFkyICsgLjA1KTtcbn1cblxuLy8gQVBDQSAwLjAuOThHXG4vLyBodHRwczovL2dpdGh1Yi5jb20vTXluZGV4L2FwY2EtdzNcbi8vIHNlZSBhbHNvIGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvc2lsdmVyL2lzc3Vlcy82NDNcblxuXG4vLyBleHBvbmVudHNcbmNvbnN0IG5vcm1CRyA9IDAuNTY7XG5jb25zdCBub3JtVFhUID0gMC41NztcbmNvbnN0IHJldlRYVCA9IDAuNjI7XG5jb25zdCByZXZCRyA9IDAuNjU7XG5cbi8vIGNsYW1wc1xuY29uc3QgYmxrVGhycyA9IDAuMDIyO1xuY29uc3QgYmxrQ2xtcCA9IDEuNDE0O1xuY29uc3QgbG9DbGlwID0gMC4xO1xuY29uc3QgZGVsdGFZbWluID0gMC4wMDA1O1xuXG4vLyBzY2FsZXJzXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3czYy9zaWx2ZXIvaXNzdWVzLzY0NVxuY29uc3Qgc2NhbGVCb1cgPSAxLjE0O1xuY29uc3QgbG9Cb1dvZmZzZXQgPSAwLjAyNztcbmNvbnN0IHNjYWxlV29CPSAxLjE0O1xuXG5mdW5jdGlvbiBmY2xhbXAgKFkpIHtcblx0aWYgKFkgPj0gYmxrVGhycykge1xuXHRcdHJldHVybiBZO1xuXHR9XG5cdHJldHVybiBZICsgKGJsa1RocnMgLSBZKSAqKiBibGtDbG1wO1xufVxuXG5mdW5jdGlvbiBsaW5lYXJpemUgKHZhbCkge1xuXHRsZXQgc2lnbiA9IHZhbCA8IDA/IC0xIDogMTtcblx0bGV0IGFicyA9IE1hdGguYWJzKHZhbCk7XG5cdHJldHVybiBzaWduICogTWF0aC5wb3coYWJzLCAyLjQpO1xufVxuXG4vLyBOb3Qgc3ltbWV0cmljLCByZXF1aXJlcyBhIGZvcmVncm91bmQgKHRleHQpIGNvbG9yLCBhbmQgYSBiYWNrZ3JvdW5kIGNvbG9yXG5mdW5jdGlvbiBjb250cmFzdEFQQ0EgKGJhY2tncm91bmQsIGZvcmVncm91bmQpIHtcblx0Zm9yZWdyb3VuZCA9IGdldENvbG9yKGZvcmVncm91bmQpO1xuXHRiYWNrZ3JvdW5kID0gZ2V0Q29sb3IoYmFja2dyb3VuZCk7XG5cblx0bGV0IFM7XG5cdGxldCBDO1xuXHRsZXQgU2FwYztcblxuXHQvLyBNeW5kZXggYXMtcHVibGlzaGVkLCBhc3N1bWVzIHNSR0IgaW5wdXRzXG5cdGxldCBSLCBHLCBCO1xuXG5cdGZvcmVncm91bmQgPSB0byhmb3JlZ3JvdW5kLCBcInNyZ2JcIik7XG5cdC8vIFNob3VsZCB0aGVzZSBiZSBjbGFtcGVkIHRvIGluLWdhbXV0IHZhbHVlcz9cblxuXHQvLyBDYWxjdWxhdGVzIFwic2NyZWVuIGx1bWluYW5jZVwiIHdpdGggbm9uLXN0YW5kYXJkIHNpbXBsZSBnYW1tYSBFT1RGXG5cdC8vIHdlaWdodHMgc2hvdWxkIGJlIGZyb20gQ1NTIENvbG9yIDQsIG5vdCB0aGUgb25lcyBoZXJlIHdoaWNoIGFyZSB2aWEgTXluZGV4IGFuZCBjb3BpZWQgZnJvbSBMaW5kYmxvb21cblx0W1IsIEcsIEJdID0gZm9yZWdyb3VuZC5jb29yZHM7XG5cdGxldCBsdW1UeHQgPSBsaW5lYXJpemUoUikgKiAwLjIxMjY3MjkgKyBsaW5lYXJpemUoRykgKiAwLjcxNTE1MjIgKyBsaW5lYXJpemUoQikgKiAwLjA3MjE3NTA7XG5cblx0YmFja2dyb3VuZCA9IHRvKGJhY2tncm91bmQsIFwic3JnYlwiKTtcblx0W1IsIEcsIEJdID0gYmFja2dyb3VuZC5jb29yZHM7XG5cdGxldCBsdW1CZyA9IGxpbmVhcml6ZShSKSAqIDAuMjEyNjcyOSArIGxpbmVhcml6ZShHKSAqIDAuNzE1MTUyMiArIGxpbmVhcml6ZShCKSAqIDAuMDcyMTc1MDtcblxuXHQvLyB0b2UgY2xhbXBpbmcgb2YgdmVyeSBkYXJrIHZhbHVlcyB0byBhY2NvdW50IGZvciBmbGFyZVxuXHRsZXQgWXR4dCA9IGZjbGFtcChsdW1UeHQpO1xuXHRsZXQgWWJnID0gZmNsYW1wKGx1bUJnKTtcblxuXHQvLyBhcmUgd2UgXCJCbGFjayBvbiBXaGl0ZVwiIChkYXJrIG9uIGxpZ2h0KSwgb3IgbGlnaHQgb24gZGFyaz9cblx0bGV0IEJvVyA9IFliZyA+IFl0eHQ7XG5cblx0Ly8gd2h5IGlzIHRoaXMgYSBkZWx0YSwgd2hlbiBZIGlzIG5vdCBwZXJjZXB0dWFsbHkgdW5pZm9ybT9cblx0Ly8gQW5zd2VyOiBpdCBpcyBhIG5vaXNlIGdhdGUsIHNlZVxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhVmVyb3UvY29sb3IuanMvaXNzdWVzLzIwOFxuXHRpZiAoTWF0aC5hYnMoWWJnIC0gWXR4dCkgPCBkZWx0YVltaW4pIHtcblx0XHRDID0gMDtcblx0fVxuXHRlbHNlIHtcblx0XHRpZiAoQm9XKSB7XG5cdFx0XHQvLyBkYXJrIHRleHQgb24gbGlnaHQgYmFja2dyb3VuZFxuXHRcdFx0UyA9IFliZyAqKiBub3JtQkcgLSBZdHh0ICoqIG5vcm1UWFQ7XG5cdFx0XHRDID0gUyAqIHNjYWxlQm9XO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGxpZ2h0IHRleHQgb24gZGFyayBiYWNrZ3JvdW5kXG5cdFx0XHRTID0gWWJnICoqIHJldkJHIC0gWXR4dCAqKiByZXZUWFQ7XG5cdFx0XHRDID0gUyAqIHNjYWxlV29CO1xuXHRcdH1cblx0fVxuXHRpZiAoTWF0aC5hYnMoQykgPCBsb0NsaXApIHtcblx0XHRTYXBjID0gMDtcblx0fVxuXHRlbHNlIGlmIChDID4gMCkge1xuXHRcdC8vIG5vdCBjbGVhciB3aGV0aGVyIFdvZmZzZXQgaXMgbG9Cb1dvZmZzZXQgb3IgbG9Xb0JvZmZzZXRcblx0XHQvLyBidXQgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlXG5cdFx0U2FwYyA9IEMgLSBsb0JvV29mZnNldDtcblx0fVxuXHRlbHNlIHtcblx0XHRTYXBjID0gQyArIGxvQm9Xb2Zmc2V0O1xuXHR9XG5cblx0cmV0dXJuIFNhcGMgKiAxMDA7XG59XG5cbi8vIE1pY2hlbHNvbiAgbHVtaW5hbmNlIGNvbnRyYXN0XG4vLyB0aGUgcmVsYXRpb24gYmV0d2VlbiB0aGUgc3ByZWFkIGFuZCB0aGUgc3VtIG9mIHRoZSB0d28gbHVtaW5hbmNlc1xuLy8gU3ltbWV0cmljLCBkb2VzIG5vdCBtYXR0ZXIgd2hpY2ggaXMgZm9yZWdyb3VuZCBhbmQgd2hpY2ggaXMgYmFja2dyb3VuZFxuLy8gTm8gYmxhY2sgbGV2ZWwgY29tcGVuc2F0aW9uIGZvciBmbGFyZS5cblxuXG5mdW5jdGlvbiBjb250cmFzdE1pY2hlbHNvbiAoY29sb3IxLCBjb2xvcjIpIHtcblx0Y29sb3IxID0gZ2V0Q29sb3IoY29sb3IxKTtcblx0Y29sb3IyID0gZ2V0Q29sb3IoY29sb3IyKTtcblxuXHRsZXQgWTEgPSBNYXRoLm1heChnZXRMdW1pbmFuY2UoY29sb3IxKSwgMCk7XG5cdGxldCBZMiA9IE1hdGgubWF4KGdldEx1bWluYW5jZShjb2xvcjIpLCAwKTtcblxuXHRpZiAoWTIgPiBZMSkge1xuXHRcdFtZMSwgWTJdID0gW1kyLCBZMV07XG5cdH1cblxuXHRsZXQgZGVub20gPSAoWTEgKyBZMik7XG5cdHJldHVybiBkZW5vbSA9PT0gMCA/IDAgOiAoWTEgLSBZMikgLyBkZW5vbTtcbn1cblxuLy8gV2ViZXIgbHVtaW5hbmNlIGNvbnRyYXN0XG4vLyBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gbHVtaW5hbmNlcyBkaXZpZGVkIGJ5IHRoZSBsb3dlciBsdW1pbmFuY2Vcbi8vIFN5bW1ldHJpYywgZG9lcyBub3QgbWF0dGVyIHdoaWNoIGlzIGZvcmVncm91bmQgYW5kIHdoaWNoIGlzIGJhY2tncm91bmRcbi8vIE5vIGJsYWNrIGxldmVsIGNvbXBlbnNhdGlvbiBmb3IgZmxhcmUuXG5cblxuLy8gdGhlIGRhcmtlc3Qgc1JHQiBjb2xvciBhYm92ZSBibGFjayBpcyAjMDAwMDAxIGFuZCB0aGlzIHByb2R1Y2VzXG4vLyBhIHBsYWluIFdlYmVyIGNvbnRyYXN0IG9mIH40NTY0Ny5cbi8vIFNvLCBzZXR0aW5nIHRoZSBkaXZpZGUtYnktemVybyByZXN1bHQgYXQgNTAwMDAgaXMgYSByZWFzb25hYmxlXG4vLyBtYXggY2xhbXAgZm9yIHRoZSBwbGFpbiBXZWJlclxuY29uc3QgbWF4ID0gNTAwMDA7XG5cbmZ1bmN0aW9uIGNvbnRyYXN0V2ViZXIgKGNvbG9yMSwgY29sb3IyKSB7XG5cdGNvbG9yMSA9IGdldENvbG9yKGNvbG9yMSk7XG5cdGNvbG9yMiA9IGdldENvbG9yKGNvbG9yMik7XG5cblx0bGV0IFkxID0gTWF0aC5tYXgoZ2V0THVtaW5hbmNlKGNvbG9yMSksIDApO1xuXHRsZXQgWTIgPSBNYXRoLm1heChnZXRMdW1pbmFuY2UoY29sb3IyKSwgMCk7XG5cblx0aWYgKFkyID4gWTEpIHtcblx0XHRbWTEsIFkyXSA9IFtZMiwgWTFdO1xuXHR9XG5cblx0cmV0dXJuIFkyID09PSAwID8gbWF4IDogKFkxIC0gWTIpIC8gWTI7XG59XG5cbi8vIENJRSBMaWdodG5lc3MgZGlmZmVyZW5jZSwgYXMgdXNlZCBieSBHb29nbGUgTWF0ZXJpYWwgRGVzaWduXG4vLyBHb29nbGUgSENUIFRvbmUgaXMgdGhlIHNhbWUgYXMgQ0lFIExpZ2h0bmVzc1xuLy8gaHR0cHM6Ly9tYXRlcmlhbC5pby9ibG9nL3NjaWVuY2Utb2YtY29sb3ItZGVzaWduXG5cblxuZnVuY3Rpb24gY29udHJhc3RMc3RhciAoY29sb3IxLCBjb2xvcjIpIHtcblx0Y29sb3IxID0gZ2V0Q29sb3IoY29sb3IxKTtcblx0Y29sb3IyID0gZ2V0Q29sb3IoY29sb3IyKTtcblxuXHRsZXQgTDEgPSBnZXQoY29sb3IxLCBbbGFiLCBcImxcIl0pO1xuXHRsZXQgTDIgPSBnZXQoY29sb3IyLCBbbGFiLCBcImxcIl0pO1xuXG5cdHJldHVybiBNYXRoLmFicyhMMSAtIEwyKTtcbn1cblxuLy8gzrogKiDOtSAgPSAyXjMgPSA4XG5jb25zdCDOtSQxID0gMjE2LzI0Mzg5OyAgLy8gNl4zLzI5XjMgPT0gKDI0LzExNileM1xuY29uc3QgzrUzID0gMjQvMTE2O1xuY29uc3QgzrogPSAyNDM4OS8yNzsgICAvLyAyOV4zLzNeM1xuXG5sZXQgd2hpdGUgPSBXSElURVMuRDY1O1xuXG52YXIgbGFiX2Q2NSA9IG5ldyBDb2xvclNwYWNlKHtcblx0aWQ6IFwibGFiLWQ2NVwiLFxuXHRuYW1lOiBcIkxhYiBENjVcIixcblx0Y29vcmRzOiB7XG5cdFx0bDoge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAxMDBdLFxuXHRcdFx0bmFtZTogXCJMXCJcblx0XHR9LFxuXHRcdGE6IHtcblx0XHRcdHJlZlJhbmdlOiBbLTEyNSwgMTI1XVxuXHRcdH0sXG5cdFx0Yjoge1xuXHRcdFx0cmVmUmFuZ2U6IFstMTI1LCAxMjVdXG5cdFx0fVxuXHR9LFxuXG5cdC8vIEFzc3VtaW5nIFhZWiBpcyByZWxhdGl2ZSB0byBENjUsIGNvbnZlcnQgdG8gQ0lFIExhYlxuXHQvLyBmcm9tIENJRSBzdGFuZGFyZCwgd2hpY2ggbm93IGRlZmluZXMgdGhlc2UgYXMgYSByYXRpb25hbCBmcmFjdGlvblxuXHR3aGl0ZSxcblxuXHRiYXNlOiBYWVpfRDY1LFxuXHQvLyBDb252ZXJ0IEQ2NS1hZGFwdGVkIFhZWiB0byBMYWJcblx0Ly8gIENJRSAxNS4zOjIwMDQgc2VjdGlvbiA4LjIuMS4xXG5cdGZyb21CYXNlIChYWVopIHtcblx0XHQvLyBjb21wdXRlIHh5eiwgd2hpY2ggaXMgWFlaIHNjYWxlZCByZWxhdGl2ZSB0byByZWZlcmVuY2Ugd2hpdGVcblx0XHRsZXQgeHl6ID0gWFlaLm1hcCgodmFsdWUsIGkpID0+IHZhbHVlIC8gd2hpdGVbaV0pO1xuXG5cdFx0Ly8gbm93IGNvbXB1dGUgZlxuXHRcdGxldCBmID0geHl6Lm1hcCh2YWx1ZSA9PiB2YWx1ZSA+IM61JDEgPyBNYXRoLmNicnQodmFsdWUpIDogKM66ICogdmFsdWUgKyAxNikvMTE2KTtcblxuXHRcdHJldHVybiBbXG5cdFx0XHQoMTE2ICogZlsxXSkgLSAxNiwgXHQgLy8gTFxuXHRcdFx0NTAwICogKGZbMF0gLSBmWzFdKSwgLy8gYVxuXHRcdFx0MjAwICogKGZbMV0gLSBmWzJdKSAgLy8gYlxuXHRcdF07XG5cdH0sXG5cdC8vIENvbnZlcnQgTGFiIHRvIEQ2NS1hZGFwdGVkIFhZWlxuXHQvLyBTYW1lIHJlc3VsdCBhcyBDSUUgMTUuMzoyMDA0IEFwcGVuZGl4IEQgYWx0aG91Z2ggdGhlIGRlcml2YXRpb24gaXMgZGlmZmVyZW50XG5cdC8vIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX1JHQl9YWVpfTWF0cml4Lmh0bWxcblx0dG9CYXNlIChMYWIpIHtcblx0XHQvLyBjb21wdXRlIGYsIHN0YXJ0aW5nIHdpdGggdGhlIGx1bWluYW5jZS1yZWxhdGVkIHRlcm1cblx0XHRsZXQgZiA9IFtdO1xuXHRcdGZbMV0gPSAoTGFiWzBdICsgMTYpLzExNjtcblx0XHRmWzBdID0gTGFiWzFdLzUwMCArIGZbMV07XG5cdFx0ZlsyXSA9IGZbMV0gLSBMYWJbMl0vMjAwO1xuXG5cdFx0Ly8gY29tcHV0ZSB4eXpcblx0XHRsZXQgeHl6ID0gW1xuXHRcdFx0ZlswXSAgID4gzrUzICA/ICBNYXRoLnBvdyhmWzBdLCAzKSAgICAgICAgICAgIDogKDExNipmWzBdLTE2KS/Ouixcblx0XHRcdExhYlswXSA+IDggICA/ICBNYXRoLnBvdygoTGFiWzBdKzE2KS8xMTYsIDMpIDogTGFiWzBdL866LFxuXHRcdFx0ZlsyXSAgID4gzrUzICA/ICBNYXRoLnBvdyhmWzJdLCAzKSAgICAgICAgICAgIDogKDExNipmWzJdLTE2KS/OulxuXHRcdF07XG5cblx0XHQvLyBDb21wdXRlIFhZWiBieSBzY2FsaW5nIHh5eiBieSByZWZlcmVuY2Ugd2hpdGVcblx0XHRyZXR1cm4geHl6Lm1hcCgodmFsdWUsIGkpID0+IHZhbHVlICogd2hpdGVbaV0pO1xuXHR9LFxuXG5cdGZvcm1hdHM6IHtcblx0XHRcImxhYi1kNjVcIjoge1xuXHRcdFx0Y29vcmRzOiBbXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPlwiLCBcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+Wy0xLDFdXCIsIFwiPG51bWJlcj4gfCA8cGVyY2VudGFnZT5bLTEsMV1cIl0sXG5cdFx0fVxuXHR9XG59KTtcblxuLy8gRGVsdGEgUGhpIFN0YXIgcGVyY2VwdHVhbCBsaWdodG5lc3MgY29udHJhc3Rcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTXluZGV4L2RlbHRhcGhpc3RhclxuLy8gVGhlIChkaWZmZXJlbmNlIGJldHdlZW4gdHdvIExzdGFycyBlYWNoIHJhaXNlZCB0byBwaGkpIHJhaXNlZCB0byAoMS9waGkpXG4vLyBTeW1tZXRyaWMsIGRvZXMgbm90IG1hdHRlciB3aGljaCBpcyBmb3JlZ3JvdW5kIGFuZCB3aGljaCBpcyBiYWNrZ3JvdW5kXG5cblxuY29uc3QgcGhpID0gTWF0aC5wb3coNSwgMC41KSAqIDAuNSArIDAuNTsgLy8gTWF0aC5waGkgY2FuIGJlIHVzZWQgaWYgTWF0aC5qc1xuXG5mdW5jdGlvbiBjb250cmFzdERlbHRhUGhpIChjb2xvcjEsIGNvbG9yMikge1xuXHRjb2xvcjEgPSBnZXRDb2xvcihjb2xvcjEpO1xuXHRjb2xvcjIgPSBnZXRDb2xvcihjb2xvcjIpO1xuXG5cdGxldCBMc3RyMSA9IGdldChjb2xvcjEsIFtsYWJfZDY1LCBcImxcIl0pO1xuXHRsZXQgTHN0cjIgPSBnZXQoY29sb3IyLCBbbGFiX2Q2NSwgXCJsXCJdKTtcblxuXHRsZXQgZGVsdGFQaGlTdGFyID0gTWF0aC5hYnMoTWF0aC5wb3coTHN0cjEsIHBoaSkgLSBNYXRoLnBvdyhMc3RyMiwgcGhpKSk7XG5cblx0bGV0IGNvbnRyYXN0ID0gTWF0aC5wb3coZGVsdGFQaGlTdGFyLCAoMSAvIHBoaSkpICogTWF0aC5TUVJUMiAtIDQwO1xuXG5cdHJldHVybiAoY29udHJhc3QgPCA3LjUpID8gMC4wIDogY29udHJhc3QgO1xufVxuXG52YXIgY29udHJhc3RNZXRob2RzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGNvbnRyYXN0QVBDQTogY29udHJhc3RBUENBLFxuXHRjb250cmFzdERlbHRhUGhpOiBjb250cmFzdERlbHRhUGhpLFxuXHRjb250cmFzdExzdGFyOiBjb250cmFzdExzdGFyLFxuXHRjb250cmFzdE1pY2hlbHNvbjogY29udHJhc3RNaWNoZWxzb24sXG5cdGNvbnRyYXN0V0NBRzIxOiBjb250cmFzdFdDQUcyMSxcblx0Y29udHJhc3RXZWJlcjogY29udHJhc3RXZWJlclxufSk7XG5cbmZ1bmN0aW9uIGNvbnRyYXN0IChiYWNrZ3JvdW5kLCBmb3JlZ3JvdW5kLCBvID0ge30pIHtcblx0aWYgKGlzU3RyaW5nKG8pKSB7XG5cdFx0byA9IHthbGdvcml0aG06IG99O1xuXHR9XG5cblx0bGV0IHthbGdvcml0aG0sIC4uLnJlc3R9ID0gbztcblxuXHRpZiAoIWFsZ29yaXRobSkge1xuXHRcdGxldCBhbGdvcml0aG1zID0gT2JqZWN0LmtleXMoY29udHJhc3RNZXRob2RzKS5tYXAoYSA9PiBhLnJlcGxhY2UoL15jb250cmFzdC8sIFwiXCIpKS5qb2luKFwiLCBcIik7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgY29udHJhc3QoKSBmdW5jdGlvbiBuZWVkcyBhIGNvbnRyYXN0IGFsZ29yaXRobS4gUGxlYXNlIHNwZWNpZnkgb25lIG9mOiAke2FsZ29yaXRobXN9YCk7XG5cdH1cblxuXHRiYWNrZ3JvdW5kID0gZ2V0Q29sb3IoYmFja2dyb3VuZCk7XG5cdGZvcmVncm91bmQgPSBnZXRDb2xvcihmb3JlZ3JvdW5kKTtcblxuXHRmb3IgKGxldCBhIGluIGNvbnRyYXN0TWV0aG9kcykge1xuXHRcdGlmIChcImNvbnRyYXN0XCIgKyBhbGdvcml0aG0udG9Mb3dlckNhc2UoKSA9PT0gYS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRyZXR1cm4gY29udHJhc3RNZXRob2RzW2FdKGJhY2tncm91bmQsIGZvcmVncm91bmQsIHJlc3QpO1xuXHRcdH1cblx0fVxuXG5cdHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gY29udHJhc3QgYWxnb3JpdGhtOiAke2FsZ29yaXRobX1gKTtcbn1cblxuLy8gQ2hyb21hdGljaXR5IGNvb3JkaW5hdGVzXG5mdW5jdGlvbiB1diAoY29sb3IpIHtcblx0bGV0IFtYLCBZLCBaXSA9IGdldEFsbChjb2xvciwgWFlaX0Q2NSk7XG5cdGxldCBkZW5vbSA9IFggKyAxNSAqIFkgKyAzICogWjtcblx0cmV0dXJuIFs0ICogWCAvIGRlbm9tLCA5ICogWSAvIGRlbm9tXTtcbn1cblxuZnVuY3Rpb24geHkgKGNvbG9yKSB7XG5cdGxldCBbWCwgWSwgWl0gPSBnZXRBbGwoY29sb3IsIFhZWl9ENjUpO1xuXHRsZXQgIHN1bSA9IFggKyBZICsgWjtcblx0cmV0dXJuIFtYIC8gc3VtLCBZIC8gc3VtXTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXIkMSAoQ29sb3IpIHtcblx0Ly8gbm8gc2V0dGVycywgYXMgbGlnaHRuZXNzIGluZm9ybWF0aW9uIGlzIGxvc3Rcblx0Ly8gd2hlbiBjb252ZXJ0aW5nIGNvbG9yIHRvIGNocm9tYXRpY2l0eVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCBcInV2XCIsIHtcblx0XHRnZXQgKCkge1xuXHRcdFx0cmV0dXJuIHV2KHRoaXMpO1xuXHRcdH1cblx0fSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgXCJ4eVwiLCB7XG5cdFx0Z2V0ICgpIHtcblx0XHRcdHJldHVybiB4eSh0aGlzKTtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgY2hyb21hdGljaXR5ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdHJlZ2lzdGVyOiByZWdpc3RlciQxLFxuXHR1djogdXYsXG5cdHh5OiB4eVxufSk7XG5cbmZ1bmN0aW9uIGRlbHRhRTc2IChjb2xvciwgc2FtcGxlKSB7XG5cdHJldHVybiBkaXN0YW5jZShjb2xvciwgc2FtcGxlLCBcImxhYlwiKTtcbn1cblxuLy8gTW9yZSBhY2N1cmF0ZSBjb2xvci1kaWZmZXJlbmNlIGZvcm11bGFlXG4vLyB0aGFuIHRoZSBzaW1wbGUgMTk3NiBFdWNsaWRlYW4gZGlzdGFuY2UgaW4gTGFiXG5cbi8vIENNQyBieSB0aGUgQ29sb3IgTWVhc3VyZW1lbnQgQ29tbWl0dGVlIG9mIHRoZVxuLy8gQnJhZGZvcmQgU29jaWV0eSBvZiBEeWVpc3RzIGFuZCBDb2xvcnN0cywgMTk5NC5cbi8vIFVzZXMgTENIIHJhdGhlciB0aGFuIExhYixcbi8vIHdpdGggZGlmZmVyZW50IHdlaWdodHMgZm9yIEwsIEMgYW5kIEggZGlmZmVyZW5jZXNcbi8vIEEgbmljZSBpbmNyZWFzZSBpbiBhY2N1cmFjeSBmb3IgbW9kZXN0IGluY3JlYXNlIGluIGNvbXBsZXhpdHlcbmNvbnN0IM+AID0gTWF0aC5QSTtcbmNvbnN0IGQyciA9IM+AIC8gMTgwO1xuXG5mdW5jdGlvbiBkZWx0YUVDTUMgKGNvbG9yLCBzYW1wbGUsIHtsID0gMiwgYyA9IDF9ID0ge30pIHtcblx0Ly8gR2l2ZW4gdGhpcyBjb2xvciBhcyB0aGUgcmVmZXJlbmNlXG5cdC8vIGFuZCBhIHNhbXBsZSxcblx0Ly8gY2FsY3VsYXRlIGRlbHRhRSBDTUMuXG5cblx0Ly8gVGhpcyBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoZSBwYXJhbWV0cmljXG5cdC8vIHdlaWdodGluZyBmYWN0b3JzIGw6YyBhcmUgMjoxXG5cdC8vIHdoaWNoIGlzIHR5cGljYWwgZm9yIG5vbi10ZXh0aWxlIHVzZXMuXG5cblx0bGV0IFtMMSwgYTEsIGIxXSA9IGxhYi5mcm9tKGNvbG9yKTtcblx0bGV0IFssIEMxLCBIMV0gPSBsY2guZnJvbShsYWIsIFtMMSwgYTEsIGIxXSk7XG5cdGxldCBbTDIsIGEyLCBiMl0gPSBsYWIuZnJvbShzYW1wbGUpO1xuXHRsZXQgQzIgPSBsY2guZnJvbShsYWIsIFtMMiwgYTIsIGIyXSlbMV07XG5cblx0Ly8gbGV0IFtMMSwgYTEsIGIxXSA9IGNvbG9yLmdldEFsbChsYWIpO1xuXHQvLyBsZXQgQzEgPSBjb2xvci5nZXQoXCJsY2guY1wiKTtcblx0Ly8gbGV0IEgxID0gY29sb3IuZ2V0KFwibGNoLmhcIik7XG5cdC8vIGxldCBbTDIsIGEyLCBiMl0gPSBzYW1wbGUuZ2V0QWxsKGxhYik7XG5cdC8vIGxldCBDMiA9IHNhbXBsZS5nZXQoXCJsY2guY1wiKTtcblxuXHQvLyBDaGVjayBmb3IgbmVnYXRpdmUgQ2hyb21hLFxuXHQvLyB3aGljaCBtaWdodCBoYXBwZW4gdGhyb3VnaFxuXHQvLyBkaXJlY3QgdXNlciBpbnB1dCBvZiBMQ0ggdmFsdWVzXG5cblx0aWYgKEMxIDwgMCkge1xuXHRcdEMxID0gMDtcblx0fVxuXHRpZiAoQzIgPCAwKSB7XG5cdFx0QzIgPSAwO1xuXHR9XG5cblx0Ly8gd2UgZG9uJ3QgbmVlZCBIMiBhcyDOlEggaXMgY2FsY3VsYXRlZCBmcm9tIM6UYSwgzpRiIGFuZCDOlENcblxuXHQvLyBMaWdodG5lc3MgYW5kIENocm9tYSBkaWZmZXJlbmNlc1xuXHQvLyBUaGVzZSBhcmUgKGNvbG9yIC0gc2FtcGxlKSwgdW5saWtlIGRlbHRhRTIwMDBcblx0bGV0IM6UTCA9IEwxIC0gTDI7XG5cdGxldCDOlEMgPSBDMSAtIEMyO1xuXG5cdGxldCDOlGEgPSBhMSAtIGEyO1xuXHRsZXQgzpRiID0gYjEgLSBiMjtcblxuXHQvLyB3ZWlnaHRlZCBIdWUgZGlmZmVyZW5jZSwgbGVzcyBmb3IgbGFyZ2VyIENocm9tYSBkaWZmZXJlbmNlXG5cblx0bGV0IEgyID0gKM6UYSAqKiAyKSArICjOlGIgKiogMikgLSAozpRDICoqIDIpO1xuXHQvLyBkdWUgdG8gcm91bmRvZmYgZXJyb3IgaXQgaXMgcG9zc2libGUgdGhhdCwgZm9yIHplcm8gYSBhbmQgYixcblx0Ly8gzpRDID4gzpRhICsgzpRiIGlzIDAsIHJlc3VsdGluZyBpbiBhdHRlbXB0aW5nXG5cdC8vIHRvIHRha2UgdGhlIHNxdWFyZSByb290IG9mIGEgbmVnYXRpdmUgbnVtYmVyXG5cblx0Ly8gdHJ5aW5nIGluc3RlYWQgdGhlIGVxdWF0aW9uIGZyb20gSW5kdXN0cmlhbCBDb2xvciBQaHlzaWNzXG5cdC8vIEJ5IEdlb3JnIEEuIEtsZWluXG5cblx0Ly8gbGV0IM6USCA9ICgoYTEgKiBiMikgLSAoYTIgKiBiMSkpIC8gTWF0aC5zcXJ0KDAuNSAqICgoQzIgKiBDMSkgKyAoYTIgKiBhMSkgKyAoYjIgKiBiMSkpKTtcblx0Ly8gY29uc29sZS5sb2coe86USH0pO1xuXHQvLyBUaGlzIGdpdmVzIHRoZSBzYW1lIHJlc3VsdCB0byAxMiBkZWNpbWFsIHBsYWNlc1xuXHQvLyBleGNlcHQgaXQgc29tZXRpbWVzIE5hTnMgd2hlbiB0cnlpbmcgdG8gcm9vdCBhIG5lZ2F0aXZlIG51bWJlclxuXG5cdC8vIGxldCDOlEggPSBNYXRoLnNxcnQoSDIpOyB3ZSBuZXZlciBhY3R1YWxseSB1c2UgdGhlIHJvb3QsIGl0IGdldHMgc3F1YXJlZCBhZ2FpbiEhXG5cblx0Ly8gcG9zaXRpb25hbCBjb3JyZWN0aW9ucyB0byB0aGUgbGFjayBvZiB1bmlmb3JtaXR5IG9mIENJRUxBQlxuXHQvLyBUaGVzZSBhcmUgYWxsIHRyeWluZyB0byBtYWtlIEpORCBlbGxpcHNvaWRzIG1vcmUgbGlrZSBzcGhlcmVzXG5cblx0Ly8gU0wgTGlnaHRuZXNzIGNyaXNwZW5pbmcgZmFjdG9yLCBkZXBlbmRzIGVudGlyZWx5IG9uIEwxIG5vdCBMMlxuXHRsZXQgU0wgPSAwLjUxMTtcdC8vIGxpbmVhciBwb3J0aW9uIG9mIHRoZSBZIHRvIEwgdHJhbnNmZXIgZnVuY3Rpb25cblx0aWYgKEwxID49IDE2KSB7XHQvLyBjdWJpYyBwb3J0aW9uXG5cdFx0U0wgPSAoMC4wNDA5NzUgKiBMMSkgLyAoMSArIDAuMDE3NjUgKiBMMSk7XG5cdH1cblxuXHQvLyBTQyBDaHJvbWEgZmFjdG9yXG5cdGxldCBTQyA9ICgoMC4wNjM4ICogQzEpIC8gKDEgKyAwLjAxMzEgKiBDMSkpICsgMC42Mzg7XG5cblx0Ly8gQ3Jvc3MgdGVybSBUIGZvciBibHVlIG5vbi1saW5lYXJpdHlcblx0bGV0IFQ7XG5cdGlmICggTnVtYmVyLmlzTmFOKEgxKSkge1xuXHRcdEgxID0gMDtcblx0fVxuXG5cdGlmIChIMSA+PSAxNjQgJiYgSDEgPD0gMzQ1KSB7XG5cdFx0VCA9IDAuNTYgKyBNYXRoLmFicygwLjIgKiBNYXRoLmNvcygoSDEgKyAxNjgpICogZDJyKSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0VCA9IDAuMzYgKyBNYXRoLmFicygwLjQgKiBNYXRoLmNvcygoSDEgKyAzNSkgKiBkMnIpKTtcblx0fVxuXHQvLyBjb25zb2xlLmxvZyh7VH0pO1xuXG5cdC8vIFNIIEh1ZSBmYWN0b3IgYWxzbyBkZXBlbmRzIG9uIEMxLFxuXHRsZXQgQzQgPSBNYXRoLnBvdyhDMSwgNCk7XG5cdGxldCBGID0gTWF0aC5zcXJ0KEM0IC8gKEM0ICsgMTkwMCkpO1xuXHRsZXQgU0ggPSBTQyAqICgoRiAqIFQpICsgMSAtIEYpO1xuXG5cdC8vIEZpbmFsbHkgY2FsY3VsYXRlIHRoZSBkZWx0YUUsIHRlcm0gYnkgdGVybSBhcyByb290IHN1bWUgb2Ygc3F1YXJlc1xuXHRsZXQgZEUgPSAozpRMIC8gKGwgKiBTTCkpICoqIDI7XG5cdGRFICs9ICjOlEMgLyAoYyAqIFNDKSkgKiogMjtcblx0ZEUgKz0gKEgyIC8gKFNIICoqIDIpKTtcblx0Ly8gZEUgKz0gKM6USCAvIFNIKSAgKiogMjtcblx0cmV0dXJuIE1hdGguc3FydChkRSk7XG5cdC8vIFlheSEhIVxufVxuXG5jb25zdCBZdyQxID0gMjAzO1x0Ly8gYWJzb2x1dGUgbHVtaW5hbmNlIG9mIG1lZGlhIHdoaXRlXG5cbnZhciBYWVpfQWJzX0Q2NSA9IG5ldyBDb2xvclNwYWNlKHtcbi8vIEFic29sdXRlIENJRSBYWVosIHdpdGggYSBENjUgd2hpdGVwb2ludCxcbi8vIGFzIHVzZWQgaW4gbW9zdCBIRFIgY29sb3JzcGFjZXMgYXMgYSBzdGFydGluZyBwb2ludC5cbi8vIFNEUiBzcGFjZXMgYXJlIGNvbnZlcnRlZCBwZXIgQlQuMjA0OFxuLy8gc28gdGhhdCBkaWZmdXNlLCBtZWRpYSB3aGl0ZSBpcyAyMDMgY2QvbcKyXG5cdGlkOiBcInh5ei1hYnMtZDY1XCIsXG5cdG5hbWU6IFwiQWJzb2x1dGUgWFlaIEQ2NVwiLFxuXHRjb29yZHM6IHtcblx0XHR4OiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDk1MDQuN10sXG5cdFx0XHRuYW1lOiBcIlhhXCIsXG5cdFx0fSxcblx0XHR5OiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDEwMDAwXSxcblx0XHRcdG5hbWU6IFwiWWFcIixcblx0XHR9LFxuXHRcdHo6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMTA4ODguM10sXG5cdFx0XHRuYW1lOiBcIlphXCIsXG5cdFx0fVxuXHR9LFxuXG5cdGJhc2U6IFhZWl9ENjUsXG5cdGZyb21CYXNlIChYWVopIHtcblx0XHQvLyBNYWtlIFhZWiBhYnNvbHV0ZSwgbm90IHJlbGF0aXZlIHRvIG1lZGlhIHdoaXRlXG5cdFx0Ly8gTWF4aW11bSBsdW1pbmFuY2UgaW4gUFEgaXMgMTAsMDAwIGNkL23CslxuXHRcdC8vIFJlbGF0aXZlIFhZWiBoYXMgWT0xIGZvciBtZWRpYSB3aGl0ZVxuXHRcdHJldHVybiBYWVoubWFwICh2ID0+IE1hdGgubWF4KHYgKiBZdyQxLCAwKSk7XG5cdH0sXG5cdHRvQmFzZSAoQWJzWFlaKSB7XG5cdFx0Ly8gQ29udmVydCB0byBtZWRpYS13aGl0ZSByZWxhdGl2ZSBYWVpcblx0XHRyZXR1cm4gQWJzWFlaLm1hcCh2ID0+IE1hdGgubWF4KHYgLyBZdyQxLCAwKSk7XG5cdH1cbn0pO1xuXG5jb25zdCBiJDEgPSAxLjE1O1xuY29uc3QgZyA9IDAuNjY7XG5jb25zdCBuJDEgPSAyNjEwIC8gKDIgKiogMTQpO1xuY29uc3QgbmludiQxID0gKDIgKiogMTQpIC8gMjYxMDtcbmNvbnN0IGMxJDIgPSAzNDI0IC8gKDIgKiogMTIpO1xuY29uc3QgYzIkMiA9IDI0MTMgLyAoMiAqKiA3KTtcbmNvbnN0IGMzJDIgPSAyMzkyIC8gKDIgKiogNyk7XG5jb25zdCBwID0gMS43ICogMjUyMyAvICgyICoqIDUpO1xuY29uc3QgcGludiA9ICgyICoqIDUpIC8gKDEuNyAqIDI1MjMpO1xuY29uc3QgZCA9IC0wLjU2O1xuY29uc3QgZDAgPSAxLjYyOTU0OTk1MzI4MjE1NjZFLTExO1xuXG5jb25zdCBYWVp0b0NvbmVfTSA9IFtcblx0WyAgMC40MTQ3ODk3MiwgMC41Nzk5OTksICAwLjAxNDY0ODAgXSxcblx0WyAtMC4yMDE1MTAwLCAgMS4xMjA2NDksICAwLjA1MzEwMDggXSxcblx0WyAtMC4wMTY2MDA4LCAgMC4yNjQ4MDAsICAwLjY2ODQ3OTkgXVxuXTtcbi8vIFhZWnRvQ29uZV9NIGludmVydGVkXG5jb25zdCBDb25ldG9YWVpfTSA9IFtcblx0WyAgMS45MjQyMjY0MzU3ODc2MDY3LCAgLTEuMDA0NzkyMzEyNTk1MzY1NywgIDAuMDM3NjUxNDA0MDMwNjE4ICAgXSxcblx0WyAgMC4zNTAzMTY3NjIwOTQ5OTkwNywgIDAuNzI2NDgxMTkzOTMxNjU1MiwgLTAuMDY1Mzg0NDIyOTQ4MDg1MDEgXSxcblx0WyAtMC4wOTA5ODI4MTA5ODI4NDc1MiwgLTAuMzEyNzI4MjkwNTIzMDczOSwgIDEuNTIyNzY2NTYxMzA1MjYwMyAgXVxuXTtcbmNvbnN0IENvbmV0b0lhYl9NID0gW1xuXHRbICAwLjUsICAgICAgIDAuNSwgICAgICAgMCAgICAgICAgXSxcblx0WyAgMy41MjQwMDAsIC00LjA2NjcwOCwgIDAuNTQyNzA4IF0sXG5cdFsgIDAuMTk5MDc2LCAgMS4wOTY3OTksIC0xLjI5NTg3NSBdXG5dO1xuLy8gQ29uZXRvSWFiX00gaW52ZXJ0ZWRcbmNvbnN0IElhYnRvQ29uZV9NID0gW1xuXHRbIDEsICAgICAgICAgICAgICAgICAgIDAuMTM4NjA1MDQzMjcxNTM5MywgICAwLjA1ODA0NzMxNjE1NjExODg2IF0sXG5cdFsgMC45OTk5OTk5OTk5OTk5OTk5LCAtMC4xMzg2MDUwNDMyNzE1MzkzLCAgLTAuMDU4MDQ3MzE2MTU2MTE4ODYgXSxcblx0WyAwLjk5OTk5OTk5OTk5OTk5OTgsIC0wLjA5NjAxOTI0MjAyNjMxODk1LCAtMC44MTE4OTE4OTYwNTYwMzg4ICBdXG5dO1xuXG52YXIgSnphemJ6ID0gbmV3IENvbG9yU3BhY2Uoe1xuXHRpZDogXCJqemF6YnpcIixcblx0bmFtZTogXCJKemF6YnpcIixcblx0Y29vcmRzOiB7XG5cdFx0ano6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMV0sXG5cdFx0XHRuYW1lOiBcIkp6XCIsXG5cdFx0fSxcblx0XHRhejoge1xuXHRcdFx0cmVmUmFuZ2U6IFstMC41LCAwLjVdLFxuXHRcdH0sXG5cdFx0Yno6IHtcblx0XHRcdHJlZlJhbmdlOiBbLTAuNSwgMC41XSxcblx0XHR9XG5cdH0sXG5cblx0YmFzZTogWFlaX0Fic19ENjUsXG5cdGZyb21CYXNlIChYWVopIHtcblx0XHQvLyBGaXJzdCBtYWtlIFhZWiBhYnNvbHV0ZSwgbm90IHJlbGF0aXZlIHRvIG1lZGlhIHdoaXRlXG5cdFx0Ly8gTWF4aW11bSBsdW1pbmFuY2UgaW4gUFEgaXMgMTAsMDAwIGNkL23CslxuXHRcdC8vIFJlbGF0aXZlIFhZWiBoYXMgWT0xIGZvciBtZWRpYSB3aGl0ZVxuXHRcdC8vIEJULjIwNDggc2F5cyBtZWRpYSB3aGl0ZSBZPTIwMyBhdCBQUSA1OFxuXG5cdFx0bGV0IFsgWGEsIFlhLCBaYSBdID0gWFlaO1xuXG5cdFx0Ly8gbW9kaWZ5IFggYW5kIFlcblx0XHRsZXQgWG0gPSAoYiQxICogWGEpIC0gKChiJDEgLSAxKSAqIFphKTtcblx0XHRsZXQgWW0gPSAoZyAqIFlhKSAtICgoZyAtIDEpICogWGEpO1xuXG5cdFx0Ly8gbW92ZSB0byBMTVMgY29uZSBkb21haW5cblx0XHRsZXQgTE1TID0gbXVsdGlwbHlNYXRyaWNlcyhYWVp0b0NvbmVfTSwgWyBYbSwgWW0sIFphIF0pO1xuXG5cdFx0Ly8gUFEtZW5jb2RlIExNU1xuXHRcdGxldCBQUUxNUyA9IExNUy5tYXAgKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdGxldCBudW0gPSBjMSQyICsgKGMyJDIgKiAoKHZhbCAvIDEwMDAwKSAqKiBuJDEpKTtcblx0XHRcdGxldCBkZW5vbSA9IDEgKyAoYzMkMiAqICgodmFsIC8gMTAwMDApICoqIG4kMSkpO1xuXG5cdFx0XHRyZXR1cm4gKG51bSAvIGRlbm9tKSAgKiogcDtcblx0XHR9KTtcblxuXHRcdC8vIGFsbW9zdCB0aGVyZSwgY2FsY3VsYXRlIEl6IGF6IGJ6XG5cdFx0bGV0IFsgSXosIGF6LCBiel0gPSBtdWx0aXBseU1hdHJpY2VzKENvbmV0b0lhYl9NLCBQUUxNUyk7XG5cdFx0Ly8gY29uc29sZS5sb2coe0l6LCBheiwgYnp9KTtcblxuXHRcdGxldCBKeiA9ICgoMSArIGQpICogSXopIC8gKDEgKyAoZCAqIEl6KSkgLSBkMDtcblx0XHRyZXR1cm4gW0p6LCBheiwgYnpdO1xuXHR9LFxuXHR0b0Jhc2UgKEp6YXpieikge1xuXHRcdGxldCBbSnosIGF6LCBiel0gPSBKemF6Yno7XG5cdFx0bGV0IEl6ID0gKEp6ICsgZDApIC8gKDEgKyBkIC0gZCAqIChKeiArIGQwKSk7XG5cblx0XHQvLyBicmluZyBpbnRvIExNUyBjb25lIGRvbWFpblxuXHRcdGxldCBQUUxNUyA9IG11bHRpcGx5TWF0cmljZXMoSWFidG9Db25lX00sIFsgSXosIGF6LCBieiBdKTtcblxuXHRcdC8vIGNvbnZlcnQgZnJvbSBQUS1jb2RlZCB0byBsaW5lYXItbGlnaHRcblx0XHRsZXQgTE1TID0gUFFMTVMubWFwKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdGxldCBudW0gPSAoYzEkMiAtICh2YWwgKiogcGludikpO1xuXHRcdFx0bGV0IGRlbm9tID0gKGMzJDIgKiAodmFsICoqIHBpbnYpKSAtIGMyJDI7XG5cdFx0XHRsZXQgeCA9IDEwMDAwICogKChudW0gLyBkZW5vbSkgKiogbmludiQxKTtcblxuXHRcdFx0cmV0dXJuICh4KTsgXHQvLyBsdW1pbmFuY2UgcmVsYXRpdmUgdG8gZGlmZnVzZSB3aGl0ZSwgWzAsIDcwIG9yIHNvXS5cblx0XHR9KTtcblxuXHRcdC8vIG1vZGlmaWVkIGFicyBYWVpcblx0XHRsZXQgWyBYbSwgWW0sIFphIF0gPSBtdWx0aXBseU1hdHJpY2VzKENvbmV0b1hZWl9NLCBMTVMpO1xuXG5cdFx0Ly8gcmVzdG9yZSBzdGFuZGFyZCBENTAgcmVsYXRpdmUgWFlaLCByZWxhdGl2ZSB0byBtZWRpYSB3aGl0ZVxuXHRcdGxldCBYYSA9IChYbSArICgoYiQxIC0xKSAqIFphKSkgLyBiJDE7XG5cdFx0bGV0IFlhID0gKFltICsgKChnIC0xKSAqIFhhKSkgLyBnO1xuXHRcdHJldHVybiBbIFhhLCBZYSwgWmEgXTtcblx0fSxcblxuXHRmb3JtYXRzOiB7XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1jb2xvci1oZHIvI0p6YXpielxuXHRcdFwiY29sb3JcIjoge31cblx0fVxufSk7XG5cbnZhciBqemN6aHogPSBuZXcgQ29sb3JTcGFjZSh7XG5cdGlkOiBcImp6Y3poelwiLFxuXHRuYW1lOiBcIkp6Q3pIelwiLFxuXHRjb29yZHM6IHtcblx0XHRqejoge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAxXSxcblx0XHRcdG5hbWU6IFwiSnpcIixcblx0XHR9LFxuXHRcdGN6OiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDFdLFxuXHRcdFx0bmFtZTogXCJDaHJvbWFcIixcblx0XHR9LFxuXHRcdGh6OiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDM2MF0sXG5cdFx0XHR0eXBlOiBcImFuZ2xlXCIsXG5cdFx0XHRuYW1lOiBcIkh1ZVwiLFxuXHRcdH1cblx0fSxcblxuXHRiYXNlOiBKemF6YnosXG5cdGZyb21CYXNlIChqemF6YnopIHtcblx0XHQvLyBDb252ZXJ0IHRvIHBvbGFyIGZvcm1cblx0XHRsZXQgW0p6LCBheiwgYnpdID0ganphemJ6O1xuXHRcdGxldCBodWU7XG5cdFx0Y29uc3QgzrUgPSAwLjAwMDI7IC8vIGNocm9tYXRpYyBjb21wb25lbnRzIG11Y2ggc21hbGxlciB0aGFuIGEsYlxuXG5cdFx0aWYgKE1hdGguYWJzKGF6KSA8IM61ICYmIE1hdGguYWJzKGJ6KSA8IM61KSB7XG5cdFx0XHRodWUgPSBOYU47XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aHVlID0gTWF0aC5hdGFuMihieiwgYXopICogMTgwIC8gTWF0aC5QSTtcblx0XHR9XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0SnosIC8vIEp6IGlzIHN0aWxsIEp6XG5cdFx0XHRNYXRoLnNxcnQoYXogKiogMiArIGJ6ICoqIDIpLCAvLyBDaHJvbWFcblx0XHRcdGNvbnN0cmFpbihodWUpIC8vIEh1ZSwgaW4gZGVncmVlcyBbMCB0byAzNjApXG5cdFx0XTtcblx0fSxcblx0dG9CYXNlIChqemN6aHopIHtcblx0XHQvLyBDb252ZXJ0IGZyb20gcG9sYXIgZm9ybVxuXHRcdC8vIGRlYnVnZ2VyO1xuXHRcdHJldHVybiBbXG5cdFx0XHRqemN6aHpbMF0sIC8vIEp6IGlzIHN0aWxsIEp6XG5cdFx0XHRqemN6aHpbMV0gKiBNYXRoLmNvcyhqemN6aHpbMl0gKiBNYXRoLlBJIC8gMTgwKSwgLy8gYXpcblx0XHRcdGp6Y3poelsxXSAqIE1hdGguc2luKGp6Y3poelsyXSAqIE1hdGguUEkgLyAxODApICAvLyBielxuXHRcdF07XG5cdH0sXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge31cblx0fSxcbn0pO1xuXG4vLyBNb3JlIGFjY3VyYXRlIGNvbG9yLWRpZmZlcmVuY2UgZm9ybXVsYWVcbi8vIHRoYW4gdGhlIHNpbXBsZSAxOTc2IEV1Y2xpZGVhbiBkaXN0YW5jZSBpbiBMYWJcblxuLy8gVXNlcyBKekN6SHosIHdoaWNoIGhhcyBpbXByb3ZlZCBwZXJjZXB0dWFsIHVuaWZvcm1pdHlcbi8vIGFuZCB0aHVzIGEgc2ltcGxlIEV1Y2xpZGVhbiByb290LXN1bSBvZiDOlEzCsiDOlEPCsiDOlEjCslxuLy8gZ2l2ZXMgZ29vZCByZXN1bHRzLlxuXG5mdW5jdGlvbiBkZWx0YUVKeiAoY29sb3IsIHNhbXBsZSkge1xuXHQvLyBHaXZlbiB0aGlzIGNvbG9yIGFzIHRoZSByZWZlcmVuY2Vcblx0Ly8gYW5kIGEgc2FtcGxlLFxuXHQvLyBjYWxjdWxhdGUgZGVsdGFFIGluIEp6Q3pIei5cblx0bGV0IFtKejEsIEN6MSwgSHoxXSA9IGp6Y3poei5mcm9tKGNvbG9yKTtcblx0bGV0IFtKejIsIEN6MiwgSHoyXSA9IGp6Y3poei5mcm9tKHNhbXBsZSk7XG5cblx0Ly8gTGlnaHRuZXNzIGFuZCBDaHJvbWEgZGlmZmVyZW5jZXNcblx0Ly8gc2lnbiBkb2VzIG5vdCBtYXR0ZXIgYXMgdGhleSBhcmUgc3F1YXJlZC5cblx0bGV0IM6USiA9IEp6MSAtIEp6Mjtcblx0bGV0IM6UQyA9IEN6MSAtIEN6MjtcblxuXHQvLyBsZW5ndGggb2YgY2hvcmQgZm9yIM6USFxuXHRpZiAoKE51bWJlci5pc05hTihIejEpKSAmJiAoTnVtYmVyLmlzTmFOKEh6MikpKSB7XG5cdFx0Ly8gYm90aCB1bmRlZmluZWQgaHVlc1xuXHRcdEh6MSA9IDA7XG5cdFx0SHoyID0gMDtcblx0fVxuXHRlbHNlIGlmIChOdW1iZXIuaXNOYU4oSHoxKSkge1xuXHRcdC8vIG9uZSB1bmRlZmluZWQsIHNldCB0byB0aGUgZGVmaW5lZCBodWVcblx0XHRIejEgPSBIejI7XG5cdH1cblx0ZWxzZSBpZiAoTnVtYmVyLmlzTmFOKEh6MikpIHtcblx0XHRIejIgPSBIejE7XG5cdH1cblxuXHRsZXQgzpRoID0gSHoxIC0gSHoyO1xuXHRsZXQgzpRIID0gMiAqIE1hdGguc3FydChDejEgKiBDejIpICogTWF0aC5zaW4oKM6UaCAvIDIpICogKE1hdGguUEkgLyAxODApKTtcblxuXHRyZXR1cm4gTWF0aC5zcXJ0KM6USiAqKiAyICsgzpRDICoqIDIgKyDOlEggKiogMik7XG59XG5cbmNvbnN0IGMxJDEgPSAzNDI0IC8gNDA5NjtcbmNvbnN0IGMyJDEgPSAyNDEzIC8gMTI4O1xuY29uc3QgYzMkMSA9IDIzOTIgLyAxMjg7XG5jb25zdCBtMSA9IDI2MTAgLyAxNjM4NDtcbmNvbnN0IG0yID0gMjUyMyAvIDMyO1xuY29uc3QgaW0xID0gMTYzODQgLyAyNjEwO1xuY29uc3QgaW0yID0gMzIgLyAyNTIzO1xuXG4vLyBUaGUgbWF0cml4IGJlbG93IGluY2x1ZGVzIHRoZSA0JSBjcm9zc3RhbGsgY29tcG9uZW50c1xuLy8gYW5kIGlzIGZyb20gdGhlIERvbGJ5IFwiV2hhdCBpcyBJQ3RDcFwiIHBhcGVyXCJcbmNvbnN0IFhZWnRvTE1TX00kMSA9IFtcblx0WyAwLjM1OTIsICAwLjY5NzYsIC0wLjAzNThdLFxuXHRbLTAuMTkyMiwgIDEuMTAwNCwgIDAuMDc1NV0sXG5cdFsgMC4wMDcwLCAgMC4wNzQ5LCAgMC44NDM0XVxuXTtcbi8vIGxpbmVhci1saWdodCBSZWMuMjAyMCB0byBMTVMsIGFnYWluIHdpdGggY3Jvc3N0YWxrXG4vLyByYXRpb25hbCB0ZXJtcyBmcm9tIEphbiBGcsO2aGxpY2gsXG4vLyBFbmNvZGluZyBIaWdoIER5bmFtaWMgUmFuZ2UgYW5kV2lkZSBDb2xvciBHYW11dCBJbWFnZXJ5LCBwLjk3XG4vLyBhbmQgSVRVLVIgQlQuMjEyNC0wIHAuMlxuLypcbmNvbnN0IFJlYzIwMjB0b0xNU19NID0gW1xuXHRbIDE2ODggLyA0MDk2LCAgMjE0NiAvIDQwOTYsICAgMjYyIC8gNDA5NiBdLFxuXHRbICA2ODMgLyA0MDk2LCAgMjk1MSAvIDQwOTYsICAgNDYyIC8gNDA5NiBdLFxuXHRbICAgOTkgLyA0MDk2LCAgIDMwOSAvIDQwOTYsICAzNjg4IC8gNDA5NiBdXG5dO1xuKi9cbi8vIHRoaXMgaW5jbHVkZXMgdGhlIEVibmVyIExNUyBjb2VmZmljaWVudHMsXG4vLyB0aGUgcm90YXRpb24sIGFuZCB0aGUgc2NhbGluZyB0byBbLTAuNSwwLjVdIHJhbmdlXG4vLyByYXRpb25hbCB0ZXJtcyBmcm9tIEZyw7ZobGljaCBwLjk3XG4vLyBhbmQgSVRVLVIgQlQuMjEyNC0wIHBwLjItM1xuY29uc3QgTE1TdG9JUFRfTSA9IFtcblx0WyAgMjA0OCAvIDQwOTYsICAgMjA0OCAvIDQwOTYsICAgICAgIDAgICAgICBdLFxuXHRbICA2NjEwIC8gNDA5NiwgLTEzNjEzIC8gNDA5NiwgIDcwMDMgLyA0MDk2IF0sXG5cdFsgMTc5MzMgLyA0MDk2LCAtMTczOTAgLyA0MDk2LCAgLTU0MyAvIDQwOTYgXVxuXTtcblxuLy8gaW52ZXJ0ZWQgbWF0cmljZXMsIGNhbGN1bGF0ZWQgZnJvbSB0aGUgYWJvdmVcbmNvbnN0IElQVHRvTE1TX00gPSBbXG5cdFswLjk5OTk4ODg5NjU2Mjg0MDEzODMzLCAwLjAwODYwNTA1MDE0NzI4NzA1ODIxLCAgMC4xMTEwMzQzNzE1OTg2MTY0Nzg2IF0sXG5cdFsxLjAwMDAxMTEwMzQzNzE1OTg2MTYsIC0wLjAwODYwNTA1MDE0NzI4NzA1ODIxLCAtMC4xMTEwMzQzNzE1OTg2MTY0Nzg2IF0sXG5cdFsxLjAwMDAzMjA2MzM5MTAwNTQxMiwgICAwLjU2MDA0OTEzNTQ3Mjc5MDAwMTEzLCAtMC4zMjA2MzM5MTAwNTQxMjAyNjQ2OV0sXG5dO1xuLypcbmNvbnN0IExNU3RvUmVjMjAyMF9NID0gW1xuXHRbIDMuNDM3NTU2ODkzMjgxNDAxMjExMiwgICAtMi41MDcyMTEyMTI1MDk1MDU4MTk1LCAgIDAuMDY5NjU0MzE5MjI4MTA0NjA4MzgyXSxcblx0Wy0wLjc5MTQyODY4NjY1NjQ0MTU2MTI1LCAgIDEuOTgzODM3MjE5ODc0MDA4OTg3NCwgIC0wLjE5MjQwODUzMzIxNzU2NzQyNjI2IF0sXG5cdFstMC4wMjU2NDY2NjI5MTE1MDY0NzYzNjMsIC0wLjA5OTI0MDI0ODY0Mzk0NTU2Njc1MSwgMS4xMjQ4ODY5MTE1NTU0NTIwNDMxICBdXG5dO1xuKi9cbmNvbnN0IExNU3RvWFlaX00kMSA9IFtcblx0WyAyLjA3MDE4MDA1NjY5NTYxMzUwOTYsICAgLTEuMzI2NDU2ODc2MTAzMDIxMDI1NSwgICAgMC4yMDY2MTYwMDY4NDc4NTUxNzA4MSBdLFxuXHRbIDAuMzY0OTg4MjUwMDMyNjU3NDc5NzQsICAgMC42ODA0NjczNjI4NTIyMzUxNDEwMiwgIC0wLjA0NTQyMTc1MzA3NTg1MzIzMTQwOV0sXG5cdFstMC4wNDk1OTU1NDIyMzg5MzIxMDc4OTYsIC0wLjA0OTQyMTE2MTE4Njc1NzQ4NzQxMiwgIDEuMTg3OTk1OTQxNzMyODAzNDM5NCAgXVxuXTtcblxuLy8gT25seSB0aGUgUFEgZm9ybSBvZiBJQ3RDcCBpcyBpbXBsZW1lbnRlZCBoZXJlLiBUaGVyZSBpcyBhbHNvIGFuIEhMRyBmb3JtLlxuLy8gZnJvbSBEb2xieSwgXCJXSEFUIElTIElDVENQP1wiXG4vLyBodHRwczovL3Byb2Zlc3Npb25hbC5kb2xieS5jb20vc2l0ZWFzc2V0cy9wZGZzL2ljdGNwX2RvbGJ5d2hpdGVwYXBlcl92MDcxLnBkZlxuLy8gYW5kXG4vLyBEb2xieSwgXCJQZXJjZXB0dWFsIENvbG9yIFZvbHVtZVxuLy8gTWVhc3VyaW5nIHRoZSBEaXN0aW5ndWlzaGFibGUgQ29sb3JzIG9mIEhEUiBhbmQgV0NHIERpc3BsYXlzXCJcbi8vIGh0dHBzOi8vcHJvZmVzc2lvbmFsLmRvbGJ5LmNvbS9zaXRlYXNzZXRzL3BkZnMvZG9sYnktdmlzaW9uLW1lYXN1cmluZy1wZXJjZXB0dWFsLWNvbG9yLXZvbHVtZS12Ny4xLnBkZlxudmFyIGljdGNwID0gbmV3IENvbG9yU3BhY2Uoe1xuXHRpZDogXCJpY3RjcFwiLFxuXHRuYW1lOiBcIklDVENQXCIsXG5cdC8vIEZyb20gQlQuMjEwMC0yIHBhZ2UgNzpcblx0Ly8gRHVyaW5nIHByb2R1Y3Rpb24sIHNpZ25hbCB2YWx1ZXMgYXJlIGV4cGVjdGVkIHRvIGV4Y2VlZCB0aGVcblx0Ly8gcmFuZ2UgReKAsiA9IFswLjAgOiAxLjBdLiBUaGlzIHByb3ZpZGVzIHByb2Nlc3NpbmcgaGVhZHJvb20gYW5kIGF2b2lkc1xuXHQvLyBzaWduYWwgZGVncmFkYXRpb24gZHVyaW5nIGNhc2NhZGVkIHByb2Nlc3NpbmcuIFN1Y2ggdmFsdWVzIG9mIEXigLIsXG5cdC8vIGJlbG93IDAuMCBvciBleGNlZWRpbmcgMS4wLCBzaG91bGQgbm90IGJlIGNsaXBwZWQgZHVyaW5nIHByb2R1Y3Rpb25cblx0Ly8gYW5kIGV4Y2hhbmdlLlxuXHQvLyBWYWx1ZXMgYmVsb3cgMC4wIHNob3VsZCBub3QgYmUgY2xpcHBlZCBpbiByZWZlcmVuY2UgZGlzcGxheXMgKGV2ZW5cblx0Ly8gdGhvdWdoIHRoZXkgcmVwcmVzZW50IOKAnG5lZ2F0aXZl4oCdIGxpZ2h0KSB0byBhbGxvdyB0aGUgYmxhY2sgbGV2ZWwgb2Zcblx0Ly8gdGhlIHNpZ25hbCAoTEIpIHRvIGJlIHByb3Blcmx5IHNldCB1c2luZyB0ZXN0IHNpZ25hbHMga25vd24gYXMg4oCcUExVR0XigJ1cblx0Y29vcmRzOiB7XG5cdFx0aToge1xuXHRcdFx0cmVmUmFuZ2U6IFswLCAxXSxcdC8vIENvbnN0YW50IGx1bWluYW5jZSxcblx0XHRcdG5hbWU6IFwiSVwiXG5cdFx0fSxcblx0XHRjdDoge1xuXHRcdFx0cmVmUmFuZ2U6IFstMC41LCAwLjVdLFx0Ly8gRnVsbCBCVC4yMDIwIGdhbXV0IGluIHJhbmdlIFstMC41LCAwLjVdXG5cdFx0XHRuYW1lOiBcIkNUXCJcblx0XHR9LFxuXHRcdGNwOiB7XG5cdFx0XHRyZWZSYW5nZTogWy0wLjUsIDAuNV0sXG5cdFx0XHRuYW1lOiBcIkNQXCJcblx0XHR9XG5cdH0sXG5cblx0YmFzZTogWFlaX0Fic19ENjUsXG5cdGZyb21CYXNlIChYWVopIHtcblx0XHQvLyBtb3ZlIHRvIExNUyBjb25lIGRvbWFpblxuXHRcdGxldCBMTVMgPSBtdWx0aXBseU1hdHJpY2VzKFhZWnRvTE1TX00kMSwgWFlaKTtcblxuXHRcdHJldHVybiBMTVN0b0lDdENwKExNUyk7XG5cdH0sXG5cdHRvQmFzZSAoSUN0Q3ApIHtcblx0XHRsZXQgTE1TID0gSUN0Q3B0b0xNUyhJQ3RDcCk7XG5cblx0XHRyZXR1cm4gbXVsdGlwbHlNYXRyaWNlcyhMTVN0b1hZWl9NJDEsIExNUyk7XG5cdH0sXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge31cblx0fSxcbn0pO1xuXG5mdW5jdGlvbiBMTVN0b0lDdENwIChMTVMpIHtcblx0Ly8gYXBwbHkgdGhlIFBRIEVPVEZcblx0Ly8gd2UgY2FuJ3QgZXZlciBiZSBkaXZpZGluZyBieSB6ZXJvIGJlY2F1c2Ugb2YgdGhlIFwiMSArXCIgaW4gdGhlIGRlbm9taW5hdG9yXG5cdGxldCBQUUxNUyA9IExNUy5tYXAgKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRsZXQgbnVtID0gYzEkMSArIChjMiQxICogKCh2YWwgLyAxMDAwMCkgKiogbTEpKTtcblx0XHRsZXQgZGVub20gPSAxICsgKGMzJDEgKiAoKHZhbCAvIDEwMDAwKSAqKiBtMSkpO1xuXG5cdFx0cmV0dXJuIChudW0gLyBkZW5vbSkgICoqIG0yO1xuXHR9KTtcblxuXHQvLyBMTVMgdG8gSVBULCB3aXRoIHJvdGF0aW9uIGZvciBZJ0MnYkMnciBjb21wYXRpYmlsaXR5XG5cdHJldHVybiBtdWx0aXBseU1hdHJpY2VzKExNU3RvSVBUX00sIFBRTE1TKTtcbn1cblxuZnVuY3Rpb24gSUN0Q3B0b0xNUyAoSUN0Q3ApIHtcblx0bGV0IFBRTE1TID0gbXVsdGlwbHlNYXRyaWNlcyhJUFR0b0xNU19NLCBJQ3RDcCk7XG5cblx0Ly8gRnJvbSBCVC4yMTI0LTAgQW5uZXggMiBDb252ZXJzaW9uIDNcblx0bGV0IExNUyA9IFBRTE1TLm1hcCAoZnVuY3Rpb24gKHZhbCkge1xuXHRcdGxldCBudW0gID0gTWF0aC5tYXgoKHZhbCAqKiBpbTIpIC0gYzEkMSwgMCk7XG5cdFx0bGV0IGRlbm9tID0gKGMyJDEgLSAoYzMkMSAqICh2YWwgKiogaW0yKSkpO1xuXHRcdHJldHVybiAxMDAwMCAqICgobnVtIC8gZGVub20pICoqIGltMSk7XG5cdH0pO1xuXG5cdHJldHVybiBMTVM7XG59XG5cbi8vIERlbHRhIEUgaW4gSUN0Q3Agc3BhY2UsXG4vLyB3aGljaCB0aGUgSVRVIGNhbGxzIERlbHRhIEUgSVRQLCB3aGljaCBpcyBzaG9ydGVyXG4vLyBmb3JtdWxhZSBmcm9tIElUVSBSZWMuIElUVS1SIEJULjIxMjQtMFxuXG5mdW5jdGlvbiBkZWx0YUVJVFAgKGNvbG9yLCBzYW1wbGUpIHtcblx0Ly8gR2l2ZW4gdGhpcyBjb2xvciBhcyB0aGUgcmVmZXJlbmNlXG5cdC8vIGFuZCBhIHNhbXBsZSxcblx0Ly8gY2FsY3VsYXRlIGRlbHRhRSBpbiBJQ3RDcFxuXHQvLyB3aGljaCBpcyBzaW1wbHkgdGhlIEV1Y2xpZGVhbiBkaXN0YW5jZVxuXG5cdGxldCBbIEkxLCBUMSwgUDEgXSA9IGljdGNwLmZyb20oY29sb3IpO1xuXHRsZXQgWyBJMiwgVDIsIFAyIF0gPSBpY3RjcC5mcm9tKHNhbXBsZSk7XG5cblx0Ly8gdGhlIDAuMjUgZmFjdG9yIGlzIHRvIHVuZG8gdGhlIGVuY29kaW5nIHNjYWxpbmcgaW4gQ3Rcblx0Ly8gdGhlIDcyMCBpcyBzbyB0aGF0IDEgZGVsdGFFID0gMSBKTkRcblx0Ly8gcGVyICBJVFUtUiBCVC4yMTI0LTAgcC4zXG5cblx0cmV0dXJuIDcyMCAqIE1hdGguc3FydCgoSTEgLSBJMikgKiogMiArICgwLjI1ICogKFQxIC1UMikgKiogMikgKyAoUDEgLSBQMikgKiogMik7XG59XG5cbi8vIFJlY2FsY3VsYXRlZCBmb3IgY29uc2lzdGVudCByZWZlcmVuY2Ugd2hpdGVcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdzNjL2Nzc3dnLWRyYWZ0cy9pc3N1ZXMvNjY0MiNpc3N1ZWNvbW1lbnQtOTQzNTIxNDg0XG5jb25zdCBYWVp0b0xNU19NID0gW1xuXHRbIDAuODE5MDIyNDQzMjE2NDMxOSwgICAgMC4zNjE5MDYyNTYyODAxMjIxLCAgIC0wLjEyODg3Mzc4MjYxMjE2NDE0IF0sXG5cdFsgMC4wMzI5ODM2NjcxOTgwMjcxLCAgICAwLjkyOTI4Njg0Njg5NjU1NDYsICAgICAwLjAzNjE0NDY2ODE2OTk5ODQ0IF0sXG5cdFsgMC4wNDgxNzcxOTk1NjYwNDYyNTUsICAwLjI2NDIzOTUyNDk0NDIyNzY0LCAgICAwLjYzMzU0NzgyNTgxMzY5MzcgIF1cbl07XG4vLyBpbnZlcnNlIG9mIFhZWnRvTE1TX01cbmNvbnN0IExNU3RvWFlaX00gPSBbXG5cdFsgIDEuMjI2ODc5ODczMzc0MTU1NywgIC0wLjU1NzgxNDk5NjU1NTQ4MTMsICAgMC4yODEzOTEwNTAxNzcyMTU4M10sXG5cdFsgLTAuMDQwNTc1NzYyNjI0MzEzNzIsICAxLjExMjI4NjgyOTM5NzA1OTQsICAtMC4wNzE3MTEwNjY2NjE1MTcwMV0sXG5cdFsgLTAuMDc2MzcyOTQ5NzQ2NzIxNDIsIC0wLjQyMTQ5MzMyMzk2Mjc5MTQsICAgMS41ODY5MjQwMjQ0MjcyNDE4IF1cbl07XG5jb25zdCBMTVN0b0xhYl9NID0gW1xuXHRbICAwLjIxMDQ1NDI1NTMsICAgMC43OTM2MTc3ODUwLCAgLTAuMDA0MDcyMDQ2OCBdLFxuXHRbICAxLjk3Nzk5ODQ5NTEsICAtMi40Mjg1OTIyMDUwLCAgIDAuNDUwNTkzNzA5OSBdLFxuXHRbICAwLjAyNTkwNDAzNzEsICAgMC43ODI3NzE3NjYyLCAgLTAuODA4Njc1NzY2MCBdXG5dO1xuLy8gTE1TdG9JYWJfTSBpbnZlcnRlZFxuY29uc3QgTGFidG9MTVNfTSA9IFtcblx0WyAwLjk5OTk5OTk5ODQ1MDUxOTgxNDMyLCAgMC4zOTYzMzc3OTIxNzM3Njc4NTY3OCwgICAwLjIxNTgwMzc1ODA2MDc1ODgwMzM5ICBdLFxuXHRbIDEuMDAwMDAwMDA4ODgxNzYwNzc2NywgIC0wLjEwNTU2MTM0MjMyMzY1NjM0OTQsICAgLTAuMDYzODU0MTc0NzcxNzA1OTAzNDAyIF0sXG5cdFsgMS4wMDAwMDAwNTQ2NzI0MTA5MTc3LCAgLTAuMDg5NDg0MTgyMDk0OTY1NzU5Njg0LCAtMS4yOTE0ODU1Mzc4NjQwOTE3Mzk5ICAgXVxuXTtcblxudmFyIE9LTGFiID0gbmV3IENvbG9yU3BhY2Uoe1xuXHRpZDogXCJva2xhYlwiLFxuICAgIG5hbWU6IFwiT2tsYWJcIixcbiAgICBjb29yZHM6IHtcblx0XHRsOiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDFdLFxuXHRcdFx0bmFtZTogXCJMXCJcblx0XHR9LFxuXHRcdGE6IHtcblx0XHRcdHJlZlJhbmdlOiBbLTAuNCwgMC40XVxuXHRcdH0sXG5cdFx0Yjoge1xuXHRcdFx0cmVmUmFuZ2U6IFstMC40LCAwLjRdXG5cdFx0fVxuICAgIH0sXG5cblx0Ly8gTm90ZSB0aGF0IFhZWiBpcyByZWxhdGl2ZSB0byBENjVcbiAgd2hpdGU6IFwiRDY1XCIsXG5cdGJhc2U6IFhZWl9ENjUsXG5cdGZyb21CYXNlIChYWVopIHtcblx0XHQvLyBtb3ZlIHRvIExNUyBjb25lIGRvbWFpblxuXHRcdGxldCBMTVMgPSBtdWx0aXBseU1hdHJpY2VzKFhZWnRvTE1TX00sIFhZWik7XG5cblx0XHQvLyBub24tbGluZWFyaXR5XG5cdFx0bGV0IExNU2cgPSBMTVMubWFwKHZhbCA9PiBNYXRoLmNicnQodmFsKSk7XG5cblx0XHRyZXR1cm4gbXVsdGlwbHlNYXRyaWNlcyhMTVN0b0xhYl9NLCBMTVNnKTtcblxuXHR9LFxuXHR0b0Jhc2UgKE9LTGFiKSB7XG5cdFx0Ly8gbW92ZSB0byBMTVMgY29uZSBkb21haW5cblx0XHRsZXQgTE1TZyA9IG11bHRpcGx5TWF0cmljZXMoTGFidG9MTVNfTSwgT0tMYWIpO1xuXG5cdFx0Ly8gcmVzdG9yZSBsaW5lYXJpdHlcblx0XHRsZXQgTE1TID0gTE1TZy5tYXAodmFsID0+IHZhbCAqKiAzKTtcblxuXHRcdHJldHVybiBtdWx0aXBseU1hdHJpY2VzKExNU3RvWFlaX00sIExNUyk7XG5cdH0sXG5cblx0Zm9ybWF0czoge1xuXHRcdFwib2tsYWJcIjoge1xuXHRcdFx0Y29vcmRzOiBbXCI8cGVyY2VudGFnZT4gfCA8bnVtYmVyPlwiLCBcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+Wy0xLDFdXCIsIFwiPG51bWJlcj4gfCA8cGVyY2VudGFnZT5bLTEsMV1cIl0sXG5cdFx0fVxuXHR9XG59KTtcblxuLy8gTW9yZSBhY2N1cmF0ZSBjb2xvci1kaWZmZXJlbmNlIGZvcm11bGFlXG4vLyB0aGFuIHRoZSBzaW1wbGUgMTk3NiBFdWNsaWRlYW4gZGlzdGFuY2UgaW4gQ0lFIExhYlxuXG5cbmZ1bmN0aW9uIGRlbHRhRU9LIChjb2xvciwgc2FtcGxlKSB7XG5cdC8vIEdpdmVuIHRoaXMgY29sb3IgYXMgdGhlIHJlZmVyZW5jZVxuXHQvLyBhbmQgYSBzYW1wbGUsXG5cdC8vIGNhbGN1bGF0ZSBkZWx0YUVPSywgdGVybSBieSB0ZXJtIGFzIHJvb3Qgc3VtIG9mIHNxdWFyZXNcblx0bGV0IFtMMSwgYTEsIGIxXSA9IE9LTGFiLmZyb20oY29sb3IpO1xuXHRsZXQgW0wyLCBhMiwgYjJdID0gT0tMYWIuZnJvbShzYW1wbGUpO1xuXHRsZXQgzpRMID0gTDEgLSBMMjtcblx0bGV0IM6UYSA9IGExIC0gYTI7XG5cdGxldCDOlGIgPSBiMSAtIGIyO1xuXHRyZXR1cm4gTWF0aC5zcXJ0KM6UTCAqKiAyICsgzpRhICoqIDIgKyDOlGIgKiogMik7XG59XG5cbnZhciBkZWx0YUVNZXRob2RzID0ge1xuXHRkZWx0YUU3Nixcblx0ZGVsdGFFQ01DLFxuXHRkZWx0YUUyMDAwLFxuXHRkZWx0YUVKeixcblx0ZGVsdGFFSVRQLFxuXHRkZWx0YUVPSyxcbn07XG5cbmZ1bmN0aW9uIGRlbHRhRSAoYzEsIGMyLCBvID0ge30pIHtcblx0aWYgKGlzU3RyaW5nKG8pKSB7XG5cdFx0byA9IHttZXRob2Q6IG99O1xuXHR9XG5cblx0bGV0IHttZXRob2QgPSBkZWZhdWx0cy5kZWx0YUUsIC4uLnJlc3R9ID0gbztcblxuXHRjMSA9IGdldENvbG9yKGMxKTtcblx0YzIgPSBnZXRDb2xvcihjMik7XG5cblx0Zm9yIChsZXQgbSBpbiBkZWx0YUVNZXRob2RzKSB7XG5cdFx0aWYgKFwiZGVsdGFlXCIgKyBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gbS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRyZXR1cm4gZGVsdGFFTWV0aG9kc1ttXShjMSwgYzIsIHJlc3QpO1xuXHRcdH1cblx0fVxuXG5cdHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gZGVsdGFFIG1ldGhvZDogJHttZXRob2R9YCk7XG59XG5cbmZ1bmN0aW9uIGxpZ2h0ZW4gKGNvbG9yLCBhbW91bnQgPSAuMjUpIHtcblx0bGV0IHNwYWNlID0gQ29sb3JTcGFjZS5nZXQoXCJva2xjaFwiLCBcImxjaFwiKTtcblx0bGV0IGxpZ2h0bmVzcyA9IFtzcGFjZSwgXCJsXCJdO1xuXHRyZXR1cm4gc2V0KGNvbG9yLCBsaWdodG5lc3MsIGwgPT4gbCAqICgxICsgYW1vdW50KSk7XG59XG5cbmZ1bmN0aW9uIGRhcmtlbiAoY29sb3IsIGFtb3VudCA9IC4yNSkge1xuXHRsZXQgc3BhY2UgPSBDb2xvclNwYWNlLmdldChcIm9rbGNoXCIsIFwibGNoXCIpO1xuXHRsZXQgbGlnaHRuZXNzID0gW3NwYWNlLCBcImxcIl07XG5cdHJldHVybiBzZXQoY29sb3IsIGxpZ2h0bmVzcywgbCA9PiBsICogKDEgLSBhbW91bnQpKTtcbn1cblxudmFyIHZhcmlhdGlvbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0ZGFya2VuOiBkYXJrZW4sXG5cdGxpZ2h0ZW46IGxpZ2h0ZW5cbn0pO1xuXG4vKipcbiAqIEZ1bmN0aW9ucyByZWxhdGVkIHRvIGNvbG9yIGludGVycG9sYXRpb25cbiAqL1xuXG4vKipcbiAqIFJldHVybiBhbiBpbnRlcm1lZGlhdGUgY29sb3IgYmV0d2VlbiB0d28gY29sb3JzXG4gKiBTaWduYXR1cmVzOiBtaXgoYzEsIGMyLCBwLCBvcHRpb25zKVxuICogICAgICAgICAgICAgbWl4KGMxLCBjMiwgb3B0aW9ucylcbiAqICAgICAgICAgICAgIG1peChjb2xvcilcbiAqIEBwYXJhbSB7Q29sb3IgfCBzdHJpbmd9IGMxIFRoZSBmaXJzdCBjb2xvclxuICogQHBhcmFtIHtDb2xvciB8IHN0cmluZ30gW2MyXSBUaGUgc2Vjb25kIGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcn0gW3A9LjVdIEEgMC0xIHBlcmNlbnRhZ2Ugd2hlcmUgMCBpcyBjMSBhbmQgMSBpcyBjMlxuICogQHBhcmFtIHtPYmplY3R9IFtvPXt9XVxuICogQHJldHVybiB7Q29sb3J9XG4gKi9cbmZ1bmN0aW9uIG1peCAoYzEsIGMyLCBwID0gLjUsIG8gPSB7fSkge1xuXHRbYzEsIGMyXSA9IFtnZXRDb2xvcihjMSksIGdldENvbG9yKGMyKV07XG5cblx0aWYgKHR5cGUocCkgPT09IFwib2JqZWN0XCIpIHtcblx0XHRbcCwgb10gPSBbLjUsIHBdO1xuXHR9XG5cblx0bGV0IHtzcGFjZSwgb3V0cHV0U3BhY2UsIHByZW11bHRpcGxpZWR9ID0gbztcblxuXHRsZXQgciA9IHJhbmdlKGMxLCBjMiwge3NwYWNlLCBvdXRwdXRTcGFjZSwgcHJlbXVsdGlwbGllZH0pO1xuXHRyZXR1cm4gcihwKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtDb2xvciB8IHN0cmluZyB8IEZ1bmN0aW9ufSBjMSBUaGUgZmlyc3QgY29sb3Igb3IgYSByYW5nZVxuICogQHBhcmFtIHtDb2xvciB8IHN0cmluZ30gW2MyXSBUaGUgc2Vjb25kIGNvbG9yIGlmIGMxIGlzIG5vdCBhIHJhbmdlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gKiBAcmV0dXJuIHtDb2xvcltdfVxuICovXG5mdW5jdGlvbiBzdGVwcyAoYzEsIGMyLCBvcHRpb25zID0ge30pIHtcblx0bGV0IGNvbG9yUmFuZ2U7XG5cblx0aWYgKGlzUmFuZ2UoYzEpKSB7XG5cdFx0Ly8gVHdlYWtpbmcgZXhpc3RpbmcgcmFuZ2Vcblx0XHRbY29sb3JSYW5nZSwgb3B0aW9uc10gPSBbYzEsIGMyXTtcblx0XHRbYzEsIGMyXSA9IGNvbG9yUmFuZ2UucmFuZ2VBcmdzLmNvbG9ycztcblx0fVxuXG5cdGxldCB7XG5cdFx0bWF4RGVsdGFFLCBkZWx0YUVNZXRob2QsXG5cdFx0c3RlcHMgPSAyLCBtYXhTdGVwcyA9IDEwMDAsXG5cdFx0Li4ucmFuZ2VPcHRpb25zXG5cdH0gPSBvcHRpb25zO1xuXG5cdGlmICghY29sb3JSYW5nZSkge1xuXHRcdFtjMSwgYzJdID0gW2dldENvbG9yKGMxKSwgZ2V0Q29sb3IoYzIpXTtcblx0XHRjb2xvclJhbmdlID0gcmFuZ2UoYzEsIGMyLCByYW5nZU9wdGlvbnMpO1xuXHR9XG5cblx0bGV0IHRvdGFsRGVsdGEgPSBkZWx0YUUoYzEsIGMyKTtcblx0bGV0IGFjdHVhbFN0ZXBzID0gbWF4RGVsdGFFID4gMD8gTWF0aC5tYXgoc3RlcHMsIE1hdGguY2VpbCh0b3RhbERlbHRhIC8gbWF4RGVsdGFFKSArIDEpIDogc3RlcHM7XG5cdGxldCByZXQgPSBbXTtcblxuXHRpZiAobWF4U3RlcHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGFjdHVhbFN0ZXBzID0gTWF0aC5taW4oYWN0dWFsU3RlcHMsIG1heFN0ZXBzKTtcblx0fVxuXG5cdGlmIChhY3R1YWxTdGVwcyA9PT0gMSkge1xuXHRcdHJldCA9IFt7cDogLjUsIGNvbG9yOiBjb2xvclJhbmdlKC41KX1dO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGxldCBzdGVwID0gMSAvIChhY3R1YWxTdGVwcyAtIDEpO1xuXHRcdHJldCA9IEFycmF5LmZyb20oe2xlbmd0aDogYWN0dWFsU3RlcHN9LCAoXywgaSkgPT4ge1xuXHRcdFx0bGV0IHAgPSBpICogc3RlcDtcblx0XHRcdHJldHVybiB7cCwgY29sb3I6IGNvbG9yUmFuZ2UocCl9O1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKG1heERlbHRhRSA+IDApIHtcblx0XHQvLyBJdGVyYXRlIG92ZXIgYWxsIHN0b3BzIGFuZCBmaW5kIG1heCBkZWx0YUVcblx0XHRsZXQgbWF4RGVsdGEgPSByZXQucmVkdWNlKChhY2MsIGN1ciwgaSkgPT4ge1xuXHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdGxldCDOlM6VID0gZGVsdGFFKGN1ci5jb2xvciwgcmV0W2kgLSAxXS5jb2xvciwgZGVsdGFFTWV0aG9kKTtcblx0XHRcdHJldHVybiBNYXRoLm1heChhY2MsIM6UzpUpO1xuXHRcdH0sIDApO1xuXG5cdFx0d2hpbGUgKG1heERlbHRhID4gbWF4RGVsdGFFKSB7XG5cdFx0XHQvLyBJbnNlcnQgaW50ZXJtZWRpYXRlIHN0b3BzIGFuZCBtZWFzdXJlIG1heERlbHRhIGFnYWluXG5cdFx0XHQvLyBXZSBuZWVkIHRvIGRvIHRoaXMgZm9yIGFsbCBwYWlycywgb3RoZXJ3aXNlIHRoZSBtaWRwb2ludCBzaGlmdHNcblx0XHRcdG1heERlbHRhID0gMDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IChpIDwgcmV0Lmxlbmd0aCkgJiYgKHJldC5sZW5ndGggPCBtYXhTdGVwcyk7IGkrKykge1xuXHRcdFx0XHRsZXQgcHJldiA9IHJldFtpIC0gMV07XG5cdFx0XHRcdGxldCBjdXIgPSByZXRbaV07XG5cblx0XHRcdFx0bGV0IHAgPSAoY3VyLnAgKyBwcmV2LnApIC8gMjtcblx0XHRcdFx0bGV0IGNvbG9yID0gY29sb3JSYW5nZShwKTtcblx0XHRcdFx0bWF4RGVsdGEgPSBNYXRoLm1heChtYXhEZWx0YSwgZGVsdGFFKGNvbG9yLCBwcmV2LmNvbG9yKSwgZGVsdGFFKGNvbG9yLCBjdXIuY29sb3IpKTtcblx0XHRcdFx0cmV0LnNwbGljZShpLCAwLCB7cCwgY29sb3I6IGNvbG9yUmFuZ2UocCl9KTtcblx0XHRcdFx0aSsrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldCA9IHJldC5tYXAoYSA9PiBhLmNvbG9yKTtcblxuXHRyZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBJbnRlcnBvbGF0ZSB0byBjb2xvcjIgYW5kIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSAwLTEgcGVyY2VudGFnZVxuICogQHBhcmFtIHtDb2xvciB8IHN0cmluZyB8IEZ1bmN0aW9ufSBjb2xvcjEgVGhlIGZpcnN0IGNvbG9yIG9yIGFuIGV4aXN0aW5nIHJhbmdlXG4gKiBAcGFyYW0ge0NvbG9yIHwgc3RyaW5nfSBbY29sb3IyXSBJZiBjb2xvcjEgaXMgYSBjb2xvciwgdGhpcyBpcyB0aGUgc2Vjb25kIGNvbG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIDAtMSBwZXJjZW50YWdlIGFuZCByZXR1cm5zIGEgY29sb3JcbiAqL1xuZnVuY3Rpb24gcmFuZ2UgKGNvbG9yMSwgY29sb3IyLCBvcHRpb25zID0ge30pIHtcblx0aWYgKGlzUmFuZ2UoY29sb3IxKSkge1xuXHRcdC8vIFR3ZWFraW5nIGV4aXN0aW5nIHJhbmdlXG5cdFx0bGV0IFtyLCBvcHRpb25zXSA9IFtjb2xvcjEsIGNvbG9yMl07XG5cblx0XHRyZXR1cm4gcmFuZ2UoLi4uci5yYW5nZUFyZ3MuY29sb3JzLCB7Li4uci5yYW5nZUFyZ3Mub3B0aW9ucywgLi4ub3B0aW9uc30pO1xuXHR9XG5cblx0bGV0IHtzcGFjZSwgb3V0cHV0U3BhY2UsIHByb2dyZXNzaW9uLCBwcmVtdWx0aXBsaWVkfSA9IG9wdGlvbnM7XG5cblx0Y29sb3IxID0gZ2V0Q29sb3IoY29sb3IxKTtcblx0Y29sb3IyID0gZ2V0Q29sb3IoY29sb3IyKTtcblxuXHQvLyBNYWtlIHN1cmUgd2UncmUgd29ya2luZyBvbiBjb3BpZXMgb2YgdGhlc2UgY29sb3JzXG5cdGNvbG9yMSA9IGNsb25lKGNvbG9yMSk7XG5cdGNvbG9yMiA9IGNsb25lKGNvbG9yMik7XG5cblx0bGV0IHJhbmdlQXJncyA9IHtjb2xvcnM6IFtjb2xvcjEsIGNvbG9yMl0sIG9wdGlvbnN9O1xuXG5cdGlmIChzcGFjZSkge1xuXHRcdHNwYWNlID0gQ29sb3JTcGFjZS5nZXQoc3BhY2UpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHNwYWNlID0gQ29sb3JTcGFjZS5yZWdpc3RyeVtkZWZhdWx0cy5pbnRlcnBvbGF0aW9uU3BhY2VdIHx8IGNvbG9yMS5zcGFjZTtcblx0fVxuXG5cdG91dHB1dFNwYWNlID0gb3V0cHV0U3BhY2U/IENvbG9yU3BhY2UuZ2V0KG91dHB1dFNwYWNlKSA6IHNwYWNlO1xuXG5cdGNvbG9yMSA9IHRvKGNvbG9yMSwgc3BhY2UpO1xuXHRjb2xvcjIgPSB0byhjb2xvcjIsIHNwYWNlKTtcblxuXHQvLyBHYW11dCBtYXAgdG8gYXZvaWQgYXJlYXMgb2YgZmxhdCBjb2xvclxuXHRjb2xvcjEgPSB0b0dhbXV0KGNvbG9yMSk7XG5cdGNvbG9yMiA9IHRvR2FtdXQoY29sb3IyKTtcblxuXHQvLyBIYW5kbGUgaHVlIGludGVycG9sYXRpb25cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvY3Nzd2ctZHJhZnRzL2lzc3Vlcy80NzM1I2lzc3VlY29tbWVudC02MzU3NDE4NDBcblx0aWYgKHNwYWNlLmNvb3Jkcy5oICYmIHNwYWNlLmNvb3Jkcy5oLnR5cGUgPT09IFwiYW5nbGVcIikge1xuXHRcdGxldCBhcmMgPSBvcHRpb25zLmh1ZSA9IG9wdGlvbnMuaHVlIHx8IFwic2hvcnRlclwiO1xuXG5cdFx0bGV0IGh1ZSA9IFtzcGFjZSwgXCJoXCJdO1xuXHRcdGxldCBbzrgxLCDOuDJdID0gW2dldChjb2xvcjEsIGh1ZSksIGdldChjb2xvcjIsIGh1ZSldO1xuXHRcdFvOuDEsIM64Ml0gPSBhZGp1c3QoYXJjLCBbzrgxLCDOuDJdKTtcblx0XHRzZXQoY29sb3IxLCBodWUsIM64MSk7XG5cdFx0c2V0KGNvbG9yMiwgaHVlLCDOuDIpO1xuXHR9XG5cblx0aWYgKHByZW11bHRpcGxpZWQpIHtcblx0XHQvLyBub3QgY29waW5nIHdpdGggcG9sYXIgc3BhY2VzIHlldFxuXHRcdGNvbG9yMS5jb29yZHMgPSBjb2xvcjEuY29vcmRzLm1hcChjID0+IGMgKiBjb2xvcjEuYWxwaGEpO1xuXHRcdGNvbG9yMi5jb29yZHMgPSBjb2xvcjIuY29vcmRzLm1hcChjID0+IGMgKiBjb2xvcjIuYWxwaGEpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdC5hc3NpZ24ocCA9PiB7XG5cdFx0cCA9IHByb2dyZXNzaW9uPyBwcm9ncmVzc2lvbihwKSA6IHA7XG5cdFx0bGV0IGNvb3JkcyA9IGNvbG9yMS5jb29yZHMubWFwKChzdGFydCwgaSkgPT4ge1xuXHRcdFx0bGV0IGVuZCA9IGNvbG9yMi5jb29yZHNbaV07XG5cdFx0XHRyZXR1cm4gaW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgcCk7XG5cdFx0fSk7XG5cblx0XHRsZXQgYWxwaGEgPSBpbnRlcnBvbGF0ZShjb2xvcjEuYWxwaGEsIGNvbG9yMi5hbHBoYSwgcCk7XG5cdFx0bGV0IHJldCA9IHtzcGFjZSwgY29vcmRzLCBhbHBoYX07XG5cblx0XHRpZiAocHJlbXVsdGlwbGllZCkge1xuXHRcdFx0Ly8gdW5kbyBwcmVtdWx0aXBsaWNhdGlvblxuXHRcdFx0cmV0LmNvb3JkcyA9IHJldC5jb29yZHMubWFwKGMgPT4gYyAvIGFscGhhKTtcblx0XHR9XG5cblx0XHRpZiAob3V0cHV0U3BhY2UgIT09IHNwYWNlKSB7XG5cdFx0XHRyZXQgPSB0byhyZXQsIG91dHB1dFNwYWNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LCB7XG5cdFx0cmFuZ2VBcmdzXG5cdH0pO1xufVxuZnVuY3Rpb24gaXNSYW5nZSAodmFsKSB7XG5cdHJldHVybiB0eXBlKHZhbCkgPT09IFwiZnVuY3Rpb25cIiAmJiAhIXZhbC5yYW5nZUFyZ3M7XG59XG5kZWZhdWx0cy5pbnRlcnBvbGF0aW9uU3BhY2UgPSBcImxhYlwiO1xuXG5mdW5jdGlvbiByZWdpc3RlciAoQ29sb3IpIHtcblx0Q29sb3IuZGVmaW5lRnVuY3Rpb24oXCJtaXhcIiwgbWl4LCB7cmV0dXJuczogXCJjb2xvclwifSk7XG5cdENvbG9yLmRlZmluZUZ1bmN0aW9uKFwicmFuZ2VcIiwgcmFuZ2UsIHtyZXR1cm5zOiBcImZ1bmN0aW9uPGNvbG9yPlwifSk7XG5cdENvbG9yLmRlZmluZUZ1bmN0aW9uKFwic3RlcHNcIiwgc3RlcHMsIHtyZXR1cm5zOiBcImFycmF5PGNvbG9yPlwifSk7XG59XG5cbnZhciBpbnRlcnBvbGF0aW9uID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGlzUmFuZ2U6IGlzUmFuZ2UsXG5cdG1peDogbWl4LFxuXHRyYW5nZTogcmFuZ2UsXG5cdHJlZ2lzdGVyOiByZWdpc3Rlcixcblx0c3RlcHM6IHN0ZXBzXG59KTtcblxudmFyIEhTTCA9IG5ldyBDb2xvclNwYWNlKHtcblx0aWQ6IFwiaHNsXCIsXG5cdG5hbWU6IFwiSFNMXCIsXG5cdGNvb3Jkczoge1xuXHRcdGg6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMzYwXSxcblx0XHRcdHR5cGU6IFwiYW5nbGVcIixcblx0XHRcdG5hbWU6IFwiSHVlXCJcblx0XHR9LFxuXHRcdHM6IHtcblx0XHRcdHJhbmdlOiBbMCwgMTAwXSxcblx0XHRcdG5hbWU6IFwiU2F0dXJhdGlvblwiXG5cdFx0fSxcblx0XHRsOiB7XG5cdFx0XHRyYW5nZTogWzAsIDEwMF0sXG5cdFx0XHRuYW1lOiBcIkxpZ2h0bmVzc1wiXG5cdFx0fVxuXHR9LFxuXG5cdGJhc2U6IHNSR0IsXG5cblx0Ly8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9hbmRfSFNWI0Zyb21fUkdCXG5cdGZyb21CYXNlOiByZ2IgPT4ge1xuXHRcdGxldCBtYXggPSBNYXRoLm1heCguLi5yZ2IpO1xuXHRcdGxldCBtaW4gPSBNYXRoLm1pbiguLi5yZ2IpO1xuXHRcdGxldCBbciwgZywgYl0gPSByZ2I7XG5cdFx0bGV0IFtoLCBzLCBsXSA9IFtOYU4sIDAsIChtaW4gKyBtYXgpLzJdO1xuXHRcdGxldCBkID0gbWF4IC0gbWluO1xuXG5cdFx0aWYgKGQgIT09IDApIHtcblx0XHRcdHMgPSAobCA9PT0gMCB8fCBsID09PSAxKSA/IDAgOiAobWF4IC0gbCkgLyBNYXRoLm1pbihsLCAxIC0gbCk7XG5cblx0XHRcdHN3aXRjaCAobWF4KSB7XG5cdFx0XHRcdGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcblx0XHRcdFx0Y2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcblx0XHRcdFx0Y2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0O1xuXHRcdFx0fVxuXG5cdFx0XHRoID0gaCAqIDYwO1xuXHRcdH1cblxuXHRcdHJldHVybiBbaCwgcyAqIDEwMCwgbCAqIDEwMF07XG5cdH0sXG5cblx0Ly8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9hbmRfSFNWI0hTTF90b19SR0JfYWx0ZXJuYXRpdmVcblx0dG9CYXNlOiBoc2wgPT4ge1xuXHRcdGxldCBbaCwgcywgbF0gPSBoc2w7XG5cdFx0aCA9IGggJSAzNjA7XG5cblx0XHRpZiAoaCA8IDApIHtcblx0XHRcdGggKz0gMzYwO1xuXHRcdH1cblxuXHRcdHMgLz0gMTAwO1xuXHRcdGwgLz0gMTAwO1xuXG5cdFx0ZnVuY3Rpb24gZiAobikge1xuXHRcdFx0bGV0IGsgPSAobiArIGgvMzApICUgMTI7XG5cdFx0XHRsZXQgYSA9IHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG5cdFx0XHRyZXR1cm4gbCAtIGEgKiBNYXRoLm1heCgtMSwgTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtmKDApLCBmKDgpLCBmKDQpXTtcblx0fSxcblxuXHRmb3JtYXRzOiB7XG5cdFx0XCJoc2xcIjoge1xuXHRcdFx0dG9HYW11dDogdHJ1ZSxcblx0XHRcdGNvb3JkczogW1wiPG51bWJlcj4gfCA8YW5nbGU+XCIsIFwiPHBlcmNlbnRhZ2U+XCIsIFwiPHBlcmNlbnRhZ2U+XCJdLFxuXHRcdH0sXG5cdFx0XCJoc2xhXCI6IHtcblx0XHRcdGNvb3JkczogW1wiPG51bWJlcj4gfCA8YW5nbGU+XCIsIFwiPHBlcmNlbnRhZ2U+XCIsIFwiPHBlcmNlbnRhZ2U+XCJdLFxuXHRcdFx0Y29tbWFzOiB0cnVlLFxuXHRcdFx0bGFzdEFscGhhOiB0cnVlLFxuXHRcdH1cblx0fSxcbn0pO1xuXG4vLyBUaGUgSHVlLCBXaGl0ZW5lc3MgQmxhY2tuZXNzIChIV0IpIGNvbG9yc3BhY2Vcbi8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLTQvI3RoZS1od2Itbm90YXRpb25cbi8vIE5vdGUgdGhhdCwgbGlrZSBIU0wsIGNhbGN1bGF0aW9ucyBhcmUgZG9uZSBkaXJlY3RseSBvblxuLy8gZ2FtbWEtY29ycmVjdGVkIHNSR0IgdmFsdWVzIHJhdGhlciB0aGFuIGxpbmVhcmlzaW5nIHRoZW0gZmlyc3QuXG5cbnZhciBIU1YgPSBuZXcgQ29sb3JTcGFjZSh7XG5cdGlkOiBcImhzdlwiLFxuXHRuYW1lOiBcIkhTVlwiLFxuXHRjb29yZHM6IHtcblx0XHRoOiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDM2MF0sXG5cdFx0XHR0eXBlOiBcImFuZ2xlXCIsXG5cdFx0XHRuYW1lOiBcIkh1ZVwiXG5cdFx0fSxcblx0XHRzOiB7XG5cdFx0XHRyYW5nZTogWzAsIDEwMF0sXG5cdFx0XHRuYW1lOiBcIlNhdHVyYXRpb25cIlxuXHRcdH0sXG5cdFx0djoge1xuXHRcdFx0cmFuZ2U6IFswLCAxMDBdLFxuXHRcdFx0bmFtZTogXCJWYWx1ZVwiXG5cdFx0fVxuXHR9LFxuXG5cdGJhc2U6IEhTTCxcblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2FuZF9IU1YjSW50ZXJjb252ZXJzaW9uXG5cdGZyb21CYXNlIChoc2wpIHtcblx0XHRsZXQgW2gsIHMsIGxdID0gaHNsO1xuXHRcdHMgLz0gMTAwO1xuXHRcdGwgLz0gMTAwO1xuXG5cdFx0bGV0IHYgPSBsICsgcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcblxuXHRcdHJldHVybiBbXG5cdFx0XHRoLCAvLyBoIGlzIHRoZSBzYW1lXG5cdFx0XHR2ID09PSAwPyAwIDogMjAwICogKDEgLSBsIC8gdiksIC8vIHNcblx0XHRcdDEwMCAqIHZcblx0XHRdO1xuXHR9LFxuXHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTViNJbnRlcmNvbnZlcnNpb25cblx0dG9CYXNlIChoc3YpIHtcblx0XHRsZXQgW2gsIHMsIHZdID0gaHN2O1xuXG5cdFx0cyAvPSAxMDA7XG5cdFx0diAvPSAxMDA7XG5cblx0XHRsZXQgbCA9IHYgKiAoMSAtIHMvMik7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0aCwgLy8gaCBpcyB0aGUgc2FtZVxuXHRcdFx0KGwgPT09IDAgfHwgbCA9PT0gMSk/IDAgOiAoKHYgLSBsKSAvIE1hdGgubWluKGwsIDEgLSBsKSkgKiAxMDAsXG5cdFx0XHRsICogMTAwXG5cdFx0XTtcblx0fSxcblx0Zm9ybWF0czoge1xuXHRcdGNvbG9yOiB7XG5cdFx0XHR0b0dhbXV0OiB0cnVlLFxuXHRcdH1cblx0fVxufSk7XG5cbi8vIFRoZSBIdWUsIFdoaXRlbmVzcyBCbGFja25lc3MgKEhXQikgY29sb3JzcGFjZVxuLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtY29sb3ItNC8jdGhlLWh3Yi1ub3RhdGlvblxuLy8gTm90ZSB0aGF0LCBsaWtlIEhTTCwgY2FsY3VsYXRpb25zIGFyZSBkb25lIGRpcmVjdGx5IG9uXG4vLyBnYW1tYS1jb3JyZWN0ZWQgc1JHQiB2YWx1ZXMgcmF0aGVyIHRoYW4gbGluZWFyaXNpbmcgdGhlbSBmaXJzdC5cblxudmFyIGh3YiA9IG5ldyBDb2xvclNwYWNlKHtcblx0aWQ6IFwiaHdiXCIsXG5cdG5hbWU6IFwiSFdCXCIsXG5cdGNvb3Jkczoge1xuXHRcdGg6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMzYwXSxcblx0XHRcdHR5cGU6IFwiYW5nbGVcIixcblx0XHRcdG5hbWU6IFwiSHVlXCJcblx0XHR9LFxuXHRcdHc6IHtcblx0XHRcdHJhbmdlOiBbMCwgMTAwXSxcblx0XHRcdG5hbWU6IFwiV2hpdGVuZXNzXCJcblx0XHR9LFxuXHRcdGI6IHtcblx0XHRcdHJhbmdlOiBbMCwgMTAwXSxcblx0XHRcdG5hbWU6IFwiQmxhY2tuZXNzXCJcblx0XHR9XG5cdH0sXG5cblx0YmFzZTogSFNWLFxuXHRmcm9tQmFzZSAoaHN2KSB7XG5cdFx0bGV0IFtoLCBzLCB2XSA9IGhzdjtcblxuXHRcdHJldHVybiBbaCwgdiAqICgxMDAgLSBzKSAvIDEwMCwgMTAwIC0gdl07XG5cdH0sXG5cdHRvQmFzZSAoaHdiKSB7XG5cdFx0bGV0IFtoLCB3LCBiXSA9IGh3YjtcblxuXHRcdC8vIE5vdyBjb252ZXJ0IHBlcmNlbnRhZ2VzIHRvIFswLi4xXVxuXHRcdHcgLz0gMTAwO1xuXHRcdGIgLz0gMTAwO1xuXG5cdFx0Ly8gQWNocm9tYXRpYyBjaGVjayAod2hpdGUgcGx1cyBibGFjayA+PSAxKVxuXHRcdGxldCBzdW0gPSB3ICsgYjtcblx0XHRpZiAoc3VtID49IDEpIHtcblx0XHRcdCBsZXQgZ3JheSA9IHcgLyBzdW07XG5cdFx0XHQgcmV0dXJuIFtoLCAwLCBncmF5ICogMTAwXTtcblx0XHR9XG5cblx0XHRsZXQgdiA9ICgxIC0gYik7XG5cdFx0bGV0IHMgPSAodiA9PT0gMCkgPyAwIDogMSAtIHcgLyB2O1xuXHRcdHJldHVybiBbaCwgcyAqIDEwMCwgdiAqIDEwMF07XG5cdH0sXG5cblx0Zm9ybWF0czoge1xuXHRcdFwiaHdiXCI6IHtcblx0XHRcdHRvR2FtdXQ6IHRydWUsXG5cdFx0XHRjb29yZHM6IFtcIjxudW1iZXI+IHwgPGFuZ2xlPlwiLCBcIjxwZXJjZW50YWdlPlwiLCBcIjxwZXJjZW50YWdlPlwiXSxcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBjb252ZXJ0IGFuIGFycmF5IG9mIGxpbmVhci1saWdodCBhOTgtcmdiIHZhbHVlcyB0byBDSUUgWFlaXG4vLyBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0Vxbl9SR0JfWFlaX01hdHJpeC5odG1sXG4vLyBoYXMgZ3JlYXRlciBudW1lcmljYWwgcHJlY2lzaW9uIHRoYW4gc2VjdGlvbiA0LjMuNS4zIG9mXG4vLyBodHRwczovL3d3dy5hZG9iZS5jb20vZGlnaXRhbGltYWcvcGRmcy9BZG9iZVJHQjE5OTgucGRmXG4vLyBidXQgdGhlIHZhbHVlcyBiZWxvdyB3ZXJlIGNhbGN1bGF0ZWQgZnJvbSBmaXJzdCBwcmluY2lwbGVzXG4vLyBmcm9tIHRoZSBjaHJvbWF0aWNpdHkgY29vcmRpbmF0ZXMgb2YgUiBHIEIgV1xuY29uc3QgdG9YWVpfTSQyID0gW1xuXHRbIDAuNTc2NjY5MDQyOTEwMTMwNSwgICAwLjE4NTU1ODIzNzkwNjU0NjMsICAgMC4xODgyMjg2NDYyMzQ5OTQ3ICBdLFxuXHRbIDAuMjk3MzQ0OTc1MjUwNTM2MDUsICAwLjYyNzM2MzU2NjI1NTQ2NjEsICAgMC4wNzUyOTE0NTg0OTM5OTc4OCBdLFxuXHRbIDAuMDI3MDMxMzYxMzg2NDEyMzQsICAwLjA3MDY4ODg1MjUzNTgyNzIzLCAgMC45OTEzMzc1MzY4Mzc2Mzg4ICBdXG5dO1xuXG5jb25zdCBmcm9tWFlaX00kMiA9IFtcblx0WyAgMi4wNDE1ODc5MDM4MTA3NDY1LCAgICAtMC41NjUwMDY5NzQyNzg4NTk2LCAgIC0wLjM0NDczMTM1MDc3ODMyOTU2IF0sXG5cdFsgLTAuOTY5MjQzNjM2MjgwODc5NSwgICAgIDEuODc1OTY3NTAxNTA3NzIwMiwgICAgMC4wNDE1NTUwNTc0MDcxNzU1NyBdLFxuXHRbICAwLjAxMzQ0NDI4MDYzMjAzMTE0MiwgIC0wLjExODM2MjM5MjIzMTAxODM4LCAgIDEuMDE1MTc0OTk0MzkxMjA1NCAgXVxuXTtcblxudmFyIEE5OExpbmVhciA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwiYTk4cmdiLWxpbmVhclwiLFxuXHRuYW1lOiBcIkxpbmVhciBBZG9iZcKuIDk4IFJHQiBjb21wYXRpYmxlXCIsXG5cdHdoaXRlOiBcIkQ2NVwiLFxuXHR0b1hZWl9NOiB0b1hZWl9NJDIsXG5cdGZyb21YWVpfTTogZnJvbVhZWl9NJDJcbn0pO1xuXG52YXIgYTk4cmdiID0gbmV3IFJHQkNvbG9yU3BhY2Uoe1xuXHRpZDogXCJhOThyZ2JcIixcblx0bmFtZTogXCJBZG9iZcKuIDk4IFJHQiBjb21wYXRpYmxlXCIsXG5cdGJhc2U6IEE5OExpbmVhcixcblx0dG9CYXNlOiBSR0IgPT4gUkdCLm1hcCh2YWwgPT4gTWF0aC5wb3coTWF0aC5hYnModmFsKSwgNTYzIC8gMjU2KSAqIE1hdGguc2lnbih2YWwpKSxcblx0ZnJvbUJhc2U6IFJHQiA9PiBSR0IubWFwKHZhbCA9PiBNYXRoLnBvdyhNYXRoLmFicyh2YWwpLCAyNTYgLyA1NjMpICogTWF0aC5zaWduKHZhbCkpLFxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHtcblx0XHRcdGlkOiBcImE5OC1yZ2JcIlxuXHRcdH1cblx0fSxcbn0pO1xuXG4vLyBjb252ZXJ0IGFuIGFycmF5IG9mICBwcm9waG90by1yZ2IgdmFsdWVzIHRvIENJRSBYWVpcbi8vIHVzaW5nICBENTAgKHNvIG5vIGNocm9tYXRpYyBhZGFwdGF0aW9uIG5lZWRlZCBhZnRlcndhcmRzKVxuLy8gaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fUkdCX1hZWl9NYXRyaXguaHRtbFxuY29uc3QgdG9YWVpfTSQxID0gW1xuXHRbIDAuNzk3NzYwNDg5NjcyMzAyNywgIDAuMTM1MTg1ODM3MTc1NzQwMzEsICAwLjAzMTM0OTM0OTU4MTUyNDggICAgIF0sXG5cdFsgMC4yODgwNzExMjgyMjkyOTM0LCAgMC43MTE4NDMyMTc4MTAxMDE0LCAgIDAuMDAwMDg1NjUzOTYwNjA1MjU5MDIgXSxcblx0WyAwLjAsICAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgMC44MjUxMDQ2MDI1MTA0NjAxICAgICBdXG5dO1xuXG5jb25zdCBmcm9tWFlaX00kMSA9IFtcblx0WyAgMS4zNDU3OTg5NzMxMDI4MjgxLCAgLTAuMjU1NTgwMTAwMDc5OTc1MzQsICAtMC4wNTExMDYyODUwNjc1MzQwMSBdLFxuXHRbIC0wLjU0NDYyMjQ5MzkwMjgzNDcsICAgMS41MDgyMzI3NDEzMTMyNzgxLCAgICAwLjAyMDUzNjAzMjM5MTQ3OTczIF0sXG5cdFsgIDAuMCwgICAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgIDEuMjExOTY3NTQ1NjM4OTQ1NCAgXVxuXTtcblxudmFyIFByb1Bob3RvTGluZWFyID0gbmV3IFJHQkNvbG9yU3BhY2Uoe1xuXHRpZDogXCJwcm9waG90by1saW5lYXJcIixcblx0bmFtZTogXCJMaW5lYXIgUHJvUGhvdG9cIixcblx0d2hpdGU6IFwiRDUwXCIsXG5cdGJhc2U6IFhZWl9ENTAsXG5cdHRvWFlaX006IHRvWFlaX00kMSxcblx0ZnJvbVhZWl9NOiBmcm9tWFlaX00kMVxufSk7XG5cbmNvbnN0IEV0ID0gMS81MTI7XG5jb25zdCBFdDIgPSAxNi81MTI7XG5cbnZhciBwcm9waG90byA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwicHJvcGhvdG9cIixcblx0bmFtZTogXCJQcm9QaG90b1wiLFxuXHRiYXNlOiBQcm9QaG90b0xpbmVhcixcblx0dG9CYXNlIChSR0IpIHtcblx0XHQvLyBUcmFuc2ZlciBjdXJ2ZSBpcyBnYW1tYSAxLjggd2l0aCBhIHNtYWxsIGxpbmVhciBwb3J0aW9uXG5cdFx0cmV0dXJuIFJHQi5tYXAodiA9PiB2IDwgRXQyPyB2IC8gMTYgOiB2ICoqIDEuOCk7XG5cdH0sXG5cdGZyb21CYXNlIChSR0IpIHtcblx0XHRyZXR1cm4gUkdCLm1hcCh2ID0+IHYgPj0gRXQ/IHYgKiogKDEvMS44KSA6IDE2ICogdik7XG5cdH0sXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge1xuXHRcdFx0aWQ6IFwicHJvcGhvdG8tcmdiXCJcblx0XHR9XG5cdH0sXG59KTtcblxudmFyIG9rbGNoID0gbmV3IENvbG9yU3BhY2Uoe1xuXHRpZDogXCJva2xjaFwiLFxuXHRuYW1lOiBcIk9rbGNoXCIsXG5cdGNvb3Jkczoge1xuXHRcdGw6IHtcblx0XHRcdHJlZlJhbmdlOiBbMCwgMV0sXG5cdFx0XHRuYW1lOiBcIkxpZ2h0bmVzc1wiXG5cdFx0fSxcblx0XHRjOiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDAuNF0sXG5cdFx0XHRuYW1lOiBcIkNocm9tYVwiXG5cdFx0fSxcblx0XHRoOiB7XG5cdFx0XHRyZWZSYW5nZTogWzAsIDM2MF0sXG5cdFx0XHR0eXBlOiBcImFuZ2xlXCIsXG5cdFx0XHRuYW1lOiBcIkh1ZVwiXG5cdFx0fVxuXHR9LFxuXHR3aGl0ZTogXCJENjVcIixcblxuXHRiYXNlOiBPS0xhYixcblx0ZnJvbUJhc2UgKG9rbGFiKSB7XG5cdFx0Ly8gQ29udmVydCB0byBwb2xhciBmb3JtXG5cdFx0bGV0IFtMLCBhLCBiXSA9IG9rbGFiO1xuXHRcdGxldCBoO1xuXHRcdGNvbnN0IM61ID0gMC4wMDAyOyAvLyBjaHJvbWF0aWMgY29tcG9uZW50cyBtdWNoIHNtYWxsZXIgdGhhbiBhLGJcblxuXHRcdGlmIChNYXRoLmFicyhhKSA8IM61ICYmIE1hdGguYWJzKGIpIDwgzrUpIHtcblx0XHRcdGggPSBOYU47XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aCA9IE1hdGguYXRhbjIoYiwgYSkgKiAxODAgLyBNYXRoLlBJO1xuXHRcdH1cblxuXHRcdHJldHVybiBbXG5cdFx0XHRMLCAvLyBPS0xhYiBMIGlzIHN0aWxsIExcblx0XHRcdE1hdGguc3FydChhICoqIDIgKyBiICoqIDIpLCAvLyBDaHJvbWFcblx0XHRcdGNvbnN0cmFpbihoKSAvLyBIdWUsIGluIGRlZ3JlZXMgWzAgdG8gMzYwKVxuXHRcdF07XG5cdH0sXG5cdC8vIENvbnZlcnQgZnJvbSBwb2xhciBmb3JtXG5cdHRvQmFzZSAob2tsY2gpIHtcblx0XHRsZXQgW0wsIEMsIGhdID0gb2tsY2g7XG5cdFx0bGV0IGEsIGI7XG5cblx0XHQvLyBjaGVjayBmb3IgTmFOIGh1ZVxuXHRcdGlmIChpc05hTihoKSkge1xuXHRcdFx0YSA9IDA7XG5cdFx0XHRiID0gMDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRhID0gQyAqIE1hdGguY29zKGggKiBNYXRoLlBJIC8gMTgwKTtcblx0XHRcdGIgPSBDICogTWF0aC5zaW4oaCAqIE1hdGguUEkgLyAxODApO1xuXHRcdH1cblxuXHRcdHJldHVybiBbIEwsIGEsIGIgXTtcblx0fSxcblxuXHRmb3JtYXRzOiB7XG5cdFx0XCJva2xjaFwiOiB7XG5cdFx0XHRjb29yZHM6IFtcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+XCIsIFwiPG51bWJlcj4gfCA8cGVyY2VudGFnZT5bMCwxXVwiLCBcIjxudW1iZXI+IHwgPGFuZ2xlPlwiXSxcblx0XHR9XG5cdH1cbn0pO1xuXG5jb25zdCBZdyA9IDIwMztcdC8vIGFic29sdXRlIGx1bWluYW5jZSBvZiBtZWRpYSB3aGl0ZSwgY2QvbcKyXG5jb25zdCBuID0gMjYxMCAvICgyICoqIDE0KTtcbmNvbnN0IG5pbnYgPSAoMiAqKiAxNCkgLyAyNjEwO1xuY29uc3QgbSA9IDI1MjMgLyAoMiAqKiA1KTtcbmNvbnN0IG1pbnYgPSAoMiAqKiA1KSAvIDI1MjM7XG5jb25zdCBjMSA9IDM0MjQgLyAoMiAqKiAxMik7XG5jb25zdCBjMiA9IDI0MTMgLyAoMiAqKiA3KTtcbmNvbnN0IGMzID0gMjM5MiAvICgyICoqIDcpO1xuXG52YXIgcmVjMjEwMFBxID0gbmV3IFJHQkNvbG9yU3BhY2Uoe1xuXHRpZDogXCJyZWMyMTAwcHFcIixcblx0bmFtZTogXCJSRUMuMjEwMC1QUVwiLFxuXHRiYXNlOiBSRUMyMDIwTGluZWFyLFxuXHR0b0Jhc2UgKFJHQikge1xuXHRcdC8vIGdpdmVuIFBRIGVuY29kZWQgY29tcG9uZW50IGluIHJhbmdlIFswLCAxXVxuXHRcdC8vIHJldHVybiBtZWRpYS13aGl0ZSByZWxhdGl2ZSBsaW5lYXItbGlnaHRcblx0XHRyZXR1cm4gUkdCLm1hcChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRsZXQgeCA9ICgoTWF0aC5tYXgoKCh2YWwgKiogbWludikgLSBjMSksIDApIC8gKGMyIC0gKGMzICogKHZhbCAqKiBtaW52KSkpKSAqKiBuaW52KTtcblx0XHRcdHJldHVybiAoeCAqIDEwMDAwIC8gWXcpOyBcdC8vIGx1bWluYW5jZSByZWxhdGl2ZSB0byBkaWZmdXNlIHdoaXRlLCBbMCwgNzAgb3Igc29dLlxuXHRcdH0pO1xuXHR9LFxuXHRmcm9tQmFzZSAoUkdCKSB7XG5cdFx0Ly8gZ2l2ZW4gbWVkaWEtd2hpdGUgcmVsYXRpdmUgbGluZWFyLWxpZ2h0XG5cdFx0Ly8gcmV0dXJuUFEgZW5jb2RlZCBjb21wb25lbnQgaW4gcmFuZ2UgWzAsIDFdXG5cdFx0cmV0dXJuIFJHQi5tYXAoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0bGV0IHggPSBNYXRoLm1heCh2YWwgKiBZdyAvIDEwMDAwLCAwKTsgXHQvLyBhYnNvbHV0ZSBsdW1pbmFuY2Ugb2YgcGVhayB3aGl0ZSBpcyAxMCwwMDAgY2QvbcKyLlxuXHRcdFx0bGV0IG51bSA9IChjMSArIChjMiAqICh4ICoqIG4pKSk7XG5cdFx0XHRsZXQgZGVub20gPSAoMSArIChjMyAqICh4ICoqIG4pKSk7XG5cblx0XHRcdHJldHVybiAoKG51bSAvIGRlbm9tKSAgKiogbSk7XG5cdFx0fSk7XG5cdH0sXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge1xuXHRcdFx0aWQ6IFwicmVjMjEwMC1wcVwiXG5cdFx0fSxcblx0fSxcbn0pO1xuXG4vLyBGSVhNRSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYVZlcm91L2NvbG9yLmpzL2lzc3Vlcy8xOTBcblxuY29uc3QgYSA9IDAuMTc4ODMyNzc7XG5jb25zdCBiID0gMC4yODQ2Njg5MjsgLy8gMSAtICg0ICogYSlcbmNvbnN0IGMgPSAwLjU1OTkxMDczOyAvLyAwLjUgLSBhICogTWF0aC5sb2coNCAqYSlcblxuY29uc3Qgc2NhbGUgPSAzLjc3NDM7XHQvLyBQbGFjZSAxOCUgZ3JleSBhdCBITEcgMC4zOCwgc28gbWVkaWEgd2hpdGUgYXQgMC43NVxuXG52YXIgcmVjMjEwMEhsZyA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwicmVjMjEwMGhsZ1wiLFxuXHRjc3NpZDogXCJyZWMyMTAwLWhsZ1wiLFxuXHRuYW1lOiBcIlJFQy4yMTAwLUhMR1wiLFxuXHRyZWZlcnJlZDogXCJzY2VuZVwiLFxuXG5cdGJhc2U6IFJFQzIwMjBMaW5lYXIsXG5cdHRvQmFzZSAoUkdCKSB7XG5cdFx0Ly8gZ2l2ZW4gSExHIGVuY29kZWQgY29tcG9uZW50IGluIHJhbmdlIFswLCAxXVxuXHRcdC8vIHJldHVybiBtZWRpYS13aGl0ZSByZWxhdGl2ZSBsaW5lYXItbGlnaHRcblx0XHRyZXR1cm4gUkdCLm1hcChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHQvLyBmaXJzdCB0aGUgSExHIEVPVEZcblx0XHRcdC8vIElUVS1SIEJULjIzOTAtMTAgcC4zMCBzZWN0aW9uXG5cdFx0XHQvLyA2LjMgVGhlIGh5YnJpZCBsb2ctZ2FtbWEgZWxlY3Ryby1vcHRpY2FsIHRyYW5zZmVyIGZ1bmN0aW9uIChFT1RGKVxuXHRcdFx0Ly8gVGhlbiBzY2FsZSBieSAzIHNvIG1lZGlhIHdoaXRlIGlzIDEuMFxuXHRcdFx0aWYgKHZhbCA8PSAwLjUpIHtcblx0XHRcdFx0cmV0dXJuICh2YWwgKiogMikgLyAzICogc2NhbGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKChNYXRoLmV4cCgodmFsIC0gYykgLyBhKSArIGIpIC8gMTIpICogc2NhbGU7XG5cdFx0fSk7XG5cdH0sXG5cdGZyb21CYXNlIChSR0IpIHtcblx0XHQvLyBnaXZlbiBtZWRpYS13aGl0ZSByZWxhdGl2ZSBsaW5lYXItbGlnaHRcblx0XHQvLyB3aGVyZSBkaWZmdXNlIHdoaXRlIGlzIDEuMCxcblx0XHQvLyByZXR1cm4gSExHIGVuY29kZWQgY29tcG9uZW50IGluIHJhbmdlIFswLCAxXVxuXHRcdHJldHVybiBSR0IubWFwKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdC8vIGZpcnN0IHNjYWxlIHRvIHB1dCBsaW5lYXItbGlnaHQgbWVkaWEgd2hpdGUgYXQgMS8zXG5cdFx0XHR2YWwgLz0gc2NhbGU7XG5cdFx0XHQvLyBub3cgdGhlIEhMRyBPRVRGXG5cdFx0XHQvLyBJVFUtUiBCVC4yMzkwLTEwIHAuMjNcblx0XHRcdC8vIDYuMSBUaGUgaHlicmlkIGxvZy1nYW1tYSBvcHRvLWVsZWN0cm9uaWMgdHJhbnNmZXIgZnVuY3Rpb24gKE9FVEYpXG5cdFx0XHRpZiAodmFsIDw9IDEvMTIpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydCggMyAqIHZhbCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYSAqIE1hdGgubG9nKDEyICogdmFsIC0gYikgKyBjO1xuXHRcdH0pO1xuXHR9LFxuXHRmb3JtYXRzOiB7XG5cdFx0Y29sb3I6IHtcblx0XHRcdGlkOiBcInJlYzIxMDAtaGxnXCJcblx0XHR9LFxuXHR9LFxufSk7XG5cbmNvbnN0IENBVHMgPSB7fTtcblxuaG9va3MuYWRkKFwiY2hyb21hdGljLWFkYXB0YXRpb24tc3RhcnRcIiwgZW52ID0+IHtcblx0aWYgKGVudi5vcHRpb25zLm1ldGhvZCkge1xuXHRcdGVudi5NID0gYWRhcHQoZW52LlcxLCBlbnYuVzIsIGVudi5vcHRpb25zLm1ldGhvZCk7XG5cdH1cbn0pO1xuXG5ob29rcy5hZGQoXCJjaHJvbWF0aWMtYWRhcHRhdGlvbi1lbmRcIiwgZW52ID0+IHtcblx0aWYgKCFlbnYuTSkge1xuXHRcdGVudi5NID0gYWRhcHQoZW52LlcxLCBlbnYuVzIsIGVudi5vcHRpb25zLm1ldGhvZCk7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBkZWZpbmVDQVQgKHtpZCwgdG9Db25lX00sIGZyb21Db25lX019KSB7XG5cdC8vIFVzZSBpZCwgdG9Db25lX00sIGZyb21Db25lX00gbGlrZSB2YXJpYWJsZXNcblx0Q0FUc1tpZF0gPSBhcmd1bWVudHNbMF07XG59XG5mdW5jdGlvbiBhZGFwdCAoVzEsIFcyLCBpZCA9IFwiQnJhZGZvcmRcIikge1xuXHQvLyBhZGFwdCBmcm9tIGEgc291cmNlIHdoaXRlcG9pbnQgb3IgaWxsdW1pbmFudCBXMVxuXHQvLyB0byBhIGRlc3RpbmF0aW9uIHdoaXRlcG9pbnQgb3IgaWxsdW1pbmFudCBXMixcblx0Ly8gdXNpbmcgdGhlIGdpdmVuIGNocm9tYXRpYyBhZGFwdGF0aW9uIHRyYW5zZm9ybSAoQ0FUKVxuXHQvLyBkZWJ1Z2dlcjtcblx0bGV0IG1ldGhvZCA9IENBVHNbaWRdO1xuXG5cdGxldCBbz4FzLCDOs3MsIM6yc10gPSBtdWx0aXBseU1hdHJpY2VzKG1ldGhvZC50b0NvbmVfTSwgVzEpO1xuXHRsZXQgW8+BZCwgzrNkLCDOsmRdID0gbXVsdGlwbHlNYXRyaWNlcyhtZXRob2QudG9Db25lX00sIFcyKTtcblxuXHQvLyBhbGwgcHJhY3RpY2FsIGlsbHVtaW5hbnRzIGhhdmUgbm9uLXplcm8gWFlaIHNvIG5vIGRpdmlzaW9uIGJ5IHplcm8gY2FuIG9jY3VyIGJlbG93XG5cdGxldCBzY2FsZSA9IFtcblx0XHRbz4FkL8+BcywgICAgMCwgICAgICAwICAgICAgXSxcblx0XHRbMCwgICAgICAgIM6zZC/Os3MsICAwICAgICAgXSxcblx0XHRbMCwgICAgICAgIDAsICAgICAgzrJkL86ycyAgXVxuXHRdO1xuXHQvLyBjb25zb2xlLmxvZyh7c2NhbGV9KTtcblxuXHRsZXQgc2NhbGVkX2NvbmVfTSA9IG11bHRpcGx5TWF0cmljZXMoc2NhbGUsIG1ldGhvZC50b0NvbmVfTSk7XG5cdGxldCBhZGFwdF9NXHQ9IG11bHRpcGx5TWF0cmljZXMobWV0aG9kLmZyb21Db25lX00sIHNjYWxlZF9jb25lX00pO1xuXHQvLyBjb25zb2xlLmxvZyh7c2NhbGVkX2NvbmVfTSwgYWRhcHRfTX0pO1xuXHRyZXR1cm4gYWRhcHRfTTtcbn1cbmRlZmluZUNBVCh7XG5cdGlkOiBcInZvbiBLcmllc1wiLFxuXHR0b0NvbmVfTTogW1xuXHRcdFsgIDAuNDAwMjQwMCwgIDAuNzA3NjAwMCwgLTAuMDgwODEwMCBdLFxuXHRcdFsgLTAuMjI2MzAwMCwgIDEuMTY1MzIwMCwgIDAuMDQ1NzAwMCBdLFxuXHRcdFsgIDAuMDAwMDAwMCwgIDAuMDAwMDAwMCwgIDAuOTE4MjIwMCBdXG5cdF0sXG5cdGZyb21Db25lX006IFtcblx0XHRbICAxLjg1OTkzNjQsIC0xLjEyOTM4MTYsICAwLjIxOTg5NzQgXSxcblx0XHRbICAwLjM2MTE5MTQsICAwLjYzODgxMjUsIC0wLjAwMDAwNjQgXSxcblx0XHRbICAwLjAwMDAwMDAsICAwLjAwMDAwMDAsICAxLjA4OTA2MzYgXVxuXHRdXG59KTtcblxuZGVmaW5lQ0FUKHtcblx0aWQ6IFwiQnJhZGZvcmRcIixcblx0Ly8gQ29udmVydCBhbiBhcnJheSBvZiBYWVogdmFsdWVzIGluIHRoZSByYW5nZSAwLjAgLSAxLjBcblx0Ly8gdG8gY29uZSBmdW5kYW1lbnRhbHNcblx0dG9Db25lX006IFtcblx0XHRbICAwLjg5NTEwMDAsICAwLjI2NjQwMDAsIC0wLjE2MTQwMDAgXSxcblx0XHRbIC0wLjc1MDIwMDAsICAxLjcxMzUwMDAsICAwLjAzNjcwMDAgXSxcblx0XHRbICAwLjAzODkwMDAsIC0wLjA2ODUwMDAsICAxLjAyOTYwMDAgXVxuXHRdLFxuXHQvLyBhbmQgYmFja1xuXHRmcm9tQ29uZV9NOiBbXG5cdFx0WyAgMC45ODY5OTI5LCAtMC4xNDcwNTQzLCAgMC4xNTk5NjI3IF0sXG5cdFx0WyAgMC40MzIzMDUzLCAgMC41MTgzNjAzLCAgMC4wNDkyOTEyIF0sXG5cdFx0WyAtMC4wMDg1Mjg3LCAgMC4wNDAwNDI4LCAgMC45Njg0ODY3IF1cblx0XVxufSk7XG5cbmRlZmluZUNBVCh7XG5cdGlkOiBcIkNBVDAyXCIsXG5cdC8vIHdpdGggY29tcGxldGUgY2hyb21hdGljIGFkYXB0YXRpb24gdG8gVzIsIHNvIEQgPSAxLjBcblx0dG9Db25lX006IFtcblx0XHRbICAwLjczMjgwMDAsICAwLjQyOTYwMDAsIC0wLjE2MjQwMDAgXSxcblx0XHRbIC0wLjcwMzYwMDAsICAxLjY5NzUwMDAsICAwLjAwNjEwMDAgXSxcblx0XHRbICAwLjAwMzAwMDAsICAwLjAxMzYwMDAsICAwLjk4MzQwMDAgXVxuXHRdLFxuXHRmcm9tQ29uZV9NOiBbXG5cdFx0WyAgMS4wOTYxMjM4LCAtMC4yNzg4NjkwLCAgMC4xODI3NDUyIF0sXG5cdFx0WyAgMC40NTQzNjkwLCAgMC40NzM1MzMyLCAgMC4wNzIwOTc4IF0sXG5cdFx0WyAtMC4wMDk2Mjc2LCAtMC4wMDU2OTgwLCAgMS4wMTUzMjU2IF1cblx0XVxufSk7XG5cbmRlZmluZUNBVCh7XG5cdGlkOiBcIkNBVDE2XCIsXG5cdHRvQ29uZV9NOiBbXG5cdFx0WyAgMC40MDEyODgsICAwLjY1MDE3MywgLTAuMDUxNDYxIF0sXG5cdFx0WyAtMC4yNTAyNjgsICAxLjIwNDQxNCwgIDAuMDQ1ODU0IF0sXG5cdFx0WyAtMC4wMDIwNzksICAwLjA0ODk1MiwgIDAuOTUzMTI3IF1cblx0XSxcblx0Ly8gdGhlIGV4dHJhIHByZWNpc2lvbiBpcyBuZWVkZWQgdG8gYXZvaWQgcm91bmR0cmlwcGluZyBlcnJvcnNcblx0ZnJvbUNvbmVfTTogW1xuXHRcdFsgIDEuODYyMDY3ODU1MDg3MjMzZSswLCAtMS4wMTEyNTQ2MzA1MzE2ODVlKzAsICAgMS40OTE4Njc3NTQ0NDQ1MThlLTEgXSxcblx0XHRbICAzLjg3NTI2NTQzMjM2MTM3MmUtMSwgIDYuMjE0NDc0NDE5MzE0NzUzZS0xLCAgLTguOTczOTg1MTY3NjEyNTE4ZS0zIF0sXG5cdFx0WyAtMS41ODQxNDk4ODQ5MzMzODZlLTIsIC0zLjQxMjI5MzgwMjg1MTU1N2UtMiwgICAxLjA0OTk2NDQzNjg3Nzg1MGUrMCBdXG5cdF1cbn0pO1xuXG5PYmplY3QuYXNzaWduKFdISVRFUywge1xuXHQvLyB3aGl0ZXBvaW50IHZhbHVlcyBmcm9tIEFTVE0gRTMwOC0wMSB3aXRoIDEwbm0gc3BhY2luZywgMTkzMSAyIGRlZ3JlZSBvYnNlcnZlclxuXHQvLyBhbGwgbm9ybWFsaXplZCB0byBZIChsdW1pbmFuY2UpID0gMS4wMDAwMFxuXHQvLyBJbGx1bWluYW50IEEgaXMgYSB0dW5nc3RlbiBlbGVjdHJpYyBsaWdodCwgZ2l2aW5nIGEgdmVyeSB3YXJtLCBvcmFuZ2UgbGlnaHQuXG5cdEE6ICBbMS4wOTg1MCwgMS4wMDAwMCwgMC4zNTU4NV0sXG5cblx0Ly8gSWxsdW1pbmFudCBDIHdhcyBhbiBlYXJseSBhcHByb3hpbWF0aW9uIHRvIGRheWxpZ2h0OiBpbGx1bWluYW50IEEgd2l0aCBhIGJsdWUgZmlsdGVyLlxuXHRDOiAgIFswLjk4MDc0LCAxLjAwMDAwMCwgMS4xODIzMl0sXG5cblx0Ly8gVGhlIGRheWxpZ2h0IHNlcmllcyBvZiBpbGx1bWluYW50cyBzaW11bGF0ZSBuYXR1cmFsIGRheWxpZ2h0LlxuXHQvLyBUaGUgY29sb3IgdGVtcGVyYXR1cmUgKGluIGRlZ3JlZXMgS2VsdmluLzEwMCkgcmFuZ2VzIGZyb21cblx0Ly8gY29vbCwgb3ZlcmNhc3QgZGF5bGlnaHQgKEQ1MCkgdG8gYnJpZ2h0LCBkaXJlY3Qgc3VubGlnaHQgKEQ2NSkuXG5cdEQ1NTogWzAuOTU2ODIsIDEuMDAwMDAsIDAuOTIxNDldLFxuXHRENzU6IFswLjk0OTcyLCAxLjAwMDAwLCAxLjIyNjM4XSxcblxuXHQvLyBFcXVhbC1lbmVyZ3kgaWxsdW1pbmFudCwgdXNlZCBpbiB0d28tc3RhZ2UgQ0FUMTZcblx0RTogICBbMS4wMDAwMCwgMS4wMDAwMCwgMS4wMDAwMF0sXG5cblx0Ly8gVGhlIEYgc2VyaWVzIG9mIGlsbHVtaW5hbnRzIHJlcHJlc2VudCBmbHVvcmVzY2VudCBsaWdodHNcblx0RjI6ICBbMC45OTE4NiwgMS4wMDAwMCwgMC42NzM5M10sXG5cdEY3OiAgWzAuOTUwNDEsIDEuMDAwMDAsIDEuMDg3NDddLFxuXHRGMTE6IFsxLjAwOTYyLCAxLjAwMDAwLCAwLjY0MzUwXSxcbn0pO1xuXG4vLyBUaGUgQUNFUyB3aGl0ZXBvaW50XG4vLyBzZWUgVEItMjAxOC0wMDEgRGVyaXZhdGlvbiBvZiB0aGUgQUNFUyBXaGl0ZSBQb2ludCBDSUUgQ2hyb21hdGljaXR5IENvb3JkaW5hdGVzXG4vLyBhbHNvIGh0dHBzOi8vZ2l0aHViLmNvbS9hbXBhcy9hY2VzLWRldi9ibG9iL21hc3Rlci9kb2N1bWVudHMvcHl0aG9uL1RCLTIwMTgtMDAxL2FjZXNfd3AucHlcbi8vIFNpbWlsYXIgdG8gRDYwXG5XSElURVMuQUNFUyA9IFswLjMyMTY4LzAuMzM3NjcsIDEuMDAwMDAsICgxLjAwMDAwIC0gMC4zMjE2OCAtIDAuMzM3NjcpLzAuMzM3NjddO1xuXG4vLyBjb252ZXJ0IGFuIGFycmF5IG9mIGxpbmVhci1saWdodCBBQ0VTY2MgdmFsdWVzIHRvIENJRSBYWVpcbmNvbnN0IHRvWFlaX00gPSBbXG5cdFsgIDAuNjYyNDU0MTgxMTA4NTA1MywgICAwLjEzNDAwNDIwNjQ1NjQzMzEzLCAgMC4xNTYxODc2ODcwMDQ5MDc4ICBdLFxuXHRbICAwLjI3MjIyODcxNjc4MDkxNDU0LCAgMC42NzQwODE3NjU4MTExNDg0LCAgIDAuMDUzNjg5NTE3NDA3OTM3MDUgXSxcblx0WyAtMC4wMDU1NzQ2NDk0OTAzOTQxMDgsIDAuMDA0MDYwNzMzNTI4OTgyODI2LCAxLjAxMDMzOTEwMDMxMjk5NzEgIF1cbl07XG5jb25zdCBmcm9tWFlaX00gPSBbXG5cdFsgIDEuNjQxMDIzMzc5Njk0MzI1NywgICAtMC4zMjQ4MDMyOTQxODQ3OSwgICAgLTAuMjM2NDI0Njk1MjM3NjEyMjUgIF0sXG5cdFsgLTAuNjYzNjYyODU4NzIyOTgyOSwgICAgMS42MTUzMzE1OTE2NTczMzc5LCAgIDAuMDE2NzU2MzQ3Njg1NTMwMTM3IF0sXG5cdFsgIDAuMDExNzIxODk0MzI4Mzc1Mzc2LCAtMC4wMDgyODQ0NDE5OTYyMzc0MDksIDAuOTg4Mzk0ODU4NTM5MDIxNSAgIF1cbl07XG5cbnZhciBBQ0VTY2cgPSBuZXcgUkdCQ29sb3JTcGFjZSh7XG5cdGlkOiBcImFjZXNjZ1wiLFxuXHRuYW1lOiBcIkFDRVNjZ1wiLFxuXG5cdC8vIEFDRVNjZyDigJMgQSBzY2VuZS1yZWZlcnJlZCwgbGluZWFyLWxpZ2h0IGVuY29kaW5nIG9mIEFDRVMgRGF0YVxuXHQvLyBodHRwczovL2RvY3MuYWNlc2NlbnRyYWwuY29tL3NwZWNpZmljYXRpb25zL2FjZXNjZy9cblx0Ly8gdXNlcyB0aGUgQVAxIHByaW1hcmllcywgc2VlIHNlY3Rpb24gNC4zLjEgQ29sb3IgcHJpbWFyaWVzXG5cdGNvb3Jkczoge1xuXHRcdHI6IHtcblx0XHRcdHJhbmdlOiBbMCwgNjU1MDRdLFxuXHRcdFx0bmFtZTogXCJSZWRcIlxuXHRcdH0sXG5cdFx0Zzoge1xuXHRcdFx0cmFuZ2U6IFswLCA2NTUwNF0sXG5cdFx0XHRuYW1lOiBcIkdyZWVuXCJcblx0XHR9LFxuXHRcdGI6IHtcblx0XHRcdHJhbmdlOiBbMCwgNjU1MDRdLFxuXHRcdFx0bmFtZTogXCJCbHVlXCJcblx0XHR9XG5cdH0sXG5cblx0cmVmZXJyZWQ6IFwic2NlbmVcIixcblxuXHR3aGl0ZTogV0hJVEVTLkFDRVMsXG5cblx0dG9YWVpfTSxcblx0ZnJvbVhZWl9NLFxuXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge31cblx0fSxcbn0pO1xuXG4vLyBleHBvcnQgZGVmYXVsdCBDb2xvcjtcblxuY29uc3QgzrUgPSAyICoqIC0xNjtcblxuLy8gdGhlIHNtYWxsZXN0IHZhbHVlIHdoaWNoLCBpbiB0aGUgMzJiaXQgSUVFRSA3NTQgZmxvYXQgZW5jb2RpbmcsXG4vLyBkZWNvZGVzIGFzIGEgbm9uLW5lZ2F0aXZlIHZhbHVlXG5jb25zdCBBQ0VTX21pbl9ub256ZXJvID0gLTAuMzU4Mjg2ODM7XG5cbi8vIGJyaWdodGVzdCBlbmNvZGVkIHZhbHVlLCBkZWNvZGVzIHRvIDY1NTA0XG5jb25zdCBBQ0VTX2NjX21heCA9IChNYXRoLmxvZzIoNjU1MDQpICsgOS43MikgLyAxNy41MjsgLy8gMS40NjhcblxudmFyIGFjZXNjYyA9IG5ldyBSR0JDb2xvclNwYWNlKHtcblx0aWQ6IFwiYWNlc2NjXCIsXG5cdG5hbWU6IFwiQUNFU2NjXCIsXG5cdC8vIHNlZSBTLTIwMTQtMDAzIEFDRVNjYyDigJMgQSBMb2dhcml0aG1pYyBFbmNvZGluZyBvZiBBQ0VTIERhdGFcblx0Ly8gaHR0cHM6Ly9kb2NzLmFjZXNjZW50cmFsLmNvbS9zcGVjaWZpY2F0aW9ucy9hY2VzY2MvXG5cdC8vIHVzZXMgdGhlIEFQMSBwcmltYXJpZXMsIHNlZSBzZWN0aW9uIDQuMy4xIENvbG9yIHByaW1hcmllc1xuXG5cdC8vIEFwcGVuZGl4IEE6IFwiVmVyeSBzbWFsbCBBQ0VTIHNjZW5lIHJlZmVycmVkIHZhbHVlcyBiZWxvdyA3IDEvNCBzdG9wc1xuXHQvLyBiZWxvdyAxOCUgbWlkZGxlIGdyYXkgYXJlIGVuY29kZWQgYXMgbmVnYXRpdmUgQUNFU2NjIHZhbHVlcy5cblx0Ly8gVGhlc2UgdmFsdWVzIHNob3VsZCBiZSBwcmVzZXJ2ZWQgcGVyIHRoZSBlbmNvZGluZyBpbiBTZWN0aW9uIDQuNFxuXHQvLyBzbyB0aGF0IGFsbCBwb3NpdGl2ZSBBQ0VTIHZhbHVlcyBhcmUgbWFpbnRhaW5lZC5cIlxuXHRjb29yZHM6IHtcblx0XHRyOiB7XG5cdFx0XHRyYW5nZTogW0FDRVNfbWluX25vbnplcm8sIEFDRVNfY2NfbWF4XSxcblx0XHRcdG5hbWU6IFwiUmVkXCJcblx0XHR9LFxuXHRcdGc6IHtcblx0XHRcdHJhbmdlOiBbQUNFU19taW5fbm9uemVybywgQUNFU19jY19tYXhdLFxuXHRcdFx0bmFtZTogXCJHcmVlblwiXG5cdFx0fSxcblx0XHRiOiB7XG5cdFx0XHRyYW5nZTogW0FDRVNfbWluX25vbnplcm8sIEFDRVNfY2NfbWF4XSxcblx0XHRcdG5hbWU6IFwiQmx1ZVwiXG5cdFx0fVxuXHR9LFxuXHRyZWZlcnJlZDogXCJzY2VuZVwiLFxuXG5cdGJhc2U6IEFDRVNjZyxcblx0Ly8gZnJvbSBzZWN0aW9uIDQuNC4yIERlY29kaW5nIEZ1bmN0aW9uXG5cdHRvQmFzZSAoUkdCKSB7XG5cdFx0Y29uc3QgbG93ID0gKDkuNzIgLSAxNSkgLyAxNy41MjsgLy8gLTAuMzAxNFxuXG5cdFx0cmV0dXJuIFJHQi5tYXAoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0aWYgKHZhbCA8PSBsb3cpIHtcblx0XHRcdFx0cmV0dXJuICgyICoqICgodmFsICogMTcuNTIpIC0gOS43MikgLSDOtSkgKiAyOyAvLyB2ZXJ5IGxvdyB2YWx1ZXMsIGJlbG93IC0wLjMwMTRcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHZhbCA8IEFDRVNfY2NfbWF4KSB7XG5cdFx0XHRcdHJldHVybiAyICoqICgodmFsICogMTcuNTIpIC0gOS43Mik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgLy8gdmFsID49IEFDRVNfY2NfbWF4XG5cdFx0XHRcdHJldHVybiA2NTUwNDtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvLyBOb24tbGluZWFyIGVuY29kaW5nIGZ1bmN0aW9uIGZyb20gUy0yMDE0LTAwMywgc2VjdGlvbiA0LjQuMSBFbmNvZGluZyBGdW5jdGlvblxuXHRmcm9tQmFzZSAoUkdCKSB7XG5cdFx0cmV0dXJuIFJHQi5tYXAoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0aWYgKHZhbCA8PSAwKSB7XG5cdFx0XHRcdHJldHVybiAoTWF0aC5sb2cyKM61KSArIDkuNzIpIC8gMTcuNTI7IC8vIC0wLjM1ODRcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHZhbCA8IM61KSB7XG5cdFx0XHRcdHJldHVybiAgKE1hdGgubG9nMijOtSArIHZhbCAqIDAuNSkgKyA5LjcyKSAvIDE3LjUyO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIHZhbCA+PSDOtVxuXHRcdFx0XHRyZXR1cm4gIChNYXRoLmxvZzIodmFsKSArIDkuNzIpIC8gMTcuNTI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdC8vIGVuY29kZWQgbWVkaWEgd2hpdGUgKHJnYiAxLDEsMSkgPT4gbGluZWFyICBbIDIyMi44NjEsIDIyMi44NjEsIDIyMi44NjEgXVxuXHQvLyBlbmNvZGVkIG1lZGlhIGJsYWNrIChyZ2IgMCwwLDApID0+IGxpbmVhciBbIDAuMDAxMTg1NywgMC4wMDExODU3LCAwLjAwMTE4NTddXG5cdGZvcm1hdHM6IHtcblx0XHRjb2xvcjoge31cblx0fVxufSk7XG5cbnZhciBzcGFjZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0QTk4UkdCOiBhOThyZ2IsXG5cdEE5OFJHQl9MaW5lYXI6IEE5OExpbmVhcixcblx0QUNFU2NjOiBhY2VzY2MsXG5cdEFDRVNjZzogQUNFU2NnLFxuXHRIU0w6IEhTTCxcblx0SFNWOiBIU1YsXG5cdEhXQjogaHdiLFxuXHRJQ1RDUDogaWN0Y3AsXG5cdEp6Q3pIejoganpjemh6LFxuXHRKemF6Yno6IEp6YXpieixcblx0TENIOiBsY2gsXG5cdExhYjogbGFiLFxuXHRMYWJfRDY1OiBsYWJfZDY1LFxuXHRPS0xDSDogb2tsY2gsXG5cdE9LTGFiOiBPS0xhYixcblx0UDM6IFAzLFxuXHRQM19MaW5lYXI6IFAzTGluZWFyLFxuXHRQcm9QaG90bzogcHJvcGhvdG8sXG5cdFByb1Bob3RvX0xpbmVhcjogUHJvUGhvdG9MaW5lYXIsXG5cdFJFQ18yMDIwOiBSRUMyMDIwLFxuXHRSRUNfMjAyMF9MaW5lYXI6IFJFQzIwMjBMaW5lYXIsXG5cdFJFQ18yMTAwX0hMRzogcmVjMjEwMEhsZyxcblx0UkVDXzIxMDBfUFE6IHJlYzIxMDBQcSxcblx0WFlaX0FCU19ENjU6IFhZWl9BYnNfRDY1LFxuXHRYWVpfRDUwOiBYWVpfRDUwLFxuXHRYWVpfRDY1OiBYWVpfRDY1LFxuXHRzUkdCOiBzUkdCLFxuXHRzUkdCX0xpbmVhcjogc1JHQkxpbmVhclxufSk7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgY29sb3JcbiAqL1xuY2xhc3MgQ29sb3Ige1xuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDb2xvci5cblx0ICogU2lnbmF0dXJlczpcblx0ICogLSBgbmV3IENvbG9yKHN0cmluZ1RvUGFyc2UpYFxuXHQgKiAtIGBuZXcgQ29sb3Iob3RoZXJDb2xvcilgXG5cdCAqIC0gYG5ldyBDb2xvcih7c3BhY2UsIGNvb3JkcywgYWxwaGF9KWBcblx0ICogLSBgbmV3IENvbG9yKHNwYWNlLCBjb29yZHMsIGFscGhhKWBcblx0ICogLSBgbmV3IENvbG9yKHNwYWNlSWQsIGNvb3JkcywgYWxwaGEpYFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcblx0XHRsZXQgY29sb3I7XG5cblx0XHRpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGNvbG9yID0gZ2V0Q29sb3IoYXJnc1swXSk7XG5cdFx0fVxuXG5cdFx0bGV0IHNwYWNlLCBjb29yZHMsIGFscGhhO1xuXG5cdFx0aWYgKGNvbG9yKSB7XG5cdFx0XHRzcGFjZSA9IGNvbG9yLnNwYWNlIHx8IGNvbG9yLnNwYWNlSWQ7XG5cdFx0XHRjb29yZHMgPSBjb2xvci5jb29yZHM7XG5cdFx0XHRhbHBoYSA9IGNvbG9yLmFscGhhO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGRlZmF1bHQgc2lnbmF0dXJlIG5ldyBDb2xvcihDb2xvclNwYWNlLCBhcnJheSBbLCBhbHBoYV0pXG5cdFx0XHRbc3BhY2UsIGNvb3JkcywgYWxwaGFdID0gYXJncztcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzcGFjZVwiLCB7XG5cdFx0XHR2YWx1ZTogQ29sb3JTcGFjZS5nZXQoc3BhY2UpLFxuXHRcdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSwgLy8gc2VlIG5vdGUgaW4gaHR0cHM6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy84LjAvI3NlYy1wcm94eS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHMtZ2V0LXAtcmVjZWl2ZXJcblx0XHR9KTtcblx0XHR0aGlzLmNvb3JkcyA9IGNvb3Jkcz8gY29vcmRzLnNsaWNlKCkgOiBbMCwgMCwgMF07XG5cdFx0dGhpcy5hbHBoYSA9IGFscGhhIDwgMT8gYWxwaGEgOiAxOyAvLyB0aGlzIGFsc28gZGVhbHMgd2l0aCBOYU4gZXRjXG5cblx0XHQvLyBDb252ZXJ0IFwiTmFOXCIgdG8gTmFOXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvb3Jkcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuY29vcmRzW2ldID09PSBcIk5hTlwiKSB7XG5cdFx0XHRcdHRoaXMuY29vcmRzW2ldID0gTmFOO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERlZmluZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciBlYWNoIGNvb3JkaW5hdGVcblx0XHRmb3IgKGxldCBpZCBpbiB0aGlzLnNwYWNlLmNvb3Jkcykge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGlkLCB7XG5cdFx0XHRcdGdldDogKCkgPT4gdGhpcy5nZXQoaWQpLFxuXHRcdFx0XHRzZXQ6IHZhbHVlID0+IHRoaXMuc2V0KGlkLCB2YWx1ZSlcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGdldCBzcGFjZUlkICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zcGFjZS5pZDtcblx0fVxuXG5cdGNsb25lICgpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKHRoaXMuc3BhY2UsIHRoaXMuY29vcmRzLCB0aGlzLmFscGhhKTtcblx0fVxuXG5cdHRvSlNPTiAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNwYWNlSWQ6IHRoaXMuc3BhY2VJZCxcblx0XHRcdGNvb3JkczogdGhpcy5jb29yZHMsXG5cdFx0XHRhbHBoYTogdGhpcy5hbHBoYVxuXHRcdH07XG5cdH1cblxuXHRkaXNwbGF5ICguLi5hcmdzKSB7XG5cdFx0bGV0IHJldCA9IGRpc3BsYXkodGhpcywgLi4uYXJncyk7XG5cblx0XHQvLyBDb252ZXJ0IGNvbG9yIG9iamVjdCB0byBDb2xvciBpbnN0YW5jZVxuXHRcdHJldC5jb2xvciA9IG5ldyBDb2xvcihyZXQuY29sb3IpO1xuXG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYSBjb2xvciBmcm9tIHRoZSBhcmd1bWVudCBwYXNzZWRcblx0ICogQmFzaWNhbGx5IGdldHMgdXMgdGhlIHNhbWUgcmVzdWx0IGFzIG5ldyBDb2xvcihjb2xvcikgYnV0IGRvZXNuJ3QgY2xvbmUgYW4gZXhpc3RpbmcgY29sb3Igb2JqZWN0XG5cdCAqL1xuXHRzdGF0aWMgZ2V0IChjb2xvciwgLi4uYXJncykge1xuXHRcdGlmIChjb2xvciBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0XHRyZXR1cm4gY29sb3I7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb2xvcihjb2xvciwgLi4uYXJncyk7XG5cdH1cblxuXHRzdGF0aWMgZGVmaW5lRnVuY3Rpb24gKG5hbWUsIGNvZGUsIG8gPSBjb2RlKSB7XG5cdFx0bGV0IHtpbnN0YW5jZSA9IHRydWUsIHJldHVybnN9ID0gbztcblxuXHRcdGxldCBmdW5jID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRcdGxldCByZXQgPSBjb2RlKC4uLmFyZ3MpO1xuXG5cdFx0XHRpZiAocmV0dXJucyA9PT0gXCJjb2xvclwiKSB7XG5cdFx0XHRcdHJldCA9IENvbG9yLmdldChyZXQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAocmV0dXJucyA9PT0gXCJmdW5jdGlvbjxjb2xvcj5cIikge1xuXHRcdFx0XHRsZXQgZiA9IHJldDtcblx0XHRcdFx0cmV0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRcdFx0XHRsZXQgcmV0ID0gZiguLi5hcmdzKTtcblx0XHRcdFx0XHRyZXR1cm4gQ29sb3IuZ2V0KHJldCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIENvcHkgYW55IGZ1bmN0aW9uIG1ldGFkYXRhXG5cdFx0XHRcdE9iamVjdC5hc3NpZ24ocmV0LCBmKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHJldHVybnMgPT09IFwiYXJyYXk8Y29sb3I+XCIpIHtcblx0XHRcdFx0cmV0ID0gcmV0Lm1hcChjID0+IENvbG9yLmdldChjKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fTtcblxuXHRcdGlmICghKG5hbWUgaW4gQ29sb3IpKSB7XG5cdFx0XHRDb2xvcltuYW1lXSA9IGZ1bmM7XG5cdFx0fVxuXG5cdFx0aWYgKGluc3RhbmNlKSB7XG5cdFx0XHRDb2xvci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdFx0XHRyZXR1cm4gZnVuYyh0aGlzLCAuLi5hcmdzKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGRlZmluZUZ1bmN0aW9ucyAobykge1xuXHRcdGZvciAobGV0IG5hbWUgaW4gbykge1xuXHRcdFx0Q29sb3IuZGVmaW5lRnVuY3Rpb24obmFtZSwgb1tuYW1lXSwgb1tuYW1lXSk7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGV4dGVuZCAoZXhwb3J0cykge1xuXHRcdGlmIChleHBvcnRzLnJlZ2lzdGVyKSB7XG5cdFx0XHRleHBvcnRzLnJlZ2lzdGVyKENvbG9yKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBObyByZWdpc3RlciBtZXRob2QsIGp1c3QgYWRkIHRoZSBtb2R1bGUncyBmdW5jdGlvbnNcblx0XHRcdGZvciAobGV0IG5hbWUgaW4gZXhwb3J0cykge1xuXHRcdFx0XHRDb2xvci5kZWZpbmVGdW5jdGlvbihuYW1lLCBleHBvcnRzW25hbWVdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbkNvbG9yLmRlZmluZUZ1bmN0aW9ucyh7XG5cdGdldCxcblx0Z2V0QWxsLFxuXHRzZXQsXG5cdHNldEFsbCxcblx0dG8sXG5cdGVxdWFscyxcblx0aW5HYW11dCxcblx0dG9HYW11dCxcblx0ZGlzdGFuY2UsXG5cdHRvU3RyaW5nOiBzZXJpYWxpemUsXG59KTtcblxuT2JqZWN0LmFzc2lnbihDb2xvciwge1xuXHR1dGlsLFxuXHRob29rcyxcblx0V0hJVEVTLFxuXHRTcGFjZTogQ29sb3JTcGFjZSxcblx0c3BhY2VzOiBDb2xvclNwYWNlLnJlZ2lzdHJ5LFxuXHRwYXJzZSxcblxuXHQvLyBHbG9iYWwgZGVmYXVsdHMgb25lIG1heSB3YW50IHRvIGNvbmZpZ3VyZVxuXHRkZWZhdWx0c1xufSk7XG5cbmZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhzcGFjZXMpKSB7XG5cdENvbG9yU3BhY2UucmVnaXN0ZXIoc3BhY2VzW2tleV0pO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGRlZmluZXMgZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgY29sb3Jbc3BhY2VJZF1cbiAqIGUuZy4gY29sb3IubGNoIG9uICphbnkqIGNvbG9yIGdpdmVzIHVzIHRoZSBsY2ggY29vcmRzXG4gKi9cblxuLy8gQWRkIHNwYWNlIGFjY2Vzc29ycyB0byBleGlzdGluZyBjb2xvciBzcGFjZXNcbmZvciAobGV0IGlkIGluIENvbG9yU3BhY2UucmVnaXN0cnkpIHtcblx0YWRkU3BhY2VBY2Nlc3NvcnMoaWQsIENvbG9yU3BhY2UucmVnaXN0cnlbaWRdKTtcbn1cblxuLy8gQWRkIHNwYWNlIGFjY2Vzc29ycyB0byBjb2xvciBzcGFjZXMgbm90IHlldCBjcmVhdGVkXG5ob29rcy5hZGQoXCJjb2xvcnNwYWNlLWluaXQtZW5kXCIsIHNwYWNlID0+IHtcblx0YWRkU3BhY2VBY2Nlc3NvcnMoc3BhY2UuaWQsIHNwYWNlKTtcblx0c3BhY2UuYWxpYXNlcz8uZm9yRWFjaChhbGlhcyA9PiB7XG5cdFx0YWRkU3BhY2VBY2Nlc3NvcnMoYWxpYXMsIHNwYWNlKTtcblx0fSk7XG59KTtcblxuZnVuY3Rpb24gYWRkU3BhY2VBY2Nlc3NvcnMgKGlkLCBzcGFjZSkge1xuXHQvLyBDb29yZGluYXRlcyBjYW4gYmUgbG9va2VkIHVwIGJ5IGJvdGggaWQgYW5kIG5hbWVcblx0T2JqZWN0LmtleXMoc3BhY2UuY29vcmRzKTtcblx0T2JqZWN0LnZhbHVlcyhzcGFjZS5jb29yZHMpLm1hcChjID0+IGMubmFtZSk7XG5cblxuXHRsZXQgcHJvcElkID0gaWQucmVwbGFjZSgvLS9nLCBcIl9cIik7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgcHJvcElkLCB7XG5cdFx0Ly8gQ29udmVydCBjb29yZHMgdG8gY29vcmRzIGluIGFub3RoZXIgY29sb3JzcGFjZSBhbmQgcmV0dXJuIHRoZW1cblx0XHQvLyBTb3VyY2UgY29sb3JzcGFjZTogdGhpcy5zcGFjZUlkXG5cdFx0Ly8gVGFyZ2V0IGNvbG9yc3BhY2U6IGlkXG5cdFx0Z2V0ICgpIHtcblx0XHRcdGxldCByZXQgPSB0aGlzLmdldEFsbChpZCk7XG5cblx0XHRcdGlmICh0eXBlb2YgUHJveHkgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0Ly8gSWYgcHJveGllcyBhcmUgbm90IHN1cHBvcnRlZCwganVzdCByZXR1cm4gYSBzdGF0aWMgYXJyYXlcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRW5hYmxlIGNvbG9yLnNwYWNlSWQuY29vcmROYW1lIHN5bnRheFxuXHRcdFx0cmV0dXJuIG5ldyBQcm94eShyZXQsIHtcblx0XHRcdFx0aGFzOiAob2JqLCBwcm9wZXJ0eSkgPT4ge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRDb2xvclNwYWNlLnJlc29sdmVDb29yZChbc3BhY2UsIHByb3BlcnR5XSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHt9XG5cblx0XHRcdFx0XHRyZXR1cm4gUmVmbGVjdC5oYXMob2JqLCBwcm9wZXJ0eSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldDogKG9iaiwgcHJvcGVydHksIHJlY2VpdmVyKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHByb3BlcnR5ICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gXCJzeW1ib2xcIiAmJiAhKHByb3BlcnR5IGluIG9iaikpIHtcblx0XHRcdFx0XHRcdGxldCB7aW5kZXh9ID0gQ29sb3JTcGFjZS5yZXNvbHZlQ29vcmQoW3NwYWNlLCBwcm9wZXJ0eV0pO1xuXG5cdFx0XHRcdFx0XHRpZiAoaW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JqW2luZGV4XTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gUmVmbGVjdC5nZXQob2JqLCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IChvYmosIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcblx0XHRcdFx0XHRpZiAocHJvcGVydHkgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSBcInN5bWJvbFwiICYmICEocHJvcGVydHkgaW4gb2JqKSB8fCBwcm9wZXJ0eSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRsZXQge2luZGV4fSA9IENvbG9yU3BhY2UucmVzb2x2ZUNvb3JkKFtzcGFjZSwgcHJvcGVydHldKTtcblxuXHRcdFx0XHRcdFx0aWYgKGluZGV4ID49IDApIHtcblx0XHRcdFx0XHRcdFx0b2JqW2luZGV4XSA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFVwZGF0ZSBjb2xvci5jb29yZHNcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRBbGwoaWQsIG9iaik7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3Quc2V0KG9iaiwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcik7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdC8vIENvbnZlcnQgY29vcmRzIGluIGFub3RoZXIgY29sb3JzcGFjZSB0byBpbnRlcm5hbCBjb29yZHMgYW5kIHNldCB0aGVtXG5cdFx0Ly8gVGFyZ2V0IGNvbG9yc3BhY2U6IHRoaXMuc3BhY2VJZFxuXHRcdC8vIFNvdXJjZSBjb2xvcnNwYWNlOiBpZFxuXHRcdHNldCAoY29vcmRzKSB7XG5cdFx0XHR0aGlzLnNldEFsbChpZCwgY29vcmRzKTtcblx0XHR9LFxuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRlbnVtZXJhYmxlOiB0cnVlXG5cdH0pO1xufVxuXG4vLyBJbXBvcnQgYWxsIG1vZHVsZXMgb2YgQ29sb3IuanNcblxuQ29sb3IuZXh0ZW5kKGRlbHRhRU1ldGhvZHMpO1xuQ29sb3IuZXh0ZW5kKHtkZWx0YUV9KTtcbk9iamVjdC5hc3NpZ24oQ29sb3IsIHtkZWx0YUVNZXRob2RzfSk7XG5Db2xvci5leHRlbmQodmFyaWF0aW9ucyk7XG5Db2xvci5leHRlbmQoe2NvbnRyYXN0fSk7XG5Db2xvci5leHRlbmQoY2hyb21hdGljaXR5KTtcbkNvbG9yLmV4dGVuZChsdW1pbmFuY2UpO1xuQ29sb3IuZXh0ZW5kKGludGVycG9sYXRpb24pO1xuQ29sb3IuZXh0ZW5kKGNvbnRyYXN0TWV0aG9kcyk7XG5cbmV4cG9ydCB7IENvbG9yIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbIm11bHRpcGx5TWF0cmljZXMiLCJBIiwiQiIsIm0iLCJsZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJ4IiwicCIsIkJfY29scyIsIl8iLCJpIiwicHJvZHVjdCIsInJvdyIsImNvbCIsInJldCIsImMiLCJpc1N0cmluZyIsInN0ciIsInR5cGUiLCJvIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwibWF0Y2giLCJ0b0xvd2VyQ2FzZSIsInRvUHJlY2lzaW9uIiwibiIsInByZWNpc2lvbiIsImludGVnZXJMZW5ndGgiLCJNYXRoIiwiZmxvb3IiLCJ0b0ZpeGVkIiwicDEwIiwicm91bmQiLCJwYXJzZUZ1bmN0aW9uIiwidHJpbSIsImlzRnVuY3Rpb25SZWdleCIsImlzTnVtYmVyUmVnZXgiLCJwYXJ0cyIsImFyZ3MiLCJyZXBsYWNlIiwiJDAiLCJhcmciLCJ0ZXN0IiwiTnVtYmVyIiwic2xpY2UiLCJ1bml0Iiwic3RhcnRzV2l0aCIsImFscGhhIiwicHVzaCIsIm5hbWUiLCJyYXdOYW1lIiwicmF3QXJncyIsImxhc3QiLCJhcnIiLCJpbnRlcnBvbGF0ZSIsInN0YXJ0IiwiZW5kIiwiaXNOYU4iLCJpbnRlcnBvbGF0ZUludiIsInZhbHVlIiwibWFwUmFuZ2UiLCJmcm9tIiwidG8iLCJwYXJzZUNvb3JkR3JhbW1hciIsImNvb3JkR3JhbW1hcnMiLCJjb29yZEdyYW1tYXIiLCJzcGxpdCIsInJhbmdlIiwiU3RyaW5nIiwidXRpbCIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsIkhvb2tzIiwiYWRkIiwiY2FsbGJhY2siLCJmaXJzdCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJydW4iLCJlbnYiLCJjb250ZXh0IiwiaG9va3MiLCJkZWZhdWx0cyIsImdhbXV0X21hcHBpbmciLCJkZWx0YUUiLCJXSElURVMiLCJENTAiLCJENjUiLCJnZXRXaGl0ZSIsImFkYXB0JDEiLCJXMSIsIlcyIiwiWFlaIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsIk0iLCLOtSQ0IiwiQ29sb3JTcGFjZSIsImNvbnN0cnVjdG9yIiwiaWQiLCJiYXNlIiwiZ2V0IiwiYWxpYXNlcyIsImZyb21CYXNlIiwidG9CYXNlIiwiY29vcmRzIiwid2hpdGUiLCJmb3JtYXRzIiwiZm9ybWF0IiwiY3NzSWQiLCJmdW5jdGlvbnMiLCJjb2xvciIsImRlZmluZVByb3BlcnR5IiwicmVmZXJyZWQiLCJnZXRQYXRoIiwicmV2ZXJzZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImluR2FtdXQiLCJlcHNpbG9uIiwiaXNQb2xhciIsImNvb3JkTWV0YSIsInZhbHVlcyIsImV2ZXJ5IiwibWV0YSIsIm1pbiIsIm1heCIsInVuZGVmaW5lZCIsImdldEZvcm1hdCIsInByb2Nlc3NGb3JtYXQiLCJlcXVhbHMiLCJzcGFjZSIsIm15UGF0aCIsInBhdGgiLCJvdGhlclBhdGgiLCJjb25uZWN0aW9uU3BhY2UiLCJjb25uZWN0aW9uU3BhY2VJbmRleCIsIkVycm9yIiwiZ2V0TWluQ29vcmRzIiwicmVmUmFuZ2UiLCJyZWdpc3RyeSIsImFsbCIsIlNldCIsInJlZ2lzdGVyIiwiYWxpYXMiLCJhbHRlcm5hdGl2ZXMiLCJhcmdUeXBlIiwicmVzb2x2ZUNvb3JkIiwicmVmIiwid29ya2luZ1NwYWNlIiwiY29vcmRUeXBlIiwiY29vcmQiLCJpbmNsdWRlcyIsImNvb3JkSWQiLCJlbnRyaWVzIiwiaW5kZXgiLCJub3JtYWxpemVkQ29vcmQiLCJrZXlzIiwiam9pbiIsIkRFRkFVTFRfRk9STUFUIiwicyIsImNvb3JkRm9ybWF0cyIsIm91dHB1dFR5cGUiLCJmcm9tUmFuZ2UiLCJ0b1JhbmdlIiwic3VmZml4Iiwic2VyaWFsaXplQ29vcmRzIiwiWFlaX0Q2NSIsInkiLCJ6IiwiaWRzIiwiUkdCQ29sb3JTcGFjZSIsInIiLCJnIiwiYiIsInRvWFlaX00iLCJmcm9tWFlaX00iLCJyZ2IiLCJ4eXoiLCJwYXJzZSIsInBhcnNlZCIsInNoaWZ0IiwiaW5kZXhPZiIsInBvcCIsImNvbG9yU3BlYyIsImZvcm1hdElkIiwic3BhY2VJZCIsImRpZFlvdU1lYW4iLCJsYXN0QWxwaGEiLCJ0eXBlcyIsInByb3ZpZGVkVHlwZSIsImZpbmQiLCJjb29yZE5hbWUiLCJhc3NpZ24iLCJnZXRDb2xvciIsImdldEFsbCIsInByb3AiLCJzZXRBbGwiLCJzZXQiLCJvYmplY3QiLCJYWVpfRDUwIiwizrUkMyIsIs61MyQxIiwizrokMSIsIndoaXRlJDEiLCJsYWIiLCJsIiwiYSIsImYiLCJjYnJ0IiwiTGFiIiwicG93IiwiY29uc3RyYWluIiwiYW5nbGUiLCJhZGp1c3QiLCJhcmMiLCJhbmdsZXMiLCJhMSIsImEyIiwiYW5nbGVEaWZmIiwibGNoIiwiaCIsIkwiLCJodWUiLCLOtSIsImFicyIsIk5hTiIsImF0YW4yIiwiUEkiLCJzcXJ0IiwiTENIIiwiTGlnaHRuZXNzIiwiQ2hyb21hIiwiSHVlIiwiY29zIiwic2luIiwiR2ZhY3RvciIsIs+AJDEiLCJyMmQiLCJkMnIkMSIsImRlbHRhRTIwMDAiLCJzYW1wbGUiLCJrTCIsImtDIiwia0giLCJMMSIsImIxIiwiQzEiLCJMMiIsImIyIiwiQzIiLCJDYmFyIiwiQzciLCJHIiwiYWRhc2gxIiwiYWRhc2gyIiwiQ2Rhc2gxIiwiQ2Rhc2gyIiwiaDEiLCJoMiIsIs6UTCIsIs6UQyIsImhkaWZmIiwiaHN1bSIsImhhYnMiLCLOlGgiLCJjb25zb2xlIiwibG9nIiwizpRIIiwiTGRhc2giLCJDZGFzaCIsIkNkYXNoNyIsImhkYXNoIiwibHNxIiwiU0wiLCJTQyIsIlQiLCJTSCIsIs6UzrgiLCJleHAiLCJSQyIsIlJUIiwiZEUiLCLOtSQyIiwiY2xvbmUiLCJ0b0dhbXV0IiwibWV0aG9kIiwic3BhY2VDb2xvciIsImNsaXBwZWQiLCJtYXBTcGFjZSIsIm1hcHBlZENvbG9yIiwiYm91bmRzIiwibG93IiwiaGlnaCIsInJldHVybnMiLCJzZXJpYWxpemUiLCJpbkdhbXV0JDEiLCJjdXN0b21PcHRpb25zIiwidW5zaGlmdCIsInN0ckFscGhhIiwibm9BbHBoYSIsImNvbW1hcyIsInRvWFlaX00kNSIsImZyb21YWVpfTSQ1IiwiUkVDMjAyMExpbmVhciIsIs6xIiwizrIiLCJSRUMyMDIwIiwiUkdCIiwidmFsIiwidG9YWVpfTSQ0IiwiZnJvbVhZWl9NJDQiLCJQM0xpbmVhciIsInRvWFlaX00kMyIsImZyb21YWVpfTSQzIiwic1JHQkxpbmVhciIsIktFWVdPUkRTIiwiZmlsbCIsImNvb3JkR3JhbW1hck51bWJlciIsInNSR0IiLCJzaWduIiwicmdiYSIsImNvbXBvbmVudCIsInBhcnNlSW50IiwiY29sbGFwc2UiLCJjb2xsYXBzaWJsZSIsImhleCIsInBhZFN0YXJ0IiwiYmxhY2siLCJQMyIsImRpc3BsYXlfc3BhY2UiLCJDU1MiLCJzdXBwb3J0cyIsImRpc3BsYXkiLCJmYWxsYmFja0NvbG9yIiwiZGlzdGFuY2UiLCJjb2xvcjEiLCJjb2xvcjIiLCJjb29yZHMxIiwiY29vcmRzMiIsInJlZHVjZSIsImFjYyIsImMxIiwiYzIiLCJnZXRMdW1pbmFuY2UiLCJzZXRMdW1pbmFuY2UiLCJyZWdpc3RlciQyIiwiQ29sb3IiLCJsdW1pbmFuY2UiLCJjb250cmFzdFdDQUcyMSIsIlkxIiwiWTIiLCJub3JtQkciLCJub3JtVFhUIiwicmV2VFhUIiwicmV2QkciLCJibGtUaHJzIiwiYmxrQ2xtcCIsImxvQ2xpcCIsImRlbHRhWW1pbiIsInNjYWxlQm9XIiwibG9Cb1dvZmZzZXQiLCJzY2FsZVdvQiIsImZjbGFtcCIsIlkiLCJsaW5lYXJpemUiLCJjb250cmFzdEFQQ0EiLCJiYWNrZ3JvdW5kIiwiZm9yZWdyb3VuZCIsIlMiLCJDIiwiU2FwYyIsIlIiLCJsdW1UeHQiLCJsdW1CZyIsIll0eHQiLCJZYmciLCJCb1ciLCJjb250cmFzdE1pY2hlbHNvbiIsImRlbm9tIiwiY29udHJhc3RXZWJlciIsImNvbnRyYXN0THN0YXIiLCLOtSQxIiwizrUzIiwizroiLCJsYWJfZDY1IiwicGhpIiwiY29udHJhc3REZWx0YVBoaSIsIkxzdHIxIiwiTHN0cjIiLCJkZWx0YVBoaVN0YXIiLCJjb250cmFzdCIsIlNRUlQyIiwiY29udHJhc3RNZXRob2RzIiwiYWxnb3JpdGhtIiwicmVzdCIsImFsZ29yaXRobXMiLCJ1diIsIlgiLCJaIiwieHkiLCJzdW0iLCJyZWdpc3RlciQxIiwiY2hyb21hdGljaXR5IiwiZGVsdGFFNzYiLCLPgCIsImQyciIsImRlbHRhRUNNQyIsIkgxIiwizpRhIiwizpRiIiwiSDIiLCJDNCIsIkYiLCJZdyQxIiwiWFlaX0Fic19ENjUiLCJ2IiwiQWJzWFlaIiwiYiQxIiwibiQxIiwibmludiQxIiwiYzEkMiIsImMyJDIiLCJjMyQyIiwicGludiIsImQiLCJkMCIsIlhZWnRvQ29uZV9NIiwiQ29uZXRvWFlaX00iLCJDb25ldG9JYWJfTSIsIklhYnRvQ29uZV9NIiwiSnphemJ6IiwianoiLCJheiIsImJ6IiwiWGEiLCJZYSIsIlphIiwiWG0iLCJZbSIsIkxNUyIsIlBRTE1TIiwibnVtIiwiSXoiLCJKeiIsImp6Y3poeiIsImN6IiwiaHoiLCJqemF6YnoiLCJkZWx0YUVKeiIsIkp6MSIsIkN6MSIsIkh6MSIsIkp6MiIsIkN6MiIsIkh6MiIsIs6USiIsImMxJDEiLCJjMiQxIiwiYzMkMSIsIm0xIiwibTIiLCJpbTEiLCJpbTIiLCJYWVp0b0xNU19NJDEiLCJMTVN0b0lQVF9NIiwiSVBUdG9MTVNfTSIsIkxNU3RvWFlaX00kMSIsImljdGNwIiwiY3QiLCJjcCIsIkxNU3RvSUN0Q3AiLCJJQ3RDcCIsIklDdENwdG9MTVMiLCJkZWx0YUVJVFAiLCJJMSIsIlQxIiwiUDEiLCJJMiIsIlQyIiwiUDIiLCJYWVp0b0xNU19NIiwiTE1TdG9YWVpfTSIsIkxNU3RvTGFiX00iLCJMYWJ0b0xNU19NIiwiT0tMYWIiLCJMTVNnIiwiZGVsdGFFT0siLCJkZWx0YUVNZXRob2RzIiwibGlnaHRlbiIsImFtb3VudCIsImxpZ2h0bmVzcyIsImRhcmtlbiIsInZhcmlhdGlvbnMiLCJtaXgiLCJvdXRwdXRTcGFjZSIsInByZW11bHRpcGxpZWQiLCJzdGVwcyIsImNvbG9yUmFuZ2UiLCJpc1JhbmdlIiwicmFuZ2VBcmdzIiwiY29sb3JzIiwibWF4RGVsdGFFIiwiZGVsdGFFTWV0aG9kIiwibWF4U3RlcHMiLCJyYW5nZU9wdGlvbnMiLCJ0b3RhbERlbHRhIiwiYWN0dWFsU3RlcHMiLCJjZWlsIiwic3RlcCIsIm1heERlbHRhIiwiY3VyIiwizpTOlSIsInByZXYiLCJzcGxpY2UiLCJwcm9ncmVzc2lvbiIsImludGVycG9sYXRpb25TcGFjZSIsIs64MSIsIs64MiIsImRlZmluZUZ1bmN0aW9uIiwiaW50ZXJwb2xhdGlvbiIsIkhTTCIsImhzbCIsImsiLCJIU1YiLCJoc3YiLCJod2IiLCJ3IiwiZ3JheSIsInRvWFlaX00kMiIsImZyb21YWVpfTSQyIiwiQTk4TGluZWFyIiwiYTk4cmdiIiwidG9YWVpfTSQxIiwiZnJvbVhZWl9NJDEiLCJQcm9QaG90b0xpbmVhciIsIkV0IiwiRXQyIiwicHJvcGhvdG8iLCJva2xjaCIsIm9rbGFiIiwiWXciLCJuaW52IiwibWludiIsImMzIiwicmVjMjEwMFBxIiwic2NhbGUiLCJyZWMyMTAwSGxnIiwiY3NzaWQiLCJDQVRzIiwiYWRhcHQiLCJkZWZpbmVDQVQiLCJ0b0NvbmVfTSIsImZyb21Db25lX00iLCLPgXMiLCLOs3MiLCLOsnMiLCLPgWQiLCLOs2QiLCLOsmQiLCJzY2FsZWRfY29uZV9NIiwiYWRhcHRfTSIsIkQ1NSIsIkQ3NSIsIkUiLCJGMiIsIkY3IiwiRjExIiwiQUNFUyIsIkFDRVNjZyIsIkFDRVNfbWluX25vbnplcm8iLCJBQ0VTX2NjX21heCIsImxvZzIiLCJhY2VzY2MiLCJzcGFjZXMiLCJBOThSR0IiLCJBOThSR0JfTGluZWFyIiwiQUNFU2NjIiwiSFdCIiwiSUNUQ1AiLCJKekN6SHoiLCJMYWJfRDY1IiwiT0tMQ0giLCJQM19MaW5lYXIiLCJQcm9QaG90byIsIlByb1Bob3RvX0xpbmVhciIsIlJFQ18yMDIwIiwiUkVDXzIwMjBfTGluZWFyIiwiUkVDXzIxMDBfSExHIiwiUkVDXzIxMDBfUFEiLCJYWVpfQUJTX0Q2NSIsInNSR0JfTGluZWFyIiwidG9KU09OIiwiY29kZSIsImluc3RhbmNlIiwiZnVuYyIsImRlZmluZUZ1bmN0aW9ucyIsImV4dGVuZCIsImV4cG9ydHMiLCJTcGFjZSIsImtleSIsImFkZFNwYWNlQWNjZXNzb3JzIiwicHJvcElkIiwiUHJveHkiLCJoYXMiLCJvYmoiLCJwcm9wZXJ0eSIsImUiLCJSZWZsZWN0IiwicmVjZWl2ZXIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/colorjs.io/dist/color.js\n");

/***/ })

};
;